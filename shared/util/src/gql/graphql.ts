/* eslint-disable */
import { TypedDocumentNode as DocumentNode } from '@graphql-typed-document-node/core';
export type Maybe<T> = T | null;
export type InputMaybe<T> = Maybe<T>;
export type Exact<T extends { [key: string]: unknown }> = { [K in keyof T]: T[K] };
export type MakeOptional<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]?: Maybe<T[SubKey]> };
export type MakeMaybe<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]: Maybe<T[SubKey]> };
export type MakeEmpty<T extends { [key: string]: unknown }, K extends keyof T> = { [_ in K]?: never };
export type Incremental<T> = T | { [P in keyof T]?: P extends ' $fragmentName' | '__typename' ? T[P] : never };
/** All built-in and custom scalars, mapped to their actual values */
export type Scalars = {
  ID: { input: string; output: string; }
  String: { input: string; output: string; }
  Boolean: { input: boolean; output: boolean; }
  Int: { input: number; output: number; }
  Float: { input: number; output: number; }
  /** Sometimes arbitrary data, usually JSON, is required.  For example, a user may have certain attributes which can be used to determine their variation.  Since we don't know the shape of the data ahead of time we use this general purpose type. */
  AbTestAbTestMetaData: { input: any; output: any; }
  /** A list of HTTP status codes, such as "404" or "500." */
  AgentApplicationSettingsErrorCollectorHttpStatus: { input: any; output: any; }
  /** The "raw" configuration values for configuring the javascript client. */
  AgentApplicationSettingsRawJsConfiguration: { input: any; output: any; }
  /** This scalar represents a explain plan row (list of values) */
  AgentTracesExplainPlanRow: { input: any; output: any; }
  /** This scalar represents a map of sql query parameters in the form of key-value pairs. */
  AgentTracesQueryParameters: { input: any; output: any; }
  /** This scalar represents a map of attributes in the form of key-value pairs. */
  AgentTracesTraceAttributes: { input: any; output: any; }
  /** Expression used for comparing incidents as part of a correlation. */
  AiDecisionsRuleExpression: { input: any; output: any; }
  /** Represents JSON nerdlet state data */
  AlertsRawNerdletState: { input: any; output: any; }
  /** This scalar represents a map of attributes in the form of key-value pairs. */
  AttributeMap: { input: any; output: any; }
  /** A JSON scalar */
  ChangeTrackingRawCustomAttributesMap: { input: any; output: any; }
  /** Nerdlet-supplied metadata to provide context to a conversation */
  CollaborationRawContextMetadata: { input: any; output: any; }
  /** Expression used for comparing incidents as part of a correlation. */
  CorrelationRuleExpression: { input: any; output: any; }
  /** Raw JSON payload with full configuration of a widget. */
  DashboardWidgetRawConfiguration: { input: any; output: any; }
  /** The `Date` scalar represents a date. The `Date` appears as an ISO8601 formatted string. */
  Date: { input: any; output: any; }
  /** The `DateTime` scalar represents a date and time. The `DateTime` appears as an ISO8601 formatted string. */
  DateTime: { input: any; output: any; }
  /** Map of key value pairs for a span */
  DistributedTracingSpanAttributes: { input: any; output: any; }
  /** Usage of this scalar is deprecated. */
  EncodedInfraFilterSet: { input: any; output: any; }
  /** The `ViolationInt` scalar type represents 52-bit signed integers */
  EntityAlertViolationInt: { input: any; output: any; }
  /** Dashboard template in Mosaic format, obtained from a dashboard template located in the Entity Synthesis Definitions repository. */
  EntityDashboardTemplatesRawMosaicTemplate: { input: any; output: any; }
  /** An encoded Entity GUID */
  EntityGuid: { input: any; output: any; }
  /** A query string using Entity Search query syntax */
  EntitySearchQuery: { input: any; output: any; }
  /** The `EpochMilliseconds` scalar represents the number of milliseconds since the Unix epoch */
  EpochMilliseconds: { input: any; output: any; }
  /** The `EpochSeconds` scalar represents the number of seconds since the Unix epoch */
  EpochSeconds: { input: any; output: any; }
  /** This scalar represents an event */
  ErrorsInboxRawEvent: { input: any; output: any; }
  /** Implements a custom scalar that is either a string, a boolean,  an integer or a datetime formatted string. */
  IncidentIntelligenceIssueFilterValue: { input: any; output: any; }
  /** Implements a custom scalar that is either a string, a boolean or an integer. */
  IncidentIntelligencePlatformFilterValue: { input: any; output: any; }
  /** Implements a custom scalar that is either a string, a boolean,  an integer or a datetime formatted string. */
  IncidentIntelligenceSearchFilterValue: { input: any; output: any; }
  /** An arbitrary key:value object containing additional data related to the environment where the installation occurred. */
  InstallationRawMetadata: { input: any; output: any; }
  /** The name of a log data partition. Has to start with 'Log_' prefix and can only contain alphanumeric characters and underscores. */
  LogConfigurationsLogDataPartitionName: { input: any; output: any; }
  /**
   * This scalar represents a Log line. It is a `Map` of `String` keys to values.
   *
   * The shape of these objects reflect the query used to generate them, the contents
   * of the objects is not part of the GraphQL schema.
   */
  LogLine: { input: any; output: any; }
  /** The `Milliseconds` scalar represents a duration in milliseconds */
  Milliseconds: { input: any; output: any; }
  /** The `Minutes` scalar represents a duration in minutes */
  Minutes: { input: any; output: any; }
  /** The `NaiveDateTime` scalar represents a date and time without a Time Zone. The `NaiveDateTime` appears as an ISO8601 formatted string. */
  NaiveDateTime: { input: any; output: any; }
  /** This scalar represents a NerdStorage document. */
  NerdStorageDocument: { input: any; output: any; }
  /** This scalar represents a NerdStore document. */
  NerdStoreDocument: { input: any; output: any; }
  /** A full artifact id scalar */
  NerdpackFullArtifactId: { input: any; output: any; }
  /** The artifact's metadata in raw JSON format. It provides all the published information of the current artifact. */
  NerdpackRawMetadata: { input: any; output: any; }
  /** Any object, number, string, boolean or array. */
  NerdpackRawVisualizationMetadataConfiguration: { input: any; output: any; }
  /** A string representing a nerdpack tag. */
  NerdpackTagName: { input: any; output: any; }
  /** Represents raw JSON configuration data */
  NetworkMonitoringRawConfiguration: { input: any; output: any; }
  /** Represents raw JSON configuration data */
  Nr1CatalogRawConfiguration: { input: any; output: any; }
  /** Represents JSON nerdlet state data */
  Nr1CatalogRawNerdletState: { input: any; output: any; }
  /**
   * This scalar represents the raw nrql query results as returned from NRDB. It is a `Map` of `String` keys to values.
   *
   * The shape of these objects reflect the query used to generate them, the contents
   * of the objects is not part of the GraphQL schema.
   */
  NrdbRawResults: { input: any; output: any; }
  /**
   * This scalar represents a NRDB Result. It is a `Map` of `String` keys to values.
   *
   * The shape of these objects reflect the query used to generate them, the contents
   * of the objects is not part of the GraphQL schema.
   */
  NrdbResult: { input: any; output: any; }
  /**
   * This scalar represents a NRQL query string.
   *
   * See the [NRQL Docs](https://docs.newrelic.com/docs/insights/nrql-new-relic-query-language/nrql-resources/nrql-syntax-components-functions) for more information about NRQL syntax.
   */
  Nrql: { input: any; output: any; }
  /** Represents a monetary balance as dollars and cents */
  ProductConsumptionBalance: { input: any; output: any; }
  /** This scalar represents arbitrary data associated with the Saved View. */
  SavedViewsRawAdditionalData: { input: any; output: any; }
  /** The `Seconds` scalar represents a duration in seconds */
  Seconds: { input: any; output: any; }
  /** The `SecureValue` scalar represents a secure value, ie a password, an API key, etc. */
  SecureValue: { input: any; output: any; }
  /** The `SemVer` scalar represents a version designation conforming to the SemVer specification. */
  SemVer: { input: any; output: any; }
};

/** An error specific to the getVariation call */
export type AbTestGetVariationError = {
  __typename?: 'AbTestGetVariationError';
  /** Additional information about the error */
  message?: Maybe<Scalars['String']['output']>;
  /** The general type of error being reported */
  type?: Maybe<AbTestGetVariationErrorType>;
};

/** The possible set of errors which may arise from the getVariation call.  This set is subject to change. */
export enum AbTestGetVariationErrorType {
  /**
   * The experiment with the given key is not currently running.
   * @deprecated This error is no longer returned because it's perfectly valid to kill an experiment.
   */
  Experimentnotrunning = 'EXPERIMENTNOTRUNNING',
  /** No experiment with the given key exists. */
  Noexperiment = 'NOEXPERIMENT'
}

/** An object for organizing parameters */
export type AbTestGetVariationRequest = {
  /** The experiment key */
  experimentKey: Scalars['String']['input'];
  /** Arbitrary data about the subject which may be needed to help determine their variation */
  metaData?: InputMaybe<Scalars['AbTestAbTestMetaData']['input']>;
  /** A subject defining key, could be a userID or organizationID for example */
  subjectKey: Scalars['String']['input'];
};

/** An object for organizing parameters */
export type AbTestGetVariationResponse = {
  __typename?: 'AbTestGetVariationResponse';
  /** Information mostly handy for development */
  errors?: Maybe<Array<Maybe<AbTestGetVariationError>>>;
  /** Arbitrary data set by the creator of the experiment related to the variation provided */
  metaData?: Maybe<Scalars['AbTestAbTestMetaData']['output']>;
  /** The experimental variation a user should see.  Can always be 'control' for the control group. */
  variationKey?: Maybe<Scalars['String']['output']>;
};

/** An object for organizing parameters */
export type AbTestTrackEventRequest = {
  /** The type of event */
  eventType: Scalars['String']['input'];
  /** Arbitrary data about the event */
  metaData?: InputMaybe<Scalars['AbTestAbTestMetaData']['input']>;
  /** A subject defining key, could be a userID or organizationID for example */
  subjectKey: Scalars['String']['input'];
  /** The type of traffic, like user or organization */
  trafficType?: InputMaybe<Scalars['String']['input']>;
};

/**
 * The `Account` object provides general data about the account, as well as
 * being the entry point into more detailed data about a single account.
 *
 * Account configuration data is queried through this object, as well as
 * telemetry data that is specific to a single account.
 */
export type Account = {
  __typename?: 'Account';
  /** This field provides access to AgentEnvironment data. */
  agentEnvironment?: Maybe<AgentEnvironmentAccountStitchedFields>;
  /** This field provides access to AiConnect data. */
  aiConnect?: Maybe<AiConnectAccountStitchedFields>;
  /** This field provides access to AiDecisions data. */
  aiDecisions?: Maybe<AiDecisionsAccountStitchedFields>;
  /** This field provides access to AiIssues data. */
  aiIssues?: Maybe<AiIssuesAccountStitchedFields>;
  /** This field provides access to AiNotifications data. */
  aiNotifications?: Maybe<AiNotificationsAccountStitchedFields>;
  /** This field provides access to AiOps data. */
  aiOps?: Maybe<AiOpsAccountStitchedFields>;
  /**
   * This field provides access to AiPostmortem data.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  aiPostmortem?: Maybe<AiPostmortemAccountStitchedFields>;
  /**
   * This field provides access to AiProfileAnalysis data.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  aiProfileAnalysis?: Maybe<AiProfileAnalysisAccountStitchedFields>;
  /** This field provides access to AiTopology data. */
  aiTopology?: Maybe<AiTopologyAccountStitchedFields>;
  /** This field provides access to AiWorkflows data. */
  aiWorkflows?: Maybe<AiWorkflowsAccountStitchedFields>;
  /** This field provides access to Alerts data. */
  alerts?: Maybe<AlertsAccountStitchedFields>;
  /**
   * This field provides access to Cartographer data.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  cartographer?: Maybe<CartographerAccountStitchedFields>;
  /**
   * The `cloud` field provides access to cloud integrations configuration data.
   *
   * For details and query examples visit
   * [our docs](https://docs.newrelic.com/docs/apis/graphql-api/tutorials/manage-your-aws-azure-google-cloud-integrations-graphql-api).
   */
  cloud?: Maybe<CloudAccountFields>;
  /** This field provides access to Commerce data. */
  commerce?: Maybe<CommerceAccountStitchedFields>;
  /** This field provides access to CommerceNotifications data. */
  commerceNotifications?: Maybe<CommerceNotificationsAccountStitchedFields>;
  /**
   * This field provides access to Correlation data.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  correlation?: Maybe<CorrelationAccountStitchedFields>;
  /** This field provides access to CorrelationIngest data. */
  correlationIngest?: Maybe<CorrelationIngestAccountStitchedFields>;
  /** This field provides access to DataManagement data. */
  dataManagement?: Maybe<DataManagementAccountStitchedFields>;
  /**
   * This field provides access to Discussion data.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  discussion?: Maybe<DiscussionAccountStitchedFields>;
  /** This field provides access to Edge data. */
  edge?: Maybe<EdgeAccountStitchedFields>;
  /** This field provides access to EventsToMetrics data. */
  eventsToMetrics?: Maybe<EventsToMetricsAccountStitchedFields>;
  /** @deprecated This field should no longer be used and returns empty results. */
  features?: Maybe<Array<Maybe<ClassicNavigationFeature>>>;
  /** This field provides access to HistoricalDataExport data. */
  historicalDataExport?: Maybe<HistoricalDataExportAccountStitchedFields>;
  id?: Maybe<Scalars['Int']['output']>;
  /** This field provides access to IncidentIntelligenceEnvironment data. */
  incidentIntelligenceEnvironment?: Maybe<IncidentIntelligenceEnvironmentAccountStitchedFields>;
  /**
   * This field provides access to IncidentIntelligenceIssue data.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  incidentIntelligenceIssue?: Maybe<IncidentIntelligenceIssueAccountStitchedFields>;
  /**
   * This field provides access to IncidentIntelligencePlatform data.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  incidentIntelligencePlatform?: Maybe<IncidentIntelligencePlatformAccountStitchedFields>;
  /**
   * This field provides access to IncidentIntelligenceSearch data.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  incidentIntelligenceSearch?: Maybe<IncidentIntelligenceSearchAccountStitchedFields>;
  /** This field provides access to Installation data. */
  installation?: Maybe<InstallationAccountStitchedFields>;
  /** This field provides access to Invitations data. */
  invitations?: Maybe<InvitationsAccountStitchedFields>;
  /** @deprecated Please use `actor.apiAccess.keySearch` to access your license keys. */
  licenseKey?: Maybe<Scalars['String']['output']>;
  /** This field provides access to LogConfigurations data. */
  logConfigurations?: Maybe<LogConfigurationsAccountStitchedFields>;
  /** This field provides access to MetricNormalization data. */
  metricNormalization?: Maybe<MetricNormalizationAccountStitchedFields>;
  name?: Maybe<Scalars['String']['output']>;
  /**
   * NerdStorage is a document database that is accessible within the New Relic One interface.
   * This allows for persistence of Nerdpack data including users' configuration settings and preferences
   * (like favorites), or any other small data sets.
   *
   * Conceptually, you can imagine NerdStorage as a nested key-value map.
   *
   * For information on New Relic NerdStorage, visit [our docs](https://developer.newrelic.com/build-tools/new-relic-one-applications/nerdstorage).
   *
   * To use the NerdStorage schema you must specify a Nerdpack ID using the NewRelic-Package-Id header in your request.
   */
  nerdStorage?: Maybe<NerdStorageAccountScope>;
  nerdStoreCollection?: Maybe<Array<Maybe<NerdStoreCollectionMember>>>;
  nerdStoreDocument?: Maybe<Scalars['NerdStoreDocument']['output']>;
  /**
   * Make a query to NRDB with a NRQL string.
   *
   * See the [NRQL Docs](https://docs.newrelic.com/docs/insights/nrql-new-relic-query-language/nrql-resources/nrql-syntax-components-functions) for more information about generating a query string.
   *
   * Example NRQL query:
   * ```
   * SELECT count(*) FROM Transaction TIMESERIES
   * ```
   *
   * For more details on how to use NRQL in the GraphQL API, visit [our docs](https://docs.newrelic.com/docs/apis/graphql-api/tutorials/query-nrql-through-new-relic-graphql-api)
   */
  nrql?: Maybe<NrdbResultContainer>;
  /** This field provides access to NrqlDropRules data. */
  nrqlDropRules?: Maybe<NrqlDropRulesAccountStitchedFields>;
  /**
   * This field provides access to NrqlLookups data.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  nrqlLookups?: Maybe<NrqlLookupsAccountStitchedFields>;
  /**
   * Poll for the results of a previously-executed asychronous NRDB query.
   *
   * The `queryId` is available in the `queryProgress` data returned by the original asynchronous query.
   *
   * See [this page](https://docs.newrelic.com/docs/apis/nerdgraph/examples/async-queries-nrql-tutorial) for additional asynchronous query documentation.
   * @deprecated This field is experimental! It may change at any time.
   *
   */
  nrqlQueryProgress?: Maybe<NrdbResultContainer>;
  /**
   * This field provides access to OpenAgentManagement data.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  openAgentManagement?: Maybe<OpenAgentManagementAccountStitchedFields>;
  /** This field provides access to Pixie data. */
  pixie?: Maybe<PixieAccountStitchedFields>;
  /** This field provides access to ProductConsumption data. */
  productConsumption?: Maybe<ProductConsumptionAccountStitchedFields>;
  /** @deprecated This field should no longer be used and returns empty results. */
  products?: Maybe<Array<Maybe<ClassicNavigationProduct>>>;
  /** This field provides access to Provisioning data. */
  provisioning?: Maybe<ProvisioningAccountStitchedFields>;
  /** This field provides access to SignupIntegrations data. */
  signupIntegrations?: Maybe<SignupIntegrationsAccountStitchedFields>;
  /** This field provides access to StreamingExport data. */
  streamingExport?: Maybe<StreamingExportAccountStitchedFields>;
  /** This field provides access to Support data. */
  support?: Maybe<SupportAccountStitchedFields>;
  /** This field provides access to Synthetics data. */
  synthetics?: Maybe<SyntheticsAccountStitchedFields>;
  /** This field provides access to UserConsumption data. */
  userConsumption?: Maybe<UserConsumptionAccountStitchedFields>;
  /**
   * This field provides access to WebsitePerformanceMonitoring data.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  websitePerformanceMonitoring?: Maybe<WebsitePerformanceMonitoringAccountStitchedFields>;
  /** This field provides access to Workload data. */
  workload?: Maybe<WorkloadAccountStitchedFields>;
};


/**
 * The `Account` object provides general data about the account, as well as
 * being the entry point into more detailed data about a single account.
 *
 * Account configuration data is queried through this object, as well as
 * telemetry data that is specific to a single account.
 */
export type AccountFeaturesArgs = {
  agentId: Scalars['Int']['input'];
  key: Scalars['String']['input'];
};


/**
 * The `Account` object provides general data about the account, as well as
 * being the entry point into more detailed data about a single account.
 *
 * Account configuration data is queried through this object, as well as
 * telemetry data that is specific to a single account.
 */
export type AccountNerdStoreCollectionArgs = {
  collection: Scalars['String']['input'];
};


/**
 * The `Account` object provides general data about the account, as well as
 * being the entry point into more detailed data about a single account.
 *
 * Account configuration data is queried through this object, as well as
 * telemetry data that is specific to a single account.
 */
export type AccountNerdStoreDocumentArgs = {
  collection: Scalars['String']['input'];
  documentId: Scalars['String']['input'];
};


/**
 * The `Account` object provides general data about the account, as well as
 * being the entry point into more detailed data about a single account.
 *
 * Account configuration data is queried through this object, as well as
 * telemetry data that is specific to a single account.
 */
export type AccountNrqlArgs = {
  async?: InputMaybe<Scalars['Boolean']['input']>;
  options?: InputMaybe<NrqlQueryOptions>;
  query: Scalars['Nrql']['input'];
  timeout?: InputMaybe<Scalars['Seconds']['input']>;
};


/**
 * The `Account` object provides general data about the account, as well as
 * being the entry point into more detailed data about a single account.
 *
 * Account configuration data is queried through this object, as well as
 * telemetry data that is specific to a single account.
 */
export type AccountNrqlQueryProgressArgs = {
  queryId: Scalars['ID']['input'];
};

export type AccountAccessInfo = {
  __typename?: 'AccountAccessInfo';
  capabilities?: Maybe<Array<Maybe<Capability>>>;
  entitlements?: Maybe<Array<Maybe<AccountEntitlement>>>;
  /**
   * These Feature Flags will be evaluated differently depending on their context:
   * * `currentUser.currentAccount` - Current User ID, current Account ID, NR admin
   * * `currentUser.account(id: N)` - Current User ID, given Account ID, NR admin
   * * `user(id: N).account(id: N)` - Given User ID, given Account ID, NR admin
   * * `account(id: N)` - Just the given Account ID
   */
  featureFlags?: Maybe<Array<Maybe<FeatureFlag>>>;
  id?: Maybe<Scalars['Int']['output']>;
  inRegion?: Maybe<Scalars['Boolean']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  parent?: Maybe<ParentAccountInfo>;
  region?: Maybe<Region>;
  /** Returns event types that are currently reporting in the account. */
  reportingEventTypes?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
};


export type AccountAccessInfoCapabilitiesArgs = {
  filter?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
};


export type AccountAccessInfoEntitlementsArgs = {
  filter?: InputMaybe<AccountEntitlementFilter>;
};


export type AccountAccessInfoFeatureFlagsArgs = {
  criteria?: InputMaybe<Scalars['String']['input']>;
  names: Array<InputMaybe<Scalars['String']['input']>>;
};


export type AccountAccessInfoReportingEventTypesArgs = {
  filter?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  timeWindow?: InputMaybe<TimeWindowInput>;
};

export type AccountAuthorization = {
  __typename?: 'AccountAuthorization';
  /** The id of the account to the be checked for authorization. */
  accountId?: Maybe<Scalars['Int']['output']>;
  /** Whether or not the user is authorized for the account. */
  authorized?: Maybe<Scalars['Boolean']['output']>;
};

export type AccountEntitlement = {
  __typename?: 'AccountEntitlement';
  name?: Maybe<Scalars['String']['output']>;
};

export type AccountEntitlementFilter = {
  names: Array<InputMaybe<Scalars['String']['input']>>;
};

/** Errors which occurred when setting account compliance */
export type AccountFeatureConfigurationSetAccountComplianceError = {
  __typename?: 'AccountFeatureConfigurationSetAccountComplianceError';
  /** A description of the error */
  description: Scalars['String']['output'];
  /** The type of error */
  type: AccountFeatureConfigurationSetAccountComplianceErrorType;
};

/** Types of errors that may occur when configuring account compliance */
export enum AccountFeatureConfigurationSetAccountComplianceErrorType {
  /** The account was not found or does not exist */
  AccountNotFound = 'ACCOUNT_NOT_FOUND',
  /** The account does not have the required product level to set HIPAA compliance */
  InsufficientProductLevel = 'INSUFFICIENT_PRODUCT_LEVEL',
  /** Internal accounts cannot be configured for HIPAA */
  InternalAccount = 'INTERNAL_ACCOUNT',
  /** The account is invalid */
  InvalidAccount = 'INVALID_ACCOUNT',
  /** An unknown error occurred */
  UndeterminedError = 'UNDETERMINED_ERROR'
}

/** Result for configuring an account for Fedramp compliance */
export type AccountFeatureConfigurationSetFedrampComplianceResult = {
  __typename?: 'AccountFeatureConfigurationSetFedrampComplianceResult';
  /** Error messages describing the failure to configure the account for compliance */
  errors?: Maybe<Array<AccountFeatureConfigurationSetAccountComplianceError>>;
  /** Message asserting the account was successfully configured for FedRamp compliance and the state of the configuration */
  success?: Maybe<Scalars['String']['output']>;
};

/** Result for configuring an account for HIPAA compliance */
export type AccountFeatureConfigurationSetHipaaComplianceResult = {
  __typename?: 'AccountFeatureConfigurationSetHipaaComplianceResult';
  /** Error messages describing the failure to configure the account for compliance */
  errors?: Maybe<Array<AccountFeatureConfigurationSetAccountComplianceError>>;
  /** Message asserting the account was successfully configured for HIPAA compliance and the state of the configuration */
  success?: Maybe<Scalars['String']['output']>;
};

export type AccountInfo = {
  __typename?: 'AccountInfo';
  createdAt?: Maybe<Scalars['Int']['output']>;
  id?: Maybe<Scalars['Int']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  parent?: Maybe<ParentAccountInfo>;
  region?: Maybe<Region>;
  status?: Maybe<AccountStatus>;
};

/** Attributes for creating an account. */
export type AccountManagementCreateInput = {
  /** The name of the account. */
  name: Scalars['String']['input'];
  /** The id of the managed organization where the account will be created. */
  organizationId?: InputMaybe<Scalars['ID']['input']>;
  /** The data center region for the account */
  regionCode?: InputMaybe<Scalars['String']['input']>;
};

/** The return object for a create-account mutation. */
export type AccountManagementCreateResponse = {
  __typename?: 'AccountManagementCreateResponse';
  /** Information about the newly created account. */
  managedAccount?: Maybe<AccountManagementManagedAccount>;
};

/** Account data view for administration tasks. */
export type AccountManagementManagedAccount = {
  __typename?: 'AccountManagementManagedAccount';
  /** The account ID. */
  id: Scalars['Int']['output'];
  /** True if account is canceled */
  isCanceled: Scalars['Boolean']['output'];
  /** The name of the account. */
  name: Scalars['String']['output'];
  /** The data center region for the account (US or EU). */
  regionCode: Scalars['String']['output'];
};

/** The field type for stitching into the NerdGraph schema. */
export type AccountManagementOrganizationStitchedFields = {
  __typename?: 'AccountManagementOrganizationStitchedFields';
  /** Admin-level info about the accounts in an organization. */
  managedAccounts?: Maybe<Array<AccountManagementManagedAccount>>;
};


/** The field type for stitching into the NerdGraph schema. */
export type AccountManagementOrganizationStitchedFieldsManagedAccountsArgs = {
  isCanceled?: InputMaybe<Scalars['Boolean']['input']>;
};

/** The attributes for updating an account. */
export type AccountManagementUpdateInput = {
  /** The ID for the account being updated. */
  id: Scalars['Int']['input'];
  /** The new account name. */
  name: Scalars['String']['input'];
};

/** The return object for an update-account mutation. */
export type AccountManagementUpdateResponse = {
  __typename?: 'AccountManagementUpdateResponse';
  /** Information about an updated account */
  managedAccount?: Maybe<AccountManagementManagedAccount>;
};

export type AccountObject = {
  __typename?: 'AccountObject';
  /** @deprecated Please use `entity` */
  agent?: Maybe<Agent>;
  /** This field provides access to AgentEnvironment data. */
  agentEnvironment?: Maybe<AgentEnvironmentAccountStitchedFields>;
  /**
   * ### agentListing
   * Retrieves a paginated list of all agents of a given type
   *
   * * `type`: required entity type
   * * `offset`: an index indicating where to begin your page of results
   * * `limit`: the number of agents to return in your result set
   * @deprecated Please use `entitySearch`
   */
  agentListing?: Maybe<AgentSearch>;
  /**
   * ### agentSearchByLabel
   * Retrieve all of the agents that match the given `label`
   *
   * * `label`: a `Label` pair as described below.
   * * `type`: required entity type
   * * `offset`: an index indicating where to begin your page of results
   * * `limit`: the number of agents to return in your result set
   *
   * `Label`s are represented as a `{type, value}` pair.
   *
   * * `type`: the label's type field (`Location`, `Team`, et cetera)
   * * `value` the label's value field (`Romania`, `APM Code`, et cetera)
   *
   * If you submit an agent search by label which only has a `type`, NerdGraph will return all of the entities
   * which have a label with that type (this can be very very large). If there are more than
   * 1000 labels that match the given `type`, you will need to paginate your requests using
   * `limit` and `offset`. These values, including `total` correspond to the number of `labels`, not `agents`.
   * @deprecated Please use `entitySearch` with `tag` query
   */
  agentSearchByLabel?: Maybe<AgentSearch>;
  /**
   * ### agentSearchByName
   * Agent search by name is paginated. If you do not pass `offset` or `limit`, `NerdGraph` returns the entire set to you. Without a `name` argument, we will return all agents.
   *
   * * `name`: a string to match against for agent name
   * * `type`: required entity type
   * * `offset`: an index indicating where to begin your page of results
   * * `limit`: the number of agents to return in your result set
   * @deprecated Please use `entitySearch`
   */
  agentSearchByName?: Maybe<AgentSearch>;
  /** @deprecated Please use `entities` */
  agents?: Maybe<Array<Maybe<Agent>>>;
  /** This field provides access to AiConnect data. */
  aiConnect?: Maybe<AiConnectAccountStitchedFields>;
  /** This field provides access to AiDecisions data. */
  aiDecisions?: Maybe<AiDecisionsAccountStitchedFields>;
  /** This field provides access to AiIssues data. */
  aiIssues?: Maybe<AiIssuesAccountStitchedFields>;
  /** This field provides access to AiNotifications data. */
  aiNotifications?: Maybe<AiNotificationsAccountStitchedFields>;
  /** This field provides access to AiOps data. */
  aiOps?: Maybe<AiOpsAccountStitchedFields>;
  /**
   * This field provides access to AiPostmortem data.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  aiPostmortem?: Maybe<AiPostmortemAccountStitchedFields>;
  /**
   * This field provides access to AiProfileAnalysis data.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  aiProfileAnalysis?: Maybe<AiProfileAnalysisAccountStitchedFields>;
  /** This field provides access to AiTopology data. */
  aiTopology?: Maybe<AiTopologyAccountStitchedFields>;
  /** This field provides access to AiWorkflows data. */
  aiWorkflows?: Maybe<AiWorkflowsAccountStitchedFields>;
  /** This field provides access to Alerts data. */
  alerts?: Maybe<AlertsAccountStitchedFields>;
  capabilities?: Maybe<Array<Maybe<Capability>>>;
  /**
   * This field provides access to Cartographer data.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  cartographer?: Maybe<CartographerAccountStitchedFields>;
  /**
   * @deprecated Usage of `children` is deprecated.
   *
   * The concept of subaccounts is a part of the legacy (V1) user model and should no longer be relied upon. The `children` field can behave differently for V2 users than it did for V1 users. In the V1 model, access is inherited so `children` always shows all of the child accounts of a particular parent account. In the V2 model, access does not inherit and the places where `children` is used should likely be using the list of accounts belonging to the organization, and it should be restricted to users with proper authorization to do so.
   *
   * Depending on the use case, suitable alternative may include querying `actor.accounts` or `customerAdministration.accounts`. If there is a current or planned use of this field and a suitable alternative can't be found, connect with the Authorization Team about your use case and an appropriate solution.
   *
   */
  children?: Maybe<Array<Maybe<AccountInfo>>>;
  /** This field provides access to Commerce data. */
  commerce?: Maybe<CommerceAccountStitchedFields>;
  /** This field provides access to CommerceNotifications data. */
  commerceNotifications?: Maybe<CommerceNotificationsAccountStitchedFields>;
  /**
   * This field provides access to Correlation data.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  correlation?: Maybe<CorrelationAccountStitchedFields>;
  /** This field provides access to CorrelationIngest data. */
  correlationIngest?: Maybe<CorrelationIngestAccountStitchedFields>;
  createdAt?: Maybe<Scalars['Int']['output']>;
  /** This field provides access to DataManagement data. */
  dataManagement?: Maybe<DataManagementAccountStitchedFields>;
  /**
   * This field provides access to Discussion data.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  discussion?: Maybe<DiscussionAccountStitchedFields>;
  /** This field provides access to Edge data. */
  edge?: Maybe<EdgeAccountStitchedFields>;
  /**
   * ### errorTrace
   * Requesting an Error Trace will permanently store it
   *
   * * `id`: the id of the Error Trace to retrieve
   * @deprecated Please use `entity.errorTrace` instead.
   */
  errorTrace?: Maybe<ErrorTrace>;
  eventTransformationRule?: Maybe<EventTransformationRule>;
  eventTransformationRuleListing?: Maybe<EventTransformationRuleListing>;
  /** This field provides access to EventsToMetrics data. */
  eventsToMetrics?: Maybe<EventsToMetricsAccountStitchedFields>;
  /**
   * These Feature Flags will be evaluated differently depending on their context:
   * * `currentUser.currentAccount` - Current User ID, current Account ID, NR admin
   * * `currentUser.account(id: N)` - Current User ID, given Account ID, NR admin
   * * `user(id: N).account(id: N)` - Given User ID, given Account ID, NR admin
   * * `account(id: N)` - Just the given Account ID
   */
  featureFlags?: Maybe<Array<Maybe<FeatureFlag>>>;
  /** @deprecated This field should no longer be used and returns empty results. */
  features?: Maybe<Array<Maybe<ClassicNavigationFeature>>>;
  highSecurity?: Maybe<Scalars['Boolean']['output']>;
  /** This field provides access to HistoricalDataExport data. */
  historicalDataExport?: Maybe<HistoricalDataExportAccountStitchedFields>;
  id?: Maybe<Scalars['Int']['output']>;
  /** This field provides access to IncidentIntelligenceEnvironment data. */
  incidentIntelligenceEnvironment?: Maybe<IncidentIntelligenceEnvironmentAccountStitchedFields>;
  /**
   * This field provides access to IncidentIntelligenceIssue data.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  incidentIntelligenceIssue?: Maybe<IncidentIntelligenceIssueAccountStitchedFields>;
  /**
   * This field provides access to IncidentIntelligencePlatform data.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  incidentIntelligencePlatform?: Maybe<IncidentIntelligencePlatformAccountStitchedFields>;
  /**
   * This field provides access to IncidentIntelligenceSearch data.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  incidentIntelligenceSearch?: Maybe<IncidentIntelligenceSearchAccountStitchedFields>;
  /** @deprecated Usage of Infra Filter Sets is deprecated. */
  infraFilterSets?: Maybe<Array<Maybe<InfraFilterSet>>>;
  /** @deprecated Please use `entitySearch` */
  infraSearch?: Maybe<InfraSearch>;
  /** This field provides access to Installation data. */
  installation?: Maybe<InstallationAccountStitchedFields>;
  /** This field provides access to Invitations data. */
  invitations?: Maybe<InvitationsAccountStitchedFields>;
  /** @deprecated Please use `actor.apiAccess.keySearch` to access your license keys. */
  licenseKey?: Maybe<Scalars['String']['output']>;
  /** This field provides access to LogConfigurations data. */
  logConfigurations?: Maybe<LogConfigurationsAccountStitchedFields>;
  /** This field provides access to MetricNormalization data. */
  metricNormalization?: Maybe<MetricNormalizationAccountStitchedFields>;
  /** @deprecated Please use `entity` */
  mobileAgent?: Maybe<Agent>;
  name?: Maybe<Scalars['String']['output']>;
  nerdStoreCollection?: Maybe<Array<Maybe<NerdStoreCollectionMember>>>;
  nerdStoreDocument?: Maybe<Scalars['NerdStoreDocument']['output']>;
  /**
   * Make a query to NRDB with a NRQL string.
   *
   * See the [NRQL Docs](https://docs.newrelic.com/docs/insights/nrql-new-relic-query-language/nrql-resources/nrql-syntax-components-functions) for more information about generating a query string.
   *
   * Example NRQL query:
   * ```
   * SELECT count(*) FROM Transaction TIMESERIES
   * ```
   */
  nrdbQuery?: Maybe<NrdbResultContainer>;
  /**
   * Poll for the results of a previously-executed asychronous NRDB query.
   *
   * The `queryId` is available in the `queryProgress` data returned by the original asynchronous query.
   *
   * See [this page](https://docs.newrelic.com/docs/apis/nerdgraph/examples/async-queries-nrql-tutorial) for additional asynchronous query documentation.
   * @deprecated This field is experimental! It may change at any time.
   *
   */
  nrdbQueryProgress?: Maybe<NrdbResultContainer>;
  /** This field provides access to NrqlDropRules data. */
  nrqlDropRules?: Maybe<NrqlDropRulesAccountStitchedFields>;
  /**
   * This field provides access to NrqlLookups data.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  nrqlLookups?: Maybe<NrqlLookupsAccountStitchedFields>;
  /**
   * This field provides access to OpenAgentManagement data.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  openAgentManagement?: Maybe<OpenAgentManagementAccountStitchedFields>;
  ownedPartnerships?: Maybe<Array<Maybe<Partnership>>>;
  parent?: Maybe<AccountInfo>;
  partnership?: Maybe<Partnership>;
  /** @deprecated Please use the `partnership` field */
  partnershipId?: Maybe<Scalars['Int']['output']>;
  payMethod?: Maybe<Scalars['String']['output']>;
  /** This field provides access to Pixie data. */
  pixie?: Maybe<PixieAccountStitchedFields>;
  /** This field provides access to ProductConsumption data. */
  productConsumption?: Maybe<ProductConsumptionAccountStitchedFields>;
  /** @deprecated This field should no longer be used and returns empty results. */
  products?: Maybe<Array<Maybe<ClassicNavigationProduct>>>;
  /** This field provides access to Provisioning data. */
  provisioning?: Maybe<ProvisioningAccountStitchedFields>;
  region?: Maybe<Region>;
  settings?: Maybe<AccountSettings>;
  /** This field provides access to SignupIntegrations data. */
  signupIntegrations?: Maybe<SignupIntegrationsAccountStitchedFields>;
  status?: Maybe<AccountStatus>;
  /** This field provides access to StreamingExport data. */
  streamingExport?: Maybe<StreamingExportAccountStitchedFields>;
  subscription?: Maybe<ProductSubscription>;
  subscriptions?: Maybe<Array<Maybe<ProductSubscription>>>;
  /** This field provides access to Support data. */
  support?: Maybe<SupportAccountStitchedFields>;
  /** This field provides access to Synthetics data. */
  synthetics?: Maybe<SyntheticsAccountStitchedFields>;
  /**
   * ### transactionTrace
   * Requesting a Transaction Trace will permanently store it
   *
   * * `id`: the id of Transaction Trace to retrieve
   * @deprecated This is deprecated and will return null results. Please use `entity.transactionTrace` instead.
   */
  transactionTrace?: Maybe<TransactionTrace>;
  /** This field provides access to UserConsumption data. */
  userConsumption?: Maybe<UserConsumptionAccountStitchedFields>;
  users?: Maybe<Array<Maybe<UserInfo>>>;
  /**
   * This field provides access to WebsitePerformanceMonitoring data.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  websitePerformanceMonitoring?: Maybe<WebsitePerformanceMonitoringAccountStitchedFields>;
  /** This field provides access to Workload data. */
  workload?: Maybe<WorkloadAccountStitchedFields>;
};


export type AccountObjectAgentArgs = {
  id: Scalars['Int']['input'];
  type: AgentType;
};


export type AccountObjectAgentListingArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  type: AgentType;
};


export type AccountObjectAgentSearchByLabelArgs = {
  label: LabelSearchInput;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  type: AgentType;
};


export type AccountObjectAgentSearchByNameArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
  name: Scalars['String']['input'];
  offset?: InputMaybe<Scalars['Int']['input']>;
  type: AgentType;
};


export type AccountObjectAgentsArgs = {
  ids: Array<InputMaybe<Scalars['Int']['input']>>;
  type: AgentType;
};


export type AccountObjectCapabilitiesArgs = {
  filter?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
};


export type AccountObjectErrorTraceArgs = {
  id: Scalars['String']['input'];
};


export type AccountObjectEventTransformationRuleArgs = {
  id: Scalars['Int']['input'];
};


export type AccountObjectEventTransformationRuleListingArgs = {
  cursor?: InputMaybe<Scalars['String']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
};


export type AccountObjectFeatureFlagsArgs = {
  criteria?: InputMaybe<Scalars['String']['input']>;
  names: Array<InputMaybe<Scalars['String']['input']>>;
};


export type AccountObjectFeaturesArgs = {
  agentId: Scalars['Int']['input'];
  key: Scalars['String']['input'];
};


export type AccountObjectInfraSearchArgs = {
  filter: Scalars['EncodedInfraFilterSet']['input'];
  violating?: InputMaybe<Scalars['Boolean']['input']>;
};


export type AccountObjectMobileAgentArgs = {
  id: Scalars['Int']['input'];
};


export type AccountObjectNerdStoreCollectionArgs = {
  collection: Scalars['String']['input'];
};


export type AccountObjectNerdStoreDocumentArgs = {
  collection: Scalars['String']['input'];
  documentId: Scalars['String']['input'];
};


export type AccountObjectNrdbQueryArgs = {
  async?: InputMaybe<Scalars['Boolean']['input']>;
  nrql: Scalars['Nrql']['input'];
  options?: InputMaybe<NrqlQueryOptions>;
  timeout?: InputMaybe<Scalars['Seconds']['input']>;
};


export type AccountObjectNrdbQueryProgressArgs = {
  queryId: Scalars['ID']['input'];
};


export type AccountObjectSubscriptionArgs = {
  cacheBust?: InputMaybe<Scalars['Boolean']['input']>;
  productLine: Scalars['String']['input'];
};


export type AccountObjectTransactionTraceArgs = {
  id: Scalars['String']['input'];
};

/** The `AccountOutline` object provides basic data about an account. */
export type AccountOutline = {
  __typename?: 'AccountOutline';
  id?: Maybe<Scalars['Int']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  region?: Maybe<Region>;
  /** Returns event types that are currently reporting in the account. */
  reportingEventTypes?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
};


/** The `AccountOutline` object provides basic data about an account. */
export type AccountOutlineReportingEventTypesArgs = {
  filter?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  timeWindow?: InputMaybe<TimeWindowInput>;
};

/** The `AccountReference` object provides basic identifying information about the account. */
export type AccountReference = {
  __typename?: 'AccountReference';
  id?: Maybe<Scalars['Int']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  region?: Maybe<Region>;
};

export type AccountSettings = {
  __typename?: 'AccountSettings';
  alerts?: Maybe<AlertSettings>;
};

/** Autogenerated return type of AcceptInvitationByTokenMutation. */
export type AccountShareInvitationsAcceptInvitationByTokenMutationPayload = {
  __typename?: 'AccountShareInvitationsAcceptInvitationByTokenMutationPayload';
  /** Indicates whether the operation was completed successfully */
  success?: Maybe<Scalars['Boolean']['output']>;
};

/** The attributes of an account share invitation. */
export type AccountShareInvitationsAccountShareInvitation = {
  __typename?: 'AccountShareInvitationsAccountShareInvitation';
  /** The timestamp this account share invitation was created. */
  createdDate: Scalars['DateTime']['output'];
  /** The timestamp this account share invitation will expire. */
  expirationDate: Scalars['DateTime']['output'];
  /** The ID of the account share invitation. */
  id: Scalars['String']['output'];
  /** an opaque cursor to supply with subsequent   requests to get the next page of results, null if there are no more pages */
  nextCursor?: Maybe<Scalars['String']['output']>;
  /** A custom label created for this account share invitation. */
  note?: Maybe<Scalars['String']['output']>;
  /** The account share resource data. */
  resourceData: AccountShareInvitationsResourceData;
  /** The current status of the account share invitation. */
  status: Scalars['String']['output'];
  /** The Token generated when creating the account share invitation. */
  token: Scalars['SecureValue']['output'];
  /** The timestamp this account share invitation was last updated. */
  updatedDate: Scalars['DateTime']['output'];
};

/** The attributes of an account share invitation. */
export type AccountShareInvitationsAccountShareInvitationSearch = {
  __typename?: 'AccountShareInvitationsAccountShareInvitationSearch';
  /** Invitations to share an account. */
  accountShareInvitations: Array<AccountShareInvitationsAccountShareInvitation>;
  /** an opaque cursor to supply with subsequent   requests to get the next page of results, null if there are no more pages */
  nextCursor?: Maybe<Scalars['String']['output']>;
  /** the total number of results */
  totalCount: Scalars['Int']['output'];
};

/** Autogenerated return type of CreateAccountShareMutation. */
export type AccountShareInvitationsCreateAccountShareMutationPayload = {
  __typename?: 'AccountShareInvitationsCreateAccountShareMutationPayload';
  /** the account share invitation */
  accountShareInvitation: AccountShareInvitationsAccountShareInvitation;
};

export type AccountShareInvitationsOrganizationStitchedFields = {
  __typename?: 'AccountShareInvitationsOrganizationStitchedFields';
  /** list of account share invitations */
  accountShareInvitations?: Maybe<AccountShareInvitationsAccountShareInvitationSearch>;
};


export type AccountShareInvitationsOrganizationStitchedFieldsAccountShareInvitationsArgs = {
  accountIds?: InputMaybe<Array<Scalars['Int']['input']>>;
  cursor?: InputMaybe<Scalars['String']['input']>;
  ids?: InputMaybe<Array<Scalars['ID']['input']>>;
  status?: InputMaybe<Scalars['String']['input']>;
};

/** The attributes of an account share invitation. */
export type AccountShareInvitationsResourceData = {
  __typename?: 'AccountShareInvitationsResourceData';
  /** The ID of the account share invitation. */
  accountId: Scalars['Int']['output'];
  /** The Token generated when creating the account share invitation. */
  limitingRoleId: Scalars['Int']['output'];
};

/** Autogenerated return type of RevokeInvitationByIdMutation. */
export type AccountShareInvitationsRevokeInvitationByIdMutationPayload = {
  __typename?: 'AccountShareInvitationsRevokeInvitationByIdMutationPayload';
  /** Indicates whether the operation was completed successfully */
  success?: Maybe<Scalars['Boolean']['output']>;
};

export enum AccountStatus {
  Active = 'ACTIVE',
  AwaitingUserFromApi = 'AWAITING_USER_FROM_API',
  Cancelled = 'CANCELLED',
  Downgraded = 'DOWNGRADED',
  New = 'NEW',
  PaidActive = 'PAID_ACTIVE',
  PaidNew = 'PAID_NEW',
  PaidPending = 'PAID_PENDING',
  Pending = 'PENDING',
  Upgraded = 'UPGRADED'
}

/** Object containing activity stream event. */
export type ActivityStreamEvent = {
  __typename?: 'ActivityStreamEvent';
  /**
   * Action applied to the referenced object.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  action: Scalars['String']['output'];
  /**
   * Count of events with the same eventId.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  count: Scalars['Int']['output'];
  /**
   * Description of the event.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  description: Scalars['String']['output'];
  /**
   * The entity associated to this event.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  entity?: Maybe<EntityOutline>;
  /**
   * family of the event.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  family: Scalars['String']['output'];
  /**
   * String that can be used to correlate two or more events.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  groupId?: Maybe<Scalars['String']['output']>;
  /**
   * The guid of the entity associated to this event.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  guid: Scalars['EntityGuid']['output'];
  /**
   * Id of the event. That would be the unique identifier of the event.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  id: Scalars['String']['output'];
  /**
   * Id of the object relative to the family.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  objectId?: Maybe<Scalars['String']['output']>;
  /**
   * Type of the object relative to the family.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  objectType: Scalars['String']['output'];
  /**
   * Link related to the object of the event.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  objectUrl?: Maybe<Scalars['String']['output']>;
  /**
   * Level of severity. INFO, WARNING, CRITICAL.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  severity: ActivityStreamEventSeverity;
  /**
   * Timestamp when the event was emitted.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  timestamp: Scalars['EpochMilliseconds']['output'];
  /**
   * Title of the event.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  title: Scalars['String']['output'];
};

/** A set of filters for activity events. */
export type ActivityStreamEventFilter = {
  /** List of event actions to filter events by. Possible values are [Started, Ended, Deployed, Created, Updated, Deleted]. */
  actions?: InputMaybe<Array<Scalars['String']['input']>>;
  /** List of event families to filter events by. Possible values are [Alerts, Anomalies, Deployments, Workloads, Infrastructure]. */
  families?: InputMaybe<Array<Scalars['String']['input']>>;
  /**
   * List of object types to filter events by. Possible values are (by family)
   * - Alerts: [Violation]
   * - Anomalies: [Anomaly]
   * - Deployments: [Basic, Blue-green, Canary, Other, Rolling, Shadow]
   * - Workloads: [Workload]
   * - Infrastructure: [Agent, Inventory]
   * - Kubernetes: [Pod, Deployment]
   */
  objectTypes?: InputMaybe<Array<Scalars['String']['input']>>;
  /** List of severities to filter events by. */
  severities?: InputMaybe<Array<ActivityStreamEventSeverity>>;
};

/** We have 3 levels of severity. */
export enum ActivityStreamEventSeverity {
  /**
   * Critical event.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  Critical = 'CRITICAL',
  /**
   * Info event.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  Info = 'INFO',
  /**
   * Warning event.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  Warning = 'WARNING'
}

/** The object contains the filters to be applied to the search. */
export type ActivityStreamSearchFilter = {
  /** Include events matching the filter. */
  include?: InputMaybe<ActivityStreamEventFilter>;
  /** Maximum number of events to be returned. */
  limit?: InputMaybe<Scalars['Int']['input']>;
  /** Search time window. */
  timeWindow: TimeWindowInput;
};

/** The result of the activity search query. */
export type ActivityStreamSearchResult = {
  __typename?: 'ActivityStreamSearchResult';
  /**
   * The list of activity events in the given time window.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  results: Array<ActivityStreamEvent>;
};

/** The `Actor` object contains fields that are scoped to the API user's access level. */
export type Actor = {
  __typename?: 'Actor';
  /** The `account` field is the entry point into data that is scoped to a single account. */
  account?: Maybe<Account>;
  /** The `accounts` field returns all accounts that the Actor is authorized to view. */
  accounts?: Maybe<Array<Maybe<AccountOutline>>>;
  /**
   * Retrieve the activity stream events applying filters when present.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  activitySearch?: Maybe<ActivityStreamSearchResult>;
  /** This field provides access to AiOps data. */
  aiOps?: Maybe<AiOpsActorStitchedFields>;
  /** This field provides access to Alerts data. */
  alerts?: Maybe<AlertsActorStitchedFields>;
  /** This field provides access to AnomalyDetectorConfigurations data. */
  anomalyDetectorConfigurations?: Maybe<AnomalyDetectorConfigurationsActorStitchedFields>;
  /** This field provides access to ApiAccess data. */
  apiAccess?: Maybe<ApiAccessActorStitchedFields>;
  /** authorizeEntity checks the actor's capabilities. Can the user do an action on a target entity? */
  authorizeEntity?: Maybe<AuthorizationAuthorizeEntityResult>;
  /** The billableCoreUserAccounts for the current actor. */
  billableCoreUserAccounts?: Maybe<Array<Maybe<AuthorizationBillableCoreUserAccount>>>;
  /**
   * The list of authorized capabilities for the given scopeType and scopeId as well as the authentication context.
   *
   *  * Actor: capabilities for acting on the actor themselves. scopeId must be null or absent.
   *  * Organization: capabilities for acting on the organization. scopeId is required.
   *  * Account: capabilities for acting on the account. scopeId is required.
   *  * Global: capabilities for acting globally. scopeId must be null or absent.
   */
  capabilities?: Maybe<Array<Maybe<AuthorizationCapability>>>;
  /** This field provides access to ChangeTracking data. */
  changeTracking?: Maybe<ChangeTrackingActorStitchedFields>;
  /** The `cloud` field provides access to cloud integrations configuration data scoped to the Actor. */
  cloud?: Maybe<CloudActorFields>;
  /**
   * This field provides access to Collaboration data.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  collaboration?: Maybe<CollaborationActorStitchedFields>;
  /**
   * This field provides access to CourierNotificationPreferences data.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  courierNotificationPreferences?: Maybe<CourierNotificationPreferencesActorStitchedFields>;
  /** This field provides access to Dashboard data. */
  dashboard?: Maybe<DashboardActorStitchedFields>;
  /** This field provides access to DataSourceGaps data. */
  dataSourceGaps?: Maybe<DataSourceGapsActorStitchedFields>;
  /** This field provides access to DistributedTracing data. */
  distributedTracing?: Maybe<DistributedTracingActorStitchedFields>;
  /**
   * Fetch a list of entities.
   *
   * You can fetch a max of 25 entities in one query.
   *
   * For more details on entities, visit our [entity docs](https://docs.newrelic.com/docs/apis/graphql-api/tutorials/use-new-relic-graphql-api-query-entities).
   */
  entities?: Maybe<Array<Maybe<Entity>>>;
  /**
   * Fetch a single entity.
   *
   * For more details on entities, visit our [entity docs](https://docs.newrelic.com/docs/apis/graphql-api/tutorials/use-new-relic-graphql-api-query-entities).
   */
  entity?: Maybe<Entity>;
  /**
   * Search for entities using a custom query.
   *
   * For more details on how to create a custom query
   * and what entity data you can request, visit our
   * [entity docs](https://docs.newrelic.com/docs/apis/graphql-api/tutorials/use-new-relic-graphql-api-query-entities).
   *
   * Note: you must supply either a `query` OR a `queryBuilder` argument, not both.
   */
  entitySearch?: Maybe<EntitySearch>;
  /**
   * Entity search with sorting by golden metric.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  entitySearchSortByGoldenMetric?: Maybe<EntitySearchSortByGoldenMetricResult>;
  /** Contains information about the entity types specified in the `entityTypes` argument. */
  entityTypes?: Maybe<Array<Maybe<EntityTypeResults>>>;
  /** This field provides access to ErrorsInbox data. */
  errorsInbox?: Maybe<ErrorsInboxActorStitchedFields>;
  /**
   * This field provides access to GoldenMetricsSearch data.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  goldenMetricsSearch?: Maybe<GoldenMetricsSearchActorStitchedFields>;
  /**
   * This field provides access to Grok data.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  grok?: Maybe<GrokActorStitchedFields>;
  /** This field provides access to IncidentIntelligenceEnvironment data. */
  incidentIntelligenceEnvironment?: Maybe<IncidentIntelligenceEnvironmentActorStitchedFields>;
  /** This field provides access to MobilePushNotification data. */
  mobilePushNotification?: Maybe<MobilePushNotificationActorStitchedFields>;
  /**
   * NerdStorage is a document database that is accessible within the New Relic One interface.
   * This allows for persistence of Nerdpack data including users' configuration settings and preferences
   * (like favorites), or any other small data sets.
   *
   * Conceptually, you can imagine NerdStorage as a nested key-value map.
   *
   * For information on New Relic NerdStorage, visit [our docs](https://developer.newrelic.com/build-tools/new-relic-one-applications/nerdstorage).
   *
   * To use the NerdStorage schema you must specify a Nerdpack ID using the NewRelic-Package-Id header in your request.
   */
  nerdStorage?: Maybe<NerdStorageActorScope>;
  /** This field provides access to NerdStorageVault data. */
  nerdStorageVault?: Maybe<NerdStorageVaultActorStitchedFields>;
  nerdStoreCollection?: Maybe<Array<Maybe<NerdStoreCollectionMember>>>;
  nerdStoreDocument?: Maybe<Scalars['NerdStoreDocument']['output']>;
  /** Nerdpacks registry. Provides queries for nerdpacks by different conditions */
  nerdpacks?: Maybe<NerdpackNerdpacks>;
  /** This field provides access to NetworkMonitoring data. */
  networkMonitoring?: Maybe<NetworkMonitoringActorStitchedFields>;
  /**
   * This field provides access to NewRelicServiceHealth data.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  newRelicServiceHealth?: Maybe<NewRelicServiceHealthActorStitchedFields>;
  /** This field provides access to Nr1Catalog data. */
  nr1Catalog?: Maybe<Nr1CatalogActorStitchedFields>;
  /**
   * Make a query to NRDB with a NRQL string.
   *
   * See the [NRQL Docs](https://docs.newrelic.com/docs/insights/nrql-new-relic-query-language/nrql-resources/nrql-syntax-components-functions) for more information about generating a query string.
   *
   * Example NRQL query:
   * ```
   * SELECT count(*) FROM Transaction TIMESERIES
   * ```
   *
   * For more details on how to use NRQL in the GraphQL API, visit [our docs](https://docs.newrelic.com/docs/apis/graphql-api/tutorials/query-nrql-through-new-relic-graphql-api)
   */
  nrql?: Maybe<CrossAccountNrdbResultContainer>;
  /** This field provides access to NrqlQueriedEntities data. */
  nrqlQueriedEntities?: Maybe<NrqlQueriedEntitiesActorStitchedFields>;
  /**
   * A historical log of NRQL queries executed by you.
   * @deprecated This field is deprecated and returns no data. Please use `queryHistory`.
   *
   */
  nrqlQueryHistory?: Maybe<Array<Maybe<NrqlHistoricalQuery>>>;
  /**
   * Poll for the results of a previously-executed asychronous NRDB query.
   *
   * The `queryId` is available in the `queryProgress` data returned by the original asynchronous query.
   *
   * See [this page](https://docs.newrelic.com/docs/apis/nerdgraph/examples/async-queries-nrql-tutorial) for additional asynchronous query documentation.
   * @deprecated This field is experimental! It may change at any time.
   *
   */
  nrqlQueryProgress?: Maybe<CrossAccountNrdbResultContainer>;
  /** The `organization` field is the entry point into data that is scoped to the user's organization. */
  organization?: Maybe<Organization>;
  /** This field provides access to Personalization data. */
  personalization?: Maybe<PersonalizationActorStitchedFields>;
  /** This field provides access to Pixie data. */
  pixie?: Maybe<PixieActorStitchedFields>;
  /** This field provides access to PreReleaseProgram data. */
  preReleaseProgram?: Maybe<PreReleaseProgramActorStitchedFields>;
  /** This field provides access to ProductConsumption data. */
  productConsumption?: Maybe<ProductConsumptionActorStitchedFields>;
  /** This field provides access to ProgrammabilityTnC data. */
  programmabilityTnC?: Maybe<ProgrammabilityTnCActorStitchedFields>;
  /** This field provides access to Provisioning data. */
  provisioning?: Maybe<ProvisioningActorStitchedFields>;
  /** This field provides access to QueryHistory data. */
  queryHistory?: Maybe<QueryHistoryActorStitchedFields>;
  /** Relationship search query that allows to traverse relationships. WARNING: this query is still experimental, and subject to breaking changes. */
  relationshipSearch?: Maybe<EntityRelationshipSearchResponse>;
  /**
   * This field provides access to SavedViews data.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  savedViews?: Maybe<SavedViewsActorStitchedFields>;
  /** This field provides access to Support data. */
  support?: Maybe<SupportActorStitchedFields>;
  /** This field provides access to Synthetics data. */
  synthetics?: Maybe<SyntheticsActorStitchedFields>;
  /** This field provides access to Tagging data. */
  tagging?: Maybe<TaggingActorStitchedFields>;
  /** This field provides access to Team data. */
  team?: Maybe<TeamActorStitchedFields>;
  /** The authenticated `User` who made this request. */
  user?: Maybe<User>;
  /**
   * This field provides access to UserEmailNotificationPreferences data.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  userEmailNotificationPreferences?: Maybe<UserEmailNotificationPreferencesActorStitchedFields>;
  /** This field provides access to Users data. */
  users?: Maybe<UsersActorStitchedFields>;
};


/** The `Actor` object contains fields that are scoped to the API user's access level. */
export type ActorAccountArgs = {
  id: Scalars['Int']['input'];
};


/** The `Actor` object contains fields that are scoped to the API user's access level. */
export type ActorAccountsArgs = {
  scope?: InputMaybe<RegionScope>;
};


/** The `Actor` object contains fields that are scoped to the API user's access level. */
export type ActorActivitySearchArgs = {
  filter: ActivityStreamSearchFilter;
  guids: Array<Scalars['EntityGuid']['input']>;
};


/** The `Actor` object contains fields that are scoped to the API user's access level. */
export type ActorAuthorizeEntityArgs = {
  action: Scalars['String']['input'];
  context: AuthorizationContext;
  target: AuthorizationObject;
};


/** The `Actor` object contains fields that are scoped to the API user's access level. */
export type ActorCapabilitiesArgs = {
  filter?: InputMaybe<AuthorizationFilter>;
  scopeId?: InputMaybe<Scalars['ID']['input']>;
  scopeType: AuthorizationScopeType;
};


/** The `Actor` object contains fields that are scoped to the API user's access level. */
export type ActorEntitiesArgs = {
  guids: Array<InputMaybe<Scalars['EntityGuid']['input']>>;
};


/** The `Actor` object contains fields that are scoped to the API user's access level. */
export type ActorEntityArgs = {
  guid: Scalars['EntityGuid']['input'];
};


/** The `Actor` object contains fields that are scoped to the API user's access level. */
export type ActorEntitySearchArgs = {
  options?: InputMaybe<EntitySearchOptions>;
  query?: InputMaybe<Scalars['String']['input']>;
  queryBuilder?: InputMaybe<EntitySearchQueryBuilder>;
  sortBy?: InputMaybe<Array<InputMaybe<EntitySearchSortCriteria>>>;
  sortByWithDirection?: InputMaybe<Array<InputMaybe<SortCriterionWithDirection>>>;
};


/** The `Actor` object contains fields that are scoped to the API user's access level. */
export type ActorEntitySearchSortByGoldenMetricArgs = {
  cursor?: InputMaybe<Scalars['String']['input']>;
  domainType: DomainTypeInput;
  filters?: InputMaybe<Array<EntitySearchMetricFilterInput>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  query?: InputMaybe<Scalars['String']['input']>;
  sortBy: EntitySearchMetricSortByInput;
  timeWindow?: InputMaybe<TimeWindowInput>;
};


/** The `Actor` object contains fields that are scoped to the API user's access level. */
export type ActorEntityTypesArgs = {
  domainTypes?: InputMaybe<Array<DomainTypeInput>>;
};


/** The `Actor` object contains fields that are scoped to the API user's access level. */
export type ActorNerdStoreCollectionArgs = {
  collection: Scalars['String']['input'];
};


/** The `Actor` object contains fields that are scoped to the API user's access level. */
export type ActorNerdStoreDocumentArgs = {
  collection: Scalars['String']['input'];
  documentId: Scalars['String']['input'];
};


/** The `Actor` object contains fields that are scoped to the API user's access level. */
export type ActorNrqlArgs = {
  accounts: Array<Scalars['Int']['input']>;
  async?: InputMaybe<Scalars['Boolean']['input']>;
  options?: InputMaybe<NrqlQueryOptions>;
  query: Scalars['Nrql']['input'];
  timeout?: InputMaybe<Scalars['Seconds']['input']>;
};


/** The `Actor` object contains fields that are scoped to the API user's access level. */
export type ActorNrqlQueryProgressArgs = {
  accounts: Array<Scalars['Int']['input']>;
  queryId: Scalars['ID']['input'];
};


/** The `Actor` object contains fields that are scoped to the API user's access level. */
export type ActorRelationshipSearchArgs = {
  filters?: InputMaybe<EntityRelationshipSearchFilters>;
  fromEntitiesGuids?: InputMaybe<Array<Scalars['EntityGuid']['input']>>;
  fromEntitiesQuery?: InputMaybe<EntityRelationshipEntitySearchQueryInput>;
  hops?: InputMaybe<Scalars['Int']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
};

/** A single component of an address (e.g. state) */
export type AddressAutocompleteAddressDetail = {
  __typename?: 'AddressAutocompleteAddressDetail';
  /** Long version of component (e.g. Florida) */
  longName?: Maybe<Scalars['String']['output']>;
  /** Short version of component (e.g. FL) */
  shortName?: Maybe<Scalars['String']['output']>;
  /** Classification of component (e.g. country, postal_code, etc) */
  types?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
};

/** A single street address suggestion. */
export type AddressAutocompleteAddressSuggestion = {
  __typename?: 'AddressAutocompleteAddressSuggestion';
  /** Street address */
  address?: Maybe<Scalars['String']['output']>;
  /** 3rd party service's identifier for address */
  id?: Maybe<Scalars['String']['output']>;
};

export type AddressAutocompleteNrPlatformStitchedFields = {
  __typename?: 'AddressAutocompleteNrPlatformStitchedFields';
  /** Query for address details broken into individual components (zip code, state, etc) from address id. */
  addressDetails?: Maybe<Array<Maybe<AddressAutocompleteAddressDetail>>>;
  /** Query for address autocomplete suggestions based from partial address. */
  addressSuggestions?: Maybe<Array<Maybe<AddressAutocompleteAddressSuggestion>>>;
};


export type AddressAutocompleteNrPlatformStitchedFieldsAddressDetailsArgs = {
  id: Scalars['String']['input'];
  token: Scalars['String']['input'];
};


export type AddressAutocompleteNrPlatformStitchedFieldsAddressSuggestionsArgs = {
  query: Scalars['String']['input'];
  token: Scalars['String']['input'];
};

export type Agent = {
  __typename?: 'Agent';
  enabled?: Maybe<Scalars['Boolean']['output']>;
  entity?: Maybe<EntityGuidSegments>;
  /** @deprecated This field is deprecated and does not return results. */
  features?: Maybe<Array<Maybe<AgentFeature>>>;
  id?: Maybe<Scalars['String']['output']>;
  /** @deprecated Please use `entitySearch` and `relationships` */
  infraHosts?: Maybe<Array<Maybe<InfraHost>>>;
  /** @deprecated This field is deprecated and does not return results. Please use entity tags instead. */
  labels?: Maybe<Array<Maybe<Label>>>;
  language?: Maybe<Scalars['String']['output']>;
  /** The agent's `name` as displayed & configured by the UI. */
  name?: Maybe<Scalars['String']['output']>;
  realAgents?: Maybe<Array<Maybe<RealAgent>>>;
  /** Given a list of metric names, return those metrics that have ever been reported by this agent. */
  reportedMetrics?: Maybe<Array<Maybe<Metric>>>;
  /** Reporting status will be queried for the last `30` minutes */
  reporting?: Maybe<Scalars['Boolean']['output']>;
  /** The agent's `reportingName` is the name that the actual Agent uses to identify itself when reporting to New Relic. */
  reportingName?: Maybe<Scalars['String']['output']>;
  settings?: Maybe<AgentSettings>;
  statuses?: Maybe<Array<Maybe<AgentStatus>>>;
  /** Summary values will be queried for the last `duration` minutes */
  summary?: Maybe<AgentSummary>;
  type?: Maybe<AgentType>;
  /** Agent version information for the running instances of the application. */
  versions?: Maybe<AgentVersions>;
  /** Returns any violations open during the requested time window. */
  violations?: Maybe<Array<Maybe<AgentViolation>>>;
};


export type AgentFeaturesArgs = {
  names?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
};


export type AgentRealAgentsArgs = {
  duration?: InputMaybe<Scalars['Minutes']['input']>;
};


export type AgentReportedMetricsArgs = {
  names: Array<InputMaybe<Scalars['String']['input']>>;
};


export type AgentSummaryArgs = {
  duration: Scalars['Minutes']['input'];
};


export type AgentViolationsArgs = {
  endTime: Scalars['EpochMilliseconds']['input'];
  startTime: Scalars['EpochMilliseconds']['input'];
};

/** The settings of a browser application. */
export type AgentApplicationApmBrowserSettings = {
  __typename?: 'AgentApplicationApmBrowserSettings';
  /** Configure cookies. The default is enabled: true. */
  cookiesEnabled: Scalars['Boolean']['output'];
  /** Configure distributed tracing in browser apps. The default is enabled: true. */
  distributedTracingEnabled: Scalars['Boolean']['output'];
  /** Determines which browser loader will be configured. The default is "SPA". */
  loaderType: AgentApplicationBrowserLoader;
};

/**
 * Determines which browser loader will be configured. There are three browser loader types. They are Pro+SPA, Pro, and Lite.
 * See [documentation](https://docs.newrelic.com/docs/browser/browser-monitoring/installation/install-browser-monitoring-agent/#agent-types) for further information.
 */
export enum AgentApplicationBrowserLoader {
  /**
   * Use PRO instead.
   * @deprecated Browsers which historically had the FULL loader will now return PRO as the loader type.
   */
  Full = 'FULL',
  /** Lite: Gives you information about some basic page load timing and browser user information. Lacks the Browser Pro features and SPA features. */
  Lite = 'LITE',
  /** Don't use an agent. */
  None = 'NONE',
  /** Pro: Gives you access to the Browser Pro features. Lacks the functionality designed for single page app monitoring. */
  Pro = 'PRO',
  /** Pro+SPA: This is the default installed agent when you enable browser monitoring. Gives you access to all of the Browser Pro features and to Single Page App (SPA) monitoring. Provides detailed page timing data and the most up-to-date New Relic features, including distributed tracing, for all types of applications. */
  Spa = 'SPA'
}

/** The settings of a browser application. Includes loader script. */
export type AgentApplicationBrowserSettings = {
  __typename?: 'AgentApplicationBrowserSettings';
  /** Configure cookies. The default is enabled: true. */
  cookiesEnabled: Scalars['Boolean']['output'];
  /** Configure distributed tracing in browser apps. The default is enabled: true. */
  distributedTracingEnabled: Scalars['Boolean']['output'];
  /** The snippet of JavaScript used to copy/paste into your JavaScript app if you aren't using an auto-instrumenting agent on the backend. Note that the resulting snippet will be a JSON string that will need to be parsed before using in your browser application. */
  loaderScript?: Maybe<Scalars['String']['output']>;
  /** Determines which browser loader will be configured. The default is "SPA". */
  loaderType: AgentApplicationBrowserLoader;
};

/** Configure additional browser settings here. */
export type AgentApplicationBrowserSettingsInput = {
  /** Configure cookies. The default is enabled: true. */
  cookiesEnabled?: InputMaybe<Scalars['Boolean']['input']>;
  /** Configure distributed tracing in browser apps. The default is enabled: true. */
  distributedTracingEnabled?: InputMaybe<Scalars['Boolean']['input']>;
  /** Determines which browser loader is configured. The default is "SPA". */
  loaderType?: InputMaybe<AgentApplicationBrowserLoader>;
};

/** The result of creating a browser application. */
export type AgentApplicationCreateBrowserResult = {
  __typename?: 'AgentApplicationCreateBrowserResult';
  /** The GUID for the affected Entity. */
  guid: Scalars['EntityGuid']['output'];
  /** The name of the application. */
  name: Scalars['String']['output'];
  /** Fields related to browser settings. */
  settings?: Maybe<AgentApplicationBrowserSettings>;
};

/** The result of creating a mobile application. */
export type AgentApplicationCreateMobileResult = {
  __typename?: 'AgentApplicationCreateMobileResult';
  /** The application's account ID. */
  accountId: Scalars['Int']['output'];
  /** The mobile application's token. */
  applicationToken: Scalars['SecureValue']['output'];
  /** Additional information about the mobile application. */
  entityOutline?: Maybe<EntityOutline>;
  /** The new mobile application's GUID. */
  guid: Scalars['EntityGuid']['output'];
  /** The application's name. */
  name: Scalars['String']['output'];
};

/** The result of deleting an application. */
export type AgentApplicationDeleteResult = {
  __typename?: 'AgentApplicationDeleteResult';
  /** Did the delete succeed? */
  success: Scalars['Boolean']['output'];
};

/** The result of enabling browser monitoring for an APM-monitored application. */
export type AgentApplicationEnableBrowserResult = {
  __typename?: 'AgentApplicationEnableBrowserResult';
  /** The application's name */
  name: Scalars['String']['output'];
  /** Fields related to browser settings. */
  settings?: Maybe<AgentApplicationApmBrowserSettings>;
};

/** The allow list object for browser applications. */
export type AgentApplicationSegmentsBrowserSegmentAllowList = {
  __typename?: 'AgentApplicationSegmentsBrowserSegmentAllowList';
  /** INTERNAL or USER */
  listType?: Maybe<AgentApplicationSegmentsListType>;
  /** The url segments that are allowed. */
  segments?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
};

/** The allow list that you would like to modify. */
export type AgentApplicationSegmentsBrowserSegmentAllowListInput = {
  /** INTERNAL or USER. Defaults to USER. */
  listType?: InputMaybe<AgentApplicationSegmentsListType>;
  /** A case sensitive list of url segments. The list cannot exceed 8192 characters in total. Each segment must be less than 100 characters. */
  segments: Array<InputMaybe<Scalars['String']['input']>>;
};

/** The resulting allow list after the modifications have been made. */
export type AgentApplicationSegmentsBrowserSegmentAllowListResult = {
  __typename?: 'AgentApplicationSegmentsBrowserSegmentAllowListResult';
  /** The NR1 entity guid. */
  entityGuid: Scalars['EntityGuid']['output'];
  /** The aggregate result of the segments in the modified list or lists. */
  segments?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
};

/** Allow lists have two different types. They are either internal lists or user lists. */
export enum AgentApplicationSegmentsListType {
  /** INTERNAL refers to a list that has been generated by New Relic. */
  Internal = 'INTERNAL',
  /** USER refers to a list that has been generated by the customer. */
  User = 'USER'
}

/** Filter the allow lists by fields specified in this object. */
export type AgentApplicationSegmentsSegmentAllowListFilters = {
  /** INTERNAL or USER. Defaults to USER */
  listType?: InputMaybe<AgentApplicationSegmentsListType>;
};

/** Settings that are applicable to APM applications and their agents. */
export type AgentApplicationSettingsApmBase = {
  __typename?: 'AgentApplicationSettingsApmBase';
  /** The name for the application */
  alias?: Maybe<Scalars['String']['output']>;
  /** Access general settings for the application. */
  apmConfig: AgentApplicationSettingsApmConfig;
  /** Enable or disable the capture of memcache keys. */
  captureMemcacheKeys?: Maybe<Scalars['Boolean']['output']>;
  /** Access settings regarding how events are handled with NRDB. */
  dataManagement: AgentApplicationSettingsDataManagement;
  /** Access error collector settings for the application. The error collector captures information about uncaught exceptions and sends them to New Relic for viewing. */
  errorCollector?: Maybe<AgentApplicationSettingsErrorCollector>;
  /** Access enabled state for the Java Flight Recorder. This is available only for the Java language agent version 8.0.0 or later. */
  jfr?: Maybe<AgentApplicationSettingsJfr>;
  /** The name originally given to the application for reporting. */
  originalName?: Maybe<Scalars['String']['output']>;
  /** In APM, when transaction traces are collected, there may be additional Slow query data available. */
  slowSql?: Maybe<AgentApplicationSettingsSlowSql>;
  /** Measures wall clock time, CPU time, and method call counts in your application's threads as they run. */
  threadProfiler?: Maybe<AgentApplicationSettingsThreadProfiler>;
  /** Type of tracer used. APM's cross application tracing links transactions between APM apps in your service-oriented architecture (SOA).  Distributed tracing is an improvement on the cross application tracing feature, and is recommended for large, distributed systems. */
  tracerType?: Maybe<AgentApplicationSettingsTracer>;
  /** Access transaction tracer settings for the application. */
  transactionTracer?: Maybe<AgentApplicationSettingsTransactionTracer>;
};

/** General settings related to APM applications. */
export type AgentApplicationSettingsApmConfig = {
  __typename?: 'AgentApplicationSettingsApmConfig';
  /** The desired target for the APDEX measurement of this APM application. */
  apdexTarget?: Maybe<Scalars['Float']['output']>;
  /** Sets if agents for this APM application should get some of their configuration from the server. */
  useServerSideConfig?: Maybe<Scalars['Boolean']['output']>;
};

/** Provides fields to set general APM application settings. */
export type AgentApplicationSettingsApmConfigInput = {
  /** The desired target for the APDEX measurement of this application. */
  apdexTarget?: InputMaybe<Scalars['Float']['input']>;
  /** Sets if installed agents should override local settings with ones set here. */
  useServerSideConfig?: InputMaybe<Scalars['Boolean']['input']>;
};

/** Browser Ajax. */
export type AgentApplicationSettingsBrowserAjax = {
  __typename?: 'AgentApplicationSettingsBrowserAjax';
  /** List of domains excluded from Ajax traces by the browser agent. */
  denyList?: Maybe<Array<Scalars['String']['output']>>;
};

/** Configuration settings related to how a browser agent handles Ajax requests. */
export type AgentApplicationSettingsBrowserAjaxInput = {
  /** A list of host destinations that will not record AjaxRequest events when requested. */
  denyList?: InputMaybe<Array<Scalars['String']['input']>>;
};

/** Settings that are applicable to browser applications. */
export type AgentApplicationSettingsBrowserBase = {
  __typename?: 'AgentApplicationSettingsBrowserBase';
  /** Access general settings for the application. */
  browserConfig: AgentApplicationSettingsBrowserConfig;
  /** browser monitoring provides real user monitoring (RUM) that measures the speed and performance of end users as they navigate the application using different web browsers, devices, operating systems, and networks. */
  browserMonitoring: AgentApplicationSettingsBrowserMonitoring;
  /** Access settings regarding how events are handled with NRDB. */
  dataManagement: AgentApplicationSettingsDataManagement;
  /** Session Replay configuration. */
  sessionReplay: AgentApplicationSettingsSessionReplay;
  /** Session Config configuration. */
  sessionTrace: AgentApplicationSettingsSessionTrace;
};

/** General settings related to APM applications. */
export type AgentApplicationSettingsBrowserConfig = {
  __typename?: 'AgentApplicationSettingsBrowserConfig';
  /** The desired target for the APDEX measurement of this browser application. */
  apdexTarget?: Maybe<Scalars['Float']['output']>;
};

/** Provides fields to set general browser application settings. */
export type AgentApplicationSettingsBrowserConfigInput = {
  /** The desired target for the APDEX measurement of this application. */
  apdexTarget?: InputMaybe<Scalars['Float']['input']>;
};

/** Distributed tracing type. See [documentation](https://docs.newrelic.com/docs/browser/new-relic-browser/browser-pro-features/browser-data-distributed-tracing/) for further information. */
export type AgentApplicationSettingsBrowserDistributedTracing = {
  __typename?: 'AgentApplicationSettingsBrowserDistributedTracing';
  /** List of allowed origins for use with distributed tracing. */
  allowedOrigins?: Maybe<Array<Scalars['String']['output']>>;
  /** Whether or not CORS is enabled in distributed tracing. */
  corsEnabled?: Maybe<Scalars['Boolean']['output']>;
  /** Whether or not CORS uses the `newrelic` header in distributed tracing. */
  corsUseNewrelicHeader?: Maybe<Scalars['Boolean']['output']>;
  /** Whether or not CORS uses tracecontext headers in distributed tracing. */
  corsUseTracecontextHeaders?: Maybe<Scalars['Boolean']['output']>;
  /** Whether or not distributed tracing is enabled. */
  enabled?: Maybe<Scalars['Boolean']['output']>;
  /** Whether or not to exclude the `newrelic` header in distributed tracing. */
  excludeNewrelicHeader?: Maybe<Scalars['Boolean']['output']>;
};

/** Configure distributed traces from within browser apps. */
export type AgentApplicationSettingsBrowserDistributedTracingInput = {
  /** Supplies allowed origins for distributed tracing in browser. */
  allowedOrigins?: InputMaybe<Array<Scalars['String']['input']>>;
  /** Enables CORS for distributed tracing in browser. */
  corsEnabled?: InputMaybe<Scalars['Boolean']['input']>;
  /** Enables the use of the `newrelic` header for CORS requests with distributed tracing. [See Docs](https://docs.newrelic.com/docs/browser/new-relic-browser/browser-pro-features/browser-data-distributed-tracing/#cors) for more information. */
  corsUseNewrelicHeader?: InputMaybe<Scalars['Boolean']['input']>;
  /** Enables CORS to use tracecontext headers for distributed tracing in browser. */
  corsUseTracecontextHeaders?: InputMaybe<Scalars['Boolean']['input']>;
  /** Enables distributed tracing in browser. */
  enabled?: InputMaybe<Scalars['Boolean']['input']>;
  /** Enables the `newrelic` header to be excluded in distributed tracing in browser. */
  excludeNewrelicHeader?: InputMaybe<Scalars['Boolean']['input']>;
};

/**
 * Determines which browser loader will be configured. Some allowed return values are specified for backwards-compatability and do not represent currently allowed values for new applications.
 * See [documentation](https://docs.newrelic.com/docs/browser/browser-monitoring/installation/install-browser-monitoring-agent/#agent-types) for further information.
 */
export enum AgentApplicationSettingsBrowserLoader {
  /**
   * Use PRO instead
   * @deprecated Browsers which historically had the FULL loader will now return PRO as the loader type.
   */
  Full = 'FULL',
  /** Lite: Gives you information about some basic page load timing and browser user information. Lacks the Browser Pro features and SPA features. */
  Lite = 'LITE',
  /** Don't use an agent. */
  None = 'NONE',
  /** Pro: Gives you access to the Browser Pro features. Lacks the functionality designed for single page app monitoring. */
  Pro = 'PRO',
  /**
   * This value is no longer in use.
   * @deprecated Browsers which historically had the RUM loader will now return LITE as the loader type.
   */
  Rum = 'RUM',
  /** Pro+SPA: This is the default installed agent when you enable browser monitoring. Gives you access to all of the Browser Pro features and to Single Page App (SPA) monitoring. Provides detailed page timing data and the most up-to-date New Relic features, including distributed tracing, for all types of applications. */
  Spa = 'SPA',
  /** This value is specified for backwards-compatability. */
  Xhr = 'XHR'
}

/** We have three types of browser agents: Lite, Pro, and Pro+SPA. */
export enum AgentApplicationSettingsBrowserLoaderInput {
  /**
   * Use PRO instead.
   * @deprecated Browsers which historically had the FULL loader will now return PRO as the loader type.
   */
  Full = 'FULL',
  /** Lite: Gives you information about some basic page load timing and browser user information. Lacks the Browser Pro features and SPA features. */
  Lite = 'LITE',
  /** Don't use an agent. */
  None = 'NONE',
  /** Pro: Gives you access to the Browser Pro features. Lacks the functionality designed for single page app monitoring. */
  Pro = 'PRO',
  /** Pro+SPA: This is the default installed agent when you enable browser monitoring. Gives you access to all of the Browser Pro features and to Single Page App (SPA) monitoring. Provides detailed page timing data and the most up-to-date New Relic features, including distributed tracing, for all types of applications. */
  Spa = 'SPA'
}

/** Browser monitoring. */
export type AgentApplicationSettingsBrowserMonitoring = {
  __typename?: 'AgentApplicationSettingsBrowserMonitoring';
  /** Enables ajax traces in the browser app. */
  ajax?: Maybe<AgentApplicationSettingsBrowserAjax>;
  /** Configure distributed tracing in browser apps. */
  distributedTracing: AgentApplicationSettingsBrowserDistributedTracing;
  /** The type of browser agent that will be loaded. */
  loader: AgentApplicationSettingsBrowserLoader;
  /** Specify the semantic version of the browser agent that you would like your app to use. Leave this blank to use the most recent version. Use 'x' in place of a numeric digit to represent the latest release within the version range. For example, '1.x.x' */
  pinnedVersion?: Maybe<Scalars['String']['output']>;
  /** Browser monitoring's page load timing feature can track sessions by using cookies that contain a simple session identifier. */
  privacy: AgentApplicationSettingsBrowserPrivacy;
};

/** Set browser monitoring application settings. */
export type AgentApplicationSettingsBrowserMonitoringInput = {
  /** Browser monitoring's page load Ajax requests. */
  ajax?: InputMaybe<AgentApplicationSettingsBrowserAjaxInput>;
  /** If you use browser to monitor end-user browser activity, you can now see end-user-originating browser-side traces in distributed tracing. */
  distributedTracing?: InputMaybe<AgentApplicationSettingsBrowserDistributedTracingInput>;
  /** Determines which browser loader will be configured. */
  loader?: InputMaybe<AgentApplicationSettingsBrowserLoaderInput>;
  /** Specify the semantic version of the browser agent that you would like your app to use. Leave this blank to use the most recent version. Use 'x' in place of a numeric digit to represent the latest release within the version range. For example, '1.x.x' */
  pinnedVersion?: InputMaybe<Scalars['String']['input']>;
  /** Browser monitoring's page load timing feature can track sessions by using cookies that contain a simple session identifier. */
  privacy?: InputMaybe<AgentApplicationSettingsBrowserPrivacyInput>;
};

/** Browser privacy. See [documentation](https://docs.newrelic.com/docs/browser/browser-monitoring/page-load-timing-resources/cookie-collection-session-tracking/) for further information. */
export type AgentApplicationSettingsBrowserPrivacy = {
  __typename?: 'AgentApplicationSettingsBrowserPrivacy';
  /** Whether or not cookies are enabled. */
  cookiesEnabled: Scalars['Boolean']['output'];
};

/** Browser monitoring's page load timing feature can track sessions by using cookies that contain a simple session identifier. */
export type AgentApplicationSettingsBrowserPrivacyInput = {
  /** If enabled, enables cookies. */
  cookiesEnabled?: InputMaybe<Scalars['Boolean']['input']>;
};

/** General Properties related to browser applications. */
export type AgentApplicationSettingsBrowserProperties = {
  __typename?: 'AgentApplicationSettingsBrowserProperties';
  /** The configuration required to run the npm version of the JS agent. This is the "pure" JSON configuration block without surrounding HTML <script> tags. */
  jsConfig?: Maybe<Scalars['AgentApplicationSettingsRawJsConfiguration']['output']>;
  /** The configuration block required to run the npm version of the JS agent. This includes the HTML <script> tags. */
  jsConfigScript?: Maybe<Scalars['String']['output']>;
  /** The snippet of JavaScript used to copy/paste into your JavaScript app if you arent using an auto-instrumentating agent on the backend. */
  jsLoaderScript?: Maybe<Scalars['String']['output']>;
};

/** Settings related to the management of transaction data sent to NRDB. */
export type AgentApplicationSettingsDataManagement = {
  __typename?: 'AgentApplicationSettingsDataManagement';
  /** Sets whether transaction events should be sent to the internal stream. */
  sendTransactionEventsToInternalStream?: Maybe<Scalars['Boolean']['output']>;
};

/** Settings related to the management of transaction data sent to NRDB. */
export type AgentApplicationSettingsDataManagementInput = {
  /** Whether or not send_transaction_events_to_internal_stream is enabled. */
  sendTransactionEventsToInternalStream?: InputMaybe<Scalars['Boolean']['input']>;
};

/** The error collector captures information about uncaught exceptions and sends them to New Relic for viewing. For more information about what these settings do and which ones are applicable for your application, please see https://docs.newrelic.com for more information about agent configuration for your language agent. */
export type AgentApplicationSettingsErrorCollector = {
  __typename?: 'AgentApplicationSettingsErrorCollector';
  /** Enables error collector. */
  enabled?: Maybe<Scalars['Boolean']['output']>;
  /** Prevents specified exception classes from affecting error rate or Apdex score while still reporting the errors to APM. */
  expectedErrorClasses?: Maybe<Array<Scalars['String']['output']>>;
  /** An array of individual HTTP status codes to be marked as expected and thus prevented from affecting error rate or Apdex score. */
  expectedErrorCodes?: Maybe<Array<Scalars['AgentApplicationSettingsErrorCollectorHttpStatus']['output']>>;
  /** Specified exception class names will be ignored and will not affect error rate or Apdex score, or be reported to APM. */
  ignoredErrorClasses?: Maybe<Array<Scalars['String']['output']>>;
  /** An array of individual HTTP status codes that should not be treated as errors. */
  ignoredErrorCodes?: Maybe<Array<Scalars['AgentApplicationSettingsErrorCollectorHttpStatus']['output']>>;
};

/** The error collector captures information about uncaught exceptions and sends them to New Relic for viewing. For more information about what these settings do and which ones are applicable for your application, please see https://docs.newrelic.com for more information about agent configuration for your language agent. */
export type AgentApplicationSettingsErrorCollectorInput = {
  /** Enables error collector. */
  enabled?: InputMaybe<Scalars['Boolean']['input']>;
  /** Prevents specified exception classes from affecting error rate or Apdex score while still reporting the errors to APM. */
  expectedErrorClasses?: InputMaybe<Array<Scalars['String']['input']>>;
  /** An array of individual HTTP status codes to be marked as expected and thus prevented from affecting error rate or Apdex score. */
  expectedErrorCodes?: InputMaybe<Array<Scalars['AgentApplicationSettingsErrorCollectorHttpStatus']['input']>>;
  /** Specified exception class names will be ignored and will not affect error rate or Apdex score, or be reported to APM. */
  ignoredErrorClasses?: InputMaybe<Array<Scalars['String']['input']>>;
  /** An array of individual HTTP status codes that should not be treated as errors. */
  ignoredErrorCodes?: InputMaybe<Array<Scalars['AgentApplicationSettingsErrorCollectorHttpStatus']['input']>>;
};

/** A configuration setting used ignore status codes associated with different hosts. */
export type AgentApplicationSettingsIgnoredStatusCodeRule = {
  __typename?: 'AgentApplicationSettingsIgnoredStatusCodeRule';
  /** An array of hosts to apply the status code rule to. */
  hosts?: Maybe<Array<Scalars['String']['output']>>;
  /** An array of status codes to be be ignored on these hosts. */
  statusCodes?: Maybe<Array<Scalars['String']['output']>>;
};

/** Input data that maps ignore status codes associated with different hosts. */
export type AgentApplicationSettingsIgnoredStatusCodeRuleInput = {
  /** An array of hosts to apply the status code rule to. */
  hosts: Array<Scalars['String']['input']>;
  /** An array of status codes to be be ignored on these hosts. */
  statusCodes: Array<Scalars['String']['input']>;
};

/** Access to the enabled state of the Java Flight Recorder. This feature only available on the Java language agent version 8.0.0 or later. */
export type AgentApplicationSettingsJfr = {
  __typename?: 'AgentApplicationSettingsJfr';
  /** If true, the java agent collects Java Flight Recorder data. (Java Agent version 8.0.0 required.) */
  enabled?: Maybe<Scalars['Boolean']['output']>;
};

/** In the Java agent (v8.0.0 or later), the Java Flight Recorder can be turned on to collect additional information about the application. This setting cannot be updated for non-java agents. */
export type AgentApplicationSettingsJfrInput = {
  /** Whether or not JFR is enabled. */
  enabled?: InputMaybe<Scalars['Boolean']['input']>;
};

/** Mask specific kinds of input options as *. */
export type AgentApplicationSettingsMaskInputOptions = {
  __typename?: 'AgentApplicationSettingsMaskInputOptions';
  /** Mask 'color' input type. */
  color: Scalars['Boolean']['output'];
  /** Mask 'date' input type. */
  date: Scalars['Boolean']['output'];
  /** Mask 'datetime_local' input type. */
  datetimeLocal: Scalars['Boolean']['output'];
  /** Mask 'email' input type. */
  email: Scalars['Boolean']['output'];
  /** Mask 'month' input type. */
  month: Scalars['Boolean']['output'];
  /** Mask 'number' input type. */
  number: Scalars['Boolean']['output'];
  /** Mask 'range' input type. */
  range: Scalars['Boolean']['output'];
  /** Mask 'search' input type. */
  search: Scalars['Boolean']['output'];
  /** Mask 'select' input type. */
  select: Scalars['Boolean']['output'];
  /** Mask 'tel' input type. */
  tel: Scalars['Boolean']['output'];
  /** Mask 'text' input type. */
  text: Scalars['Boolean']['output'];
  /** Mask 'text_area' input type. */
  textArea: Scalars['Boolean']['output'];
  /** Mask 'time' input type. */
  time: Scalars['Boolean']['output'];
  /** Mask 'url' input type. */
  url: Scalars['Boolean']['output'];
  /** Mask 'week' input type. */
  week: Scalars['Boolean']['output'];
};

/** Mask specific kinds of input options as *. */
export type AgentApplicationSettingsMaskInputOptionsInput = {
  /** Mask 'color' input type. */
  color?: InputMaybe<Scalars['Boolean']['input']>;
  /** Mask 'date' input type. */
  date?: InputMaybe<Scalars['Boolean']['input']>;
  /** Mask 'datetime_local' input type. */
  datetimeLocal?: InputMaybe<Scalars['Boolean']['input']>;
  /** Mask 'email' input type. */
  email?: InputMaybe<Scalars['Boolean']['input']>;
  /** Mask 'month' input type. */
  month?: InputMaybe<Scalars['Boolean']['input']>;
  /** Mask 'number' input type. */
  number?: InputMaybe<Scalars['Boolean']['input']>;
  /** Mask 'range' input type. */
  range?: InputMaybe<Scalars['Boolean']['input']>;
  /** Mask 'search' input type. */
  search?: InputMaybe<Scalars['Boolean']['input']>;
  /** Mask 'select' input type. */
  select?: InputMaybe<Scalars['Boolean']['input']>;
  /** Mask 'tel' input type. */
  tel?: InputMaybe<Scalars['Boolean']['input']>;
  /** Mask 'text' input type. */
  text?: InputMaybe<Scalars['Boolean']['input']>;
  /** Mask 'text_area' input type. */
  textArea?: InputMaybe<Scalars['Boolean']['input']>;
  /** Mask 'time' input type. */
  time?: InputMaybe<Scalars['Boolean']['input']>;
  /** Mask 'url' input type. */
  url?: InputMaybe<Scalars['Boolean']['input']>;
  /** Mask 'week' input type. */
  week?: InputMaybe<Scalars['Boolean']['input']>;
};

/** Settings that are applicable to mobile applications. */
export type AgentApplicationSettingsMobileBase = {
  __typename?: 'AgentApplicationSettingsMobileBase';
  /** Log Reporting settings associated with the mobile application. */
  logReporting?: Maybe<AgentApplicationSettingsMobileLogReporting>;
  /** Network settings associated with the mobile application. */
  networkSettings?: Maybe<AgentApplicationSettingsMobileNetworkSettings>;
  /** Enables viewing in-depth reports for mobile application crashes. */
  useCrashReports?: Maybe<Scalars['Boolean']['output']>;
};

/** An object containing settings related to mobile log reporting */
export type AgentApplicationSettingsMobileLogReporting = {
  __typename?: 'AgentApplicationSettingsMobileLogReporting';
  /** A configuration object to enable mobile log reporting */
  enabled: Scalars['Boolean']['output'];
  /** A configuration object to set the mobile log reporting level */
  level: AgentApplicationSettingsMobileLogReportingLevel;
};

/** Configure mobile network settings here. */
export type AgentApplicationSettingsMobileLogReportingInput = {
  /** Enable or disables mobile log reporting */
  enabled?: InputMaybe<Scalars['Boolean']['input']>;
  /** Verbosity level for mobile log reporting */
  level?: InputMaybe<AgentApplicationSettingsMobileLogReportingLevel>;
};

/** Determines the level for log reporting in your mobile applications. Valid settings are: 'NONE', 'ERROR', 'WARN', 'INFO', 'VERBOSE', and 'DEBUG'. */
export enum AgentApplicationSettingsMobileLogReportingLevel {
  /** Designates fine-grained informational events that are most useful to debug an application. */
  Debug = 'DEBUG',
  /** Designates error events that might still allow the application to continue running. */
  Error = 'ERROR',
  /** Designates informational messages that highlight the progress of the application at coarse-grained level. */
  Info = 'INFO',
  /** The highest possible rank and is intended to turn off logging. */
  None = 'NONE',
  /** Expanded level of logging output */
  Verbose = 'VERBOSE',
  /** [Default] Designates potentially harmful situations. */
  Warn = 'WARN'
}

/** An object containing your network settings. */
export type AgentApplicationSettingsMobileNetworkSettings = {
  __typename?: 'AgentApplicationSettingsMobileNetworkSettings';
  /** A list of configuration settings that map host to alias names for grouping and identification purposes. */
  aliases?: Maybe<Array<AgentApplicationSettingsNetworkAlias>>;
  /** Configuration setting to apply either the show or hide strategy for network filtering. */
  filterMode?: Maybe<AgentApplicationSettingsNetworkFilterMode>;
  /** A list of hostnames that would be applied to our filter settings when the filterMode is 'HIDE.' */
  hideList?: Maybe<Array<Scalars['String']['output']>>;
  /** A list of rules to ignore status codes associated with different hosts. */
  ignoredStatusCodeRules?: Maybe<Array<AgentApplicationSettingsIgnoredStatusCodeRule>>;
  /** A list of hostnames that would be applied to our filter settings when the filterMode is 'SHOW.' */
  showList?: Maybe<Array<Scalars['String']['output']>>;
};

/** General properties related to mobile applications. */
export type AgentApplicationSettingsMobileProperties = {
  __typename?: 'AgentApplicationSettingsMobileProperties';
  /** A token used to authenticate your mobile application for data ingest. */
  applicationToken?: Maybe<Scalars['SecureValue']['output']>;
};

/** Configure mobile settings here. */
export type AgentApplicationSettingsMobileSettingsInput = {
  /** Input arguments for log reporting settings. */
  logReporting?: InputMaybe<AgentApplicationSettingsMobileLogReportingInput>;
  /** Input arguments for network settings. */
  networkSettings?: InputMaybe<AgentApplicationSettingsNetworkSettingsInput>;
  /** Sets if application should use crash report or not for mobile settings. */
  useCrashReports?: InputMaybe<Scalars['Boolean']['input']>;
};

/** A configuration setting that maps hosts to alias names for grouping and identification purposes. */
export type AgentApplicationSettingsNetworkAlias = {
  __typename?: 'AgentApplicationSettingsNetworkAlias';
  /** An alternative name that can be used to reference the hostnames. */
  alias?: Maybe<Scalars['String']['output']>;
  /** A list of hostnames to associate with an alias. */
  hosts?: Maybe<Array<Scalars['String']['output']>>;
};

/** Input data that maps hosts to alias names for grouping and identification purposes. */
export type AgentApplicationSettingsNetworkAliasesInput = {
  /** An alternative name that can be used to reference the hostnames. */
  alias: Scalars['String']['input'];
  /** A list of hostnames to associate with an alias. */
  hosts: Array<Scalars['String']['input']>;
};

/** Configuration setting to apply either the show or hide strategy for network filtering. */
export enum AgentApplicationSettingsNetworkFilterMode {
  /** Disables both show and hide confurations. */
  Disabled = 'DISABLED',
  /** Use the hide list configuration. */
  Hide = 'HIDE',
  /** Use the show list configuration. */
  Show = 'SHOW'
}

/** Configure mobile network settings here. */
export type AgentApplicationSettingsNetworkSettingsInput = {
  /** Input data that maps hosts to alias names for grouping and identification purposes. */
  aliases?: InputMaybe<Array<AgentApplicationSettingsNetworkAliasesInput>>;
  /** Configuration setting to apply either the show or hide strategy for network filtering. */
  filterMode?: InputMaybe<AgentApplicationSettingsNetworkFilterMode>;
  /** A list of hostnames that would be applied to our filter settings when the filterMode is 'HIDE.' */
  hideList?: InputMaybe<Array<Scalars['String']['input']>>;
  /** Input data that maps ignore status codes associated with different hosts. */
  ignoredStatusCodeRules?: InputMaybe<Array<AgentApplicationSettingsIgnoredStatusCodeRuleInput>>;
  /** A list of hostnames that would be applied to our filter settings when the filterMode is 'SHOW.' */
  showList?: InputMaybe<Array<Scalars['String']['input']>>;
};

/**
 * Obfuscation level for SQL queries reported in transaction trace nodes.
 *
 * When turned on, the New Relic agent will attempt to remove values from SQL qeries.
 *
 * For example:
 *
 * ```
 * SELECT * FROM Table WHERE ssn='123-45-6789'
 * ```
 *
 * might become:
 *
 * ```
 * SELECT * FROM Table WHERE ssn=?
 * ```
 *
 * This can behave differently for differnet applications and frameworks. Please test for your specific case.
 * Note: RAW collection is not campatible with High Security mode and cannot be set if your agent is running in that mode.
 */
export enum AgentApplicationSettingsRecordSqlEnum {
  /** This is the default value. This setting strips string literals and numeric sequences from your queries and replaces them with the ? character. For example: the query select * from table where ssn='123-45-6789' would become select * from table where ssn=?. */
  Obfuscated = 'OBFUSCATED',
  /** Query collection is turned off entirely. */
  Off = 'OFF',
  /** If you are confident that full query data collection will not impact your data security or your users' privacy, you can change the setting to RAW, which will record all query values. NOTE: 'RAW' is not permitted when 'High security mode' is enabled. */
  Raw = 'RAW'
}

/** session replay */
export type AgentApplicationSettingsSessionReplay = {
  __typename?: 'AgentApplicationSettingsSessionReplay';
  /** When true, Session Replay will activate normally (this is the default). If set to false, Session Replay will not record automatically, but the agent will allow recording to be turned on via it's API. Please see [here](https://docs.newrelic.com/docs/browser/new-relic-browser/browser-apis/start/) for more details. */
  autoStart: Scalars['Boolean']['output'];
  /** String to configure which selector should be blocked */
  blockSelector: Scalars['String']['output'];
  /** Indicates whether the agent will serialize fonts for collection without public asset url. */
  collectFonts: Scalars['Boolean']['output'];
  /** Session Replay enabled. */
  enabled: Scalars['Boolean']['output'];
  /** Percentage from 0-10 specifying how many of all user sessions that contain errors should be recorded. */
  errorSamplingRate: Scalars['Float']['output'];
  /** Indicates whether the agent will serialize images for collection without public asset url */
  inlineImages: Scalars['Boolean']['output'];
  /** Indicates whether the agent will serialize css for collection without public asset url. */
  inlineStylesheet: Scalars['Boolean']['output'];
  /** Mask all input content as * */
  maskAllInputs: Scalars['Boolean']['output'];
  /** Mask specific kinds of input options as *. */
  maskInputOptions: AgentApplicationSettingsMaskInputOptions;
  /** String to configure which selector should be masked. */
  maskTextSelector?: Maybe<Scalars['String']['output']>;
  /** Percentage from 0-10 specifying how many of all user sessions should be recorded. */
  samplingRate: Scalars['Float']['output'];
};

/** Session Replay configuration. */
export type AgentApplicationSettingsSessionReplayInput = {
  /** When true, Session Replay will activate normally (this is the default). If set to false, Session Replay will not record automatically, but the agent will allow recording to be turned on via it's API. Please see [here](https://docs.newrelic.com/docs/browser/new-relic-browser/browser-apis/start/) for more details. */
  autoStart?: InputMaybe<Scalars['Boolean']['input']>;
  /** String to configure which selector should be blocked */
  blockSelector?: InputMaybe<Scalars['String']['input']>;
  /** Indicates whether to serialize fonts for collection without public asset url or not. */
  collectFonts?: InputMaybe<Scalars['Boolean']['input']>;
  /** Session Replay enabled. */
  enabled?: InputMaybe<Scalars['Boolean']['input']>;
  /** Percentage from 0-10 specifying how many of all user sessions that contain errors should be recorded. */
  errorSamplingRate?: InputMaybe<Scalars['Float']['input']>;
  /** Indicates whether to serialize images for collection without public asset url or not. */
  inlineImages?: InputMaybe<Scalars['Boolean']['input']>;
  /** Indicates whether to serialize css for collection without public asset url or not. */
  inlineStylesheet?: InputMaybe<Scalars['Boolean']['input']>;
  /** Mask all input content as * */
  maskAllInputs?: InputMaybe<Scalars['Boolean']['input']>;
  /** Mask specific kinds of input options as *. */
  maskInputOptions?: InputMaybe<AgentApplicationSettingsMaskInputOptionsInput>;
  /** String to configure which selector should be masked. */
  maskTextSelector?: InputMaybe<Scalars['String']['input']>;
  /** Percentage from 0-10 specifying how many of all user sessions should be recorded. */
  samplingRate?: InputMaybe<Scalars['Float']['input']>;
};

/** session trace */
export type AgentApplicationSettingsSessionTrace = {
  __typename?: 'AgentApplicationSettingsSessionTrace';
  /** Session Trace enabled. */
  enabled: Scalars['Boolean']['output'];
  /** Percentage from 0-10 specifying how many of all user sessions that contain errors should be recorded. */
  errorSamplingRate: Scalars['Float']['output'];
  /** Percentage from 0-10 specifying how many of all user sessions should be recorded. */
  samplingRate: Scalars['Float']['output'];
};

/** Session Trace configuration. */
export type AgentApplicationSettingsSessionTraceInput = {
  /** Session Trace enabled. */
  enabled?: InputMaybe<Scalars['Boolean']['input']>;
  /** Percentage from 0-10 specifying how many of all user sessions that contain errors should be recorded. */
  errorSamplingRate?: InputMaybe<Scalars['Float']['input']>;
  /** Percentage from 0-10 specifying how many of all user sessions should be recorded. */
  samplingRate?: InputMaybe<Scalars['Float']['input']>;
};

/** In APM, when transaction traces are collected, there may be additional Slow query data available. */
export type AgentApplicationSettingsSlowSql = {
  __typename?: 'AgentApplicationSettingsSlowSql';
  /** If true, the agent collects slow SQL queries. */
  enabled?: Maybe<Scalars['Boolean']['output']>;
};

/** In APM, when transaction traces are collected, there may be additional Slow query data available. */
export type AgentApplicationSettingsSlowSqlInput = {
  /** Whether or not slow_sql is enabled. */
  enabled?: InputMaybe<Scalars['Boolean']['input']>;
};

/** Measures wall clock time, CPU time, and method call counts in your application's threads as they run. */
export type AgentApplicationSettingsThreadProfiler = {
  __typename?: 'AgentApplicationSettingsThreadProfiler';
  /** Whether or not the Thread Profiler is enabled for your application. */
  enabled?: Maybe<Scalars['Boolean']['output']>;
};

/** Settings for the thread profiler. */
export type AgentApplicationSettingsThreadProfilerInput = {
  /** Is thread profiling enabled for this application? */
  enabled?: InputMaybe<Scalars['Boolean']['input']>;
};

/** Determines whether a threshold is statically configured or dynamically configured. */
export enum AgentApplicationSettingsThresholdTypeEnum {
  /** Configures the threshold to be 4 times the value of APDEX_T. */
  ApdexF = 'APDEX_F',
  /** Threshold will be statically configured via the corresponding "value" field. */
  Value = 'VALUE'
}

/** The type of tracing being done. */
export enum AgentApplicationSettingsTracer {
  /** Cross-application tracing feature enabled. */
  CrossApplicationTracer = 'CROSS_APPLICATION_TRACER',
  /** Distributed tracing feature enabled. */
  DistributedTracing = 'DISTRIBUTED_TRACING',
  /** Both cross-application and distributed tracing disabled. */
  None = 'NONE'
}

/** Input object for setting the type of tracing performed. */
export type AgentApplicationSettingsTracerTypeInput = {
  /** The type of tracing being done. */
  value?: InputMaybe<AgentApplicationSettingsTracer>;
};

/** Transaction tracer settings related to APM applications. For more information about what these settings do and which ones are applicable for your application, please see https://docs.newrelic.com for more information about agent configuration for your language agent. */
export type AgentApplicationSettingsTransactionTracer = {
  __typename?: 'AgentApplicationSettingsTransactionTracer';
  /** DEPRECATED: Please use capture_memcache_keys on parent type. */
  captureMemcacheKeys?: Maybe<Scalars['Boolean']['output']>;
  /** If true, this enables the transaction tracer feature, enabling collection of transaction traces. */
  enabled?: Maybe<Scalars['Boolean']['output']>;
  /** If true, enables the collection of explain plans in transaction traces. This setting will also apply to explain plans in slow SQL traces if slow_sql.explain_enabled is not set separately. */
  explainEnabled?: Maybe<Scalars['Boolean']['output']>;
  /** Relevant only when explain_enabled is true. Can be set to automatic configuration (APDEX_F) or manual (see explainThresholdValue). */
  explainThresholdType?: Maybe<AgentApplicationSettingsThresholdTypeEnum>;
  /** Threshold (in seconds) above which the agent will collect explain plans. Relevant only when explainEnabled is true and explainThresholdType is set to VALUE. */
  explainThresholdValue?: Maybe<Scalars['Seconds']['output']>;
  /** Set to true to enable logging of queries to the agent log file instead of uploading to New Relic. Queries are logged using the record_sql mode. */
  logSql?: Maybe<Scalars['Boolean']['output']>;
  /** Obfuscation level for SQL queries reported in transaction trace nodes. */
  recordSql?: Maybe<AgentApplicationSettingsRecordSqlEnum>;
  /** Specify a threshold in seconds. The agent includes stack traces in transaction trace nodes when the stack trace duration exceeds this threshold. */
  stackTraceThreshold?: Maybe<Scalars['Seconds']['output']>;
  /** Relevant only when TransactionTracer is enabled. Can be set to automatic configuration (APDEX_F) or manual (see TransactionThresholdValue). */
  transactionThresholdType?: Maybe<AgentApplicationSettingsThresholdTypeEnum>;
  /** Threshold (in seconds) that transactions with a duration longer than this threshold are eligible for transaction traces.  Relevant only when transaction tracer is enabled and transaction_threshold_type is set to VALUE. */
  transactionThresholdValue?: Maybe<Scalars['Seconds']['output']>;
};

/** Fields related to transaction traces and data collection for traces. */
export type AgentApplicationSettingsTransactionTracerInput = {
  /** DEPRECATED: Please use capture_memcache_keys on parent type */
  captureMemcacheKeys?: InputMaybe<Scalars['Boolean']['input']>;
  /** If true, this enables the transaction tracer feature, enabling collection of transaction traces. */
  enabled?: InputMaybe<Scalars['Boolean']['input']>;
  /** If true, enables the collection of explain plans in transaction traces. This setting will also apply to explain plans in slow SQL traces if slow_sql.explain_enabled is not set separately. */
  explainEnabled?: InputMaybe<Scalars['Boolean']['input']>;
  /** Relevant only when explain_enabled is true. Can be set to automatic configuration (APDEX_F) or manual (see explainThresholdValue). */
  explainThresholdType?: InputMaybe<AgentApplicationSettingsThresholdTypeEnum>;
  /** Threshold (in seconds) above which the agent will collect explain plans. Relevant only when explain_enabled is true and explainThresholdType is set to VALUE. */
  explainThresholdValue?: InputMaybe<Scalars['Seconds']['input']>;
  /** Set to true to enable logging of queries to the agent log file instead of uploading to New Relic. Queries are logged using the record_sql mode. */
  logSql?: InputMaybe<Scalars['Boolean']['input']>;
  /** Obfuscation level for SQL queries reported in transaction trace nodes. */
  recordSql?: InputMaybe<AgentApplicationSettingsRecordSqlEnum>;
  /** Specify a threshold in seconds. The agent includes stack traces in transaction trace nodes when the stack trace duration exceeds this threshold. */
  stackTraceThreshold?: InputMaybe<Scalars['Seconds']['input']>;
  /** Relevant only when transaction tracer is enabled. Can be set to automatic configuration (APDEX_F) or manual (see TransactionThresholdValue). */
  transactionThresholdType?: InputMaybe<AgentApplicationSettingsThresholdTypeEnum>;
  /** Threshold (in seconds) that transactions with a duration longer than this threshold are eligible for transaction traces.  Relevant only when transaction tracer is enabled and transaction_threshold_type is set to VALUE. */
  transactionThresholdValue?: InputMaybe<Scalars['Seconds']['input']>;
};

/** Information about any errors encountered while updating values. */
export type AgentApplicationSettingsUpdateError = {
  __typename?: 'AgentApplicationSettingsUpdateError';
  /** A 'human readable' description of the error. */
  description?: Maybe<Scalars['String']['output']>;
  /** The category of the error. */
  errorClass?: Maybe<AgentApplicationSettingsUpdateErrorClass>;
  /** The field that was being updated when the error was encountered. */
  field?: Maybe<Scalars['String']['output']>;
};

/** Categories of errors that could occur while attempting updates. */
export enum AgentApplicationSettingsUpdateErrorClass {
  /** You are not authorized to update this field. */
  AccessDenied = 'ACCESS_DENIED',
  /** The given value for the field is not valid or out of range. */
  InvalidInput = 'INVALID_INPUT',
  /** No record could be found using the given input value. */
  NotFound = 'NOT_FOUND'
}

/**
 * The new settings to use - leave blank any settings you do not wish to modify.
 *
 * While all settings can be specified here, some may not affect your installed agents, depending on the language agent and the current version installed. Note: not all settings of your agent are available to be set server-side.
 *
 * Please see docs.newrelic.com for more information about the capabilities of individual agents.
 *
 * [Go agent configuration](https://docs.newrelic.com/docs/agents/go-agent/configuration/go-agent-configuration/)
 *
 * [Java agent configuration](https://docs.newrelic.com/docs/agents/java-agent/configuration/java-agent-configuration-config-file/)
 *
 * [.Net agent configuration](https://docs.newrelic.com/docs/agents/net-agent/configuration/net-agent-configuration/)
 *
 * [nodejs agent configuration](https://docs.newrelic.com/docs/agents/nodejs-agent/installation-configuration/nodejs-agent-configuration/)
 *
 * [PHP agent configuration](https://docs.newrelic.com/docs/agents/php-agent/configuration/php-agent-configuration/)
 *
 * [Python agent configuration](https://docs.newrelic.com/docs/agents/python-agent/configuration/python-agent-configuration/)
 *
 * [Ruby agent configuration](https://docs.newrelic.com/docs/agents/ruby-agent/configuration/ruby-agent-configuration/)
 */
export type AgentApplicationSettingsUpdateInput = {
  /** The new name for the application. */
  alias?: InputMaybe<Scalars['String']['input']>;
  /** Provides fields to set general APM application settings. */
  apmConfig?: InputMaybe<AgentApplicationSettingsApmConfigInput>;
  /** Provides fields to set general browser application settings. */
  browserConfig?: InputMaybe<AgentApplicationSettingsBrowserConfigInput>;
  /** Provides fields to set browser monitoring application settings. */
  browserMonitoring?: InputMaybe<AgentApplicationSettingsBrowserMonitoringInput>;
  /** Enable or disable the capture of memcache keys */
  captureMemcacheKeys?: InputMaybe<Scalars['Boolean']['input']>;
  /** The field for applying settings regarding how events are handled with NRDB. */
  dataManagement?: InputMaybe<AgentApplicationSettingsDataManagementInput>;
  /** Captures information about uncaught exceptions and sends them to New Relic for viewing. */
  errorCollector?: InputMaybe<AgentApplicationSettingsErrorCollectorInput>;
  /** In the Java Agent (v8.0.0 or later), it can collect additional data with the Java Flight Recorder enabled. */
  jfr?: InputMaybe<AgentApplicationSettingsJfrInput>;
  /** Input object for mobile settings. */
  mobileSettings?: InputMaybe<AgentApplicationSettingsMobileSettingsInput>;
  /** DEPRECATED: Use `alias` to set a new name for the application. */
  name?: InputMaybe<Scalars['String']['input']>;
  /** fields for session replay config */
  sessionReplay?: InputMaybe<AgentApplicationSettingsSessionReplayInput>;
  /** fields for session trace config */
  sessionTrace?: InputMaybe<AgentApplicationSettingsSessionTraceInput>;
  /** In APM, when transaction traces are collected, there may be additional Slow query data available. */
  slowSql?: InputMaybe<AgentApplicationSettingsSlowSqlInput>;
  /** Settings for the thread profiler. */
  threadProfiler?: InputMaybe<AgentApplicationSettingsThreadProfilerInput>;
  /** Input object for setting the type of tracing performed. */
  tracerType?: InputMaybe<AgentApplicationSettingsTracerTypeInput>;
  /** Transaction tracer settings related to APM applications. */
  transactionTracer?: InputMaybe<AgentApplicationSettingsTransactionTracerInput>;
  /** DEPRECATED: Please set crash reports in the mobile settings input object instead! */
  useCrashReports?: InputMaybe<Scalars['Boolean']['input']>;
};

/** The result of updating application settings. */
export type AgentApplicationSettingsUpdateResult = {
  __typename?: 'AgentApplicationSettingsUpdateResult';
  /** The name for the application. */
  alias?: Maybe<Scalars['String']['output']>;
  /** Access general settings for the application. */
  apmSettings?: Maybe<AgentApplicationSettingsApmBase>;
  /** Access general properties for the application. */
  browserProperties?: Maybe<AgentApplicationSettingsBrowserProperties>;
  /** Access general settings for the browser application. */
  browserSettings?: Maybe<AgentApplicationSettingsBrowserBase>;
  /** Information about any errors encountered while updating values. */
  errors?: Maybe<Array<Maybe<AgentApplicationSettingsUpdateError>>>;
  /** The GUID for the affected Entity. */
  guid: Scalars['EntityGuid']['output'];
  /** Access mobile settings for the application. */
  mobileSettings?: Maybe<AgentApplicationSettingsMobileBase>;
  /**
   * The name for the application.
   * @deprecated Deprecated. Use `alias` instead!
   */
  name?: Maybe<Scalars['String']['output']>;
};

/** Data found for one application instance's loaded modules. */
export type AgentEnvironmentAccountApplicationLoadedModules = {
  __typename?: 'AgentEnvironmentAccountApplicationLoadedModules';
  /** List of Guids of the APM Applications this instance belongs to. */
  applicationGuids: Array<Scalars['EntityGuid']['output']>;
  /** Information of the application instance, such as host and language. */
  details?: Maybe<AgentEnvironmentApplicationInstanceDetails>;
  /** A list of loaded modules of the application instance. */
  loadedModules?: Maybe<Array<AgentEnvironmentApplicationLoadedModule>>;
};

/** Results for loaded modules search. This list is paginated. Use the cursor to go through all the available results. */
export type AgentEnvironmentAccountApplicationLoadedModulesResults = {
  __typename?: 'AgentEnvironmentAccountApplicationLoadedModulesResults';
  /** If nextCursor is a String value, set it to the cursor input field while searching in order to get the next page of results. */
  nextCursor?: Maybe<Scalars['String']['output']>;
  /** Results of the search. */
  results?: Maybe<Array<AgentEnvironmentAccountApplicationLoadedModules>>;
};

/** Results for environment attributes search. This list is paginated. Use the cursor to go through all the available results. */
export type AgentEnvironmentAccountEnvironmentAttributesResults = {
  __typename?: 'AgentEnvironmentAccountEnvironmentAttributesResults';
  /** If nextCursor is a String value, set it to the cursor input field while searching in order to get the next page of results. */
  nextCursor?: Maybe<Scalars['String']['output']>;
  /** Results of the search. */
  results?: Maybe<Array<AgentEnvironmentApplicationEnvironmentAttributes>>;
};

/** account-scope schemas */
export type AgentEnvironmentAccountStitchedFields = {
  __typename?: 'AgentEnvironmentAccountStitchedFields';
  /** Contains environment attributes regarding the reported setting of the reporting agent at account level. */
  agentSettingsAttributes?: Maybe<AgentEnvironmentAccountEnvironmentAttributesResults>;
  /** Contains general environment attributes from the same environment where the application instance is running. */
  environmentAttributes?: Maybe<AgentEnvironmentAccountEnvironmentAttributesResults>;
  /** Contains environment attributes regarding modules loaded by the application instance. Used only by the Java agent. */
  modules?: Maybe<AgentEnvironmentAccountApplicationLoadedModulesResults>;
};


/** account-scope schemas */
export type AgentEnvironmentAccountStitchedFieldsAgentSettingsAttributesArgs = {
  cursor?: InputMaybe<Scalars['String']['input']>;
  filter?: InputMaybe<AgentEnvironmentFilter>;
};


/** account-scope schemas */
export type AgentEnvironmentAccountStitchedFieldsEnvironmentAttributesArgs = {
  cursor?: InputMaybe<Scalars['String']['input']>;
  filter?: InputMaybe<AgentEnvironmentFilter>;
};


/** account-scope schemas */
export type AgentEnvironmentAccountStitchedFieldsModulesArgs = {
  cursor?: InputMaybe<Scalars['String']['input']>;
  filter?: InputMaybe<AgentEnvironmentFilter>;
};

/** Environment data found for one application instance. */
export type AgentEnvironmentApplicationEnvironmentAttributes = {
  __typename?: 'AgentEnvironmentApplicationEnvironmentAttributes';
  /** List of Guids of the APM Applications this instance belongs to. */
  applicationGuids: Array<Scalars['EntityGuid']['output']>;
  /** A list of environment attributes of the application instance. */
  attributes?: Maybe<Array<AgentEnvironmentAttribute>>;
  /** Information of the application instance, such as host and language. */
  details?: Maybe<AgentEnvironmentApplicationInstanceDetails>;
};

/** Representation of the New Relic agent collecting data. */
export type AgentEnvironmentApplicationInstance = {
  __typename?: 'AgentEnvironmentApplicationInstance';
  /** Contains environment attributes regarding the reported setting of the reporting agent. */
  agentSettingsAttributes?: Maybe<Array<AgentEnvironmentAttribute>>;
  /** Information of the application instance, such as host and language. */
  details: AgentEnvironmentApplicationInstanceDetails;
  /** Contains general environment attributes from the same environment where the application instance is running. */
  environmentAttributes?: Maybe<Array<AgentEnvironmentAttribute>>;
  /** Contains environment attributes regarding modules loaded by the application instance. Used only by the Java agent. */
  modules?: Maybe<Array<AgentEnvironmentApplicationLoadedModule>>;
};


/** Representation of the New Relic agent collecting data. */
export type AgentEnvironmentApplicationInstanceAgentSettingsAttributesArgs = {
  filter?: InputMaybe<AgentEnvironmentFilter>;
};


/** Representation of the New Relic agent collecting data. */
export type AgentEnvironmentApplicationInstanceEnvironmentAttributesArgs = {
  filter?: InputMaybe<AgentEnvironmentFilter>;
};


/** Representation of the New Relic agent collecting data. */
export type AgentEnvironmentApplicationInstanceModulesArgs = {
  filter?: InputMaybe<AgentEnvironmentFilter>;
};

/** Details of an application instance such as host and language. */
export type AgentEnvironmentApplicationInstanceDetails = {
  __typename?: 'AgentEnvironmentApplicationInstanceDetails';
  /** Host of the application instance. */
  host: Scalars['String']['output'];
  /** Host display name of the application instance. */
  hostDisplayName: Scalars['String']['output'];
  /** ID of the application instance. */
  id: Scalars['ID']['output'];
  /** Instance name generated by language, host and name */
  instanceName: Scalars['String']['output'];
  /** Language of the application instance. */
  language: Scalars['String']['output'];
  /** Name of the application instance. */
  name: Scalars['String']['output'];
};

/** List of APM application instances with pagination data. */
export type AgentEnvironmentApplicationInstancesResult = {
  __typename?: 'AgentEnvironmentApplicationInstancesResult';
  /** List of APM application instances . */
  applicationInstances?: Maybe<Array<AgentEnvironmentApplicationInstance>>;
  /** If nextCursor is a String value, set it to the cursor input field while searching in order to get the next page of results. */
  nextCursor?: Maybe<Scalars['String']['output']>;
};

/** Represents a module loaded by the apm application. */
export type AgentEnvironmentApplicationLoadedModule = {
  __typename?: 'AgentEnvironmentApplicationLoadedModule';
  /** Extra module attributes. */
  attributes: Array<Maybe<AgentEnvironmentLoadedModuleAttribute>>;
  /** Module name. */
  name: Scalars['String']['output'];
  /** Module version. */
  version?: Maybe<Scalars['String']['output']>;
};

/** Represents one attribute from within the environment on which an agent is running. */
export type AgentEnvironmentAttribute = {
  __typename?: 'AgentEnvironmentAttribute';
  /** Environment attribute name. */
  attribute: Scalars['String']['output'];
  /** Value of the environment attribute. */
  value: Scalars['String']['output'];
};

/** A filter that can be applied to filter results. */
export type AgentEnvironmentFilter = {
  /** A string to filter results that includes this string anywhere. Case insensitive. */
  contains?: InputMaybe<Scalars['String']['input']>;
  /** A string to filter out results that includes this string anywhere. Case insensitive. */
  doesNotContain?: InputMaybe<Scalars['String']['input']>;
  /** A string to filter results that are exactly as the string provided. Case sensitive. */
  equals?: InputMaybe<Scalars['String']['input']>;
  /** A string to filter results that starts with this string. Case insensitive. */
  startsWith?: InputMaybe<Scalars['String']['input']>;
};

/** Attribute belonging to a loaded module. */
export type AgentEnvironmentLoadedModuleAttribute = {
  __typename?: 'AgentEnvironmentLoadedModuleAttribute';
  /** Name of the module attribute. */
  name: Scalars['String']['output'];
  /** Value of the module attribute. */
  value: Scalars['String']['output'];
};

export type AgentFeature = {
  __typename?: 'AgentFeature';
  minVersion?: Maybe<Scalars['String']['output']>;
  name?: Maybe<Scalars['String']['output']>;
};

/** Features of the Agent */
export type AgentFeatures = {
  __typename?: 'AgentFeatures';
  /** The minimum version available for the Agent on this entity */
  minVersion?: Maybe<Scalars['String']['output']>;
  /** The name of the feature */
  name?: Maybe<Scalars['String']['output']>;
};

/** Agent Feature Filter */
export enum AgentFeaturesFilter {
  Dotnet = 'DOTNET',
  Elixir = 'ELIXIR',
  Go = 'GO',
  Html = 'HTML',
  Java = 'JAVA',
  Mobile = 'MOBILE',
  Nodejs = 'NODEJS',
  Php = 'PHP',
  Python = 'PYTHON',
  Ruby = 'RUBY',
  Sdk = 'SDK'
}

/** Information about an Agent release */
export type AgentRelease = {
  __typename?: 'AgentRelease';
  /** Patch for a bug */
  bugs?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
  /** The date of the release */
  date?: Maybe<Scalars['Date']['output']>;
  /** Link to agent distribution */
  downloadLink?: Maybe<Scalars['String']['output']>;
  /** The date the release will reach the end of its life. See [New Relic's EOL Policy](https://docs.newrelic.com/docs/licenses/end-of-life/notification-changes-new-relic-saas-features-distributed-software/) for details */
  eolDate?: Maybe<Scalars['Date']['output']>;
  /** New feature or instrumentation */
  features?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
  /** Fix for a security vulnerability */
  security?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
  /** The release note's location on the docs website. The full URL would be prefixed with [https://docs.newrelic.com](https://docs.newrelic.com/) */
  slug?: Maybe<Scalars['String']['output']>;
  /** The version of the release */
  version?: Maybe<Scalars['String']['output']>;
};

/** Agent Release Filter */
export enum AgentReleasesFilter {
  Android = 'ANDROID',
  Browser = 'BROWSER',
  Dotnet = 'DOTNET',
  Elixir = 'ELIXIR',
  Go = 'GO',
  Infrastructure = 'INFRASTRUCTURE',
  Ios = 'IOS',
  Java = 'JAVA',
  Nodejs = 'NODEJS',
  Php = 'PHP',
  Python = 'PYTHON',
  Ruby = 'RUBY',
  Sdk = 'SDK'
}

export type AgentSearch = {
  __typename?: 'AgentSearch';
  agents?: Maybe<Array<Maybe<Agent>>>;
  limit?: Maybe<Scalars['Int']['output']>;
  offset?: Maybe<Scalars['Int']['output']>;
  total?: Maybe<Scalars['Int']['output']>;
};

export type AgentSettings = {
  __typename?: 'AgentSettings';
  apdexTarget?: Maybe<Scalars['Float']['output']>;
  serverSideConfig?: Maybe<Scalars['Boolean']['output']>;
};

export type AgentStatus = {
  __typename?: 'AgentStatus';
  alertStatus?: Maybe<AlertStatus>;
  label?: Maybe<Scalars['String']['output']>;
  level?: Maybe<Scalars['String']['output']>;
  openedAt?: Maybe<Scalars['EpochMilliseconds']['output']>;
};

export type AgentSummary = {
  __typename?: 'AgentSummary';
  apdex?: Maybe<SummaryValue>;
  errorRate?: Maybe<SummaryValue>;
  nonWebResponseTime?: Maybe<SummaryValue>;
  throughput?: Maybe<SummaryValue>;
  webResponseTime?: Maybe<SummaryValue>;
};

/** An object that represents an error trace sample. */
export type AgentTracesErrorTrace = {
  __typename?: 'AgentTracesErrorTrace';
  /** Map of attributes collected by the agent. */
  agentAttributes?: Maybe<Scalars['AgentTracesTraceAttributes']['output']>;
  /** Error count. */
  count?: Maybe<Scalars['Int']['output']>;
  /** Exception class. */
  exceptionClass?: Maybe<Scalars['String']['output']>;
  /** Agent host. */
  host?: Maybe<Scalars['String']['output']>;
  /** Trace identifier. */
  id: Scalars['ID']['output'];
  /** Map Attributes which can not be turned off by the user.These are generally not shown to the customer (NR only). */
  intrinsicAttributes?: Maybe<Scalars['AgentTracesTraceAttributes']['output']>;
  /** Error message. */
  message?: Maybe<Scalars['String']['output']>;
  /** Path, as definted by agents. */
  path: Scalars['String']['output'];
  /** Error stack trace. */
  stackTrace?: Maybe<Array<Maybe<AgentTracesStackTraceFrame>>>;
  /** When the error occured. */
  startTime: Scalars['EpochMilliseconds']['output'];
  /** URI. */
  uri?: Maybe<Scalars['String']['output']>;
  /** Map of attributes collected by the user using the API. */
  userAttributes?: Maybe<Scalars['AgentTracesTraceAttributes']['output']>;
};

/** An object that represents error trace ordering. */
export type AgentTracesErrorTraceOrderBy = {
  /** Order by direction. */
  direction?: InputMaybe<AgentTracesOrderByDirection>;
  /** Field to order by. */
  field: AgentTracesErrorTraceOrderByField;
};

/** The different error trace fields to order by. */
export enum AgentTracesErrorTraceOrderByField {
  /** Error count. */
  Count = 'COUNT',
  /** Error exception class. */
  ExceptionClass = 'EXCEPTION_CLASS',
  /** Error message. */
  Message = 'MESSAGE',
  /** Error trace path. */
  Path = 'PATH',
  /** Trace start time. */
  Timestamp = 'TIMESTAMP'
}

/** An object that reppresents an error trace query. */
export type AgentTracesErrorTraceQuery = {
  /** Exception class pattern. Wildcard (SQL LIKE syntax) */
  exceptionClassPattern?: InputMaybe<Scalars['String']['input']>;
  /** List of trace Ids. */
  ids?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;
  /** Maximum number of traces returned. */
  limit?: InputMaybe<Scalars['Int']['input']>;
  /** Error message pattern. Wildcard (SQL LIKE syntax) */
  messagePattern?: InputMaybe<Scalars['String']['input']>;
  /** Error trace ordering. */
  orderBy?: InputMaybe<AgentTracesErrorTraceOrderBy>;
  /** Error path pattern. Wildcard (SQL LIKE syntax) */
  pathPattern?: InputMaybe<Scalars['String']['input']>;
  /** End time. */
  startTimeMax?: InputMaybe<Scalars['EpochMilliseconds']['input']>;
  /** Start time. */
  startTimeMin?: InputMaybe<Scalars['EpochMilliseconds']['input']>;
};

/** An object representing a sql explain plan. */
export type AgentTracesExplainPlan = {
  __typename?: 'AgentTracesExplainPlan';
  /** Explain plan headers. */
  headers?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
  /** Explain plan rows. */
  rows?: Maybe<Array<Maybe<Scalars['AgentTracesExplainPlanRow']['output']>>>;
};

/** Order by direction */
export enum AgentTracesOrderByDirection {
  /** Ascending. */
  Asc = 'ASC',
  /** Descending. */
  Desc = 'DESC'
}

/** An object that represents a sql trace sample. */
export type AgentTracesSqlTrace = {
  __typename?: 'AgentTracesSqlTrace';
  /** Backtrace */
  backtrace?: Maybe<Array<Maybe<AgentTracesStackTraceFrame>>>;
  /** Number of SQL statements like this. */
  callCount?: Maybe<Scalars['Int']['output']>;
  /** Database instance name */
  databaseInstanceName?: Maybe<Scalars['String']['output']>;
  /** Database metric name, as defined by agents. */
  databaseMetricName: Scalars['String']['output'];
  /** Database name */
  databaseName?: Maybe<Scalars['String']['output']>;
  /** Explain plan */
  explainPlan?: Maybe<AgentTracesExplainPlan>;
  /** Trace identifier. */
  id: Scalars['ID']['output'];
  /** Call time, maximum of all `call_count` traces. */
  maxCallTime?: Maybe<Scalars['Milliseconds']['output']>;
  /** Call time, minimum of all `call_count` traces. */
  minCallTime?: Maybe<Scalars['Milliseconds']['output']>;
  /** ORM input query */
  ormInputQuery?: Maybe<Scalars['String']['output']>;
  /** ORM name */
  ormName?: Maybe<Scalars['String']['output']>;
  /** Path, as definted by agents. */
  path: Scalars['String']['output'];
  /** Query parameters */
  queryParameters?: Maybe<Scalars['AgentTracesQueryParameters']['output']>;
  /** SQL statement. */
  sql?: Maybe<Scalars['String']['output']>;
  /** An agent generated `sql_id`. */
  sqlId: Scalars['ID']['output'];
  /** When the SQL query occured. */
  startTime: Scalars['EpochMilliseconds']['output'];
  /** Call time, as added across all `call_count` traces. */
  totalCallTime?: Maybe<Scalars['Milliseconds']['output']>;
  /** URI of SQL, as defined by agents. */
  uri: Scalars['String']['output'];
};

/** An object that represents SQL trace ordering */
export type AgentTracesSqlTraceOrderBy = {
  /** Order by direction. */
  direction?: InputMaybe<AgentTracesOrderByDirection>;
  /** Field to order by. */
  field: AgentTracesSqlTraceOrderByField;
};

/** The different SQL trace fields to order by. */
export enum AgentTracesSqlTraceOrderByField {
  /** Trace duration. */
  Duration = 'DURATION',
  /** Call time, maximum of all `call_count` traces. */
  MaxCallTime = 'MAX_CALL_TIME',
  /** SQL trace path. */
  Path = 'PATH',
  /** Agent generated `sql_id`. */
  SqlId = 'SQL_ID',
  /** Trace start time. */
  Timestamp = 'TIMESTAMP',
  /** Call time, as added across all `call_count` traces. */
  TotalCallTime = 'TOTAL_CALL_TIME'
}

/** An object that reppresents a SQL trace query. */
export type AgentTracesSqlTraceQuery = {
  /** Database metric name pattern. Wildcard (SQL LIKE syntax) */
  databaseMetricNamePattern?: InputMaybe<Scalars['String']['input']>;
  /** List of trace Ids. */
  ids?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;
  /** Maximum number of traces returned. */
  limit?: InputMaybe<Scalars['Int']['input']>;
  /** SQL trace ordering. */
  orderBy?: InputMaybe<AgentTracesSqlTraceOrderBy>;
  /** Path pattern. Wildcard (SQL LIKE syntax) */
  pathPattern?: InputMaybe<Scalars['String']['input']>;
  /** An agent generated `sql_id`. */
  sqlId?: InputMaybe<Scalars['ID']['input']>;
  /** SQL pattern. Wildcard (SQL LIKE syntax) */
  sqlPattern?: InputMaybe<Scalars['String']['input']>;
  /** End time. */
  startTimeMax?: InputMaybe<Scalars['EpochMilliseconds']['input']>;
  /** Start time. */
  startTimeMin?: InputMaybe<Scalars['EpochMilliseconds']['input']>;
  /** URI pattern. Wildcard (SQL LIKE syntax) */
  uriPattern?: InputMaybe<Scalars['String']['input']>;
};

/** An object representing an stack trace segment */
export type AgentTracesStackTraceFrame = {
  __typename?: 'AgentTracesStackTraceFrame';
  /** Frame filepath */
  filepath?: Maybe<Scalars['String']['output']>;
  /** Formatted frame */
  formatted: Scalars['String']['output'];
  /** Frame line number */
  line?: Maybe<Scalars['Int']['output']>;
  /** Frame name */
  name?: Maybe<Scalars['String']['output']>;
};

/** Error for delete mutation results */
export type AgentTracesTraceMutationError = {
  __typename?: 'AgentTracesTraceMutationError';
  /** Details of error */
  message?: Maybe<Scalars['String']['output']>;
  /** Type of error */
  type?: Maybe<AgentTracesTraceMutationErrorType>;
};

/** Types of errors for mutations */
export enum AgentTracesTraceMutationErrorType {
  /** Error removing trace */
  RemovalError = 'REMOVAL_ERROR'
}

/** Result of the delete mutation */
export type AgentTracesTraceMutationResult = {
  __typename?: 'AgentTracesTraceMutationResult';
  /** List of errors, if any */
  errors?: Maybe<Array<Maybe<AgentTracesTraceMutationError>>>;
};

/** An object that represents a transaction trace sample. */
export type AgentTracesTransactionTrace = {
  __typename?: 'AgentTracesTransactionTrace';
  /** Map of attributes collected by the agent. */
  agentAttributes?: Maybe<Scalars['AgentTracesTraceAttributes']['output']>;
  /** Duration from when the response is received to when the response is returned in milliseconds. */
  duration: Scalars['Milliseconds']['output'];
  /** List of trace segment edges. */
  edges?: Maybe<Array<Maybe<AgentTracesTransactionTraceEdge>>>;
  /** GUID of the transaction which was used for CAT. */
  guid?: Maybe<Scalars['String']['output']>;
  /** Trace identifier */
  id?: Maybe<Scalars['ID']['output']>;
  /** Map Attributes which can not be turned off by the user.These are generally not shown to the customer (NR only). */
  intrinsicAttributes?: Maybe<Scalars['AgentTracesTraceAttributes']['output']>;
  /** List of trace segment nodes. */
  nodes?: Maybe<Array<Maybe<AgentTracesTransactionTraceNode>>>;
  /** The transaction metric name. */
  path: Scalars['String']['output'];
  /** Agent protocol version. */
  protocolVersion: Scalars['Int']['output'];
  /** The backing source for the transaction trace sample */
  source?: Maybe<AgentTracesTransactionTraceSource>;
  /** Transaction start time in milliseconds since the unix epoch. */
  startTime: Scalars['EpochMilliseconds']['output'];
  /** The transaction url. */
  uri: Scalars['String']['output'];
  /** Map of attributes collected by the user using the API. */
  userAttributes?: Maybe<Scalars['AgentTracesTraceAttributes']['output']>;
};

/** An object that represents parent/child relationship between to trace segment nodes */
export type AgentTracesTransactionTraceEdge = {
  __typename?: 'AgentTracesTransactionTraceEdge';
  /** Child segment GUID. */
  childId?: Maybe<Scalars['ID']['output']>;
  /** Parent segment GUID. */
  parentId?: Maybe<Scalars['ID']['output']>;
};

/** An object that represents a filter for a transaction trace sample. */
export type AgentTracesTransactionTraceFilter = {
  /** The backing source for the transaction trace sample */
  source?: InputMaybe<AgentTracesTransactionTraceSource>;
  /** End time */
  startTimeMax?: InputMaybe<Scalars['EpochMilliseconds']['input']>;
  /** Start time */
  startTimeMin?: InputMaybe<Scalars['EpochMilliseconds']['input']>;
};

/** An object that represent a Trace Node. */
export type AgentTracesTransactionTraceNode = {
  __typename?: 'AgentTracesTransactionTraceNode';
  /** Map of segment attributes. */
  attributes?: Maybe<Scalars['AgentTracesTraceAttributes']['output']>;
  /** Segment duration. */
  duration?: Maybe<Scalars['Milliseconds']['output']>;
  /** Segment exlusive duration. */
  exclusiveDurationMs?: Maybe<Scalars['EpochMilliseconds']['output']>;
  /** Segment ID. */
  id?: Maybe<Scalars['ID']['output']>;
  /** Segment name. */
  name?: Maybe<Scalars['String']['output']>;
  /** Segment start time in milliseconds since the unix epoch. */
  timestamp?: Maybe<Scalars['EpochMilliseconds']['output']>;
};

/** An object that represents transaction trace ordering. */
export type AgentTracesTransactionTraceOrderBy = {
  /** Order by direction. */
  direction?: InputMaybe<AgentTracesOrderByDirection>;
  /** Field to order by. */
  field: AgentTracesTransactionTraceOrderByField;
};

/** The different transaction trace fields to order by. */
export enum AgentTracesTransactionTraceOrderByField {
  /** Trace duration. */
  Duration = 'DURATION',
  /** Transaction trace path. */
  Path = 'PATH',
  /** Trace start time. */
  Timestamp = 'TIMESTAMP'
}

/** An object that reppresents a transaction trace query. */
export type AgentTracesTransactionTraceQuery = {
  /** Exact GUIDs. */
  guids?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  /** List of trace Ids. */
  ids?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;
  /** Maximum number of traces returned. */
  limit?: InputMaybe<Scalars['Int']['input']>;
  /** Transaction trace ordering. */
  orderBy?: InputMaybe<AgentTracesTransactionTraceOrderBy>;
  /** Parameters pattern. Wildcard (SQL LIKE syntax) */
  parametersPattern?: InputMaybe<Scalars['String']['input']>;
  /** Transaction path pattern. Wildcard (SQL LIKE syntax) */
  pathPattern?: InputMaybe<Scalars['String']['input']>;
  /** Exact paths. */
  paths?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  /** List of Real Agent Ids */
  realAgentIds?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;
  /** Tracing data source types to return from the query */
  sources?: InputMaybe<Array<InputMaybe<AgentTracesTransactionTraceSource>>>;
  /** End time. */
  startTimeMax?: InputMaybe<Scalars['EpochMilliseconds']['input']>;
  /** Start time. */
  startTimeMin?: InputMaybe<Scalars['EpochMilliseconds']['input']>;
  /** URL pattern. Wildcard (SQL LIKE syntax) */
  urlPattern?: InputMaybe<Scalars['String']['input']>;
};

/** The different sources of transaction tracing data */
export enum AgentTracesTransactionTraceSource {
  /** Distributed tracing data type */
  DistributedTrace = 'DISTRIBUTED_TRACE',
  /** Original transaction trace data type */
  TransactionTrace = 'TRANSACTION_TRACE'
}

export enum AgentType {
  Application = 'APPLICATION',
  BrowserApplication = 'BROWSER_APPLICATION',
  MobileApplication = 'MOBILE_APPLICATION',
  Server = 'SERVER'
}

export type AgentVersions = {
  __typename?: 'AgentVersions';
  /** The highest agent version amongst all the running application instances */
  maxVersion?: Maybe<Scalars['String']['output']>;
  /** The release date of the highest agent version amongst all the running application instances */
  maxVersionReleaseDate?: Maybe<Scalars['Date']['output']>;
  /** The lowest agent version amongst all the running application instances */
  minVersion?: Maybe<Scalars['String']['output']>;
  /** The release date of the lowest agent version amongst all the running application instances */
  minVersionReleaseDate?: Maybe<Scalars['Date']['output']>;
};

export type AgentViolation = {
  __typename?: 'AgentViolation';
  /** A link to the agent in the time window in which the violation occurred */
  agentUrl?: Maybe<Scalars['String']['output']>;
  alertStatus?: Maybe<AlertStatus>;
  closedAt?: Maybe<Scalars['EpochMilliseconds']['output']>;
  label?: Maybe<Scalars['String']['output']>;
  level?: Maybe<Scalars['String']['output']>;
  openedAt?: Maybe<Scalars['EpochMilliseconds']['output']>;
  /** A link to the violation if it is connected to an incident */
  violationUrl?: Maybe<Scalars['String']['output']>;
};

export type AiConnectAccountStitchedFields = {
  __typename?: 'AiConnectAccountStitchedFields';
  /** Fetch a single Enricher by Id or by Name */
  enricher?: Maybe<AiConnectEnricher>;
  /** List all Enrichers, filter by workflowId and/or type if provided */
  enrichers: Array<AiConnectEnricher>;
  /** Fetch a single Notifier by Id or by Name */
  notifier?: Maybe<AiConnectNotifier>;
  /** List all Notifiers, by WorkflowId or by Name */
  notifiers: Array<AiConnectNotifier>;
  /** Fetch a specific Workflow Variable, by Name or Id */
  variable?: Maybe<AiConnectVariable>;
  /** Fetch a list of all Workflow Variables, can be filtered by type or source */
  variables: Array<AiConnectVariable>;
  /** Fetch a Workflow by Id */
  workflow?: Maybe<AiConnectWorkflow>;
  /** Fetch all account Workflows */
  workflows: Array<AiConnectWorkflow>;
};


export type AiConnectAccountStitchedFieldsEnricherArgs = {
  enricherId?: InputMaybe<Scalars['ID']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  workflowId?: InputMaybe<Scalars['ID']['input']>;
};


export type AiConnectAccountStitchedFieldsEnrichersArgs = {
  type?: InputMaybe<AiConnectEnricherTypes>;
  workflowId?: InputMaybe<Scalars['ID']['input']>;
};


export type AiConnectAccountStitchedFieldsNotifierArgs = {
  name?: InputMaybe<Scalars['String']['input']>;
  notifierId?: InputMaybe<Scalars['ID']['input']>;
  workflowId?: InputMaybe<Scalars['ID']['input']>;
};


export type AiConnectAccountStitchedFieldsNotifiersArgs = {
  type?: InputMaybe<AiConnectNotifierTypes>;
  workflowId?: InputMaybe<Scalars['ID']['input']>;
};


export type AiConnectAccountStitchedFieldsVariableArgs = {
  id?: InputMaybe<Scalars['ID']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
};


export type AiConnectAccountStitchedFieldsVariablesArgs = {
  source?: InputMaybe<AiConnectVariableSource>;
};


export type AiConnectAccountStitchedFieldsWorkflowArgs = {
  workflowId: Scalars['ID']['input'];
};

/** A pair of key values */
export type AiConnectAttribute = {
  __typename?: 'AiConnectAttribute';
  /** The Key */
  key: Scalars['String']['output'];
  /** The Value */
  value: Scalars['String']['output'];
};

/** A pair of key-value defining custom attributes */
export type AiConnectAttributeInput = {
  /** key */
  key: Scalars['String']['input'];
  /** value */
  value: Scalars['String']['input'];
};

/** Authentication interface */
export type AiConnectAuth = {
  /** Authentication type */
  type: AiConnectAuthType;
};

/** All possible Authentication methods */
export enum AiConnectAuthType {
  /** Basic user and password authentication */
  Basic = 'BASIC',
  /** Token based authentication */
  Token = 'TOKEN',
  /** User and Token based authentication */
  UserToken = 'USER_TOKEN'
}

/** Send an event to AWS EventBridge */
export type AiConnectAwsEventBridgeNotifier = AiConnectNotifier & {
  __typename?: 'AiConnectAwsEventBridgeNotifier';
  /** Is this entity currently active */
  active: Scalars['Boolean']['output'];
  /** Customer's AWS account id, should be a 12-digit numerical value */
  awsAccountId: Scalars['String']['output'];
  /** Customer's AWS region */
  awsRegion: Scalars['String']['output'];
  /** The content of the event */
  body: Scalars['String']['output'];
  /** Created DateTime */
  createdAt: Scalars['DateTime']['output'];
  /** EventBus that will get the data */
  eventBusName: Scalars['String']['output'];
  /** Entity Id */
  id: Scalars['ID']['output'];
  /** Entity name (customer defined) */
  name: Scalars['String']['output'];
  /** Notifier type */
  type: AiConnectNotifierTypes;
  /** Updated DateTime */
  updatedAt: Scalars['DateTime']['output'];
  /** The Workflow Id this entity belongs to */
  workflowId: Scalars['ID']['output'];
};

/** An input object for AWS Event Bridge Notifiers */
export type AiConnectAwsEventBridgeNotifierInput = {
  /** awsAccountId */
  awsAccountId: Scalars['String']['input'];
  /** awsRegion */
  awsRegion: Scalars['String']['input'];
  /** body */
  body: Scalars['String']['input'];
  /** eventBusName */
  eventBusName: Scalars['String']['input'];
  /** name */
  name: Scalars['String']['input'];
};

/** AWS EventBridge test input */
export type AiConnectAwsEventBridgeNotifierTestInput = {
  /** awsAccountId */
  awsAccountId: Scalars['String']['input'];
  /** awsRegion */
  awsRegion: Scalars['String']['input'];
  /** body */
  body: Scalars['String']['input'];
  /** eventBusName */
  eventBusName: Scalars['String']['input'];
};

/** AWS EventBridge details to be updated */
export type AiConnectAwsEventBridgeNotifierUpdate = {
  /** active */
  active?: InputMaybe<Scalars['Boolean']['input']>;
  /** awsAccountId */
  awsAccountId?: InputMaybe<Scalars['String']['input']>;
  /** awsRegion */
  awsRegion?: InputMaybe<Scalars['String']['input']>;
  /** body */
  body?: InputMaybe<Scalars['String']['input']>;
  /** eventBusName */
  eventBusName?: InputMaybe<Scalars['String']['input']>;
  /** id */
  id: Scalars['ID']['input'];
  /** name */
  name?: InputMaybe<Scalars['String']['input']>;
};

/** Basic user and password authentication */
export type AiConnectBasicAuth = AiConnectAuth & {
  __typename?: 'AiConnectBasicAuth';
  /** Authentication type */
  type: AiConnectAuthType;
  /** Username */
  username: Scalars['String']['output'];
};

/** Basic user and password authentication input */
export type AiConnectBasicAuthInput = {
  /** password */
  password: Scalars['SecureValue']['input'];
  /** username */
  username: Scalars['String']['input'];
};

/** Any possible Credentials type */
export type AiConnectCredentialsInput = {
  /** basic */
  basic?: InputMaybe<AiConnectBasicAuthInput>;
  /** token */
  token?: InputMaybe<AiConnectTokenAuthInput>;
  /** userToken */
  userToken?: InputMaybe<AiConnectUserTokenAuthInput>;
};

/** Object for validation errors */
export type AiConnectDataValidationError = AiConnectResponseError & {
  __typename?: 'AiConnectDataValidationError';
  /** Error description */
  description: Scalars['String']['output'];
  /** Additional details for the specific error that occurred */
  details?: Maybe<Scalars['String']['output']>;
  /** List of invalid fields */
  fields: Array<AiConnectFieldError>;
  /** Error type */
  type: Scalars['String']['output'];
};

/** Response for all delete operations. Include deleted entity Id's and/or Errors */
export type AiConnectDeleteResponse = AiConnectResponse & {
  __typename?: 'AiConnectDeleteResponse';
  /** List of deleted entities */
  entitiesId?: Maybe<Array<Scalars['ID']['output']>>;
  /** List of errors that occurred */
  errors: Array<AiConnectResponseError>;
};

/** An Enricher object */
export type AiConnectEnricher = {
  /** Is this entity currently active */
  active: Scalars['Boolean']['output'];
  /** Created DateTime */
  createdAt: Scalars['DateTime']['output'];
  /** Entity Id */
  id: Scalars['ID']['output'];
  /** Entity name (customer defined) */
  name: Scalars['String']['output'];
  /** Enricher type */
  type: AiConnectEnricherTypes;
  /** Updated DateTime */
  updatedAt: Scalars['DateTime']['output'];
  /** The Workflow Id this entity belongs to */
  workflowId: Scalars['ID']['output'];
};

/** Response for all Enricher related mutation. Includes relevant Enrichers and/or Errors */
export type AiConnectEnricherResponse = AiConnectResponse & {
  __typename?: 'AiConnectEnricherResponse';
  /** Successfully mutated Enricher */
  enricher?: Maybe<AiConnectEnricher>;
  /** List of errors that occurred */
  errors: Array<AiConnectResponseError>;
};

/** All possible Enrichers */
export enum AiConnectEnricherTypes {
  /** NRQL Enricher */
  Nrql = 'NRQL'
}

/** An object containing all Enrichers */
export type AiConnectEnrichers = {
  /** nrqlList */
  nrqlList?: InputMaybe<Array<AiConnectNrqlEnricherInput>>;
};

/** Enricher details to be updated */
export type AiConnectEnrichersUpdate = {
  /** nrql */
  nrql?: InputMaybe<AiConnectNrqlEnricherUpdate>;
};

/** Invalid field object */
export type AiConnectFieldError = {
  __typename?: 'AiConnectFieldError';
  /** Field name */
  field: Scalars['String']['output'];
  /** Validation error */
  message: Scalars['String']['output'];
};

/** A pair of key value */
export type AiConnectHeader = {
  __typename?: 'AiConnectHeader';
  /** The Key */
  key: Scalars['String']['output'];
  /** The Value */
  value: Scalars['String']['output'];
};

/** A pair of key-value defining custom header */
export type AiConnectHeaderInput = {
  /** key */
  key: Scalars['String']['input'];
  /** value */
  value: Scalars['String']['input'];
};

/** Create a Jira ticket */
export type AiConnectJiraNotifier = AiConnectNotifier & {
  __typename?: 'AiConnectJiraNotifier';
  /** Is this entity currently active */
  active: Scalars['Boolean']['output'];
  /** Designated issue assignee */
  assignee?: Maybe<Scalars['String']['output']>;
  /** Customer defined custom map */
  attributes: Array<AiConnectAttribute>;
  /** Created DateTime */
  createdAt: Scalars['DateTime']['output'];
  /** Jira Credentials */
  credentials: AiConnectUserTokenAuth;
  /** Entity Id */
  id: Scalars['ID']['output'];
  /** Designated issue type */
  issueType?: Maybe<Scalars['String']['output']>;
  /** Entity name (customer defined) */
  name: Scalars['String']['output'];
  /** Designated issue priority */
  priority?: Maybe<Scalars['String']['output']>;
  /** The project in which the ticket will be created */
  project: Scalars['String']['output'];
  /** Designated issue watchers */
  status?: Maybe<Scalars['String']['output']>;
  /** Allow two-way integration with Jira */
  twoWayIntegration?: Maybe<Scalars['Boolean']['output']>;
  /** Notifier type */
  type: AiConnectNotifierTypes;
  /** Updated DateTime */
  updatedAt: Scalars['DateTime']['output'];
  /** Customer's Atlassian account URL */
  url: Scalars['String']['output'];
  /** Designated issue watchers list */
  watchers?: Maybe<Array<Scalars['String']['output']>>;
  /** The Workflow Id this entity belongs to */
  workflowId: Scalars['ID']['output'];
};

/** An input object for Jira Notifiers */
export type AiConnectJiraNotifierInput = {
  /** assignee */
  assignee?: InputMaybe<Scalars['String']['input']>;
  /** attributes */
  attributes?: InputMaybe<Array<AiConnectAttributeInput>>;
  /** credentials */
  credentials: AiConnectUserTokenAuthInput;
  /** issueType */
  issueType?: InputMaybe<Scalars['String']['input']>;
  /** name */
  name: Scalars['String']['input'];
  /** priority */
  priority?: InputMaybe<Scalars['String']['input']>;
  /** project */
  project: Scalars['String']['input'];
  /** status */
  status?: InputMaybe<Scalars['String']['input']>;
  /** twoWayIntegration */
  twoWayIntegration?: InputMaybe<Scalars['Boolean']['input']>;
  /** url */
  url: Scalars['String']['input'];
  /** watchers */
  watchers?: InputMaybe<Array<Scalars['String']['input']>>;
};

/** Jira Notifier test input */
export type AiConnectJiraNotifierTestInput = {
  /** assignee */
  assignee?: InputMaybe<Scalars['String']['input']>;
  /** attributes */
  attributes?: InputMaybe<Array<AiConnectAttributeInput>>;
  /** credentials */
  credentials: AiConnectUserTokenAuthInput;
  /** issueType */
  issueType?: InputMaybe<Scalars['String']['input']>;
  /** priority */
  priority?: InputMaybe<Scalars['String']['input']>;
  /** project */
  project: Scalars['String']['input'];
  /** status */
  status?: InputMaybe<Scalars['String']['input']>;
  /** url */
  url: Scalars['String']['input'];
  /** watchers */
  watchers?: InputMaybe<Array<Scalars['String']['input']>>;
};

/** Jira Notifier details to be updated */
export type AiConnectJiraNotifierUpdate = {
  /** active */
  active?: InputMaybe<Scalars['Boolean']['input']>;
  /** assignee */
  assignee?: InputMaybe<Scalars['String']['input']>;
  /** attributes */
  attributes?: InputMaybe<Array<AiConnectAttributeInput>>;
  /** credentials */
  credentials?: InputMaybe<AiConnectUserTokenAuthInput>;
  /** id */
  id: Scalars['ID']['input'];
  /** issueType */
  issueType?: InputMaybe<Scalars['String']['input']>;
  /** name */
  name?: InputMaybe<Scalars['String']['input']>;
  /** priority */
  priority?: InputMaybe<Scalars['String']['input']>;
  /** project */
  project?: InputMaybe<Scalars['String']['input']>;
  /** status */
  status?: InputMaybe<Scalars['String']['input']>;
  /** twoWayIntegration */
  twoWayIntegration?: InputMaybe<Scalars['Boolean']['input']>;
  /** url */
  url?: InputMaybe<Scalars['String']['input']>;
  /** watchers */
  watchers?: InputMaybe<Array<Scalars['String']['input']>>;
};

/** Object for various errors */
export type AiConnectMutationResponseError = AiConnectResponseError & {
  __typename?: 'AiConnectMutationResponseError';
  /** Error description */
  description: Scalars['String']['output'];
  /** Additional details for the specific error that occurred */
  details?: Maybe<Scalars['String']['output']>;
  /** Error type */
  type: Scalars['String']['output'];
};

/** A Notifier Object */
export type AiConnectNotifier = {
  /** Is this entity currently active */
  active: Scalars['Boolean']['output'];
  /** Created DateTime */
  createdAt: Scalars['DateTime']['output'];
  /** Entity Id */
  id: Scalars['ID']['output'];
  /** Entity name (customer defined) */
  name: Scalars['String']['output'];
  /** Notifier type */
  type: AiConnectNotifierTypes;
  /** Updated DateTime */
  updatedAt: Scalars['DateTime']['output'];
  /** The Workflow Id this entity belongs to */
  workflowId: Scalars['ID']['output'];
};

/** Response for all Notifiers related mutation. Includes relevant Notifiers and/or Errors */
export type AiConnectNotifierResponse = AiConnectResponse & {
  __typename?: 'AiConnectNotifierResponse';
  /** List of errors that occurred */
  errors: Array<AiConnectResponseError>;
  /** Successfully mutated Notifier */
  notifier?: Maybe<AiConnectNotifier>;
};

/** Common interface for all Notifier Tests */
export type AiConnectNotifierTestInput = {
  /** awsEventBridge */
  awsEventBridge?: InputMaybe<AiConnectAwsEventBridgeNotifierTestInput>;
  /** jira */
  jira?: InputMaybe<AiConnectJiraNotifierTestInput>;
  /** serviceNow */
  serviceNow?: InputMaybe<AiConnectServiceNowNotifierTestInput>;
  /** webhook */
  webhook?: InputMaybe<AiConnectWebhookNotifierTestInput>;
};

/** Response for the various tests in the system. Includes test status and/or Errors */
export type AiConnectNotifierTestResponse = AiConnectResponse & {
  __typename?: 'AiConnectNotifierTestResponse';
  /** Additional results information */
  details?: Maybe<Scalars['String']['output']>;
  /** List of errors that occurred */
  errors: Array<AiConnectResponseError>;
  /** Test result - success or failure */
  result: AiConnectTestResult;
};

/** All possible Notifiers */
export enum AiConnectNotifierTypes {
  /** AWS Event Bridge Notifier */
  Awseventbridge = 'AWSEVENTBRIDGE',
  /** Jira Notifier */
  Jira = 'JIRA',
  /** ServiceNow Notifier */
  Servicenow = 'SERVICENOW',
  /** Webhook Notifier */
  Webhook = 'WEBHOOK'
}

/** An object containing all Notifiers */
export type AiConnectNotifiers = {
  /** awsEventBridge */
  awsEventBridge?: InputMaybe<Array<AiConnectAwsEventBridgeNotifierInput>>;
  /** jira */
  jira?: InputMaybe<Array<AiConnectJiraNotifierInput>>;
  /** serviceNow */
  serviceNow?: InputMaybe<Array<AiConnectServiceNowNotifierInput>>;
  /** webhook */
  webhook?: InputMaybe<Array<AiConnectWebhookNotifierInput>>;
};

/** Notifiers details to be updated */
export type AiConnectNotifiersUpdate = {
  /** awsEventBridge */
  awsEventBridge?: InputMaybe<AiConnectAwsEventBridgeNotifierUpdate>;
  /** jira */
  jira?: InputMaybe<AiConnectJiraNotifierUpdate>;
  /** serviceNow */
  serviceNow?: InputMaybe<AiConnectServiceNowNotifierUpdate>;
  /** webhook */
  webhook?: InputMaybe<AiConnectWebhookNotifierUpdate>;
};

/** Enrich a Workflow by querying NRQL */
export type AiConnectNrqlEnricher = AiConnectEnricher & {
  __typename?: 'AiConnectNrqlEnricher';
  /** Is this entity currently active */
  active: Scalars['Boolean']['output'];
  /** Created DateTime */
  createdAt: Scalars['DateTime']['output'];
  /** Entity Id */
  id: Scalars['ID']['output'];
  /** Entity name (customer defined) */
  name: Scalars['String']['output'];
  /** NRQL output type */
  outputType: AiConnectNrqlOutputType;
  /** NRQL query that will be performed */
  queryTemplate: Scalars['String']['output'];
  /** Enricher type */
  type: AiConnectEnricherTypes;
  /** Updated DateTime */
  updatedAt: Scalars['DateTime']['output'];
  /** The Workflow Id this entity belongs to */
  workflowId: Scalars['ID']['output'];
};

/** An Enricher object for NRQL */
export type AiConnectNrqlEnricherInput = {
  /** name */
  name: Scalars['String']['input'];
  /** outputType */
  outputType?: InputMaybe<AiConnectNrqlOutputType>;
  /** queryTemplate */
  queryTemplate: Scalars['String']['input'];
};

/** NRQL Enricher details to be updated */
export type AiConnectNrqlEnricherUpdate = {
  /** active */
  active?: InputMaybe<Scalars['Boolean']['input']>;
  /** id */
  id: Scalars['ID']['input'];
  /** name */
  name?: InputMaybe<Scalars['String']['input']>;
  /** outputType */
  outputType?: InputMaybe<AiConnectNrqlOutputType>;
  /** queryTemplate */
  queryTemplate?: InputMaybe<Scalars['String']['input']>;
};

/** NRQL Enricher output type */
export enum AiConnectNrqlOutputType {
  /** Static chart URL */
  Chart = 'CHART',
  /** Default json output */
  Json = 'JSON'
}

/** NewRelic Alert Policy */
export type AiConnectPolicy = {
  __typename?: 'AiConnectPolicy';
  /** The NewRelic Alert policy Id */
  id: Scalars['Int']['output'];
};

/** A list of Policies that trigger this Workflow */
export type AiConnectPolicyInput = {
  /** id */
  id: Scalars['Int']['input'];
};

/** Common interface for all Response objects */
export type AiConnectResponse = {
  /** List of errors that occurred */
  errors: Array<AiConnectResponseError>;
};

/** Common interface for response errors */
export type AiConnectResponseError = {
  /** Error description */
  description: Scalars['String']['output'];
  /** Additional details for the specific error that occurred */
  details?: Maybe<Scalars['String']['output']>;
  /** Error type */
  type: Scalars['String']['output'];
};

/** Create a ServiceNow ticket */
export type AiConnectServiceNowNotifier = AiConnectNotifier & {
  __typename?: 'AiConnectServiceNowNotifier';
  /** Is this entity currently active */
  active: Scalars['Boolean']['output'];
  /** Customer defined custom map */
  attributes: Array<AiConnectAttribute>;
  /** Created DateTime */
  createdAt: Scalars['DateTime']['output'];
  /** ServiceNow Credentials */
  credentials: AiConnectBasicAuth;
  /** Entity Id */
  id: Scalars['ID']['output'];
  /** Entity name (customer defined) */
  name: Scalars['String']['output'];
  /** Allow two-way integration with ServiceNow */
  twoWayIntegration?: Maybe<Scalars['Boolean']['output']>;
  /** Notifier type */
  type: AiConnectNotifierTypes;
  /** Updated DateTime */
  updatedAt: Scalars['DateTime']['output'];
  /** Customer's ServiceNow account URL */
  url: Scalars['String']['output'];
  /** The Workflow Id this entity belongs to */
  workflowId: Scalars['ID']['output'];
};

/** An input object for ServiceNow Notifiers */
export type AiConnectServiceNowNotifierInput = {
  /** attributes */
  attributes?: InputMaybe<Array<AiConnectAttributeInput>>;
  /** credentials */
  credentials: AiConnectBasicAuthInput;
  /** name */
  name: Scalars['String']['input'];
  /** twoWayIntegration */
  twoWayIntegration?: InputMaybe<Scalars['Boolean']['input']>;
  /** url */
  url: Scalars['String']['input'];
};

/** ServiceNow Notifier test input */
export type AiConnectServiceNowNotifierTestInput = {
  /** attributes */
  attributes?: InputMaybe<Array<AiConnectAttributeInput>>;
  /** credentials */
  credentials: AiConnectBasicAuthInput;
  /** url */
  url: Scalars['String']['input'];
};

/** ServiceNow Notifier details to be updated */
export type AiConnectServiceNowNotifierUpdate = {
  /** active */
  active?: InputMaybe<Scalars['Boolean']['input']>;
  /** attributes */
  attributes?: InputMaybe<Array<AiConnectAttributeInput>>;
  /** credentials */
  credentials?: InputMaybe<AiConnectBasicAuthInput>;
  /** id */
  id: Scalars['ID']['input'];
  /** name */
  name?: InputMaybe<Scalars['String']['input']>;
  /** twoWayIntegration */
  twoWayIntegration?: InputMaybe<Scalars['Boolean']['input']>;
  /** url */
  url?: InputMaybe<Scalars['String']['input']>;
};

/** Results from various tests in the system */
export enum AiConnectTestResult {
  /** Test failed */
  Fail = 'FAIL',
  /** Test was successful */
  Ok = 'OK'
}

/** Token based authentication */
export type AiConnectTokenAuth = AiConnectAuth & {
  __typename?: 'AiConnectTokenAuth';
  /** Token Prefix */
  prefix: Scalars['String']['output'];
  /** Authentication type */
  type: AiConnectAuthType;
};

/** Token based authentication input */
export type AiConnectTokenAuthInput = {
  /** prefix */
  prefix: Scalars['String']['input'];
  /** token */
  token: Scalars['SecureValue']['input'];
};

/** Username with Token based authentication */
export type AiConnectUserTokenAuth = AiConnectAuth & {
  __typename?: 'AiConnectUserTokenAuth';
  /** Authentication type */
  type: AiConnectAuthType;
  /** Username */
  username: Scalars['String']['output'];
};

/** Username with Token based authentication */
export type AiConnectUserTokenAuthInput = {
  /** token */
  token: Scalars['SecureValue']['input'];
  /** username */
  username: Scalars['String']['input'];
};

/** List of Workflow related Variables for the customer to use in the Enrichers/Notifiers */
export type AiConnectVariable = {
  __typename?: 'AiConnectVariable';
  /** Is this Variable in the default payload */
  default: Scalars['Boolean']['output'];
  /** User readable variable name */
  displayName: Scalars['String']['output'];
  /** Variable Id */
  id: Scalars['ID']['output'];
  /** Variable name */
  name: Scalars['String']['output'];
  /** The source of this Variable */
  source: AiConnectVariableSource;
  /** Primitive type of the Variable */
  type: AiConnectVariableType;
};

/** The source of a Workflow Variable */
export enum AiConnectVariableSource {
  /** Variable is global */
  Global = 'GLOBAL',
  /** Variable originated from New Relic */
  Nr = 'NR',
  /** Variable originated from Pager Duty */
  Pd = 'PD'
}

/** The type of a Workflow Variable */
export enum AiConnectVariableType {
  /** A variable of type Boolean */
  Boolean = 'BOOLEAN',
  /** A variable of type Double */
  Double = 'DOUBLE',
  /** A variable of type Enum */
  Enum = 'ENUM',
  /** A variable of type Int */
  Int = 'INT',
  /** A variable of type Long */
  Long = 'LONG',
  /** A variable of type String */
  String = 'STRING'
}

/** Send your incident to a Webhook */
export type AiConnectWebhookNotifier = AiConnectNotifier & {
  __typename?: 'AiConnectWebhookNotifier';
  /** Is this entity currently active */
  active: Scalars['Boolean']['output'];
  /** The data that will be sent */
  body: Scalars['String']['output'];
  /** Created DateTime */
  createdAt: Scalars['DateTime']['output'];
  /** Webhook Credentials */
  credentials?: Maybe<AiConnectAuth>;
  /** Pair of key-value string headers */
  headers?: Maybe<Array<AiConnectHeader>>;
  /** Entity Id */
  id: Scalars['ID']['output'];
  /** Entity name (customer defined) */
  name: Scalars['String']['output'];
  /** Notifier type */
  type: AiConnectNotifierTypes;
  /** Updated DateTime */
  updatedAt: Scalars['DateTime']['output'];
  /** Customer Webhook URL */
  url: Scalars['String']['output'];
  /** The Workflow Id this entity belongs to */
  workflowId: Scalars['ID']['output'];
};

/** An input object for Webhook Notifiers */
export type AiConnectWebhookNotifierInput = {
  /** body */
  body: Scalars['String']['input'];
  /** credentials */
  credentials?: InputMaybe<AiConnectCredentialsInput>;
  /** headers */
  headers?: InputMaybe<Array<AiConnectHeaderInput>>;
  /** name */
  name: Scalars['String']['input'];
  /** url */
  url: Scalars['String']['input'];
};

/** Webhook Notifier test input */
export type AiConnectWebhookNotifierTestInput = {
  /** body */
  body?: InputMaybe<Scalars['String']['input']>;
  /** credentials */
  credentials?: InputMaybe<AiConnectCredentialsInput>;
  /** headers */
  headers?: InputMaybe<Array<AiConnectHeaderInput>>;
  /** url */
  url: Scalars['String']['input'];
};

/** Webhook Notifier details to be updated */
export type AiConnectWebhookNotifierUpdate = {
  /** active */
  active?: InputMaybe<Scalars['Boolean']['input']>;
  /** body */
  body?: InputMaybe<Scalars['String']['input']>;
  /** credentials */
  credentials?: InputMaybe<AiConnectCredentialsInput>;
  /** headers */
  headers?: InputMaybe<Array<AiConnectHeaderInput>>;
  /** id */
  id: Scalars['ID']['input'];
  /** name */
  name?: InputMaybe<Scalars['String']['input']>;
  /** url */
  url?: InputMaybe<Scalars['String']['input']>;
};

/** Connect Workflow */
export type AiConnectWorkflow = {
  __typename?: 'AiConnectWorkflow';
  /** The account this Workflow belongs to */
  accountId: Scalars['Int']['output'];
  /** Is this Workflow currently active */
  active: Scalars['Boolean']['output'];
  /** Created timestamp in milliseconds */
  createdAt: Scalars['DateTime']['output'];
  /** The user which created this Workflow */
  creatorId: Scalars['Int']['output'];
  /** List of Enrichers belong to a specific Workflow */
  enrichers: Array<AiConnectEnricher>;
  /** Workflow Id */
  id: Scalars['ID']['output'];
  /** Last Workflow execution time */
  lastExecution?: Maybe<Scalars['DateTime']['output']>;
  /** User defined custom name */
  name: Scalars['String']['output'];
  /** List of Notifiers belong to a specific Workflow */
  notifiers: Array<AiConnectNotifier>;
  /** A list of Policies that trigger this Workflow */
  policies: Array<AiConnectPolicy>;
  /** Last modified timestamp in milliseconds */
  updatedAt: Scalars['DateTime']['output'];
};

/** Workflow input object */
export type AiConnectWorkflowInput = {
  /** active */
  active?: InputMaybe<Scalars['Boolean']['input']>;
  /** enrichers */
  enrichers?: InputMaybe<AiConnectEnrichers>;
  /** name */
  name: Scalars['String']['input'];
  /** notifiers */
  notifiers: AiConnectNotifiers;
  /** policies */
  policies: Array<AiConnectPolicyInput>;
};

/** Response for all Workflow related mutation. Includes relevant Workflow and/or Errors */
export type AiConnectWorkflowResponse = AiConnectResponse & {
  __typename?: 'AiConnectWorkflowResponse';
  /** List of errors that occurred */
  errors: Array<AiConnectResponseError>;
  /** Successfully mutated Workflows */
  workflow?: Maybe<AiConnectWorkflow>;
};

/** Result of a single step executed as part of workflow (Enricher/Notifier) */
export type AiConnectWorkflowStepResult = {
  __typename?: 'AiConnectWorkflowStepResult';
  /** Reason for failure, if we failed */
  error?: Maybe<Scalars['String']['output']>;
  /** The action's name */
  name: Scalars['String']['output'];
  /** Successful outcome, if available */
  result?: Maybe<Scalars['String']['output']>;
  /** Completed without errors? */
  success: Scalars['Boolean']['output'];
};

/** Result of a whole workflow running */
export type AiConnectWorkflowTestResponse = AiConnectResponse & {
  __typename?: 'AiConnectWorkflowTestResponse';
  /** Extra details (if available) */
  details?: Maybe<Scalars['String']['output']>;
  /** List of errors that occurred */
  errors: Array<AiConnectResponseError>;
  /** Extra message in case of errors */
  message?: Maybe<Scalars['String']['output']>;
  /** Test result - success or failure */
  status: AiConnectTestResult;
  /** Specific information for each step executed */
  steps: Array<AiConnectWorkflowStepResult>;
};

/** Update Workflow object */
export type AiConnectWorkflowUpdate = {
  /** active */
  active?: InputMaybe<Scalars['Boolean']['input']>;
  /** id */
  id: Scalars['ID']['input'];
  /** name */
  name?: InputMaybe<Scalars['String']['input']>;
  /** policies */
  policies?: InputMaybe<Array<AiConnectPolicyInput>>;
};

export type AiDecisionsAccountStitchedFields = {
  __typename?: 'AiDecisionsAccountStitchedFields';
  /** Fetch a decision by ID. */
  decision?: Maybe<AiDecisionsDecision>;
  /** Returns a paginated list of decisions. */
  decisions: AiDecisionsDecisionListing;
};


export type AiDecisionsAccountStitchedFieldsDecisionArgs = {
  decisionId: Scalars['ID']['input'];
};


export type AiDecisionsAccountStitchedFieldsDecisionsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  decisionStates?: InputMaybe<Array<AiDecisionsDecisionState>>;
  decisionTypes?: InputMaybe<Array<AiDecisionsDecisionType>>;
  pageSize?: InputMaybe<Scalars['Int']['input']>;
  sortMethod?: InputMaybe<AiDecisionsDecisionSortMethod>;
};

/** Input type for All expression */
export type AiDecisionsAllInput = {
  /** Children expressions. */
  children: Array<AiDecisionsRuleExpressionInput>;
};

/** Input type for And expression */
export type AiDecisionsAndInput = {
  /** Left child expression. */
  left: AiDecisionsRuleExpressionInput;
  /** Right child expression. */
  right: AiDecisionsRuleExpressionInput;
};

/** A key-value entry. */
export type AiDecisionsAnnotationEntry = {
  __typename?: 'AiDecisionsAnnotationEntry';
  /** Key of entry. */
  key: Scalars['String']['output'];
  /** Value of entry. */
  value: Scalars['String']['output'];
};

/** A search for a subset of incidents that may be relevant for a given rule expression */
export type AiDecisionsApplicableIncidentSearch = {
  __typename?: 'AiDecisionsApplicableIncidentSearch';
  /** Time search operation completed */
  completedAt?: Maybe<Scalars['EpochMilliseconds']['output']>;
  /** Time search operation was created */
  createdAt: Scalars['EpochMilliseconds']['output'];
  /** Error message if search operation failed */
  errorMessage?: Maybe<Scalars['String']['output']>;
  /** ID of search operation */
  id: Scalars['ID']['output'];
  /** Number of incidents scanned by the search operation */
  incidentsScanned: Scalars['Int']['output'];
  /** Listing of incident selectors and potential applicable incidents */
  results: Array<AiDecisionsSelectorExamples>;
  /** Time search operation was last updated */
  updatedAt: Scalars['EpochMilliseconds']['output'];
};

/** Input type for AttributeExists expression */
export type AiDecisionsAttributeExistsInput = {
  /** Incident selector to be used in comparison. */
  incident: AiDecisionsIncidentObjectInput;
};

/** Input type for CategoricalClustering expression */
export type AiDecisionsCategoricalClusteringInput = {
  /** Threshold for comparison. */
  threshold: Scalars['Float']['input'];
};

/** A decision used to compare incidents and subsequently merge issues. */
export type AiDecisionsDecision = {
  __typename?: 'AiDecisionsDecision';
  /** Internal data associated with this decision. */
  annotations: Array<AiDecisionsAnnotationEntry>;
  /** Length of the window in which incidents are compared. */
  correlationWindowLength?: Maybe<Scalars['Milliseconds']['output']>;
  /** Time decision was created. */
  createdAt: Scalars['EpochMilliseconds']['output'];
  /** Creator of decision. */
  creator?: Maybe<UserReference>;
  /** Expression to use to compare incidents. */
  decisionExpression: Scalars['AiDecisionsRuleExpression']['output'];
  /** Type of decision. */
  decisionType: AiDecisionsDecisionType;
  /** Description of decision. */
  description?: Maybe<Scalars['String']['output']>;
  /** ID of decision. */
  id: Scalars['ID']['output'];
  /** External data associated with this decision. */
  metadata: AiDecisionsRuleMetadata;
  /** Number of correlations within a window required to merge issues. */
  minCorrelationThreshold: Scalars['Int']['output'];
  /** Name of decision. */
  name: Scalars['String']['output'];
  /** Configuration to allow decision to override issue properties. */
  overrideConfiguration?: Maybe<AiDecisionsOverrideConfiguration>;
  /** Creation source of decision. */
  source: AiDecisionsRuleSource;
  /** Current state of decision. */
  state: AiDecisionsDecisionState;
  /** Time decision was last updated. */
  updatedAt: Scalars['EpochMilliseconds']['output'];
};

/** Windowed view of an account's decisions. */
export type AiDecisionsDecisionListing = {
  __typename?: 'AiDecisionsDecisionListing';
  /** Number of decisions in this window. */
  count: Scalars['Int']['output'];
  /** List of decisions in this window. */
  decisions: Array<AiDecisionsDecision>;
  /** Cursor used to fetch next page. */
  nextCursor?: Maybe<Scalars['String']['output']>;
  /** Cursor used to fetch previous page. */
  prevCursor?: Maybe<Scalars['String']['output']>;
};

/** Sorting method for decisions. */
export enum AiDecisionsDecisionSortMethod {
  /** Sort decisions by id */
  Id = 'ID',
  /** Sort decisions by latest_created */
  LatestCreated = 'LATEST_CREATED',
  /** Sort decisions by state_last_modified */
  StateLastModified = 'STATE_LAST_MODIFIED'
}

/** State of decision. */
export enum AiDecisionsDecisionState {
  /** Decision state is disabled */
  Disabled = 'DISABLED',
  /** Decision state is enabled */
  Enabled = 'ENABLED'
}

/** Type of decision */
export enum AiDecisionsDecisionType {
  /** Decision type is explicit */
  Explicit = 'EXPLICIT',
  /** Decision type is global */
  Global = 'GLOBAL',
  /** Decision type is implicit */
  Implicit = 'IMPLICIT'
}

/** Input type for FixedContains expression */
export type AiDecisionsFixedContainsInput = {
  /** Incident selector to be used in comparison. */
  container: AiDecisionsIncidentObjectInput;
  /** Value to be used in comparison. */
  value: Scalars['String']['input'];
};

/** Input type for FixedCosineDistance expression */
export type AiDecisionsFixedCosineDistanceInput = {
  /** Incident selector to be used in comparison. */
  incident: AiDecisionsIncidentObjectInput;
  /** Maximum distance threshold. */
  maxDistance: Scalars['Float']['input'];
  /** Value to be used in comparison. */
  value: Scalars['String']['input'];
};

/** Input type for FixedEndsWith expression */
export type AiDecisionsFixedEndsWithInput = {
  /** Incident selector to be used in comparison. */
  incident: AiDecisionsIncidentObjectInput;
  /** Value to be used in comparison. */
  value: Scalars['String']['input'];
};

/** Input type for FixedEqual expression */
export type AiDecisionsFixedEqualInput = {
  /** Incident selector to be used in comparison. */
  incident: AiDecisionsIncidentObjectInput;
  /** Value to be used in comparison. */
  value: Scalars['String']['input'];
};

/** Input type for FixedFuzzyScore expression */
export type AiDecisionsFixedFuzzyScoreInput = {
  /** Incident selector to be used in comparison. */
  incident: AiDecisionsIncidentObjectInput;
  /** Minimum distance threshold. */
  minDistance: Scalars['Int']['input'];
  /** Value to be used in comparison. */
  value: Scalars['String']['input'];
};

/** Input type for FixedFuzzyWuzzyAdaptiveRatio expression */
export type AiDecisionsFixedFuzzyWuzzyAdaptiveRatioInput = {
  /** Incident selector to be used in comparison. */
  incident: AiDecisionsIncidentObjectInput;
  /** Minimum similarity threshold. */
  minSimilarity: Scalars['Float']['input'];
  /** Value to be used in comparison. */
  value: Scalars['String']['input'];
};

/** Input type for FixedFuzzyWuzzyPartialRatio expression */
export type AiDecisionsFixedFuzzyWuzzyPartialRatioInput = {
  /** Incident selector to be used in comparison. */
  incident: AiDecisionsIncidentObjectInput;
  /** Minimum similarity threshold. */
  minSimilarity: Scalars['Float']['input'];
  /** Value to be used in comparison. */
  value: Scalars['String']['input'];
};

/** Input type for FixedFuzzyWuzzyRatio expression */
export type AiDecisionsFixedFuzzyWuzzyRatioInput = {
  /** Incident selector to be used in comparison. */
  incident: AiDecisionsIncidentObjectInput;
  /** Minimum similarity threshold. */
  minSimilarity: Scalars['Float']['input'];
  /** Value to be used in comparison. */
  value: Scalars['String']['input'];
};

/** Input type for FixedFuzzyWuzzyTokenSetRatio expression */
export type AiDecisionsFixedFuzzyWuzzyTokenSetRatioInput = {
  /** Incident selector to be used in comparison. */
  incident: AiDecisionsIncidentObjectInput;
  /** Minimum similarity threshold. */
  minSimilarity: Scalars['Float']['input'];
  /** Value to be used in comparison. */
  value: Scalars['String']['input'];
};

/** Input type for FixedGreaterThan expression */
export type AiDecisionsFixedGreaterThanInput = {
  /** Value to be used in comparison. */
  compared: Scalars['Float']['input'];
  /** Incident selector to be used in comparison. */
  incident: AiDecisionsIncidentObjectInput;
};

/** Input type for FixedGreaterThanOrEqual expression */
export type AiDecisionsFixedGreaterThanOrEqualInput = {
  /** Value to be used in comparison. */
  compared: Scalars['Float']['input'];
  /** Incident selector to be used in comparison. */
  incident: AiDecisionsIncidentObjectInput;
};

/** Input type for FixedHammingDistance expression */
export type AiDecisionsFixedHammingDistanceInput = {
  /** Incident selector to be used in comparison. */
  incident: AiDecisionsIncidentObjectInput;
  /** Maximum distance threshold. */
  maxDistance: Scalars['Int']['input'];
  /** Value to be used in comparison. */
  value: Scalars['String']['input'];
};

/** Input type for FixedJaccardDistance expression */
export type AiDecisionsFixedJaccardDistanceInput = {
  /** Incident selector to be used in comparison. */
  incident: AiDecisionsIncidentObjectInput;
  /** Maximum distance threshold. */
  maxDistance: Scalars['Float']['input'];
  /** Value to be used in comparison. */
  value: Scalars['String']['input'];
};

/** Input type for FixedJaroWinkler expression */
export type AiDecisionsFixedJaroWinklerInput = {
  /** Incident selector to be used in comparison. */
  incident: AiDecisionsIncidentObjectInput;
  /** Minimum distance threshold. */
  minDistance: Scalars['Float']['input'];
  /** Value to be used in comparison. */
  value: Scalars['String']['input'];
};

/** Input type for FixedLessThan expression */
export type AiDecisionsFixedLessThanInput = {
  /** Value to be used in comparison. */
  compared: Scalars['Float']['input'];
  /** Incident selector to be used in comparison. */
  incident: AiDecisionsIncidentObjectInput;
};

/** Input type for FixedLessThanOrEqual expression */
export type AiDecisionsFixedLessThanOrEqualInput = {
  /** Value to be used in comparison. */
  compared: Scalars['Float']['input'];
  /** Incident selector to be used in comparison. */
  incident: AiDecisionsIncidentObjectInput;
};

/** Input type for FixedLevenshtein expression */
export type AiDecisionsFixedLevenshteinInput = {
  /** Incident selector to be used in comparison. */
  incident: AiDecisionsIncidentObjectInput;
  /** Maximum distance threshold. */
  maxDistance: Scalars['Int']['input'];
  /** Value to be used in comparison. */
  value: Scalars['String']['input'];
};

/** Input type for FixedLongestCommonSubsequenceDistance expression */
export type AiDecisionsFixedLongestCommonSubsequenceDistanceInput = {
  /** Incident selector to be used in comparison. */
  incident: AiDecisionsIncidentObjectInput;
  /** Maximum distance threshold. */
  maxDistance: Scalars['Float']['input'];
  /** Value to be used in comparison. */
  value: Scalars['String']['input'];
};

/** Input type for FixedNumericalEqual expression */
export type AiDecisionsFixedNumericalEqualInput = {
  /** Value to be used in comparison. */
  compared: Scalars['Float']['input'];
  /** Incident selector to be used in comparison. */
  incident: AiDecisionsIncidentObjectInput;
};

/** Input type for FixedRegularExpression expression */
export type AiDecisionsFixedRegularExpressionInput = {
  /** Incident selector to be used in comparison. */
  incident: AiDecisionsIncidentObjectInput;
  /** Value to be used in comparison. */
  value: Scalars['String']['input'];
};

/** Input type for FixedSoundEx expression */
export type AiDecisionsFixedSoundExInput = {
  /** Incident selector to be used in comparison. */
  incident: AiDecisionsIncidentObjectInput;
  /** Minimum distance threshold. */
  minDistance: Scalars['Int']['input'];
  /** Value to be used in comparison. */
  value: Scalars['String']['input'];
};

/** Input type for FixedStartsWith expression */
export type AiDecisionsFixedStartsWithInput = {
  /** Incident selector to be used in comparison. */
  incident: AiDecisionsIncidentObjectInput;
  /** Value to be used in comparison. */
  value: Scalars['String']['input'];
};

/** Represents an attribute of an incident. */
export type AiDecisionsIncidentObjectInput = {
  /** Attribute to process of selected incident. */
  attribute: Scalars['String']['input'];
  /** Incident to select. */
  select: AiDecisionsIncidentSelect;
};

/** Select incident for comparison. */
export enum AiDecisionsIncidentSelect {
  /** Select first incident in comparison. */
  FirstIncident = 'FIRST_INCIDENT',
  /** Select second incident in comparison. */
  SecondIncident = 'SECOND_INCIDENT'
}

/** Priority of issue. */
export enum AiDecisionsIssuePriority {
  /** Issue priority of critical */
  Critical = 'CRITICAL',
  /** Issue priority of high */
  High = 'HIGH',
  /** Issue priority of low */
  Low = 'LOW',
  /** Issue priority of medium */
  Medium = 'MEDIUM'
}

/** Represents a piece of user feedback for a merge. */
export type AiDecisionsMergeFeedback = {
  __typename?: 'AiDecisionsMergeFeedback';
  /** ID of child issue. */
  childIssueId: Scalars['ID']['output'];
  /** Opinion of the current user on this merge. */
  opinion: AiDecisionsOpinion;
  /** ID of parent issue. */
  parentIssueId: Scalars['ID']['output'];
  /** ID of correlation rule. */
  ruleId: Scalars['ID']['output'];
  /** ID of user. */
  userId: Scalars['ID']['output'];
};

/** Input type for Not expression */
export type AiDecisionsNotInput = {
  /** Child expression. */
  child: AiDecisionsRuleExpressionInput;
};

/** Input type for One expression */
export type AiDecisionsOneInput = {
  /** Children expressions. */
  children: Array<AiDecisionsRuleExpressionInput>;
};

/** Result of an operation. */
export type AiDecisionsOperationResult = {
  __typename?: 'AiDecisionsOperationResult';
  /** Status of the operation. */
  result: AiDecisionsResultType;
};

/** Types of opinions users can leave as feedback. */
export enum AiDecisionsOpinion {
  /** A dislike opinion */
  Dislike = 'DISLIKE',
  /** A like opinion */
  Like = 'LIKE'
}

/** Represents a number of opinions. */
export type AiDecisionsOpinionEntry = {
  __typename?: 'AiDecisionsOpinionEntry';
  /** Number of this type of opinion. */
  count: Scalars['Int']['output'];
  /** Type of opinion. */
  opinion: AiDecisionsOpinion;
};

/** Input type for Or expression */
export type AiDecisionsOrInput = {
  /** Left child expression. */
  left: AiDecisionsRuleExpressionInput;
  /** Right child expression. */
  right: AiDecisionsRuleExpressionInput;
};

/** Configuration for overriding properties of issues created by merges. */
export type AiDecisionsOverrideConfiguration = {
  __typename?: 'AiDecisionsOverrideConfiguration';
  /** Description merged issues should take. */
  description?: Maybe<Scalars['String']['output']>;
  /** Priority merged issues should take. */
  priority?: Maybe<AiDecisionsIssuePriority>;
  /** Title merged issues should take. */
  title?: Maybe<Scalars['String']['output']>;
};

/** Configuration for overriding properties of issues created by merges. */
export type AiDecisionsOverrideConfigurationInput = {
  /** Description merged issues should take. */
  description?: InputMaybe<Scalars['String']['input']>;
  /** Priority merged issues should take. */
  priority?: InputMaybe<AiDecisionsIssuePriority>;
  /** Title merged issues should take. */
  title?: InputMaybe<Scalars['String']['input']>;
};

/** Input type for RelativeCommonPrefix expression */
export type AiDecisionsRelativeCommonPrefixInput = {
  /** Value to be used in comparison. */
  value: Scalars['String']['input'];
};

/** Input type for RelativeContains expression */
export type AiDecisionsRelativeContainsInput = {
  /** Incident selector to be used in comparison. */
  contained: AiDecisionsIncidentObjectInput;
  /** Incident selector to be used in comparison. */
  container: AiDecisionsIncidentObjectInput;
};

/** Input type for RelativeCosineDistance expression */
export type AiDecisionsRelativeCosineDistanceInput = {
  /** Left operand of comparison. */
  left: AiDecisionsIncidentObjectInput;
  /** Maximum distance threshold. */
  maxDistance: Scalars['Float']['input'];
  /** Right operand of comparison. */
  right: AiDecisionsIncidentObjectInput;
};

/** Input type for RelativeEndsWith expression */
export type AiDecisionsRelativeEndsWithInput = {
  /** Incident selector to be used in comparison. */
  contained: AiDecisionsIncidentObjectInput;
  /** Incident selector to be used in comparison. */
  container: AiDecisionsIncidentObjectInput;
};

/** Input type for RelativeEqual expression */
export type AiDecisionsRelativeEqualInput = {
  /** Left operand of comparison. */
  left: AiDecisionsIncidentObjectInput;
  /** Right operand of comparison. */
  right: AiDecisionsIncidentObjectInput;
};

/** Input type for RelativeFuzzyScore expression */
export type AiDecisionsRelativeFuzzyScoreInput = {
  /** Left operand of comparison. */
  left: AiDecisionsIncidentObjectInput;
  /** Minimum distance threshold. */
  minDistance: Scalars['Int']['input'];
  /** Right operand of comparison. */
  right: AiDecisionsIncidentObjectInput;
};

/** Input type for RelativeFuzzyWuzzyAdaptiveRatio expression */
export type AiDecisionsRelativeFuzzyWuzzyAdaptiveRatioInput = {
  /** Left operand of comparison. */
  left: AiDecisionsIncidentObjectInput;
  /** Minimum similarity threshold. */
  minSimilarity: Scalars['Float']['input'];
  /** Right operand of comparison. */
  right: AiDecisionsIncidentObjectInput;
};

/** Input type for RelativeFuzzyWuzzyPartialRatio expression */
export type AiDecisionsRelativeFuzzyWuzzyPartialRatioInput = {
  /** Left operand of comparison. */
  left: AiDecisionsIncidentObjectInput;
  /** Minimum similarity threshold. */
  minSimilarity: Scalars['Float']['input'];
  /** Right operand of comparison. */
  right: AiDecisionsIncidentObjectInput;
};

/** Input type for RelativeFuzzyWuzzyRatio expression */
export type AiDecisionsRelativeFuzzyWuzzyRatioInput = {
  /** Left operand of comparison. */
  left: AiDecisionsIncidentObjectInput;
  /** Minimum similarity threshold. */
  minSimilarity: Scalars['Float']['input'];
  /** Right operand of comparison. */
  right: AiDecisionsIncidentObjectInput;
};

/** Input type for RelativeFuzzyWuzzyTokenSetRatio expression */
export type AiDecisionsRelativeFuzzyWuzzyTokenSetRatioInput = {
  /** Left operand of comparison. */
  left: AiDecisionsIncidentObjectInput;
  /** Minimum similarity threshold. */
  minSimilarity: Scalars['Float']['input'];
  /** Right operand of comparison. */
  right: AiDecisionsIncidentObjectInput;
};

/** Input type for RelativeGreaterThan expression */
export type AiDecisionsRelativeGreaterThanInput = {
  /** Left operand of comparison. */
  left: AiDecisionsIncidentObjectInput;
  /** Right operand of comparison. */
  right: AiDecisionsIncidentObjectInput;
};

/** Input type for RelativeGreaterThanOrEqual expression */
export type AiDecisionsRelativeGreaterThanOrEqualInput = {
  /** Left operand of comparison. */
  left: AiDecisionsIncidentObjectInput;
  /** Right operand of comparison. */
  right: AiDecisionsIncidentObjectInput;
};

/** Input type for RelativeHammingDistance expression */
export type AiDecisionsRelativeHammingDistanceInput = {
  /** Left operand of comparison. */
  left: AiDecisionsIncidentObjectInput;
  /** Maximum distance threshold. */
  maxDistance: Scalars['Int']['input'];
  /** Right operand of comparison. */
  right: AiDecisionsIncidentObjectInput;
};

/** Input type for RelativeJaccardDistance expression */
export type AiDecisionsRelativeJaccardDistanceInput = {
  /** Left operand of comparison. */
  left: AiDecisionsIncidentObjectInput;
  /** Maximum distance threshold. */
  maxDistance: Scalars['Float']['input'];
  /** Right operand of comparison. */
  right: AiDecisionsIncidentObjectInput;
};

/** Input type for RelativeJaroWinkler expression */
export type AiDecisionsRelativeJaroWinklerInput = {
  /** Left operand of comparison. */
  left: AiDecisionsIncidentObjectInput;
  /** Minimum distance threshold. */
  minDistance: Scalars['Float']['input'];
  /** Right operand of comparison. */
  right: AiDecisionsIncidentObjectInput;
};

/** Input type for RelativeLessThan expression */
export type AiDecisionsRelativeLessThanInput = {
  /** Left operand of comparison. */
  left: AiDecisionsIncidentObjectInput;
  /** Right operand of comparison. */
  right: AiDecisionsIncidentObjectInput;
};

/** Input type for RelativeLessThanOrEqual expression */
export type AiDecisionsRelativeLessThanOrEqualInput = {
  /** Left operand of comparison. */
  left: AiDecisionsIncidentObjectInput;
  /** Right operand of comparison. */
  right: AiDecisionsIncidentObjectInput;
};

/** Input type for RelativeLevenshtein expression */
export type AiDecisionsRelativeLevenshteinInput = {
  /** Left operand of comparison. */
  left: AiDecisionsIncidentObjectInput;
  /** Maximum distance threshold. */
  maxDistance: Scalars['Int']['input'];
  /** Right operand of comparison. */
  right: AiDecisionsIncidentObjectInput;
};

/** Input type for RelativeLongestCommonSubsequenceDistance expression */
export type AiDecisionsRelativeLongestCommonSubsequenceDistanceInput = {
  /** Left operand of comparison. */
  left: AiDecisionsIncidentObjectInput;
  /** Maximum distance threshold. */
  maxDistance: Scalars['Float']['input'];
  /** Right operand of comparison. */
  right: AiDecisionsIncidentObjectInput;
};

/** Input type for RelativeNumericalEqual expression */
export type AiDecisionsRelativeNumericalEqualInput = {
  /** Left operand of comparison. */
  left: AiDecisionsIncidentObjectInput;
  /** Right operand of comparison. */
  right: AiDecisionsIncidentObjectInput;
};

/** Input type for RelativeRegularExpression expression */
export type AiDecisionsRelativeRegularExpressionInput = {
  /** Left operand of comparison. */
  left: AiDecisionsIncidentObjectInput;
  /** Right operand of comparison. */
  right: AiDecisionsIncidentObjectInput;
  /** Value to be used in comparison. */
  value: Scalars['String']['input'];
};

/** Input type for RelativeSoundEx expression */
export type AiDecisionsRelativeSoundExInput = {
  /** Left operand of comparison. */
  left: AiDecisionsIncidentObjectInput;
  /** Minimum distance threshold. */
  minDistance: Scalars['Int']['input'];
  /** Right operand of comparison. */
  right: AiDecisionsIncidentObjectInput;
};

/** Input type for RelativeStartsWith expression */
export type AiDecisionsRelativeStartsWithInput = {
  /** Incident selector to be used in comparison. */
  contained: AiDecisionsIncidentObjectInput;
  /** Incident selector to be used in comparison. */
  container: AiDecisionsIncidentObjectInput;
};

/** Input type for RelativeTopologicallyDependent expression */
export type AiDecisionsRelativeTopologicallyDependentInput = {
  /** From Vertex Id. */
  from: Array<Scalars['ID']['input']>;
  /** Graph Id. */
  graphId?: InputMaybe<Scalars['ID']['input']>;
  /** Maximum number of hops */
  maxHops?: InputMaybe<Scalars['Int']['input']>;
  /** Required Vertex Attributes */
  requiredAttributes: Array<Scalars['String']['input']>;
  /** Required Vertex Classes */
  requiredClasses: Array<AiDecisionsVertexClass>;
  /** To Vertex Id. */
  to: Array<Scalars['ID']['input']>;
};

/** Status of an operation. */
export enum AiDecisionsResultType {
  /** Failed operation */
  Failure = 'FAILURE',
  /** Successful operation */
  Success = 'SUCCESS'
}

/** A correlation rule used to compare incidents and subsequently merge issues. */
export type AiDecisionsRule = {
  __typename?: 'AiDecisionsRule';
  /** Internal data associated with this rule. */
  annotations: Array<AiDecisionsAnnotationEntry>;
  /** Length of the window in which incidents are compared. */
  correlationWindowLength?: Maybe<Scalars['Milliseconds']['output']>;
  /** Time rule was created. */
  createdAt: Scalars['EpochMilliseconds']['output'];
  /** Creator of rule. */
  creator?: Maybe<UserReference>;
  /** Description of rule. */
  description?: Maybe<Scalars['String']['output']>;
  /** ID of rule. */
  id: Scalars['ID']['output'];
  /** External data associated with this rule. */
  metadata: AiDecisionsRuleMetadata;
  /** Number of correlations within a window required to merge issues. */
  minCorrelationThreshold: Scalars['Int']['output'];
  /** Name of rule. */
  name: Scalars['String']['output'];
  /** Configuration to allow rule to override issue properties. */
  overrideConfiguration?: Maybe<AiDecisionsOverrideConfiguration>;
  /** Expression to use to compare incidents. */
  ruleExpression: Scalars['AiDecisionsRuleExpression']['output'];
  /** Type of rule. */
  ruleType: AiDecisionsRuleType;
  /** Creation source of rule. */
  source: AiDecisionsRuleSource;
  /** Current state of rule. */
  state: AiDecisionsRuleState;
  /** Time rule was last updated. */
  updatedAt: Scalars['EpochMilliseconds']['output'];
};

/** Blueprint for rule creation. */
export type AiDecisionsRuleBlueprint = {
  /** Length of the window in which incidents are compared. */
  correlationWindowLength?: InputMaybe<Scalars['Milliseconds']['input']>;
  /** Creator of rule. */
  creator?: InputMaybe<Scalars['String']['input']>;
  /** Description of rule. */
  description?: InputMaybe<Scalars['String']['input']>;
  /** Number of correlations within a window required to merge issues. */
  minCorrelationThreshold?: InputMaybe<Scalars['Int']['input']>;
  /** Name of rule. */
  name: Scalars['String']['input'];
  /** Configuration to allow rule to override issue properties. */
  overrideConfiguration?: InputMaybe<AiDecisionsOverrideConfigurationInput>;
  /** Expression to use to compare incidents. */
  ruleExpression: AiDecisionsRuleExpressionInput;
  /** Type of rule. */
  ruleType: AiDecisionsRuleType;
  /** Creation source of rule. */
  source: AiDecisionsRuleSource;
};

/** Rule expression input */
export type AiDecisionsRuleExpressionInput = {
  /** Input type for All expression */
  all?: InputMaybe<AiDecisionsAllInput>;
  /** Input type for And expression */
  and?: InputMaybe<AiDecisionsAndInput>;
  /** Input type for AttributeExists expression */
  attributeExists?: InputMaybe<AiDecisionsAttributeExistsInput>;
  /** Input type for CategoricalClustering expression */
  categoricalClustering?: InputMaybe<AiDecisionsCategoricalClusteringInput>;
  /** Input type for FixedContains expression */
  fixedContains?: InputMaybe<AiDecisionsFixedContainsInput>;
  /** Input type for FixedCosineDistance expression */
  fixedCosineDistance?: InputMaybe<AiDecisionsFixedCosineDistanceInput>;
  /** Input type for FixedEndsWith expression */
  fixedEndsWith?: InputMaybe<AiDecisionsFixedEndsWithInput>;
  /** Input type for FixedEqual expression */
  fixedEqual?: InputMaybe<AiDecisionsFixedEqualInput>;
  /** Input type for FixedFuzzyScore expression */
  fixedFuzzyScore?: InputMaybe<AiDecisionsFixedFuzzyScoreInput>;
  /** Input type for FixedFuzzyWuzzyAdaptiveRatio expression */
  fixedFuzzyWuzzyAdaptiveRatio?: InputMaybe<AiDecisionsFixedFuzzyWuzzyAdaptiveRatioInput>;
  /** Input type for FixedFuzzyWuzzyPartialRatio expression */
  fixedFuzzyWuzzyPartialRatio?: InputMaybe<AiDecisionsFixedFuzzyWuzzyPartialRatioInput>;
  /** Input type for FixedFuzzyWuzzyRatio expression */
  fixedFuzzyWuzzyRatio?: InputMaybe<AiDecisionsFixedFuzzyWuzzyRatioInput>;
  /** Input type for FixedFuzzyWuzzyTokenSetRatio expression */
  fixedFuzzyWuzzyTokenSetRatio?: InputMaybe<AiDecisionsFixedFuzzyWuzzyTokenSetRatioInput>;
  /** Input type for FixedGreaterThan expression */
  fixedGreaterThan?: InputMaybe<AiDecisionsFixedGreaterThanInput>;
  /** Input type for FixedGreaterThanOrEqual expression */
  fixedGreaterThanOrEqual?: InputMaybe<AiDecisionsFixedGreaterThanOrEqualInput>;
  /** Input type for FixedHammingDistance expression */
  fixedHammingDistance?: InputMaybe<AiDecisionsFixedHammingDistanceInput>;
  /** Input type for FixedJaccardDistance expression */
  fixedJaccardDistance?: InputMaybe<AiDecisionsFixedJaccardDistanceInput>;
  /** Input type for FixedJaroWinkler expression */
  fixedJaroWinkler?: InputMaybe<AiDecisionsFixedJaroWinklerInput>;
  /** Input type for FixedLessThan expression */
  fixedLessThan?: InputMaybe<AiDecisionsFixedLessThanInput>;
  /** Input type for FixedLessThanOrEqual expression */
  fixedLessThanOrEqual?: InputMaybe<AiDecisionsFixedLessThanOrEqualInput>;
  /** Input type for FixedLevenshtein expression */
  fixedLevenshtein?: InputMaybe<AiDecisionsFixedLevenshteinInput>;
  /** Input type for FixedLongestCommonSubsequenceDistance expression */
  fixedLongestCommonSubsequenceDistance?: InputMaybe<AiDecisionsFixedLongestCommonSubsequenceDistanceInput>;
  /** Input type for FixedNumericalEqual expression */
  fixedNumericalEqual?: InputMaybe<AiDecisionsFixedNumericalEqualInput>;
  /** Input type for FixedRegularExpression expression */
  fixedRegularExpression?: InputMaybe<AiDecisionsFixedRegularExpressionInput>;
  /** Input type for FixedSoundEx expression */
  fixedSoundEx?: InputMaybe<AiDecisionsFixedSoundExInput>;
  /** Input type for FixedStartsWith expression */
  fixedStartsWith?: InputMaybe<AiDecisionsFixedStartsWithInput>;
  /** Input type for Not expression */
  not?: InputMaybe<AiDecisionsNotInput>;
  /** Input type for One expression */
  one?: InputMaybe<AiDecisionsOneInput>;
  /** Input type for Or expression */
  or?: InputMaybe<AiDecisionsOrInput>;
  /** Input type for RelativeCommonPrefix expression */
  relativeCommonPrefix?: InputMaybe<AiDecisionsRelativeCommonPrefixInput>;
  /** Input type for RelativeContains expression */
  relativeContains?: InputMaybe<AiDecisionsRelativeContainsInput>;
  /** Input type for RelativeCosineDistance expression */
  relativeCosineDistance?: InputMaybe<AiDecisionsRelativeCosineDistanceInput>;
  /** Input type for RelativeEndsWith expression */
  relativeEndsWith?: InputMaybe<AiDecisionsRelativeEndsWithInput>;
  /** Input type for RelativeEqual expression */
  relativeEqual?: InputMaybe<AiDecisionsRelativeEqualInput>;
  /** Input type for RelativeFuzzyScore expression */
  relativeFuzzyScore?: InputMaybe<AiDecisionsRelativeFuzzyScoreInput>;
  /** Input type for RelativeFuzzyWuzzyAdaptiveRatio expression */
  relativeFuzzyWuzzyAdaptiveRatio?: InputMaybe<AiDecisionsRelativeFuzzyWuzzyAdaptiveRatioInput>;
  /** Input type for RelativeFuzzyWuzzyPartialRatio expression */
  relativeFuzzyWuzzyPartialRatio?: InputMaybe<AiDecisionsRelativeFuzzyWuzzyPartialRatioInput>;
  /** Input type for RelativeFuzzyWuzzyRatio expression */
  relativeFuzzyWuzzyRatio?: InputMaybe<AiDecisionsRelativeFuzzyWuzzyRatioInput>;
  /** Input type for RelativeFuzzyWuzzyTokenSetRatio expression */
  relativeFuzzyWuzzyTokenSetRatio?: InputMaybe<AiDecisionsRelativeFuzzyWuzzyTokenSetRatioInput>;
  /** Input type for RelativeGreaterThan expression */
  relativeGreaterThan?: InputMaybe<AiDecisionsRelativeGreaterThanInput>;
  /** Input type for RelativeGreaterThanOrEqual expression */
  relativeGreaterThanOrEqual?: InputMaybe<AiDecisionsRelativeGreaterThanOrEqualInput>;
  /** Input type for RelativeHammingDistance expression */
  relativeHammingDistance?: InputMaybe<AiDecisionsRelativeHammingDistanceInput>;
  /** Input type for RelativeJaccardDistance expression */
  relativeJaccardDistance?: InputMaybe<AiDecisionsRelativeJaccardDistanceInput>;
  /** Input type for RelativeJaroWinkler expression */
  relativeJaroWinkler?: InputMaybe<AiDecisionsRelativeJaroWinklerInput>;
  /** Input type for RelativeLessThan expression */
  relativeLessThan?: InputMaybe<AiDecisionsRelativeLessThanInput>;
  /** Input type for RelativeLessThanOrEqual expression */
  relativeLessThanOrEqual?: InputMaybe<AiDecisionsRelativeLessThanOrEqualInput>;
  /** Input type for RelativeLevenshtein expression */
  relativeLevenshtein?: InputMaybe<AiDecisionsRelativeLevenshteinInput>;
  /** Input type for RelativeLongestCommonSubsequenceDistance expression */
  relativeLongestCommonSubsequenceDistance?: InputMaybe<AiDecisionsRelativeLongestCommonSubsequenceDistanceInput>;
  /** Input type for RelativeNumericalEqual expression */
  relativeNumericalEqual?: InputMaybe<AiDecisionsRelativeNumericalEqualInput>;
  /** Input type for RelativeRegularExpression expression */
  relativeRegularExpression?: InputMaybe<AiDecisionsRelativeRegularExpressionInput>;
  /** Input type for RelativeSoundEx expression */
  relativeSoundEx?: InputMaybe<AiDecisionsRelativeSoundExInput>;
  /** Input type for RelativeStartsWith expression */
  relativeStartsWith?: InputMaybe<AiDecisionsRelativeStartsWithInput>;
  /** Input type for RelativeTopologicallyDependent expression */
  relativeTopologicallyDependent?: InputMaybe<AiDecisionsRelativeTopologicallyDependentInput>;
  /** Input type for WholeCosineDistance expression */
  wholeCosineDistance?: InputMaybe<AiDecisionsWholeCosineDistanceInput>;
  /** Input type for WholeJaccardSimilarity expression */
  wholeJaccardSimilarity?: InputMaybe<AiDecisionsWholeJaccardSimilarityInput>;
};

/** Metadata about a decision. */
export type AiDecisionsRuleMetadata = {
  __typename?: 'AiDecisionsRuleMetadata';
  /** Summary of user opinions for merges by this decision */
  mergeOpinionCount: Array<AiDecisionsOpinionEntry>;
};

/** Possible creation sources for rules. */
export enum AiDecisionsRuleSource {
  /** Created by ADMIN */
  Admin = 'ADMIN',
  /** Created by GENERATED */
  Generated = 'GENERATED',
  /** Created by SYSTEM */
  System = 'SYSTEM',
  /** Created by USER */
  User = 'USER'
}

/** State of rule. */
export enum AiDecisionsRuleState {
  /** Rule state is disabled */
  Disabled = 'DISABLED',
  /** Rule state is enabled */
  Enabled = 'ENABLED'
}

/** Type of rule */
export enum AiDecisionsRuleType {
  /** Rule type is explicit */
  Explicit = 'EXPLICIT',
  /** Rule type is global */
  Global = 'GLOBAL',
  /** Rule type is implicit */
  Implicit = 'IMPLICIT'
}

/** Blueprint for a search operation */
export type AiDecisionsSearchBlueprint = {
  /** Expression to use to compare incidents. */
  expression: AiDecisionsRuleExpressionInput;
  /** Maximum number of incidents to query for each available incident selector */
  limit?: InputMaybe<Scalars['Int']['input']>;
  /** Duration to consider resources for. */
  retentionWindowLength?: InputMaybe<Scalars['Milliseconds']['input']>;
};

/** Number of incidents applicable for a selector */
export type AiDecisionsSelectorApplicability = {
  __typename?: 'AiDecisionsSelectorApplicability';
  /** Applicable number of incidents */
  count: Scalars['Int']['output'];
  /** Incident selector */
  select: AiDecisionsIncidentSelect;
};

/** Example subset of incidents applicable for a selector */
export type AiDecisionsSelectorExamples = {
  __typename?: 'AiDecisionsSelectorExamples';
  /** IDs of incidents that can be applied to this selector */
  incidents: Array<Scalars['ID']['output']>;
  /** Incident selector */
  select: AiDecisionsIncidentSelect;
};

/** Simulation of a rule expression for a certain period of time. */
export type AiDecisionsSimulation = {
  __typename?: 'AiDecisionsSimulation';
  /** Example potential incident correlations. */
  candidateIncidents: Array<Array<Scalars['ID']['output']>>;
  /** Time simulation completed. */
  completedAt?: Maybe<Scalars['EpochMilliseconds']['output']>;
  /** Time simulation was created. */
  createdAt: Scalars['EpochMilliseconds']['output'];
  /** Error message if simulation failed. */
  errorMessage?: Maybe<Scalars['String']['output']>;
  /** ID of simulation. */
  id: Scalars['ID']['output'];
  /** Applicability of ingested incidents to the expression. */
  incidentsApplicable: Array<AiDecisionsSelectorApplicability>;
  /** Number of incidents correlated by simulation. */
  incidentsCorrelated: Scalars['Int']['output'];
  /** Number of incidents ingested by simulation. */
  incidentsIngested: Scalars['Int']['output'];
  /** Number of applicable incidents processed by simulation. */
  incidentsProcessed: Scalars['Int']['output'];
  /** Percentage of current progress of simulation. */
  progress: Scalars['Float']['output'];
  /** Time simulation was last updated. */
  updatedAt: Scalars['EpochMilliseconds']['output'];
};

/** Blueprint for simulation creation. */
export type AiDecisionsSimulationBlueprint = {
  /** Length of the window in which incidents are compared. */
  correlationWindowLength?: InputMaybe<Scalars['Milliseconds']['input']>;
  /** Expression to use to compare incidents. */
  expression: AiDecisionsRuleExpressionInput;
  /** Number of correlated incidents within window required to merge issues. */
  minCorrelationThreshold?: InputMaybe<Scalars['Int']['input']>;
  /** Duration to consider resources for. */
  retentionWindowLength?: InputMaybe<Scalars['Milliseconds']['input']>;
};

/** A suggested correlation rule. */
export type AiDecisionsSuggestion = {
  __typename?: 'AiDecisionsSuggestion';
  /** Length of the window in which incidents are compared. */
  correlationWindowLength?: Maybe<Scalars['Milliseconds']['output']>;
  /** Time suggestion was created. */
  createdAt: Scalars['EpochMilliseconds']['output'];
  /** Description of suggestion. */
  description?: Maybe<Scalars['String']['output']>;
  /** External hash of suggestion. */
  hash: Scalars['String']['output'];
  /** ID of suggestion. */
  id: Scalars['ID']['output'];
  /** Number of correlations within a window required to merge issues. */
  minCorrelationThreshold: Scalars['Int']['output'];
  /** Name of suggestion. */
  name: Scalars['String']['output'];
  /** Configuration to allow rule to override issue properties. */
  overrideConfiguration?: Maybe<AiDecisionsOverrideConfiguration>;
  /** Expression to use to compare incidents. */
  ruleExpression: Scalars['AiDecisionsRuleExpression']['output'];
  /** Acceptance state of suggestion. */
  state: AiDecisionsSuggestionState;
  /** Service/user that created this suggestion. */
  suggester: Scalars['String']['output'];
  /** External support for suggestion. */
  support?: Maybe<Scalars['String']['output']>;
};

/** Blueprint for suggestion creation. */
export type AiDecisionsSuggestionBlueprint = {
  /** Length of the window in which incidents are compared. */
  correlationWindowLength?: InputMaybe<Scalars['Milliseconds']['input']>;
  /** Description of suggestion. */
  description?: InputMaybe<Scalars['String']['input']>;
  /** Hash of suggestion. */
  hash: Scalars['String']['input'];
  /** Number of correlations within a window required to merge issues. */
  minCorrelationThreshold?: InputMaybe<Scalars['Int']['input']>;
  /** Name of suggestion. */
  name: Scalars['String']['input'];
  /** Configuration to allow rule to override issue properties. */
  overrideConfiguration?: InputMaybe<AiDecisionsOverrideConfigurationInput>;
  /** Expression to use to compare incidents. */
  ruleExpression: AiDecisionsRuleExpressionInput;
  /** Service/user that created this suggestion. */
  suggester: Scalars['String']['input'];
  /** Support for suggestion. */
  support?: InputMaybe<Scalars['String']['input']>;
};

/** State of suggestion */
export enum AiDecisionsSuggestionState {
  /** Suggestion is accepted */
  Accepted = 'ACCEPTED',
  /** Suggestion is declined */
  Declined = 'DECLINED',
  /** Suggestion is postponed */
  Postponed = 'POSTPONED',
  /** Suggestion is undecided */
  Undecided = 'UNDECIDED'
}

/** Class of vertex. */
export enum AiDecisionsVertexClass {
  /** Vertex class is application */
  Application = 'APPLICATION',
  /** Vertex class is cloudservice */
  Cloudservice = 'CLOUDSERVICE',
  /** Vertex class is cluster */
  Cluster = 'CLUSTER',
  /** Vertex class is datastore */
  Datastore = 'DATASTORE',
  /** Vertex class is host */
  Host = 'HOST',
  /** Vertex class is team */
  Team = 'TEAM'
}

/** Input type for WholeCosineDistance expression */
export type AiDecisionsWholeCosineDistanceInput = {
  /** Maximum distance threshold. */
  maxDistance: Scalars['Float']['input'];
};

/** Input type for WholeJaccardSimilarity expression */
export type AiDecisionsWholeJaccardSimilarityInput = {
  /** Threshold for comparison. */
  threshold: Scalars['Float']['input'];
};

export type AiIssuesAccountStitchedFields = {
  __typename?: 'AiIssuesAccountStitchedFields';
  /** Fetch config for env */
  configByEnvironment?: Maybe<AiIssuesConfigurationByEnvironment>;
  /** Fetch incidents latest data by supplied filter */
  incidents?: Maybe<AiIssuesIncidentData>;
  /** Fetch incidents events data by supplied filter */
  incidentsEvents?: Maybe<AiIssuesIncidentData>;
  /** Fetch issues latest data by supplied filter */
  issues?: Maybe<AiIssuesIssueData>;
  /** Fetch issues events data by supplied filter */
  issuesEvents?: Maybe<AiIssuesIssueData>;
};


export type AiIssuesAccountStitchedFieldsIncidentsArgs = {
  cursor?: InputMaybe<Scalars['String']['input']>;
  filter?: InputMaybe<AiIssuesFilterIncidents>;
  timeWindow?: InputMaybe<TimeWindowInput>;
};


export type AiIssuesAccountStitchedFieldsIncidentsEventsArgs = {
  cursor?: InputMaybe<Scalars['String']['input']>;
  filter?: InputMaybe<AiIssuesFilterIncidentsEvents>;
  timeWindow?: InputMaybe<TimeWindowInput>;
};


export type AiIssuesAccountStitchedFieldsIssuesArgs = {
  cursor?: InputMaybe<Scalars['String']['input']>;
  filter?: InputMaybe<AiIssuesFilterIssues>;
  timeWindow?: InputMaybe<TimeWindowInput>;
};


export type AiIssuesAccountStitchedFieldsIssuesEventsArgs = {
  cursor?: InputMaybe<Scalars['String']['input']>;
  filter?: InputMaybe<AiIssuesFilterIssuesEvents>;
  timeWindow?: InputMaybe<TimeWindowInput>;
};

/** Anomaly incident */
export type AiIssuesAnomalyIncident = AiIssuesIIncident & {
  __typename?: 'AiIssuesAnomalyIncident';
  /** account */
  account?: Maybe<AccountReference>;
  /** An account id this incident is stored in */
  accountIds: Scalars['String']['output'];
  /** The anomaly id */
  anomalyId?: Maybe<Scalars['String']['output']>;
  /** The time the incident was closed */
  closedAt?: Maybe<Scalars['EpochMilliseconds']['output']>;
  /** The time the incident was created */
  createdAt: Scalars['EpochMilliseconds']['output'];
  /** The description provided through API */
  description: Array<Scalars['String']['output']>;
  /** A list of unique entity identifiers */
  entityGuids?: Maybe<Scalars['EntityGuid']['output']>;
  /** A list of entity names */
  entityNames?: Maybe<Scalars['String']['output']>;
  /** A list of entity types */
  entityTypes?: Maybe<Scalars['String']['output']>;
  /**
   * See our documentation to learn about environments
   * @deprecated Use account
   */
  environmentId: Scalars['Int']['output'];
  /** Incident identifier */
  incidentId: Scalars['ID']['output'];
  /** Incident priority */
  priority: AiIssuesPriority;
  /** Incident state */
  state: AiIssuesIncidentState;
  /** Incident event timestamp */
  timestamp: Scalars['EpochMilliseconds']['output'];
  /** The description the user gave the condition if provided. Otherwise the incident description */
  title: Scalars['String']['output'];
  /** The time the incident was last updated */
  updatedAt: Scalars['EpochMilliseconds']['output'];
};

/** Configuration per environment */
export type AiIssuesConfigurationByEnvironment = {
  __typename?: 'AiIssuesConfigurationByEnvironment';
  /** Configuration */
  config?: Maybe<AiIssuesEnvironmentConfiguration>;
};

/** Response for configuration override */
export type AiIssuesConfigurationOverrideResponse = {
  __typename?: 'AiIssuesConfigurationOverrideResponse';
  /** Updated configuration */
  config?: Maybe<AiIssuesEnvironmentConfiguration>;
  /** Error, if any */
  error?: Maybe<Scalars['String']['output']>;
};

/** Issue correlation status */
export enum AiIssuesCorrelationStatus {
  /** When issue is completely merged, all events routed to 'internal' issue */
  Merged = 'MERGED',
  /** Issue is not in an active merge process */
  Open = 'OPEN'
}

/** Environment configuration object */
export type AiIssuesEnvironmentConfiguration = {
  __typename?: 'AiIssuesEnvironmentConfiguration';
  /** Flapping interval in seconds */
  flappingInterval?: Maybe<Scalars['Seconds']['output']>;
  /** Grace periods per priority */
  gracePeriod?: Maybe<Array<AiIssuesGracePeriodConfig>>;
  /** Inactive period in seconds */
  inactivePeriod?: Maybe<Scalars['Seconds']['output']>;
  /** Incident timeout in seconds */
  incidentTimeout?: Maybe<Scalars['Seconds']['output']>;
  /** Issue TTL in seconds */
  issueTtl?: Maybe<Scalars['Seconds']['output']>;
  /** Max incidents in the issue */
  maxIssueSize?: Maybe<Scalars['Int']['output']>;
};

/** Filter incidents */
export type AiIssuesFilterIncidents = {
  /** entityGuids */
  entityGuids?: InputMaybe<Array<Scalars['EntityGuid']['input']>>;
  /** entityTypes */
  entityTypes?: InputMaybe<Array<Scalars['String']['input']>>;
  /** ids */
  ids?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** priority */
  priority?: InputMaybe<Array<Scalars['String']['input']>>;
  /** states */
  states?: InputMaybe<Array<AiIssuesIncidentState>>;
};

/** Filter incidents events */
export type AiIssuesFilterIncidentsEvents = {
  /** entityGuids */
  entityGuids?: InputMaybe<Array<Scalars['EntityGuid']['input']>>;
  /** entityTypes */
  entityTypes?: InputMaybe<Array<Scalars['String']['input']>>;
  /** ids */
  ids?: InputMaybe<Array<Scalars['ID']['input']>>;
};

/** Filter issues */
export type AiIssuesFilterIssues = {
  /** A list of condition ids associated with an issue. */
  conditionIds?: InputMaybe<Array<Scalars['Int']['input']>>;
  /** A string to filter results that includes this string on key issue attributes (examples: condition, entity, ...). Case sensitive. */
  contains?: InputMaybe<Scalars['String']['input']>;
  /** Entity guids associated with an issue. */
  entityGuids?: InputMaybe<Array<Scalars['EntityGuid']['input']>>;
  /** Entity types associated with an issue. */
  entityTypes?: InputMaybe<Array<Scalars['String']['input']>>;
  /** A list of unique issue identifiers. */
  ids?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** For acknowledged issues */
  isAcknowledged?: InputMaybe<Scalars['Boolean']['input']>;
  /** For correlated issues */
  isCorrelated?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filtering for muting states */
  mutingStates?: InputMaybe<Array<AiIssuesIssueMutingState>>;
  /** A list of policy ids associated with an issue. */
  policyIds?: InputMaybe<Array<Scalars['Int']['input']>>;
  /** A list of priorities associated with an issue. Can be: 'CRITICAL', 'HIGH', 'MEDIUM' or 'LOW' */
  priority?: InputMaybe<Array<Scalars['String']['input']>>;
  /**
   * A list of sources associated with an issue.
   * Sources can be:
   * - 'newrelic' (indicating data originating from the NewRelic platform)
   * - 'rest' (indicating data originating from external sources via api)
   */
  sources?: InputMaybe<Array<Scalars['String']['input']>>;
  /** A list of states associated with an issue. */
  states?: InputMaybe<Array<AiIssuesIssueState>>;
};

/** Filter issues events */
export type AiIssuesFilterIssuesEvents = {
  /** entityGuids */
  entityGuids?: InputMaybe<Array<Scalars['EntityGuid']['input']>>;
  /** entityTypes */
  entityTypes?: InputMaybe<Array<Scalars['String']['input']>>;
  /** ids */
  ids?: InputMaybe<Array<Scalars['ID']['input']>>;
};

/** Grace period config per priority */
export type AiIssuesGracePeriodConfig = {
  __typename?: 'AiIssuesGracePeriodConfig';
  /** Grace period for notification in seconds per priority */
  period: Scalars['Seconds']['output'];
  /** Priority for which grace period is defined (MEDIUM/LOW/HIGH/CRITICAL) */
  priority: AiIssuesPriority;
};

/** Grace periods for issue to be activated per priority */
export type AiIssuesGracePeriodConfigurationInput = {
  /** critical */
  critical: Scalars['Seconds']['input'];
  /** high */
  high: Scalars['Seconds']['input'];
  /** low */
  low: Scalars['Seconds']['input'];
  /** medium */
  medium: Scalars['Seconds']['input'];
};

/** Incident interface */
export type AiIssuesIIncident = {
  /** account */
  account?: Maybe<AccountReference>;
  /** An account id this incident is stored in */
  accountIds: Scalars['String']['output'];
  /** The time the incident was closed */
  closedAt?: Maybe<Scalars['EpochMilliseconds']['output']>;
  /** The time the incident was created */
  createdAt: Scalars['EpochMilliseconds']['output'];
  /** The description is generated from the policy name and the condition name or provided through API */
  description: Array<Scalars['String']['output']>;
  /** A list of unique entity identifiers */
  entityGuids?: Maybe<Scalars['EntityGuid']['output']>;
  /** A list of entity names */
  entityNames?: Maybe<Scalars['String']['output']>;
  /** A list of entity types */
  entityTypes?: Maybe<Scalars['String']['output']>;
  /**
   * See our documentation to learn about environments
   * @deprecated Use account
   */
  environmentId: Scalars['Int']['output'];
  /** Incident identifier */
  incidentId: Scalars['ID']['output'];
  /** Incident priority */
  priority: AiIssuesPriority;
  /** Incident state */
  state: AiIssuesIncidentState;
  /** Incident event timestamp */
  timestamp: Scalars['EpochMilliseconds']['output'];
  /** The description the user gave the condition if provided. Otherwise the incident description */
  title: Scalars['String']['output'];
  /** The time the incident was last updated */
  updatedAt: Scalars['EpochMilliseconds']['output'];
};

/** Incidents data */
export type AiIssuesIncidentData = {
  __typename?: 'AiIssuesIncidentData';
  /** Incidents */
  incidents: Array<AiIssuesIIncident>;
  /** Cursor to get the next batch of results */
  nextCursor?: Maybe<Scalars['String']['output']>;
};

/** Incident state */
export enum AiIssuesIncidentState {
  /** Incident is closed */
  Closed = 'CLOSED',
  /** Incident is created */
  Created = 'CREATED'
}

/** User action for issue */
export type AiIssuesIncidentUserActionResponse = {
  __typename?: 'AiIssuesIncidentUserActionResponse';
  /** account id */
  accountId: Scalars['Int']['output'];
  /** Error, if any */
  error?: Maybe<Scalars['String']['output']>;
  /** Incident id */
  incidentId: Scalars['ID']['output'];
};

/** Issue */
export type AiIssuesIssue = {
  __typename?: 'AiIssuesIssue';
  /** account */
  account?: Maybe<AccountReference>;
  /** A list of account Ids. As an issue could be correlated with others from other accounts. */
  accountIds: Array<Scalars['Int']['output']>;
  /** The time the issue was acknowledged */
  acknowledgedAt?: Maybe<Scalars['EpochMilliseconds']['output']>;
  /** The user that acknowledged the issue */
  acknowledgedBy?: Maybe<Scalars['String']['output']>;
  /** The channel that acknowledged the issue */
  acknowledgedByChannel?: Maybe<Scalars['String']['output']>;
  /** The time the issue was activated */
  activatedAt?: Maybe<Scalars['EpochMilliseconds']['output']>;
  /** The time the issue was closed */
  closedAt?: Maybe<Scalars['EpochMilliseconds']['output']>;
  /** The user that manually closed the issue */
  closedBy?: Maybe<Scalars['String']['output']>;
  /** The channel that closed the issue */
  closedByChannel?: Maybe<Scalars['String']['output']>;
  /** A list of condition ids associated with this issue */
  conditionFamilyId?: Maybe<Array<Scalars['Int']['output']>>;
  /** A list of condition text descriptions associated with this issue */
  conditionName?: Maybe<Array<Scalars['String']['output']>>;
  /** A list of New Relic products connected to the conditions associated with this issue */
  conditionProduct?: Maybe<Array<Scalars['String']['output']>>;
  /** The merge id that caused the creation of this issue */
  correlatedBy?: Maybe<Scalars['String']['output']>;
  /** A list of correlation rule descriptions applied to correlate this issue to other issues */
  correlationRuleDescriptions?: Maybe<Array<Scalars['String']['output']>>;
  /** A list of correlation rule ids applied to correlate this issue to other issues */
  correlationRuleIds?: Maybe<Array<Scalars['Int']['output']>>;
  /** A list of correlation rule names applied to correlate this issue to other issues */
  correlationRuleNames?: Maybe<Array<Scalars['String']['output']>>;
  /** The issue correlation status */
  correlationStatus?: Maybe<AiIssuesCorrelationStatus>;
  /** The time the issue was created */
  createdAt: Scalars['EpochMilliseconds']['output'];
  /** A list of ML data associated with this issue */
  dataMlModules?: Maybe<Array<AiIssuesKeyValues>>;
  /** A list of urls into New Relic product page, scoped to this issue */
  deepLinkUrl?: Maybe<Array<Scalars['String']['output']>>;
  /** A list of incident descriptions */
  description: Array<Scalars['String']['output']>;
  /** A list of unique entity identifiers */
  entityGuids?: Maybe<Array<Scalars['EntityGuid']['output']>>;
  /** A list of entity names */
  entityNames?: Maybe<Array<Scalars['String']['output']>>;
  /** A list of entity types */
  entityTypes?: Maybe<Array<Scalars['String']['output']>>;
  /**
   * See our documentation to learn about environments
   * @deprecated Use account
   */
  environmentId: Scalars['Int']['output'];
  /** An issue event that could be INCIDENT_ADDED, USER_ACTION, INCIDENT_CLOSED,... */
  eventType: Scalars['String']['output'];
  /** A list of incident IDs in this issue. Notice, in some cases there may be thousands of incidents in an issue */
  incidentIds?: Maybe<Array<Scalars['String']['output']>>;
  /** True means that other issues were correlated to this one */
  isCorrelated: Scalars['Boolean']['output'];
  /** See our documentation to learn about idle issues */
  isIdle: Scalars['Boolean']['output'];
  /** Issue identifier */
  issueId: Scalars['ID']['output'];
  /** The reason this issue was merged */
  mergeReason?: Maybe<Scalars['String']['output']>;
  /** The issue muting state (supress notifications) */
  mutingState?: Maybe<AiIssuesIssueMutingState>;
  /** A list of origins of the incidents (violations, anomalies, external) */
  origins: Array<Scalars['String']['output']>;
  /** The merge id if this issue is part of the merge or null otherwise */
  parentMergeId?: Maybe<Scalars['String']['output']>;
  /** A list of policy ids associated with this issue */
  policyIds?: Maybe<Array<Scalars['Int']['output']>>;
  /** A list of policy names associated with this issue */
  policyName?: Maybe<Array<Scalars['String']['output']>>;
  /** The issue priority */
  priority: AiIssuesPriority;
  /** The number of issues correlated with this issue */
  realIssueCount?: Maybe<Scalars['Int']['output']>;
  /** A list of sources of the incidents (newrelic or external) */
  sources: Array<Scalars['String']['output']>;
  /** The issue state */
  state: AiIssuesIssueState;
  /** A list of underlying incident titles */
  title: Array<Scalars['String']['output']>;
  /** The count of underlying incidents */
  totalIncidents: Scalars['Int']['output'];
  /** The time the issue was unacknowledged */
  unAcknowledgedAt?: Maybe<Scalars['EpochMilliseconds']['output']>;
  /** The user that unacknowledged the issue */
  unAcknowledgedBy?: Maybe<Scalars['String']['output']>;
  /** The channel that unacknowledged the issue */
  unAcknowledgedByChannel?: Maybe<Scalars['String']['output']>;
  /** The time the issue was last updated */
  updatedAt: Scalars['EpochMilliseconds']['output'];
  /** A list of wildcard expressions used for wildcard metrics associated with this issue */
  wildcard?: Maybe<Array<Scalars['String']['output']>>;
};

/** Issues data */
export type AiIssuesIssueData = {
  __typename?: 'AiIssuesIssueData';
  /** Issues */
  issues: Array<AiIssuesIssue>;
  /** Cursor to get the next batch of results */
  nextCursor?: Maybe<Scalars['String']['output']>;
};

/** Issue muting state */
export enum AiIssuesIssueMutingState {
  /** Issue is muted */
  FullyMuted = 'FULLY_MUTED',
  /** Issue is not muted */
  NotMuted = 'NOT_MUTED',
  /** Issue is partially muted */
  PartiallyMuted = 'PARTIALLY_MUTED'
}

/** Issue state */
export enum AiIssuesIssueState {
  /** Issue is activated */
  Activated = 'ACTIVATED',
  /** Issue is closed */
  Closed = 'CLOSED',
  /** Issue is created */
  Created = 'CREATED',
  /** Issue is deactivated */
  Deactivated = 'DEACTIVATED'
}

/** User operations with issue */
export enum AiIssuesIssueUserAction {
  /** Acknowledge issue */
  Ack = 'ACK',
  /** Resolve issue */
  Resolve = 'RESOLVE',
  /** Unacknowledge issue */
  Unack = 'UNACK'
}

/** Response for user action */
export type AiIssuesIssueUserActionResponse = {
  __typename?: 'AiIssuesIssueUserActionResponse';
  /** Error, if any */
  error?: Maybe<Scalars['String']['output']>;
  /** User operation performed with an issue */
  result?: Maybe<AiIssuesIssueUserActionResult>;
};

/** User action for issue */
export type AiIssuesIssueUserActionResult = {
  __typename?: 'AiIssuesIssueUserActionResult';
  /** Account id */
  accountId: Scalars['Int']['output'];
  /** User action */
  action: AiIssuesIssueUserAction;
  /** Issue id */
  issueId: Scalars['ID']['output'];
};

/** Key value type */
export type AiIssuesKeyValue = {
  __typename?: 'AiIssuesKeyValue';
  /** key */
  key: Scalars['String']['output'];
  /** value */
  value: Scalars['String']['output'];
};

/** Key to values type */
export type AiIssuesKeyValues = {
  __typename?: 'AiIssuesKeyValues';
  /** key */
  key: Scalars['String']['output'];
  /** A list of values */
  value: Array<Scalars['String']['output']>;
};

/** Newrelic incident */
export type AiIssuesNewRelicIncident = AiIssuesIIncident & {
  __typename?: 'AiIssuesNewRelicIncident';
  /** account */
  account?: Maybe<AccountReference>;
  /** An account id this incident is stored in */
  accountIds: Scalars['String']['output'];
  /** The time the incident was closed */
  closedAt?: Maybe<Scalars['EpochMilliseconds']['output']>;
  /** The condition id */
  conditionFamilyId?: Maybe<Scalars['String']['output']>;
  /** The time the incident was created */
  createdAt: Scalars['EpochMilliseconds']['output'];
  /** The description is generated from the policy name and the condition name */
  description: Array<Scalars['String']['output']>;
  /** A list of unique entity identifiers */
  entityGuids?: Maybe<Scalars['EntityGuid']['output']>;
  /** A list of entity names */
  entityNames?: Maybe<Scalars['String']['output']>;
  /** A list of entity types */
  entityTypes?: Maybe<Scalars['String']['output']>;
  /**
   * See our documentation to learn about environments
   * @deprecated Use account
   */
  environmentId: Scalars['Int']['output'];
  /** Incident identifier */
  incidentId: Scalars['ID']['output'];
  /** The policy id */
  policyIds?: Maybe<Scalars['String']['output']>;
  /** Incident priority */
  priority: AiIssuesPriority;
  /** Incident state */
  state: AiIssuesIncidentState;
  /** Incident event timestamp */
  timestamp: Scalars['EpochMilliseconds']['output'];
  /** The description the user gave the condition if provided. Otherwise the incident description */
  title: Scalars['String']['output'];
  /** The time the incident was last updated */
  updatedAt: Scalars['EpochMilliseconds']['output'];
};

/** Issue priority */
export enum AiIssuesPriority {
  /** Critical priority */
  Critical = 'CRITICAL',
  /** High priority */
  High = 'HIGH',
  /** Low priority */
  Low = 'LOW',
  /** Medium priority */
  Medium = 'MEDIUM'
}

/** Rest incident */
export type AiIssuesRestIncident = AiIssuesIIncident & {
  __typename?: 'AiIssuesRestIncident';
  /** account */
  account?: Maybe<AccountReference>;
  /** An account id this incident is stored in */
  accountIds: Scalars['String']['output'];
  /** Aggregation of tags related to this incident */
  aggregationTags?: Maybe<Array<AiIssuesKeyValue>>;
  /** The time the incident was closed */
  closedAt?: Maybe<Scalars['EpochMilliseconds']['output']>;
  /** The time the incident was created */
  createdAt: Scalars['EpochMilliseconds']['output'];
  /** The description provided through API */
  description: Array<Scalars['String']['output']>;
  /** A list of unique entity identifiers */
  entityGuids?: Maybe<Scalars['EntityGuid']['output']>;
  /** A list of entity names */
  entityNames?: Maybe<Scalars['String']['output']>;
  /** A list of entity types */
  entityTypes?: Maybe<Scalars['String']['output']>;
  /**
   * See our documentation to learn about environments
   * @deprecated Use account
   */
  environmentId: Scalars['Int']['output'];
  /** Incident identifier */
  incidentId: Scalars['ID']['output'];
  /** Incident priority */
  priority: AiIssuesPriority;
  /** Incident state */
  state: AiIssuesIncidentState;
  /** Incident event timestamp */
  timestamp: Scalars['EpochMilliseconds']['output'];
  /** The description the user gave the condition if provided. Otherwise the incident description */
  title: Scalars['String']['output'];
  /** The time the incident was last updated */
  updatedAt: Scalars['EpochMilliseconds']['output'];
};

export type AiNotificationsAccountStitchedFields = {
  __typename?: 'AiNotificationsAccountStitchedFields';
  /** Fetch channel creation schema */
  channelSchema?: Maybe<AiNotificationsChannelSchemaResult>;
  /** Fetch a field suggestions list for Channel creation */
  channelSuggestions?: Maybe<AiNotificationsSuggestionsResponse>;
  /** Fetch a Channel by product */
  channels?: Maybe<AiNotificationsChannelsResponse>;
  /** Fetch a field suggestions list for Destination creation */
  destinationSuggestions?: Maybe<AiNotificationsSuggestionsResponse>;
  /** Fetch a Destinations by type */
  destinations?: Maybe<AiNotificationsDestinationsResponse>;
  /** Find duplicate destinations */
  duplicateDestinations?: Maybe<AiNotificationsDuplicateDestinationsResponse>;
  /** Get an OAuth URL by destination type */
  oAuthUrl?: Maybe<AiNotificationsOAuthUrlResponse>;
  /**
   * Fetch a field suggestions list for Channel creation
   * @deprecated API is being deprecated in favor of channelSuggestions API
   */
  suggestions?: Maybe<AiNotificationsSuggestionsResponse>;
  /** Fetch a Variables by product */
  variables?: Maybe<AiNotificationsVariableResult>;
};


export type AiNotificationsAccountStitchedFieldsChannelSchemaArgs = {
  channelType: AiNotificationsChannelType;
  constraints?: InputMaybe<Array<AiNotificationsConstraint>>;
  destinationId: Scalars['ID']['input'];
  product?: InputMaybe<AiNotificationsProduct>;
};


export type AiNotificationsAccountStitchedFieldsChannelSuggestionsArgs = {
  channelType: AiNotificationsChannelType;
  constraints?: InputMaybe<Array<AiNotificationsConstraint>>;
  cursor?: InputMaybe<Scalars['String']['input']>;
  destinationId: Scalars['ID']['input'];
  filter?: InputMaybe<AiNotificationsSuggestionFilter>;
  key: Scalars['String']['input'];
};


export type AiNotificationsAccountStitchedFieldsChannelsArgs = {
  cursor?: InputMaybe<Scalars['String']['input']>;
  filters?: InputMaybe<AiNotificationsChannelFilter>;
  sorter?: InputMaybe<AiNotificationsChannelSorter>;
};


export type AiNotificationsAccountStitchedFieldsDestinationSuggestionsArgs = {
  constraints?: InputMaybe<Array<AiNotificationsConstraint>>;
  cursor?: InputMaybe<Scalars['String']['input']>;
  destinationType: AiNotificationsDestinationType;
  filter?: InputMaybe<AiNotificationsSuggestionFilter>;
  key: Scalars['String']['input'];
};


export type AiNotificationsAccountStitchedFieldsDestinationsArgs = {
  cursor?: InputMaybe<Scalars['String']['input']>;
  filters?: InputMaybe<AiNotificationsDestinationFilter>;
  sorter?: InputMaybe<AiNotificationsDestinationSorter>;
};


export type AiNotificationsAccountStitchedFieldsDuplicateDestinationsArgs = {
  cursor?: InputMaybe<Scalars['String']['input']>;
};


export type AiNotificationsAccountStitchedFieldsOAuthUrlArgs = {
  redirectUrl?: InputMaybe<Scalars['String']['input']>;
  type: AiNotificationsDestinationType;
};


export type AiNotificationsAccountStitchedFieldsSuggestionsArgs = {
  channelType: AiNotificationsChannelType;
  constraints?: InputMaybe<Array<AiNotificationsConstraint>>;
  cursor?: InputMaybe<Scalars['String']['input']>;
  destinationId: Scalars['ID']['input'];
  filter?: InputMaybe<AiNotificationsSuggestionFilter>;
  key: Scalars['String']['input'];
};


export type AiNotificationsAccountStitchedFieldsVariablesArgs = {
  cursor?: InputMaybe<Scalars['String']['input']>;
  filters?: InputMaybe<AiNotificationsVariableFilter>;
  sorter?: InputMaybe<AiNotificationsVariableSorter>;
};

/** Authentication interface */
export type AiNotificationsAuth = AiNotificationsBasicAuth | AiNotificationsOAuth2Auth | AiNotificationsTokenAuth;

/** Authentication types */
export enum AiNotificationsAuthType {
  /** Basic user and password authentication */
  Basic = 'BASIC',
  /** OAuth based authentication */
  Oauth2 = 'OAUTH2',
  /** Token based authentication */
  Token = 'TOKEN'
}

/** Basic user and password authentication */
export type AiNotificationsBasicAuth = {
  __typename?: 'AiNotificationsBasicAuth';
  /** Authentication Type - Basic */
  authType: AiNotificationsAuthType;
  /** Username */
  user: Scalars['String']['output'];
};

/** Basic auth input object */
export type AiNotificationsBasicAuthInput = {
  /** password */
  password: Scalars['SecureValue']['input'];
  /** user */
  user: Scalars['String']['input'];
};

/** Channel object */
export type AiNotificationsChannel = {
  __typename?: 'AiNotificationsChannel';
  /** The accountId of the creator of the channel */
  accountId: Scalars['Int']['output'];
  /** Is channel active */
  active: Scalars['Boolean']['output'];
  /** Channel creation time */
  createdAt: Scalars['DateTime']['output'];
  /** Related destination type */
  destinationId: Scalars['ID']['output'];
  /** Channel id */
  id: Scalars['ID']['output'];
  /** Channel name */
  name: Scalars['String']['output'];
  /** Related product type */
  product: AiNotificationsProduct;
  /** List of destination property types */
  properties: Array<AiNotificationsProperty>;
  /** Channel Status */
  status: AiNotificationsChannelStatus;
  /** Channel type */
  type: AiNotificationsChannelType;
  /** Channel last update time */
  updatedAt: Scalars['DateTime']['output'];
  /** Message template creator userId */
  updatedBy: Scalars['Int']['output'];
};

/** Channel fields to filter by */
export enum AiNotificationsChannelFields {
  /** active field */
  Active = 'ACTIVE',
  /** created timestamp field */
  CreatedAt = 'CREATED_AT',
  /** default field */
  Default = 'DEFAULT',
  /** destination id field */
  DestinationId = 'DESTINATION_ID',
  /** name field */
  Name = 'NAME',
  /** product field */
  Product = 'PRODUCT',
  /** status field */
  Status = 'STATUS',
  /** type field */
  Type = 'TYPE',
  /** updated timestamp field */
  UpdatedAt = 'UPDATED_AT',
  /** updated_by field */
  UpdatedBy = 'UPDATED_BY'
}

/** Filter channel object */
export type AiNotificationsChannelFilter = {
  /** active */
  active?: InputMaybe<Scalars['Boolean']['input']>;
  /** destinationId */
  destinationId?: InputMaybe<Scalars['ID']['input']>;
  /** id */
  id?: InputMaybe<Scalars['ID']['input']>;
  /** ids */
  ids?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** name */
  name?: InputMaybe<Scalars['String']['input']>;
  /** product */
  product?: InputMaybe<AiNotificationsProduct>;
  /** property */
  property?: InputMaybe<AiNotificationsPropertyFilter>;
  /** statuses */
  statuses?: InputMaybe<Array<AiNotificationsChannelStatus>>;
  /** type */
  type?: InputMaybe<AiNotificationsChannelType>;
};

/** Channel input object */
export type AiNotificationsChannelInput = {
  /** destinationId */
  destinationId: Scalars['ID']['input'];
  /** name */
  name: Scalars['String']['input'];
  /** product */
  product: AiNotificationsProduct;
  /** properties */
  properties: Array<AiNotificationsPropertyInput>;
  /** type */
  type: AiNotificationsChannelType;
};

/** Response for all channel related mutations. Includes relevant channel and/or errors */
export type AiNotificationsChannelResponse = {
  __typename?: 'AiNotificationsChannelResponse';
  /** Successfully mutated channel */
  channel?: Maybe<AiNotificationsChannel>;
  /** Error in channel mutation */
  error?: Maybe<AiNotificationsError>;
  /**
   * Deprecated list of errors
   * @deprecated Errors is being deprecated in favor of a singular error field
   */
  errors: Array<AiNotificationsError>;
};

/** Channel schema object */
export type AiNotificationsChannelSchemaResult = {
  __typename?: 'AiNotificationsChannelSchemaResult';
  /** Error while querying channelSchema */
  error?: Maybe<AiNotificationsError>;
  /**
   * Deprecated list of errors
   * @deprecated Errors is being deprecated in favor of a singular error field
   */
  errors: Array<AiNotificationsError>;
  /** Result of channelSchema query */
  result: AiNotificationsResult;
  /** Possible fields for the channel */
  schema?: Maybe<AiNotificationsSchema>;
};

/** Sort object */
export type AiNotificationsChannelSorter = {
  /** direction */
  direction: AiNotificationsSortOrder;
  /** field */
  field: AiNotificationsChannelFields;
};

/** Channel statuses */
export enum AiNotificationsChannelStatus {
  /** Configuration Error channel status */
  ConfigurationError = 'CONFIGURATION_ERROR',
  /** Configuration Warning channel status */
  ConfigurationWarning = 'CONFIGURATION_WARNING',
  /** Default channel status */
  Default = 'DEFAULT',
  /**
   * Draft channel status
   * @deprecated unused status
   */
  Draft = 'DRAFT',
  /**
   * Error channel status
   * @deprecated unused status
   */
  Error = 'ERROR',
  /**
   * Tested channel status
   * @deprecated unused status
   */
  Tested = 'TESTED',
  /**
   * Throttled channel status
   * @deprecated unused status
   */
  Throttled = 'THROTTLED',
  /** Unknown Error channel status */
  UnknownError = 'UNKNOWN_ERROR'
}

/** Result of a notification test */
export type AiNotificationsChannelTestResponse = {
  __typename?: 'AiNotificationsChannelTestResponse';
  /** Extra details (if available) */
  details?: Maybe<Scalars['String']['output']>;
  /** Test response error */
  error?: Maybe<AiNotificationsError>;
  /**
   * Deprecated list of errors
   * @deprecated Errors is being deprecated in favor of a singular error field
   */
  errors: Array<AiNotificationsError>;
  /** The evidence (url for example) of the channel being created. */
  evidence?: Maybe<Scalars['String']['output']>;
  /** Test result - success or failure */
  result: AiNotificationsResult;
};

/** Channel type */
export enum AiNotificationsChannelType {
  /** Email channel type */
  Email = 'EMAIL',
  /** Event Bridge channel type */
  EventBridge = 'EVENT_BRIDGE',
  /** Jira Classic channel type */
  JiraClassic = 'JIRA_CLASSIC',
  /** Jira Nextgen channel type */
  JiraNextgen = 'JIRA_NEXTGEN',
  /** Mobile push channel type */
  MobilePush = 'MOBILE_PUSH',
  /** PagerDuty channel type */
  PagerdutyAccountIntegration = 'PAGERDUTY_ACCOUNT_INTEGRATION',
  /** Pager Duty channel type */
  PagerdutyServiceIntegration = 'PAGERDUTY_SERVICE_INTEGRATION',
  /** Servicenow events channel type */
  ServicenowEvents = 'SERVICENOW_EVENTS',
  /** Servicenow incidents channel type */
  ServicenowIncidents = 'SERVICENOW_INCIDENTS',
  /** ServiceNow app channel type */
  ServiceNowApp = 'SERVICE_NOW_APP',
  /** Slack channel type */
  Slack = 'SLACK',
  /** Slack Collaboration channel type */
  SlackCollaboration = 'SLACK_COLLABORATION',
  /** Legacy Slack channel type based on Incoming Webhooks */
  SlackLegacy = 'SLACK_LEGACY',
  /** Webhook channel type */
  Webhook = 'WEBHOOK'
}

/** Channel update object */
export type AiNotificationsChannelUpdate = {
  /** active */
  active?: InputMaybe<Scalars['Boolean']['input']>;
  /** name */
  name?: InputMaybe<Scalars['String']['input']>;
  /** properties */
  properties?: InputMaybe<Array<AiNotificationsPropertyInput>>;
};

/** Channel result object */
export type AiNotificationsChannelsResponse = {
  __typename?: 'AiNotificationsChannelsResponse';
  /** Channel entities */
  entities: Array<AiNotificationsChannel>;
  /** Error in channel entities fetching */
  error?: Maybe<AiNotificationsResponseError>;
  /**
   * Deprecated list of errors
   * @deprecated Errors is being deprecated in favor of a singular error field
   */
  errors: Array<AiNotificationsResponseError>;
  /** Cursor to get the next batch of results */
  nextCursor?: Maybe<Scalars['String']['output']>;
  /** Count of all channel entities */
  totalCount: Scalars['Int']['output'];
};

/** List of schema/suggestions constraints */
export type AiNotificationsConstraint = {
  /** key */
  key: Scalars['String']['input'];
  /** value */
  value: Scalars['String']['input'];
};

/** Missing constraint error. Constraints can be retrieved using suggestion api */
export type AiNotificationsConstraintError = {
  __typename?: 'AiNotificationsConstraintError';
  /** Names of other constraints this constraint is dependent on */
  dependencies: Array<Scalars['String']['output']>;
  /** Name of the missing constraint */
  name: Scalars['String']['output'];
};

/** Object for constraints errors */
export type AiNotificationsConstraintsError = {
  __typename?: 'AiNotificationsConstraintsError';
  /** List of missing constraints for channel creation */
  constraints: Array<AiNotificationsConstraintError>;
};

/** Credential input object */
export type AiNotificationsCredentialsInput = {
  /** basic */
  basic?: InputMaybe<AiNotificationsBasicAuthInput>;
  /** oauth2 */
  oauth2?: InputMaybe<AiNotificationsOAuth2AuthInput>;
  /** token */
  token?: InputMaybe<AiNotificationsTokenAuthInput>;
  /** type */
  type: AiNotificationsAuthType;
};

/** Object for validation errors */
export type AiNotificationsDataValidationError = {
  __typename?: 'AiNotificationsDataValidationError';
  /** Top level error details */
  details: Scalars['String']['output'];
  /** List of invalid fields */
  fields: Array<AiNotificationsFieldError>;
};

/** Delete response object */
export type AiNotificationsDeleteResponse = {
  __typename?: 'AiNotificationsDeleteResponse';
  /** Error in object deletion */
  error?: Maybe<AiNotificationsResponseError>;
  /**
   * Deprecated list of errors
   * @deprecated Errors is being deprecated in favor of a singular error field
   */
  errors: Array<AiNotificationsResponseError>;
  /** Deleted object ids */
  ids?: Maybe<Array<Scalars['ID']['output']>>;
};

/** Destination Object */
export type AiNotificationsDestination = {
  __typename?: 'AiNotificationsDestination';
  /** The accountId of the creator of the destination */
  accountId: Scalars['Int']['output'];
  /** Destination active */
  active: Scalars['Boolean']['output'];
  /** Authentication for this destination */
  auth?: Maybe<AiNotificationsAuth>;
  /** Destination created at */
  createdAt: Scalars['DateTime']['output'];
  /** Entity Id of the Destination */
  guid: Scalars['EntityGuid']['output'];
  /** Destination id */
  id: Scalars['ID']['output'];
  /** Indicates whether the user is authenticated with the destination */
  isUserAuthenticated: Scalars['Boolean']['output'];
  /** Last time a notification was sent */
  lastSent?: Maybe<Scalars['DateTime']['output']>;
  /** Destination name */
  name: Scalars['String']['output'];
  /** List of destination property types */
  properties: Array<AiNotificationsProperty>;
  /** Destination status */
  status: AiNotificationsDestinationStatus;
  /** Destination type */
  type: AiNotificationsDestinationType;
  /** Destination updated at */
  updatedAt: Scalars['DateTime']['output'];
  /** Destination updated by */
  updatedBy: Scalars['Int']['output'];
};

/** Destination fields */
export enum AiNotificationsDestinationFields {
  /** active field */
  Active = 'ACTIVE',
  /** created_at field */
  CreatedAt = 'CREATED_AT',
  /** default field */
  Default = 'DEFAULT',
  /** last_sent field */
  LastSent = 'LAST_SENT',
  /** name field */
  Name = 'NAME',
  /** status field */
  Status = 'STATUS',
  /** type field */
  Type = 'TYPE',
  /** updated_at field */
  UpdatedAt = 'UPDATED_AT',
  /** updated_by field */
  UpdatedBy = 'UPDATED_BY'
}

/** Filter destination object */
export type AiNotificationsDestinationFilter = {
  /** active */
  active?: InputMaybe<Scalars['Boolean']['input']>;
  /** authType */
  authType?: InputMaybe<AiNotificationsAuthType>;
  /** id */
  id?: InputMaybe<Scalars['ID']['input']>;
  /** ids */
  ids?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** name */
  name?: InputMaybe<Scalars['String']['input']>;
  /** property */
  property?: InputMaybe<AiNotificationsPropertyFilter>;
  /** type */
  type?: InputMaybe<AiNotificationsDestinationType>;
  /** updatedAt */
  updatedAt?: InputMaybe<Scalars['DateTime']['input']>;
};

/** Destination input object */
export type AiNotificationsDestinationInput = {
  /** auth */
  auth?: InputMaybe<AiNotificationsCredentialsInput>;
  /** name */
  name: Scalars['String']['input'];
  /** properties */
  properties: Array<AiNotificationsPropertyInput>;
  /** type */
  type: AiNotificationsDestinationType;
};

/** A group of duplicate destinations */
export type AiNotificationsDestinationMergeResult = {
  __typename?: 'AiNotificationsDestinationMergeResult';
  /** ID of the destination into which the other destination was merged */
  remainingDestinationId: Scalars['ID']['output'];
  /** IDs of the destination that was removed during the merging process */
  removedDestinationId: Scalars['ID']['output'];
  /** IDs of all the channels that were moved from the removed destination to the remaining one */
  updatedChannelIds: Array<Scalars['ID']['output']>;
};

/** Response for all destinations related mutation. Includes relevant destination and/or errors */
export type AiNotificationsDestinationResponse = {
  __typename?: 'AiNotificationsDestinationResponse';
  /** Successfully mutated destination */
  destination?: Maybe<AiNotificationsDestination>;
  /** Error in destination mutation */
  error?: Maybe<AiNotificationsError>;
  /**
   * Deprecated list of errors
   * @deprecated Errors is being deprecated in favor of a singular error field
   */
  errors: Array<AiNotificationsError>;
};

/** Sort object */
export type AiNotificationsDestinationSorter = {
  /** direction */
  direction: AiNotificationsSortOrder;
  /** field */
  field: AiNotificationsDestinationFields;
};

/** Destination statuses */
export enum AiNotificationsDestinationStatus {
  /** Authentication Error destination status */
  AuthenticationError = 'AUTHENTICATION_ERROR',
  /** Authorization Error destination status */
  AuthorizationError = 'AUTHORIZATION_ERROR',
  /** Authorization Warning destination status */
  AuthorizationWarning = 'AUTHORIZATION_WARNING',
  /** Auth Error destination status */
  AuthError = 'AUTH_ERROR',
  /** Configuration Error destination status */
  ConfigurationError = 'CONFIGURATION_ERROR',
  /** Default destination status */
  Default = 'DEFAULT',
  /**
   * Draft channel status
   * @deprecated unused status
   */
  Draft = 'DRAFT',
  /**
   * Error channel status
   * @deprecated unused status
   */
  Error = 'ERROR',
  /** External Server Error destination status */
  ExternalServerError = 'EXTERNAL_SERVER_ERROR',
  /** Temporary Warning destination status */
  TemporaryWarning = 'TEMPORARY_WARNING',
  /**
   * Tested channel status
   * @deprecated unused status
   */
  Tested = 'TESTED',
  /**
   * Throttled channel status
   * @deprecated unused status
   */
  Throttled = 'THROTTLED',
  /** Throttling Warning destination status */
  ThrottlingWarning = 'THROTTLING_WARNING',
  /** Timeout Error destination status */
  TimeoutError = 'TIMEOUT_ERROR',
  /** Uninstalled destination status */
  Uninstalled = 'UNINSTALLED',
  /** Unknown Error destination status */
  UnknownError = 'UNKNOWN_ERROR'
}

/** Result of a connection test */
export type AiNotificationsDestinationTestResponse = {
  __typename?: 'AiNotificationsDestinationTestResponse';
  /** Extra details (if available) */
  details?: Maybe<Scalars['String']['output']>;
  /** Test response error */
  error?: Maybe<AiNotificationsError>;
  /**
   * Deprecated list of errors
   * @deprecated Errors is being deprecated in favor of a singular error field
   */
  errors: Array<AiNotificationsError>;
  /** Test result - success or failure */
  result: AiNotificationsResult;
};

/** Destination types */
export enum AiNotificationsDestinationType {
  /** Email destination type */
  Email = 'EMAIL',
  /** EventBridge destination type */
  EventBridge = 'EVENT_BRIDGE',
  /** Jira destination type */
  Jira = 'JIRA',
  /** Mobile push destination type */
  MobilePush = 'MOBILE_PUSH',
  /** PagerDuty destination type */
  PagerdutyAccountIntegration = 'PAGERDUTY_ACCOUNT_INTEGRATION',
  /** PagerDuty destination type} */
  PagerdutyServiceIntegration = 'PAGERDUTY_SERVICE_INTEGRATION',
  /** ServiceNow destination type */
  ServiceNow = 'SERVICE_NOW',
  /** ServiceNow app destination type */
  ServiceNowApp = 'SERVICE_NOW_APP',
  /** Slack destination type */
  Slack = 'SLACK',
  /** Slack Collaboration destination type */
  SlackCollaboration = 'SLACK_COLLABORATION',
  /** Legacy Slack destination type based on Incoming Webhooks */
  SlackLegacy = 'SLACK_LEGACY',
  /** WebHook destination type */
  Webhook = 'WEBHOOK'
}

/** Destination update object */
export type AiNotificationsDestinationUpdate = {
  /** active */
  active?: InputMaybe<Scalars['Boolean']['input']>;
  /** auth */
  auth?: InputMaybe<AiNotificationsCredentialsInput>;
  /** disableAuth */
  disableAuth?: InputMaybe<Scalars['Boolean']['input']>;
  /** name */
  name?: InputMaybe<Scalars['String']['input']>;
  /** properties */
  properties?: InputMaybe<Array<AiNotificationsPropertyInput>>;
};

/** Destinations result object */
export type AiNotificationsDestinationsResponse = {
  __typename?: 'AiNotificationsDestinationsResponse';
  /** Destination entities */
  entities: Array<AiNotificationsDestination>;
  /** Error in destinations entities fetching */
  error?: Maybe<AiNotificationsResponseError>;
  /**
   * Deprecated list of errors
   * @deprecated Errors is being deprecated in favor of a singular error field
   */
  errors: Array<AiNotificationsResponseError>;
  /** Cursor to get the next batch of results */
  nextCursor?: Maybe<Scalars['String']['output']>;
  /** Count of all destination entities */
  totalCount: Scalars['Int']['output'];
};

/** An identified group of duplicate destinations */
export type AiNotificationsDuplicateDestinations = {
  __typename?: 'AiNotificationsDuplicateDestinations';
  /** IDs of the duplicate destinations */
  destinationIds: Array<Scalars['ID']['output']>;
  /** Type of the destinations in the group */
  destinationType: AiNotificationsDestinationType;
};

/** Duplicate destination search response */
export type AiNotificationsDuplicateDestinationsResponse = {
  __typename?: 'AiNotificationsDuplicateDestinationsResponse';
  /** Groups of duplicate destinations */
  duplicateGroups: Array<AiNotificationsDuplicateDestinations>;
  /** A cursor to fetch the next page. Null if there is no next page. */
  nextCursor?: Maybe<Scalars['String']['output']>;
};

/** A list of dynamic variables used by the Channel */
export type AiNotificationsDynamicVariable = {
  /** exampleValue */
  exampleValue?: InputMaybe<AiNotificationsExampleValue>;
  /** name */
  name: Scalars['String']['input'];
};

/** Error object */
export type AiNotificationsError = AiNotificationsConstraintsError | AiNotificationsDataValidationError | AiNotificationsResponseError | AiNotificationsSuggestionError;

/** Error types */
export enum AiNotificationsErrorType {
  /** Unable to connect to external service to perform this action */
  ConnectionError = 'CONNECTION_ERROR',
  /** This operation could not be completed because the entity is in use */
  EntityInUse = 'ENTITY_IN_USE',
  /** An external server error has occurred */
  ExternalServerError = 'EXTERNAL_SERVER_ERROR',
  /** Targeted account does not have access to this feature */
  FeatureFlagDisabled = 'FEATURE_FLAG_DISABLED',
  /** The channel name doesn't exist */
  InvalidChannelName = 'INVALID_CHANNEL_NAME',
  /** The credentials provided were invalid, Please check them and try again */
  InvalidCredentials = 'INVALID_CREDENTIALS',
  /** Could not provide suggestions for this key */
  InvalidKey = 'INVALID_KEY',
  /** The parameter provided does not correspond to any valid entity */
  InvalidParameter = 'INVALID_PARAMETER',
  /** Entities limit has been reached */
  LimitReached = 'LIMIT_REACHED',
  /** User is missing capabilities */
  MissingCapabilities = 'MISSING_CAPABILITIES',
  /** This key requires additional constraints */
  MissingConstraints = 'MISSING_CONSTRAINTS',
  /** At least one parameter is required to complete this action */
  MissingParameters = 'MISSING_PARAMETERS',
  /** This destination does not support OAuth authentication */
  OauthNotSupported = 'OAUTH_NOT_SUPPORTED',
  /** This destination does not provide any suggestions */
  SuggestionsUnavailable = 'SUGGESTIONS_UNAVAILABLE',
  /** Request did not finish within time limit */
  TimeoutError = 'TIMEOUT_ERROR',
  /** The variable type is different from the example type */
  TypeExampleMismatch = 'TYPE_EXAMPLE_MISMATCH',
  /** This account is not allowed to perform this action */
  UnauthorizedAccount = 'UNAUTHORIZED_ACCOUNT',
  /** Received one or more unexpected parameters */
  UnexpectedParameter = 'UNEXPECTED_PARAMETER',
  /** The New Relic application was removed */
  UninstalledDestination = 'UNINSTALLED_DESTINATION',
  /** An unknown error has occurred */
  UnknownError = 'UNKNOWN_ERROR'
}

/** Example properties to be added to the rendering context, for tests */
export type AiNotificationsExampleValue = {
  /** example */
  example: Scalars['String']['input'];
  /** type */
  type: AiNotificationsVariableType;
};

/** Invalid field object */
export type AiNotificationsFieldError = {
  __typename?: 'AiNotificationsFieldError';
  /** Field name */
  field: Scalars['String']['output'];
  /** Validation error */
  message: Scalars['String']['output'];
};

/** Destinations merge response */
export type AiNotificationsMergeDestinationsResponse = {
  __typename?: 'AiNotificationsMergeDestinationsResponse';
  /** Merge results */
  merges?: Maybe<Array<AiNotificationsDestinationMergeResult>>;
};

/** A group of destinations to merge */
export type AiNotificationsMergeGroup = {
  /** destinationIds */
  destinationIds: Array<Scalars['ID']['input']>;
};

/** OAuth2 based authentication */
export type AiNotificationsOAuth2Auth = {
  __typename?: 'AiNotificationsOAuth2Auth';
  /** OAuth2 access token url */
  accessTokenUrl: Scalars['String']['output'];
  /** Authentication Type - Token or Oauth2 */
  authType: AiNotificationsAuthType;
  /** OAuth2 authorization url */
  authorizationUrl: Scalars['String']['output'];
  /** OAuth2 clientId */
  clientId: Scalars['String']['output'];
  /** Token prefix */
  prefix: Scalars['String']['output'];
  /** Interval of how often should the access token be refreshed */
  refreshInterval?: Maybe<Scalars['Int']['output']>;
  /** Is the OAuth2 access token refreshable */
  refreshable: Scalars['Boolean']['output'];
  /** OAuth2 token's scope */
  scope?: Maybe<Scalars['String']['output']>;
};

/** OAuth2 auth input object */
export type AiNotificationsOAuth2AuthInput = {
  /** accessTokenUrl */
  accessTokenUrl: Scalars['String']['input'];
  /** authorizationUrl */
  authorizationUrl: Scalars['String']['input'];
  /** clientId */
  clientId: Scalars['String']['input'];
  /** clientSecret */
  clientSecret: Scalars['SecureValue']['input'];
  /** prefix */
  prefix?: InputMaybe<Scalars['String']['input']>;
  /** refreshInterval */
  refreshInterval?: InputMaybe<Scalars['Int']['input']>;
  /** refreshToken */
  refreshToken?: InputMaybe<Scalars['SecureValue']['input']>;
  /** refreshable */
  refreshable: Scalars['Boolean']['input'];
  /** scope */
  scope?: InputMaybe<Scalars['String']['input']>;
  /** token */
  token: Scalars['SecureValue']['input'];
};

/** OAuth URL response */
export type AiNotificationsOAuthUrlResponse = {
  __typename?: 'AiNotificationsOAuthUrlResponse';
  /** OAuth response error */
  error?: Maybe<AiNotificationsResponseError>;
  /**
   * Deprecated list of errors
   * @deprecated Errors is being deprecated in favor of a singular error field
   */
  errors: Array<AiNotificationsResponseError>;
  /** Transaction id to track OAuth flow with */
  transactionId?: Maybe<Scalars['ID']['output']>;
  /** OAuth URL for the user */
  url: Scalars['String']['output'];
};

/** Product types */
export enum AiNotificationsProduct {
  /** Alerts product type */
  Alerts = 'ALERTS',
  /** APM product type */
  Apm = 'APM',
  /** Change tracking product type */
  ChangeTracking = 'CHANGE_TRACKING',
  /** CSSP (EOPs) product type */
  Cssp = 'CSSP',
  /** Discussions and comments product type */
  Discussions = 'DISCUSSIONS',
  /** Error Tracking product type */
  ErrorTracking = 'ERROR_TRACKING',
  /** Incident Intelligence product type */
  Iint = 'IINT',
  /** Notifications internal product type */
  Ntfc = 'NTFC',
  /** Proactive Detection product type */
  Pd = 'PD',
  /** Security product type */
  Security = 'SECURITY',
  /** Sharing product type */
  Sharing = 'SHARING'
}

/** Channel property Object */
export type AiNotificationsProperty = {
  __typename?: 'AiNotificationsProperty';
  /** Channel property display key */
  displayValue?: Maybe<Scalars['String']['output']>;
  /** Channel property key */
  key: Scalars['String']['output'];
  /** Channel property display key */
  label?: Maybe<Scalars['String']['output']>;
  /** Channel property value */
  value: Scalars['String']['output'];
};

/** Filter object by property */
export type AiNotificationsPropertyFilter = {
  /** key */
  key: Scalars['String']['input'];
  /** value */
  value: Scalars['String']['input'];
};

/** Property object */
export type AiNotificationsPropertyInput = {
  /** displayValue */
  displayValue?: InputMaybe<Scalars['String']['input']>;
  /** key */
  key: Scalars['String']['input'];
  /** label */
  label?: InputMaybe<Scalars['String']['input']>;
  /** value */
  value: Scalars['String']['input'];
};

/** Response error object */
export type AiNotificationsResponseError = {
  __typename?: 'AiNotificationsResponseError';
  /** Error description */
  description: Scalars['String']['output'];
  /** Error details */
  details: Scalars['String']['output'];
  /** Error type */
  type: AiNotificationsErrorType;
};

/** Result status */
export enum AiNotificationsResult {
  /** Failure */
  Fail = 'FAIL',
  /** Success */
  Success = 'SUCCESS'
}

/** Channel schema object */
export type AiNotificationsSchema = {
  __typename?: 'AiNotificationsSchema';
  /** Possible fields for the channel */
  fields: Array<AiNotificationsSchemaField>;
};

/** Schema field object */
export type AiNotificationsSchemaField = {
  __typename?: 'AiNotificationsSchemaField';
  /** UI Component details */
  component: AiNotificationsUiComponent;
  /** Field key */
  key: Scalars['String']['output'];
  /** Field label shown in the UI */
  label: Scalars['String']['output'];
  /** Is the field mandatory */
  mandatory: Scalars['Boolean']['output'];
};

/** Additional options for SELECT type components */
export type AiNotificationsSelectComponentOptions = {
  __typename?: 'AiNotificationsSelectComponentOptions';
  /** Is custom value creation allowed */
  creatable: Scalars['Boolean']['output'];
  /** List of field keys their values are required in order to fetch suggestions for this field */
  dependentOn: Array<Scalars['String']['output']>;
  /** List of field keys their values can be used to filter suggestions by */
  filteredBy: Array<Scalars['String']['output']>;
  /** Do we allow additional values as input other than suggested? */
  label: Scalars['Boolean']['output'];
  /** Are we expecting a single or multiple values */
  multiple: Scalars['Boolean']['output'];
  /** Is this component searchable */
  searchable: Scalars['Boolean']['output'];
  /** Preloaded suggestions for */
  suggestions: Array<AiNotificationsSuggestion>;
};

/** Sort order */
export enum AiNotificationsSortOrder {
  /** Ascending sort order */
  Asc = 'ASC',
  /** Descending sort order */
  Desc = 'DESC'
}

/** Suggestion object */
export type AiNotificationsSuggestion = {
  __typename?: 'AiNotificationsSuggestion';
  /** Suggestion label */
  displayValue: Scalars['String']['output'];
  /** Should suggestion be the default selection */
  icon?: Maybe<Scalars['String']['output']>;
  /** Suggestion key */
  value: Scalars['String']['output'];
};

/** Object for suggestion errors */
export type AiNotificationsSuggestionError = {
  __typename?: 'AiNotificationsSuggestionError';
  /**
   * SuggestionError description
   * @deprecated this entire object will be deprecated, please refrain from using SuggestionError
   */
  description: Scalars['String']['output'];
  /**
   * SuggestionError details
   * @deprecated this entire object will be deprecated, please refrain from using SuggestionError
   */
  details: Scalars['String']['output'];
  /**
   * SuggestionError type
   * @deprecated this entire object will be deprecated, please refrain from using SuggestionError
   */
  type: AiNotificationsErrorType;
};

/** Suggestion filter object */
export type AiNotificationsSuggestionFilter = {
  /** type */
  type: AiNotificationsSuggestionFilterType;
  /** value */
  value: Scalars['String']['input'];
};

/** Filters for the suggestions object */
export enum AiNotificationsSuggestionFilterType {
  /** Contains specific string */
  Contains = 'CONTAINS',
  /** Starts with a specific string */
  Startswith = 'STARTSWITH'
}

/** Possible values for a field by its key */
export type AiNotificationsSuggestionsResponse = {
  __typename?: 'AiNotificationsSuggestionsResponse';
  /** List of Suggestion objects */
  entities: Array<AiNotificationsSuggestion>;
  /** Error while fetching suggestions */
  error?: Maybe<AiNotificationsError>;
  /**
   * Deprecated list of errors
   * @deprecated Errors is being deprecated in favor of a singular error field
   */
  errors: Array<AiNotificationsSuggestionError>;
  /** Cursor to get the next batch of results */
  nextCursor?: Maybe<Scalars['String']['output']>;
  /** Suggestions request result */
  result: AiNotificationsResult;
  /** Count of all suggestion entities, -1 if unavailable */
  totalCount: Scalars['Int']['output'];
};

/** Token based authentication */
export type AiNotificationsTokenAuth = {
  __typename?: 'AiNotificationsTokenAuth';
  /** Authentication Type - Token or Oauth2 */
  authType: AiNotificationsAuthType;
  /** Token Prefix */
  prefix: Scalars['String']['output'];
};

/** Token auth input object */
export type AiNotificationsTokenAuthInput = {
  /** prefix */
  prefix?: InputMaybe<Scalars['String']['input']>;
  /** token */
  token: Scalars['SecureValue']['input'];
};

/** UI component object */
export type AiNotificationsUiComponent = {
  __typename?: 'AiNotificationsUiComponent';
  /** Should we allow variables rendering in this component */
  allowTemplateVariables: Scalars['Boolean']['output'];
  /** Which data validation is applied to this component */
  dataValidation: AiNotificationsUiComponentValidation;
  /** Default value of this component */
  defaultValue?: Maybe<AiNotificationsSuggestion>;
  /** Additional options for SELECT type components */
  selectOptions?: Maybe<AiNotificationsSelectComponentOptions>;
  /** Component type */
  type: AiNotificationsUiComponentType;
  /** Is this component a part of the default fields */
  visibleByDefault: Scalars['Boolean']['output'];
};

/** UI component type */
export enum AiNotificationsUiComponentType {
  /**
   * Button component
   * @deprecated unused component type
   */
  Button = 'BUTTON',
  /** Dictionary type component */
  DictionaryWithMask = 'DICTIONARY_WITH_MASK',
  /** Handlebars powered payload editor */
  Payload = 'PAYLOAD',
  /** Select component */
  Select = 'SELECT',
  /** Multiline text box */
  TextArea = 'TEXT_AREA',
  /** Single line text field */
  TextField = 'TEXT_FIELD',
  /** Toggle component */
  Toggle = 'TOGGLE'
}

/** Type of Validation required for this component */
export enum AiNotificationsUiComponentValidation {
  /** Data should be a valid DATE ISO-8601 format */
  Date = 'DATE',
  /** Data should be a valid DATETIME ISO-8601 format */
  Datetime = 'DATETIME',
  /** Data should be a valid email */
  Email = 'EMAIL',
  /** Data should be a valid JSON */
  Json = 'JSON',
  /** No validation */
  None = 'NONE',
  /** Data should be a valid number */
  Number = 'NUMBER',
  /** Data should be a valid URL */
  Url = 'URL'
}

/** Variable object */
export type AiNotificationsVariable = {
  __typename?: 'AiNotificationsVariable';
  /** Is variable active */
  active: Scalars['Boolean']['output'];
  /** Variable category */
  category: AiNotificationsVariableCategory;
  /** Variable creation time */
  createdAt: Scalars['DateTime']['output'];
  /** Variable description */
  description?: Maybe<Scalars['String']['output']>;
  /** Variable example */
  example: Scalars['String']['output'];
  /** Variable id */
  id: Scalars['ID']['output'];
  /** Variable key */
  key: Scalars['String']['output'];
  /** Variable label */
  label?: Maybe<Scalars['String']['output']>;
  /** Variable name */
  name: Scalars['String']['output'];
  /** Related product type */
  product: AiNotificationsProduct;
  /** Variable type */
  type: AiNotificationsVariableType;
  /** Variable update time */
  updatedAt: Scalars['DateTime']['output'];
  /** Variable creator userId */
  updatedBy: Scalars['Int']['output'];
};

/** Category fields to group by */
export enum AiNotificationsVariableCategory {
  /** Condition category */
  Condition = 'CONDITION',
  /** Entities category */
  Entities = 'ENTITIES',
  /** Incident category */
  Incident = 'INCIDENT',
  /** Issue category */
  Issue = 'ISSUE',
  /** Default category */
  Other = 'OTHER',
  /** Policy category */
  Policy = 'POLICY',
  /** Tags category */
  Tags = 'TAGS',
  /** Workflow category */
  Workflow = 'WORKFLOW'
}

/** Variable fields to filter by */
export enum AiNotificationsVariableFields {
  /** active field */
  Active = 'ACTIVE',
  /** default field */
  Default = 'DEFAULT',
  /** description field */
  Description = 'DESCRIPTION',
  /** example field */
  Example = 'EXAMPLE',
  /** key field */
  Key = 'KEY',
  /** label field */
  Label = 'LABEL',
  /** name field */
  Name = 'NAME',
  /** product field */
  Product = 'PRODUCT',
  /** type field */
  Type = 'TYPE'
}

/** Filter variable object */
export type AiNotificationsVariableFilter = {
  /** active */
  active?: InputMaybe<Scalars['Boolean']['input']>;
  /** key */
  key?: InputMaybe<Scalars['String']['input']>;
  /** label */
  label?: InputMaybe<Scalars['String']['input']>;
  /** name */
  name?: InputMaybe<Scalars['String']['input']>;
  /** product */
  product?: InputMaybe<AiNotificationsProduct>;
};

/** Channel result object */
export type AiNotificationsVariableResult = {
  __typename?: 'AiNotificationsVariableResult';
  /** Variable entities */
  entities: Array<AiNotificationsVariable>;
  /** Cursor to get the next batch of results */
  nextCursor?: Maybe<Scalars['String']['output']>;
  /** Count of all variable entities */
  totalCount: Scalars['Int']['output'];
};

/** Sort object */
export type AiNotificationsVariableSorter = {
  /** direction */
  direction: AiNotificationsSortOrder;
  /** field */
  field: AiNotificationsVariableFields;
};

/** Variable types */
export enum AiNotificationsVariableType {
  /** Boolean variable type */
  Boolean = 'BOOLEAN',
  /** List variable type */
  List = 'LIST',
  /** number variable type */
  Number = 'NUMBER',
  /** Object variable type */
  Object = 'OBJECT',
  /** String variable type */
  String = 'STRING'
}

/** Query scoped to an account */
export type AiOpsAccountStitchedFields = {
  __typename?: 'AiOpsAccountStitchedFields';
  /** Data related to analyses */
  analysis?: Maybe<AiOpsAnalysisNamespacedFields>;
};

/** Query data scoped to the person making the request. */
export type AiOpsActorStitchedFields = {
  __typename?: 'AiOpsActorStitchedFields';
  /** Retrieve information related to the proactive detection feature. */
  proactiveDetection?: Maybe<AiOpsProactiveDetectionNamespacedFields>;
  /** Retrieve information about the actor's slack integrations. */
  slack?: Maybe<AiOpsSlackNamespacedFields>;
};

/** Query data related to analyses. */
export type AiOpsAnalysisNamespacedFields = {
  __typename?: 'AiOpsAnalysisNamespacedFields';
  /** Data scoped to an anomaly event. */
  anomaly: AiOpsAnomalyNamespacedFields;
  /** Data scoped to an Incident Intelligence incident. */
  incident: AiOpsIncidentNamespacedFields;
};


/** Query data related to analyses. */
export type AiOpsAnalysisNamespacedFieldsAnomalyArgs = {
  id: Scalars['ID']['input'];
};


/** Query data related to analyses. */
export type AiOpsAnalysisNamespacedFieldsIncidentArgs = {
  id: Scalars['ID']['input'];
};

/** The result of closing an anomaly */
export type AiOpsAnomalyCloseResult = {
  __typename?: 'AiOpsAnomalyCloseResult';
  /** The anomaly ID */
  id: Scalars['ID']['output'];
};

/** Query data related to anomalies. */
export type AiOpsAnomalyNamespacedFields = {
  __typename?: 'AiOpsAnomalyNamespacedFields';
  /** User comments. */
  comments: AiOpsCommentsResult;
};

/** Analysis comments submitted by users. */
export type AiOpsComment = {
  __typename?: 'AiOpsComment';
  /** The time at which the comment was submitted. */
  createdAt: Scalars['EpochMilliseconds']['output'];
  /** Unique identifier for the comment. */
  id: Scalars['ID']['output'];
  /** Text submitted by a user. */
  text: Scalars['String']['output'];
  /** The user that submitted the comment. */
  user?: Maybe<UserReference>;
  /** Unique identifier for the user. */
  userId: Scalars['ID']['output'];
};

/** The result of deleting a comment. */
export type AiOpsCommentDeleteResult = {
  __typename?: 'AiOpsCommentDeleteResult';
  /** Id of the deleted comment. */
  id: Scalars['ID']['output'];
};

/** The result of a query for analysis comments. */
export type AiOpsCommentsResult = {
  __typename?: 'AiOpsCommentsResult';
  /** Comments submitted by users. */
  results: Array<AiOpsComment>;
};

/** Proactive Detection destination types */
export enum AiOpsDestinationType {
  /** Incident Intelligence destinations */
  IncidentIntelligence = 'INCIDENT_INTELLIGENCE',
  /** Slack destinations */
  Slack = 'SLACK',
  /** Webhook destinations */
  Webhook = 'WEBHOOK'
}

/** User preference context by which to scope event query results */
export enum AiOpsEventsQueryContext {
  /** AiOps overview and anomaly pages */
  AiOps = 'AI_OPS',
  /** Activity feeds and other NR One contexts */
  Global = 'GLOBAL'
}

/** Training label for a time window */
export enum AiOpsFeedbackLabel {
  /** Period is considered an anomaly */
  Anomaly = 'ANOMALY',
  /** Period is considered normal */
  Normal = 'NORMAL'
}

/** Feedback period */
export type AiOpsFeedbackPeriod = {
  __typename?: 'AiOpsFeedbackPeriod';
  /** anomaly ID; provide if period overlaps with an anomaly */
  anomalyId?: Maybe<Scalars['String']['output']>;
  /** Label to classify time window */
  label: AiOpsFeedbackLabel;
  /** Time window for feedback period */
  timeWindow: TimeWindow;
  /** user ID */
  userId?: Maybe<Scalars['Int']['output']>;
};

/** Destination containing information required to send events to Incident Intelligence. */
export type AiOpsIncidentIntelligenceDestination = {
  __typename?: 'AiOpsIncidentIntelligenceDestination';
  /** The id of the Incident Intelligence environment to which events will be sent. */
  environmentId: Scalars['Int']['output'];
};

/** Destination containing information required to send events to Incident Intelligence. */
export type AiOpsIncidentIntelligenceDestinationInput = {
  /** The id of incident intelligence environment to which the events will be sent. */
  environmentId: Scalars['Int']['input'];
};

/** Query data related to incidents. */
export type AiOpsIncidentNamespacedFields = {
  __typename?: 'AiOpsIncidentNamespacedFields';
  /** User comments. */
  comments: AiOpsCommentsResult;
};

/** Description of a signal that is being monitored. */
export type AiOpsMonitoredSignal = {
  __typename?: 'AiOpsMonitoredSignal';
  /** Whether or not the signal is enabled. */
  enabled: Scalars['Boolean']['output'];
  /** The type of signal that is being monitored. */
  signalType: AiOpsSignalType;
};

/** Description of a signal that is being monitored. */
export type AiOpsMonitoredSignalInput = {
  /** Whether or not the signal is enabled. */
  enabled: Scalars['Boolean']['input'];
  /** The type of signal that is being monitored. */
  signalType: AiOpsSignalType;
};

/** The result of an operation that could fail or succeed */
export enum AiOpsOutcome {
  /** The operation failed */
  Failure = 'FAILURE',
  /** The operation succeeded */
  Success = 'SUCCESS'
}

/** Data related to Proactive Detection */
export type AiOpsProactiveDetection = {
  __typename?: 'AiOpsProactiveDetection';
  /** Retrieve all Proactive Detection configurations */
  configurations?: Maybe<AiOpsProactiveDetectionConfigSearchResults>;
  /** Retrieve Proactive Detection-related events for an entity */
  events?: Maybe<AiOpsProactiveDetectionEventsResult>;
};


/** Data related to Proactive Detection */
export type AiOpsProactiveDetectionEventsArgs = {
  query: AiOpsProactiveDetectionEntityEventsQuery;
};

/** Criteria used to filter Proactive Detection events by actor */
export type AiOpsProactiveDetectionActorEventsQuery = {
  /** Account IDs to filter events by */
  accountIds?: InputMaybe<Array<Scalars['Int']['input']>>;
  /** Filter events based on the category of signal that was analyzed */
  categories?: InputMaybe<Array<Scalars['String']['input']>>;
  /** Filter events by configuration ID */
  configurationId?: InputMaybe<Scalars['ID']['input']>;
  /** Filter events to those with the provided configuration types */
  configurationTypes?: InputMaybe<Array<AiOpsProactiveDetectionEventConfigurationType>>;
  /** User preference context to scope query by */
  context?: InputMaybe<AiOpsEventsQueryContext>;
  /** Cursor to paginate results by */
  cursor?: InputMaybe<Scalars['String']['input']>;
  /** Filter to events that were recorded at or before this timestamp */
  endTime: Scalars['EpochMilliseconds']['input'];
  /** Find events for the specified entity guids */
  entityGuids?: InputMaybe<Array<Scalars['EntityGuid']['input']>>;
  /** Filter to these Proactive Detection monitoring status */
  filterMonitoringStatus?: InputMaybe<Array<AiOpsProactiveDetectionEventMonitoringStatus>>;
  /** Filter to these Proactive Detection event types */
  filterTypes?: InputMaybe<Array<AiOpsProactiveDetectionEventType>>;
  /** Filter events based on the type of signal that was analyzed */
  signalIds?: InputMaybe<Array<Scalars['String']['input']>>;
  /** DEPRECATED - Use signalIds - Filter events based on the type of signal that was analyzed */
  signalTypes?: InputMaybe<Array<AiOpsSignalType>>;
  /** Filter to events that were recorded at or after this timestamp */
  startTime: Scalars['EpochMilliseconds']['input'];
  /** Filter events using text search */
  textSearch?: InputMaybe<Scalars['String']['input']>;
};

/** A Proactive Detection configuration. These allow users to subscribe to events detected by the AiOps platform. */
export type AiOpsProactiveDetectionConfig = {
  __typename?: 'AiOpsProactiveDetectionConfig';
  /** The account to which the Proactive Detection configuration belongs. */
  account?: Maybe<AccountReference>;
  /** The entities whose real time failure warnings will be sent to the configured slack channels. */
  entities: Array<EntityOutline>;
  /** The number of entities being monitored */
  entityCount: Scalars['Int']['output'];
  /** The unique id of the Proactive Detection configuration. */
  id: Scalars['ID']['output'];
  /** The list of incident intelligence destinations to notify when a real time failure warning is detected. */
  incidentIntelligenceDestinations: Array<AiOpsIncidentIntelligenceDestination>;
  /** Timestamp of the last time the configuration was updated. */
  lastUpdatedAt?: Maybe<Scalars['EpochMilliseconds']['output']>;
  /** The list of signals that the configuration is monitoring. */
  monitoredSignals?: Maybe<Array<AiOpsMonitoredSignal>>;
  /** The name of the configuration */
  name?: Maybe<Scalars['String']['output']>;
  /** The list of slack channels to notify when a real time failure warning is detected. */
  slackChannels?: Maybe<Array<AiOpsSlackChannel>>;
  /** The list of webhooks to notify when a real time failure warning is detected. */
  webhooks?: Maybe<Array<AiOpsWebhook>>;
};

/** The information needed to create or update a Proactive Detection configuration */
export type AiOpsProactiveDetectionConfigInput = {
  /** The id of the account to which the configuration belongs. */
  accountId: Scalars['Int']['input'];
  /** The list of entities that will be monitored. */
  entityGuids: Array<Scalars['EntityGuid']['input']>;
  /** The list of incident intelligence destinations to notify when a real time failure warning is detected. */
  incidentIntelligenceDestinations?: InputMaybe<Array<AiOpsIncidentIntelligenceDestinationInput>>;
  /** The list of signals that the configuration is monitoring. */
  monitoredSignals?: InputMaybe<Array<AiOpsMonitoredSignalInput>>;
  /** The name of the configuration */
  name?: InputMaybe<Scalars['String']['input']>;
  /** The slack channels that will be notified when a warning is detected. */
  slackChannels?: InputMaybe<Array<AiOpsSlackChannelInput>>;
  /** The list of webhooks that will be notified when a warning is detected. */
  webhooks?: InputMaybe<Array<AiOpsWebhookInput>>;
};

/** The result of any operation that mutates a Proactive Detection configuration */
export type AiOpsProactiveDetectionConfigMutationResult = {
  __typename?: 'AiOpsProactiveDetectionConfigMutationResult';
  /**
   * The Proactive Detection configuration that was modified.
   * This will be null if the provided input is not valid.
   */
  config?: Maybe<AiOpsProactiveDetectionConfig>;
  /**
   * A list of errors that will be returned if the input is not valid.
   * This will be empty if the provided input is valid.
   */
  validationErrorMessages?: Maybe<Array<AiOpsValidationErrorMessage>>;
};

/** The result of any operation that mutates one or more Proactive Detection configurations */
export type AiOpsProactiveDetectionConfigMutationResults = {
  __typename?: 'AiOpsProactiveDetectionConfigMutationResults';
  /**
   * The Proactive Detection configuration that was modified.
   * This will be null if the provided input is not valid.
   */
  configs: Array<AiOpsProactiveDetectionConfig>;
  /**
   * A list of errors that will be returned if the input is not valid.
   * This will be empty if the provided input is valid.
   */
  validationErrorMessages?: Maybe<Array<AiOpsValidationErrorMessage>>;
};

/** Simplified version of a Proactive Detection configuration */
export type AiOpsProactiveDetectionConfigOutline = {
  __typename?: 'AiOpsProactiveDetectionConfigOutline';
  /** The account to which the Proactive Detection configuration belongs. */
  account?: Maybe<AccountReference>;
  /** The unique id of the Proactive Detection configuration. */
  id: Scalars['ID']['output'];
  /** The name of the configuration */
  name?: Maybe<Scalars['String']['output']>;
};

/** Result of finding a config by id or retrieving a draft */
export type AiOpsProactiveDetectionConfigResult = {
  __typename?: 'AiOpsProactiveDetectionConfigResult';
  /** The Proactive Detection config that was found. */
  result?: Maybe<AiOpsProactiveDetectionConfig>;
};

/** The result of any operation that is querying Proactive Detection configurations. */
export type AiOpsProactiveDetectionConfigSearchResults = {
  __typename?: 'AiOpsProactiveDetectionConfigSearchResults';
  /** The number of Proactive Detection configurations matching the search result. */
  count: Scalars['Int']['output'];
  /** The list of Proactive Detection configurations that were found. */
  results: Array<AiOpsProactiveDetectionConfig>;
};

/** Criteria used to filter Proactive Detection configuration searches */
export type AiOpsProactiveDetectionConfigsQuery = {
  /** Filter to configurations containing these destinations */
  destinationTypes?: InputMaybe<Array<AiOpsDestinationType>>;
  /** The ID of the environment to scope configurations by */
  environmentId?: InputMaybe<Scalars['Int']['input']>;
};

/** Criteria used to filter Proactive Detection events by entity */
export type AiOpsProactiveDetectionEntityEventsQuery = {
  /** User preference context to scope query by */
  context?: InputMaybe<AiOpsEventsQueryContext>;
  /** Cursor to paginate results by */
  cursor?: InputMaybe<Scalars['String']['input']>;
  /** Filter to events that were recorded at or before this timestamp */
  endTime: Scalars['EpochMilliseconds']['input'];
  /** Filter to these Proactive Detection event types */
  filterTypes?: InputMaybe<Array<AiOpsProactiveDetectionEventType>>;
  /** Filter to events that were recorded at or after this timestamp */
  startTime: Scalars['EpochMilliseconds']['input'];
};

/** A Proactive Detection event */
export type AiOpsProactiveDetectionEvent = {
  __typename?: 'AiOpsProactiveDetectionEvent';
  /** Account ID of the event */
  accountId: Scalars['Int']['output'];
  /** Anomaly ID of the event */
  anomalyId: Scalars['ID']['output'];
  /** Human readable category related to the type of signal evaluated */
  category: Scalars['String']['output'];
  /** Flag describing the configuration type associated with the event. */
  configurationType: AiOpsProactiveDetectionEventConfigurationType;
  /** Related configurations */
  configurations: Array<AiOpsProactiveDetectionConfigOutline>;
  /** Description of the event */
  description: Scalars['String']['output'];
  /** The time the event ended */
  endedAt?: Maybe<Scalars['EpochMilliseconds']['output']>;
  /** The Entity associated with the event */
  entity?: Maybe<EntityOutline>;
  /** ID of the event */
  id: Scalars['ID']['output'];
  /** Flag describing the monitoring status of the entity associated with the event. */
  monitoringStatus: AiOpsProactiveDetectionEventMonitoringStatus;
  /** Nrql query that can be used to chart the event */
  nrql: Scalars['Nrql']['output'];
  /** Type of signal that was evaluated */
  signalId: Scalars['String']['output'];
  /** DEPRECATED - Use SignalId - Type of signal that was evaluated */
  signalType: AiOpsSignalType;
  /** The time the event started */
  startedAt: Scalars['EpochMilliseconds']['output'];
  /** The time the event was recorded */
  timestamp: Scalars['EpochMilliseconds']['output'];
  /** Human readable version of the event type */
  title: Scalars['String']['output'];
  /** Type of event */
  type: AiOpsProactiveDetectionEventType;
};

/** The type of configuration that is monitoring the event. */
export enum AiOpsProactiveDetectionEventConfigurationType {
  /** Entity is not monitored by a specific configuration and was automatically detected. */
  Automatic = 'AUTOMATIC',
  /** Entity is being monitored by a Proactive Detection configuration. */
  Configuration = 'CONFIGURATION',
  /** Entity is being monitored by a custom configuration */
  Custom = 'CUSTOM',
  /** Unknown configuration type. */
  Unknown = 'UNKNOWN'
}

/** Proactive Detection monitoring status */
export enum AiOpsProactiveDetectionEventMonitoringStatus {
  /** Event recorded for an entity that is monitored by Proactive Detection */
  Monitored = 'MONITORED',
  /** Unknown Proactive Detection event monitoring status */
  Unknown = 'UNKNOWN',
  /** Event recorded for an entity that is NOT monitored by Proactive Detection */
  Unmonitored = 'UNMONITORED'
}

/** Proactive Detection event types */
export enum AiOpsProactiveDetectionEventType {
  /** Event recorded when a Proactive Detection anomaly has ended */
  AnomalyClose = 'ANOMALY_CLOSE',
  /** Event recorded when a Proactive Detection anomaly has begun */
  AnomalyOpen = 'ANOMALY_OPEN',
  /** Unknown Proactive Detection event type */
  Unknown = 'UNKNOWN'
}

/** Result of a query to retrieve Proactive Detection events */
export type AiOpsProactiveDetectionEventsResult = {
  __typename?: 'AiOpsProactiveDetectionEventsResult';
  /** Cursor to fetch additional events; null if no additional results */
  nextCursor?: Maybe<Scalars['String']['output']>;
  /** List of Proactive Detection events filtered by criteria */
  results: Array<AiOpsProactiveDetectionEvent>;
};

/** Query data related to AiOps Proactive Detection. */
export type AiOpsProactiveDetectionNamespacedFields = {
  __typename?: 'AiOpsProactiveDetectionNamespacedFields';
  /** Retrieve a config by ID */
  config?: Maybe<AiOpsProactiveDetectionConfigResult>;
  /** Retrieve the current users most recent draft */
  configDraft?: Maybe<AiOpsProactiveDetectionConfigResult>;
  /** Retrieve Proactive Detection configurations */
  configs?: Maybe<AiOpsProactiveDetectionConfigSearchResults>;
  /** Retrieve a Proactive Detection Event */
  event?: Maybe<AiOpsProactiveDetectionEvent>;
  /** Retrieve Proactive Detection events */
  events?: Maybe<AiOpsProactiveDetectionEventsResult>;
  /** Search for training sessions that are within the provided timeWindow. Results are paginated. See cursor and nextCursor for pagination# */
  trainingSessionSearch: AiOpsTrainingSessionSearchResult;
  /** Retrieve user messages data */
  userMessages?: Maybe<AiOpsUserMessagesResult>;
};


/** Query data related to AiOps Proactive Detection. */
export type AiOpsProactiveDetectionNamespacedFieldsConfigArgs = {
  id: Scalars['ID']['input'];
};


/** Query data related to AiOps Proactive Detection. */
export type AiOpsProactiveDetectionNamespacedFieldsConfigsArgs = {
  query?: InputMaybe<AiOpsProactiveDetectionConfigsQuery>;
};


/** Query data related to AiOps Proactive Detection. */
export type AiOpsProactiveDetectionNamespacedFieldsEventArgs = {
  accountId: Scalars['Int']['input'];
  anomalyId: Scalars['ID']['input'];
};


/** Query data related to AiOps Proactive Detection. */
export type AiOpsProactiveDetectionNamespacedFieldsEventsArgs = {
  query: AiOpsProactiveDetectionActorEventsQuery;
};


/** Query data related to AiOps Proactive Detection. */
export type AiOpsProactiveDetectionNamespacedFieldsTrainingSessionSearchArgs = {
  anomalyId?: InputMaybe<Scalars['String']['input']>;
  anomalyType?: InputMaybe<Scalars['String']['input']>;
  cursor?: InputMaybe<Scalars['String']['input']>;
  guid: Scalars['EntityGuid']['input'];
  timeWindow?: InputMaybe<TimeWindowInput>;
};

/** The signal type */
export enum AiOpsSignalType {
  /** APM application error count */
  ApmApplicationErrorcount = 'APM_APPLICATION_ERRORCOUNT',
  /** APM application response time ms */
  ApmApplicationResponsetimems = 'APM_APPLICATION_RESPONSETIMEMS',
  /** APM application throughput */
  ApmApplicationThroughput = 'APM_APPLICATION_THROUGHPUT',
  /** Browser application errors */
  BrowserApplicationErrors = 'BROWSER_APPLICATION_ERRORS',
  /** Browser application first Input Delay (75 percentile) (ms) */
  BrowserApplicationFirstinputdelay75Percentilems = 'BROWSER_APPLICATION_FIRSTINPUTDELAY75PERCENTILEMS',
  /** Browser application largest Contentful Paint (75 percentile) (s) */
  BrowserApplicationLargestcontentfulpaint75Percentiles = 'BROWSER_APPLICATION_LARGESTCONTENTFULPAINT75PERCENTILES',
  /** Browser application throughput (ppm) */
  BrowserApplicationThroughputppm = 'BROWSER_APPLICATION_THROUGHPUTPPM',
  /** Error rate */
  ErrorRate = 'ERROR_RATE',
  /** AWS volume average write time */
  InfraAwsebsvolumeAveragewritetimems = 'INFRA_AWSEBSVOLUME_AVERAGEWRITETIMEMS',
  /** Container cpu usage */
  InfraContainerCpuusage = 'INFRA_CONTAINER_CPUUSAGE',
  /** Container cpu utilitization */
  InfraContainerCpuutilization = 'INFRA_CONTAINER_CPUUTILIZATION',
  /** Container memory usage */
  InfraContainerMemoryusage = 'INFRA_CONTAINER_MEMORYUSAGE',
  /** Container storage usage */
  InfraContainerStorageusage = 'INFRA_CONTAINER_STORAGEUSAGE',
  /** Host network traffic */
  InfraHostNetworktraffic = 'INFRA_HOST_NETWORKTRAFFIC',
  /** Redis instance connected clients */
  InfraRedisinstanceConnectedclients = 'INFRA_REDISINSTANCE_CONNECTEDCLIENTS',
  /** Redis instance keyspace misses per second */
  InfraRedisinstanceKeyspacemissespersecond = 'INFRA_REDISINSTANCE_KEYSPACEMISSESPERSECOND',
  /** Mobile application HTTP errors and network failures */
  MobileApplicationHttperrorsandnetworkfailures = 'MOBILE_APPLICATION_HTTPERRORSANDNETWORKFAILURES',
  /** Mobile application HTTP response time (95%) (s) */
  MobileApplicationHttpresponsetime95S = 'MOBILE_APPLICATION_HTTPRESPONSETIME95S',
  /** Mobile application requests per minute */
  MobileApplicationRequestsperminute = 'MOBILE_APPLICATION_REQUESTSPERMINUTE',
  /** Custom NRQL query */
  Nrql = 'NRQL',
  /** Non-web response time */
  ResponseTimeNonWeb = 'RESPONSE_TIME_NON_WEB',
  /** Web Response time */
  ResponseTimeWeb = 'RESPONSE_TIME_WEB',
  /** Synthetic monitor failures */
  SynthMonitorFailures = 'SYNTH_MONITOR_FAILURES',
  /** Synthetic monitor median duration (s) */
  SynthMonitorMediandurations = 'SYNTH_MONITOR_MEDIANDURATIONS',
  /** Non-web throughput */
  ThroughputNonWeb = 'THROUGHPUT_NON_WEB',
  /** Web throughput */
  ThroughputWeb = 'THROUGHPUT_WEB',
  /** Unknown */
  Unknown = 'UNKNOWN'
}

/** The information needed to identify a slack channel. */
export type AiOpsSlackChannel = {
  __typename?: 'AiOpsSlackChannel';
  /** The id of the channel */
  channelId: Scalars['ID']['output'];
  /** The name of the channel. */
  channelName: Scalars['String']['output'];
  /** The id of the team to which the channel belongs. */
  teamId: Scalars['ID']['output'];
  /** The name of the team to which the channel belongs. */
  teamName: Scalars['String']['output'];
  /** time zone set by the user creating the Slack destination configuration, stored as IANA database name string */
  timeZone?: Maybe<Scalars['String']['output']>;
  /**
   * The default visibility of the slack channel in the UI -- PUBLIC or PRIVATE
   * If private, the user does not have permission to see the information about the slack channel.
   * If public, the user has permission to see the information about the slack channel.
   */
  visibility: Scalars['String']['output'];
};

/** The information needed to create a slack channel. */
export type AiOpsSlackChannelInput = {
  /** The id of the channel */
  channelId: Scalars['ID']['input'];
  /** The name of the channel. */
  channelName?: InputMaybe<Scalars['String']['input']>;
  /** The id of the team to which the channel belongs. */
  teamId: Scalars['ID']['input'];
  /** The name of the team to which the channel belongs. */
  teamName?: InputMaybe<Scalars['String']['input']>;
  /** time zone set by the user creating the Slack destination configuration, stored as IANA database name string */
  timeZone?: InputMaybe<Scalars['String']['input']>;
};

/** Query data about the actor's slack integrations. */
export type AiOpsSlackNamespacedFields = {
  __typename?: 'AiOpsSlackNamespacedFields';
  /** Retrieve the url that can be used to install the slack application. */
  appInstallUrl: Scalars['String']['output'];
};


/** Query data about the actor's slack integrations. */
export type AiOpsSlackNamespacedFieldsAppInstallUrlArgs = {
  accountId: Scalars['Int']['input'];
  redirectUrl: Scalars['String']['input'];
};

/** Error found when storing a training session */
export type AiOpsStoreTrainingSessionError = {
  __typename?: 'AiOpsStoreTrainingSessionError';
  /** Error message */
  message: Scalars['String']['output'];
  /** Error type */
  type: AiOpsStoreTrainingSessionErrorType;
};

/** Type of error */
export enum AiOpsStoreTrainingSessionErrorType {
  /** Invalid input */
  InvalidInput = 'INVALID_INPUT'
}

/** Result of storing training session */
export type AiOpsStoreTrainingSessionResult = {
  __typename?: 'AiOpsStoreTrainingSessionResult';
  /** Errors */
  errors?: Maybe<Array<AiOpsStoreTrainingSessionError>>;
  /** Session that was stored */
  session?: Maybe<AiOpsTrainingSession>;
};

/** Proactive detection training session */
export type AiOpsTrainingSession = {
  __typename?: 'AiOpsTrainingSession';
  /** type of anomaly */
  anomalyType: Scalars['String']['output'];
  /** Labeled periods */
  periods: Array<AiOpsFeedbackPeriod>;
};

/** The paginated results of the training session search */
export type AiOpsTrainingSessionSearchResult = {
  __typename?: 'AiOpsTrainingSessionSearchResult';
  /** Total number of training sessions found in all pages */
  count: Scalars['Int']['output'];
  /** The next cursor for fetching additional training session results. */
  nextCursor?: Maybe<Scalars['String']['output']>;
  /** List of training sessions in this page */
  results: Array<AiOpsTrainingSession>;
};

/** The set of User Messages that users will be shown depending on account age, messages dismissed, etc. */
export enum AiOpsUserMessageId {
  /** A message showing what has changed as of 2020-03-01 */
  WhatsNew_03_01_2021 = 'WHATS_NEW_03_01_2021'
}

/** Contains the ID of the message whose viewed state is being modified and whether the update to it was successful */
export type AiOpsUserMessageResult = {
  __typename?: 'AiOpsUserMessageResult';
  /** Reports whether the User Message operation succeeded */
  outcome?: Maybe<AiOpsOutcome>;
  /** Identifies the particular User Message being modified */
  userMessageId?: Maybe<AiOpsUserMessageId>;
};

/** Result of querying data about user messages */
export type AiOpsUserMessagesResult = {
  __typename?: 'AiOpsUserMessagesResult';
  /** List of IDs of User Messages that user has not viewed */
  notViewed: Array<AiOpsUserMessageId>;
};

/** Validation error returned when a mutation payload contains invalid values. */
export type AiOpsValidationErrorMessage = {
  __typename?: 'AiOpsValidationErrorMessage';
  /** The field of the resource containing the invalid value */
  field: Scalars['String']['output'];
  /** The line number of the value that was identified as invalid. */
  lineNumber?: Maybe<Scalars['Int']['output']>;
  /** An explanation of why the value is invalid */
  message: Scalars['String']['output'];
  /** The resource containing the invalid field */
  resource: Scalars['String']['output'];
  /** The value that was invalid */
  value?: Maybe<Scalars['String']['output']>;
};

/** The information needed to communicate with a webhook. */
export type AiOpsWebhook = {
  __typename?: 'AiOpsWebhook';
  /** The custom headers that will be included when the message is delivered */
  customHeaders?: Maybe<Array<AiOpsWebhookCustomHeader>>;
  /** The information describing the payload that will be provided when the webhook is called */
  payloadMetadata?: Maybe<AiOpsWebhookPayloadMetadata>;
  /** The url to which messages will be delivered */
  url: Scalars['String']['output'];
};

/** A custom header that will be provided when calling the webhook. */
export type AiOpsWebhookCustomHeader = {
  __typename?: 'AiOpsWebhookCustomHeader';
  /** The name of the custom header that will be included in the webhook message */
  name: Scalars['String']['output'];
  /** The value of the custom header that will be included in the webhook message */
  value: Scalars['String']['output'];
  /**
   * The default visibility of the value in the UI text input-- PUBLIC or PRIVATE
   * Setting this PRIVATE will obfuscate the field in the UI on page load
   */
  visibility: Scalars['String']['output'];
};

/** A custom header that will be provided when calling the webhook. */
export type AiOpsWebhookCustomHeaderInput = {
  /** The name of the custom header that will be included in the webhook message */
  name: Scalars['String']['input'];
  /** The value of the custom header that will be included in the webhook message */
  value: Scalars['String']['input'];
  /**
   * The default visibility of the value in the UI text input-- PUBLIC or PRIVATE
   * Setting this PRIVATE will obfuscate the field in the UI on page load
   */
  visibility: Scalars['String']['input'];
};

/** The information needed to create a webhook. */
export type AiOpsWebhookInput = {
  /** The custom headers that will be included when the message is delivered */
  customHeaders?: InputMaybe<Array<AiOpsWebhookCustomHeaderInput>>;
  /** The information describing the payload that will be provided when the webhook is called */
  payloadMetadata?: InputMaybe<AiOpsWebhookPayloadMetadataInput>;
  /** The url to which messages will be delivered */
  url: Scalars['String']['input'];
};

/** The information describing the payload that will be provided when the webhook is called */
export type AiOpsWebhookPayloadMetadata = {
  __typename?: 'AiOpsWebhookPayloadMetadata';
  /** The template that will be used when the webhook is called */
  template: Scalars['String']['output'];
  /** The type of template that will be used when the webhook is called */
  templateType?: Maybe<AiOpsWebhookPayloadTemplateType>;
  /** The version of the payload */
  version: Scalars['String']['output'];
};

/** The information describing the payload that will be provided when the webhook is called */
export type AiOpsWebhookPayloadMetadataInput = {
  /** The template that will be used when the webhook is called */
  template: Scalars['String']['input'];
  /** The type of template that will be used when the webhook is called */
  templateType?: InputMaybe<AiOpsWebhookPayloadTemplateType>;
};

/** The type of template that will be used when the webhook is called. */
export enum AiOpsWebhookPayloadTemplateType {
  /**
   * The webhook will use a template that was provided by the user.
   * No new attributes will be included uness the user manually updates the custom template.
   */
  Custom = 'CUSTOM',
  /**
   * The webhook to use the most recent default template.
   * Any new attributes available to the webhook will be automatically included in the payload.
   */
  Default = 'DEFAULT'
}

/** A preview of the data that will be sent to the webhook when it is called. */
export type AiOpsWebhookPreview = {
  __typename?: 'AiOpsWebhookPreview';
  /** An example curl command that can be used to test the webhook locally. */
  curl: Scalars['String']['output'];
  /** The payload that will be provided when the webhook is called. */
  payload: Scalars['String']['output'];
};

/** The result of generating a preview of the data that will be sent to the webhook when it is called. */
export type AiOpsWebhookPreviewResult = {
  __typename?: 'AiOpsWebhookPreviewResult';
  /** This will be present if the provided webhook input was valid. */
  preview?: Maybe<AiOpsWebhookPreview>;
  /**
   * This will always return a list.
   * If the provided webhook input was valid, the list will be empty.
   * If the provided webhook input was not valid, the list will contain at least one validation error message.
   */
  validationErrorMessages: Array<AiOpsValidationErrorMessage>;
};

/** Response from a webhook after sending a notification to the webhook */
export type AiOpsWebhookResponse = {
  __typename?: 'AiOpsWebhookResponse';
  /** The http response body that was returned when the webhook was called */
  body: Scalars['String']['output'];
  /** The http response code that was returned when the webhook was called */
  code: Scalars['Int']['output'];
  /** The http response headers that were returned when the webhook was called */
  headers: Array<AiOpsWebhookCustomHeader>;
  /** The http response message that was returned when the webhook was called */
  message: Scalars['String']['output'];
};

/** Result of sending a test notification to a webhook */
export type AiOpsWebhookTestResult = {
  __typename?: 'AiOpsWebhookTestResult';
  /** Response from the webhook that received a test notification */
  response: AiOpsWebhookResponse;
  /** List of error messages associated with invalid webhook input; list may be empty if webhook input is valid */
  validationErrorMessages: Array<AiOpsValidationErrorMessage>;
};

export type AiPostmortemAccountStitchedFields = {
  __typename?: 'AiPostmortemAccountStitchedFields';
  /**
   * Fetch a postmortem by ID.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  postmortem?: Maybe<AiPostmortemPostmortemTemplate>;
  /**
   * Fetch a paginated list of postmortems
   * @deprecated This field is experimental and subject to breaking changes.
   */
  postmortems?: Maybe<AiPostmortemPostmortemListing>;
  /**
   * Get a paginated list of relevant postmortems
   * @deprecated This field is experimental and subject to breaking changes.
   */
  relevantPostmortems?: Maybe<AiPostmortemPostmortemListing>;
  /**
   * Get a paginated list of relevant postmortems by issue ids
   * @deprecated This field is experimental and subject to breaking changes.
   */
  relevantPostmortemsByIssues?: Maybe<AiPostmortemPostmortemListing>;
  /**
   * Fetch a paginated list of postmortems with matched creator
   * @deprecated This field is experimental and subject to breaking changes.
   */
  searchPostmortemsByCreator?: Maybe<AiPostmortemPostmortemListing>;
  /**
   * Fetch a paginated list of postmortems with matched entity name
   * @deprecated This field is experimental and subject to breaking changes.
   */
  searchPostmortemsByEntityName?: Maybe<AiPostmortemPostmortemListing>;
  /**
   * Fetch a paginated list of postmortems with matched issue ids
   * @deprecated This field is experimental and subject to breaking changes.
   */
  searchPostmortemsByIssueIds?: Maybe<AiPostmortemPostmortemListing>;
  /**
   * Fetch a paginated list of postmortems with matched keywords
   * @deprecated This field is experimental and subject to breaking changes.
   */
  searchPostmortemsByKeywords?: Maybe<AiPostmortemPostmortemListing>;
};


export type AiPostmortemAccountStitchedFieldsPostmortemArgs = {
  postmortemId: Scalars['ID']['input'];
};


export type AiPostmortemAccountStitchedFieldsPostmortemsArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
  nextCursor?: InputMaybe<Scalars['String']['input']>;
  previousCursor?: InputMaybe<Scalars['String']['input']>;
  sortMethod?: InputMaybe<AiPostmortemPostmortemSortMethod>;
};


export type AiPostmortemAccountStitchedFieldsRelevantPostmortemsArgs = {
  alertConditionIds: Array<Scalars['ID']['input']>;
  alertPolicyIds: Array<Scalars['ID']['input']>;
  entityNames: Array<Scalars['String']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  nextCursor?: InputMaybe<Scalars['String']['input']>;
  previousCursor?: InputMaybe<Scalars['String']['input']>;
};


export type AiPostmortemAccountStitchedFieldsRelevantPostmortemsByIssuesArgs = {
  issueIds: Array<Scalars['ID']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  nextCursor?: InputMaybe<Scalars['String']['input']>;
  previousCursor?: InputMaybe<Scalars['String']['input']>;
};


export type AiPostmortemAccountStitchedFieldsSearchPostmortemsByCreatorArgs = {
  creator: Scalars['String']['input'];
  limit?: InputMaybe<Scalars['Int']['input']>;
  nextCursor?: InputMaybe<Scalars['String']['input']>;
  previousCursor?: InputMaybe<Scalars['String']['input']>;
};


export type AiPostmortemAccountStitchedFieldsSearchPostmortemsByEntityNameArgs = {
  entityName: Scalars['String']['input'];
  limit?: InputMaybe<Scalars['Int']['input']>;
  nextCursor?: InputMaybe<Scalars['String']['input']>;
  previousCursor?: InputMaybe<Scalars['String']['input']>;
};


export type AiPostmortemAccountStitchedFieldsSearchPostmortemsByIssueIdsArgs = {
  issueIds: Array<Scalars['ID']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  nextCursor?: InputMaybe<Scalars['String']['input']>;
  previousCursor?: InputMaybe<Scalars['String']['input']>;
};


export type AiPostmortemAccountStitchedFieldsSearchPostmortemsByKeywordsArgs = {
  keywords: Scalars['String']['input'];
  limit?: InputMaybe<Scalars['Int']['input']>;
  nextCursor?: InputMaybe<Scalars['String']['input']>;
  previousCursor?: InputMaybe<Scalars['String']['input']>;
};

/** A collection of chart entries. */
export type AiPostmortemChartData = {
  __typename?: 'AiPostmortemChartData';
  /**
   * List of anomaly chart data entries
   * @deprecated This field is experimental and subject to breaking changes.
   */
  anomalyChartData: Array<AiPostmortemChartDataEntry>;
  /**
   * List of entity chart data entries
   * @deprecated This field is experimental and subject to breaking changes.
   */
  entityChartData: Array<AiPostmortemChartDataEntry>;
};

/** An entry of chart metadata and data. */
export type AiPostmortemChartDataEntry = {
  __typename?: 'AiPostmortemChartDataEntry';
  /**
   * account id of the query
   * @deprecated This field is experimental and subject to breaking changes.
   */
  accountId?: Maybe<Scalars['Int']['output']>;
  /**
   * List of data point values
   * @deprecated This field is experimental and subject to breaking changes.
   */
  data: Array<Scalars['String']['output']>;
  /**
   * name of entity involved with the chart
   * @deprecated This field is experimental and subject to breaking changes.
   */
  entityName?: Maybe<Scalars['String']['output']>;
  /**
   * id of chart entry
   * @deprecated This field is experimental and subject to breaking changes.
   */
  id: Scalars['String']['output'];
  /**
   * metadata of the event
   * @deprecated This field is experimental and subject to breaking changes.
   */
  metadata: Array<AiPostmortemMetadataEntry>;
  /**
   * query to pull out the events
   * @deprecated This field is experimental and subject to breaking changes.
   */
  query: Scalars['String']['output'];
  /**
   * event timeframe
   * @deprecated This field is experimental and subject to breaking changes.
   */
  timeframe?: Maybe<TimeWindow>;
  /**
   * title of chart entry
   * @deprecated This field is experimental and subject to breaking changes.
   */
  title: Scalars['String']['output'];
  /**
   * type of chart entry
   * @deprecated This field is experimental and subject to breaking changes.
   */
  type: Scalars['String']['output'];
  /**
   * ID of entity involved with the chart
   * @deprecated This field is experimental and subject to breaking changes.
   */
  vertexId?: Maybe<Scalars['String']['output']>;
};

/** An entry of chart metadata and data. */
export type AiPostmortemChartDataEntryInput = {
  /** account id of the query */
  accountId?: InputMaybe<Scalars['Int']['input']>;
  /** List of data point values */
  data: Array<Scalars['String']['input']>;
  /** name of entity involved with the chart */
  entityName?: InputMaybe<Scalars['String']['input']>;
  /** id of chart entry */
  id: Scalars['String']['input'];
  /** metadata of the event */
  metadata: Array<AiPostmortemMetadataEntryInput>;
  /** query to pull out the events */
  query: Scalars['String']['input'];
  /** event timeframe */
  timeframe?: InputMaybe<TimeWindowInput>;
  /** title of chart entry */
  title: Scalars['String']['input'];
  /** type of chart entry */
  type: Scalars['String']['input'];
  /** ID of entity involved with the chart */
  vertexId?: InputMaybe<Scalars['String']['input']>;
};

/** A collection of chart entries. */
export type AiPostmortemChartDataInput = {
  /** List of anomaly chart data entries */
  anomalyChartData: Array<AiPostmortemChartDataEntryInput>;
  /** List of entity chart data entries */
  entityChartData: Array<AiPostmortemChartDataEntryInput>;
};

/** Data content of an event */
export type AiPostmortemEventData = {
  __typename?: 'AiPostmortemEventData';
  /**
   * source of the incident
   * @deprecated This field is experimental and subject to breaking changes.
   */
  account: Array<Scalars['String']['output']>;
  /**
   * action of the anomaly
   * @deprecated This field is experimental and subject to breaking changes.
   */
  action?: Maybe<Scalars['String']['output']>;
  /**
   * url of the agent
   * @deprecated This field is experimental and subject to breaking changes.
   */
  agentUrl?: Maybe<Scalars['String']['output']>;
  /**
   * severity of the alert
   * @deprecated This field is experimental and subject to breaking changes.
   */
  alertSeverity?: Maybe<Scalars['String']['output']>;
  /**
   * status of the alert
   * @deprecated This field is experimental and subject to breaking changes.
   */
  alertStatus?: Maybe<Scalars['String']['output']>;
  /**
   * ID of the anomaly
   * @deprecated This field is experimental and subject to breaking changes.
   */
  anomalyId?: Maybe<Scalars['String']['output']>;
  /**
   * IDs of the issues associated with the incident
   * @deprecated This field is experimental and subject to breaking changes.
   */
  associatedIssues: Array<Scalars['String']['output']>;
  /**
   * category of the anomaly
   * @deprecated This field is experimental and subject to breaking changes.
   */
  category?: Maybe<Scalars['String']['output']>;
  /**
   * changelog of the deployment
   * @deprecated This field is experimental and subject to breaking changes.
   */
  changelog?: Maybe<Scalars['String']['output']>;
  /**
   * event close time
   * @deprecated This field is experimental and subject to breaking changes.
   */
  closedAt: Scalars['EpochMilliseconds']['output'];
  /**
   * condition names of the incident
   * @deprecated This field is experimental and subject to breaking changes.
   */
  conditionName: Array<Scalars['String']['output']>;
  /**
   * deep link url of the incident
   * @deprecated This field is experimental and subject to breaking changes.
   */
  deepLinkUrl: Array<Scalars['String']['output']>;
  /**
   * description of the event
   * @deprecated This field is experimental and subject to breaking changes.
   */
  description: Array<Scalars['String']['output']>;
  /**
   * label of the violation
   * @deprecated This field is experimental and subject to breaking changes.
   */
  label?: Maybe<Scalars['String']['output']>;
  /**
   * level of the violation
   * @deprecated This field is experimental and subject to breaking changes.
   */
  level?: Maybe<Scalars['String']['output']>;
  /**
   * metadata of the event
   * @deprecated This field is experimental and subject to breaking changes.
   */
  metadata: Array<AiPostmortemMetadataEntry>;
  /**
   * nrql of the anomaly
   * @deprecated This field is experimental and subject to breaking changes.
   */
  nrql?: Maybe<Scalars['Nrql']['output']>;
  /**
   * event open time
   * @deprecated This field is experimental and subject to breaking changes.
   */
  openedAt: Scalars['EpochMilliseconds']['output'];
  /**
   * permalink of the deployment
   * @deprecated This field is experimental and subject to breaking changes.
   */
  permalink?: Maybe<Scalars['String']['output']>;
  /**
   * policy names of the incident
   * @deprecated This field is experimental and subject to breaking changes.
   */
  policyName: Array<Scalars['String']['output']>;
  /**
   * priority of the incident
   * @deprecated This field is experimental and subject to breaking changes.
   */
  priority?: Maybe<Scalars['String']['output']>;
  /**
   * revision of the deployment
   * @deprecated This field is experimental and subject to breaking changes.
   */
  revision?: Maybe<Scalars['String']['output']>;
  /**
   * severity of the anomaly
   * @deprecated This field is experimental and subject to breaking changes.
   */
  severity?: Maybe<Scalars['String']['output']>;
  /**
   * source of the incident
   * @deprecated This field is experimental and subject to breaking changes.
   */
  source: Array<Scalars['String']['output']>;
  /**
   * state of the incident
   * @deprecated This field is experimental and subject to breaking changes.
   */
  state?: Maybe<Scalars['String']['output']>;
  /**
   * tag of the incident
   * @deprecated This field is experimental and subject to breaking changes.
   */
  tag: Array<AiPostmortemMetadataEntry>;
  /**
   * title of the event
   * @deprecated This field is experimental and subject to breaking changes.
   */
  title: Array<Scalars['String']['output']>;
  /**
   * user of the deployment
   * @deprecated This field is experimental and subject to breaking changes.
   */
  user?: Maybe<Scalars['String']['output']>;
  /**
   * ID of the vertex
   * @deprecated This field is experimental and subject to breaking changes.
   */
  vertexId?: Maybe<Scalars['String']['output']>;
  /**
   * ID of the violation
   * @deprecated This field is experimental and subject to breaking changes.
   */
  violationId?: Maybe<Scalars['String']['output']>;
  /**
   * url link of the violation
   * @deprecated This field is experimental and subject to breaking changes.
   */
  violationUrl?: Maybe<Scalars['String']['output']>;
};

/** Data content of an event. */
export type AiPostmortemEventDataInput = {
  /** source of the incident */
  account: Array<Scalars['String']['input']>;
  /** action of the anomaly */
  action?: InputMaybe<Scalars['String']['input']>;
  /** url of the agent */
  agentUrl?: InputMaybe<Scalars['String']['input']>;
  /** severity of the alert */
  alertSeverity?: InputMaybe<Scalars['String']['input']>;
  /** status of the alert */
  alertStatus?: InputMaybe<Scalars['String']['input']>;
  /** ID of the anomaly */
  anomalyId?: InputMaybe<Scalars['String']['input']>;
  /** IDs of the issues associated with the incident */
  associatedIssues: Array<Scalars['String']['input']>;
  /** category of the anomaly */
  category?: InputMaybe<Scalars['String']['input']>;
  /** changelog of the deployment */
  changelog?: InputMaybe<Scalars['String']['input']>;
  /** event close time */
  closedAt: Scalars['EpochMilliseconds']['input'];
  /** condition names of the incident */
  conditionName: Array<Scalars['String']['input']>;
  /** deep link url of the incident */
  deepLinkUrl: Array<Scalars['String']['input']>;
  /** description of the event */
  description: Array<Scalars['String']['input']>;
  /** label of the violation */
  label?: InputMaybe<Scalars['String']['input']>;
  /** level of the violation */
  level?: InputMaybe<Scalars['String']['input']>;
  /** metadata of the event */
  metadata: Array<AiPostmortemMetadataEntryInput>;
  /** nrql of the anomaly */
  nrql?: InputMaybe<Scalars['Nrql']['input']>;
  /** event open time */
  openedAt: Scalars['EpochMilliseconds']['input'];
  /** permalink of the deployment */
  permalink?: InputMaybe<Scalars['String']['input']>;
  /** policy names of the incident */
  policyName: Array<Scalars['String']['input']>;
  /** priority of the incident */
  priority?: InputMaybe<Scalars['String']['input']>;
  /** revision of the deployment */
  revision?: InputMaybe<Scalars['String']['input']>;
  /** severity of the anomaly */
  severity?: InputMaybe<Scalars['String']['input']>;
  /** source of the incident */
  source: Array<Scalars['String']['input']>;
  /** state of the incident */
  state?: InputMaybe<Scalars['String']['input']>;
  /** tag of the incident */
  tag: Array<AiPostmortemMetadataEntryInput>;
  /** title of the event */
  title: Array<Scalars['String']['input']>;
  /** user of the deployment */
  user?: InputMaybe<Scalars['String']['input']>;
  /** ID of vertex */
  vertexId?: InputMaybe<Scalars['String']['input']>;
  /** ID of the violation */
  violationId?: InputMaybe<Scalars['String']['input']>;
  /** url link of the violation */
  violationUrl?: InputMaybe<Scalars['String']['input']>;
};

/** An entry by a list of events happen at the specific timestamp */
export type AiPostmortemEventEntry = {
  __typename?: 'AiPostmortemEventEntry';
  /**
   * chart data of the event
   * @deprecated This field is experimental and subject to breaking changes.
   */
  chartData?: Maybe<AiPostmortemChartData>;
  /**
   * data content of the event
   * @deprecated This field is experimental and subject to breaking changes.
   */
  eventData?: Maybe<AiPostmortemEventData>;
  /**
   * type of the event
   * @deprecated This field is experimental and subject to breaking changes.
   */
  eventType: AiPostmortemEventType;
  /**
   * user note for the event
   * @deprecated This field is experimental and subject to breaking changes.
   */
  note: Scalars['String']['output'];
  /**
   * entry timestamp
   * @deprecated This field is experimental and subject to breaking changes.
   */
  timestamp: Scalars['EpochMilliseconds']['output'];
  /**
   * latest updater of the entry
   * @deprecated This field is experimental and subject to breaking changes.
   */
  updater?: Maybe<UserReference>;
  /**
   * a list of user comments
   * @deprecated This field is experimental and subject to breaking changes.
   */
  userComments: Array<AiPostmortemUserComment>;
};

/** An entry of a list of events happen at the specific timestamp. */
export type AiPostmortemEventEntryInput = {
  /** chart data of the entry */
  chartData?: InputMaybe<AiPostmortemChartDataInput>;
  /** event data of the entry */
  eventData?: InputMaybe<AiPostmortemEventDataInput>;
  /** type of the event */
  eventType: AiPostmortemEventType;
  /** user note for the event */
  note: Scalars['String']['input'];
  /** entry timestamp */
  timestamp: Scalars['EpochMilliseconds']['input'];
  /** latest updater of the entry */
  updater?: InputMaybe<Scalars['String']['input']>;
  /** a sequence of user comments for the event entry */
  userComments: Array<AiPostmortemUserCommentInput>;
};

/** An entry by a list of events happen at the specific timestamp */
export type AiPostmortemEventEntryList = {
  __typename?: 'AiPostmortemEventEntryList';
  /**
   * An entry by a list of events
   * @deprecated This field is experimental and subject to breaking changes.
   */
  entries: Array<AiPostmortemEventEntry>;
};

/** A list of entries of events happen along the timeline. */
export type AiPostmortemEventEntryListInput = {
  /** A list of entries of events */
  entries: Array<AiPostmortemEventEntryInput>;
};

/** Type of event. */
export enum AiPostmortemEventType {
  /**
   * Event type is alert_violation
   * @deprecated This field is experimental and subject to breaking changes.
   */
  AlertViolation = 'ALERT_VIOLATION',
  /**
   * Event type is anomaly
   * @deprecated This field is experimental and subject to breaking changes.
   */
  Anomaly = 'ANOMALY',
  /**
   * Event type is deployment
   * @deprecated This field is experimental and subject to breaking changes.
   */
  Deployment = 'DEPLOYMENT',
  /**
   * Event type is incident
   * @deprecated This field is experimental and subject to breaking changes.
   */
  Incident = 'INCIDENT',
  /**
   * Event type is user
   * @deprecated This field is experimental and subject to breaking changes.
   */
  User = 'USER'
}

/** Level of impact. */
export enum AiPostmortemImpactLevel {
  /**
   * Impact level is critical
   * @deprecated This field is experimental and subject to breaking changes.
   */
  Critical = 'CRITICAL',
  /**
   * Impact level is high
   * @deprecated This field is experimental and subject to breaking changes.
   */
  High = 'HIGH',
  /**
   * Impact level is low
   * @deprecated This field is experimental and subject to breaking changes.
   */
  Low = 'LOW',
  /**
   * Impact level is medium
   * @deprecated This field is experimental and subject to breaking changes.
   */
  Medium = 'MEDIUM'
}

/** A template of issue fields. */
export type AiPostmortemIssueTemplate = {
  __typename?: 'AiPostmortemIssueTemplate';
  /**
   * account id of issue
   * @deprecated This field is experimental and subject to breaking changes.
   */
  accountId: Scalars['Int']['output'];
  /**
   * closed timestamp
   * @deprecated This field is experimental and subject to breaking changes.
   */
  closedAt: Scalars['EpochMilliseconds']['output'];
  /**
   * condition ids of issue
   * @deprecated This field is experimental and subject to breaking changes.
   */
  conditionId: Array<Scalars['String']['output']>;
  /**
   * creation timestamp
   * @deprecated This field is experimental and subject to breaking changes.
   */
  createdAt: Scalars['EpochMilliseconds']['output'];
  /**
   * description of issue
   * @deprecated This field is experimental and subject to breaking changes.
   */
  description: Array<Scalars['String']['output']>;
  /**
   * id of issue
   * @deprecated This field is experimental and subject to breaking changes.
   */
  id: Scalars['String']['output'];
  /**
   * metadata entries
   * @deprecated This field is experimental and subject to breaking changes.
   */
  metadata: Array<AiPostmortemMetadataEntry>;
  /**
   * policy ids of issue
   * @deprecated This field is experimental and subject to breaking changes.
   */
  policyId: Array<Scalars['String']['output']>;
  /**
   * priority of issue
   * @deprecated This field is experimental and subject to breaking changes.
   */
  priority: Scalars['String']['output'];
  /**
   * id of issue
   * @deprecated This field is experimental and subject to breaking changes.
   */
  state: Scalars['String']['output'];
  /**
   * title of issue
   * @deprecated This field is experimental and subject to breaking changes.
   */
  title: Array<Scalars['String']['output']>;
  /**
   * a list of vertex IDs
   * @deprecated This field is experimental and subject to breaking changes.
   */
  vertexId: Array<Scalars['String']['output']>;
};

/** A template of issue fields. */
export type AiPostmortemIssueTemplateInput = {
  /** account id of issue */
  accountId: Scalars['Int']['input'];
  /** closed timestamp */
  closedAt: Scalars['EpochMilliseconds']['input'];
  /** condition ids of issue */
  conditionId: Array<Scalars['String']['input']>;
  /** creation timestamp */
  createdAt: Scalars['EpochMilliseconds']['input'];
  /** description of issue */
  description: Array<Scalars['String']['input']>;
  /** id of issue */
  id: Scalars['String']['input'];
  /** metadata entries */
  metadata: Array<AiPostmortemMetadataEntryInput>;
  /** policy ids of issue */
  policyId: Array<Scalars['String']['input']>;
  /** priority of issue */
  priority: Scalars['String']['input'];
  /** id of issue */
  state: Scalars['String']['input'];
  /** title of issue */
  title: Array<Scalars['String']['input']>;
  /** a list of vertex IDs */
  vertexId: Array<Scalars['String']['input']>;
};

/** A piece of metadata attribute key and value. */
export type AiPostmortemMetadataEntry = {
  __typename?: 'AiPostmortemMetadataEntry';
  /**
   * key name of the metadata entry
   * @deprecated This field is experimental and subject to breaking changes.
   */
  name: Scalars['String']['output'];
  /**
   * value of the metadata entry
   * @deprecated This field is experimental and subject to breaking changes.
   */
  value: Array<Scalars['String']['output']>;
};

/** A piece of metadata attribute key and value. */
export type AiPostmortemMetadataEntryInput = {
  /** key name of the metadata entry */
  name: Scalars['String']['input'];
  /** value of the metadata entry */
  value: Array<Scalars['String']['input']>;
};

/** An entry of user note happened at the specific timestamp */
export type AiPostmortemNoteEvent = {
  __typename?: 'AiPostmortemNoteEvent';
  /**
   * a user note with creator info
   * @deprecated This field is experimental and subject to breaking changes.
   */
  entry: AiPostmortemNoteOutput;
  /**
   * event timestamp
   * @deprecated This field is experimental and subject to breaking changes.
   */
  timestamp: Scalars['EpochMilliseconds']['output'];
};

/** An entry of a note event happen at the specific timestamp. */
export type AiPostmortemNoteEventInput = {
  /** a user note entry happened at the specific timestamp */
  entry: AiPostmortemNoteInput;
  /** event timestamp */
  timestamp: Scalars['EpochMilliseconds']['input'];
};

/** An entry marking a user note on action with the creator user info. */
export type AiPostmortemNoteInput = {
  /** The individual who writes the note */
  creator: Scalars['String']['input'];
  /** The contents of the note */
  note: Scalars['String']['input'];
};

/** An entry marking a user note on action with the creator user info. */
export type AiPostmortemNoteOutput = {
  __typename?: 'AiPostmortemNoteOutput';
  /**
   * The individual who writes the note
   * @deprecated This field is experimental and subject to breaking changes.
   */
  creator: Scalars['String']['output'];
  /**
   * The contents of the note
   * @deprecated This field is experimental and subject to breaking changes.
   */
  note: Scalars['String']['output'];
};

/** Result of an operation. */
export type AiPostmortemOperationResult = {
  __typename?: 'AiPostmortemOperationResult';
  /**
   * Status of the operation.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  result: AiPostmortemResultType;
};

/** Blueprint for postmortem creation. */
export type AiPostmortemPostmortemBlueprint = {
  /** Future action items of the incident or outage */
  actionItems?: InputMaybe<Scalars['String']['input']>;
  /** IDs of alert conditions involved during the incident or outage. */
  alertConditionIds: Array<Scalars['ID']['input']>;
  /** IDs of alert policies involved during the incident or outage. */
  alertPolicyIds: Array<Scalars['ID']['input']>;
  /** authors contributed to the postmortem. */
  authors: Array<AiPostmortemUserInput>;
  /** creator of the postmortem piece. */
  creator: Scalars['String']['input'];
  /** Names of the entities affected by the incident or outage. */
  entityNames: Array<Scalars['String']['input']>;
  /** links to activity events. */
  events: AiPostmortemEventEntryListInput;
  /** customer impact by the incident or outage the postmortem is reporting for. */
  impact?: InputMaybe<Scalars['String']['input']>;
  /** impact level of the outage or incident the postmortem reports for. */
  impactLevel: AiPostmortemImpactLevel;
  /** IDs of issues relevant to the outage. */
  issueIds: Array<Scalars['ID']['input']>;
  /** a list of issues relevant to the incident or outage */
  issues: Array<AiPostmortemIssueTemplateInput>;
  /** latest updater of the postmortem piece. */
  latestUpdater: Scalars['String']['input'];
  /** recovery actions taken for the incident or outage */
  recovery?: InputMaybe<Scalars['String']['input']>;
  /** root cause of the incident or outage the postmortem is reporting for. */
  rootCause?: InputMaybe<Scalars['String']['input']>;
  /** rosters to resolve the outage or incident. */
  rosters: Array<AiPostmortemUserInput>;
  /** stat events. */
  stats: AiPostmortemEventEntryListInput;
  /** status of the postmortem. */
  status: AiPostmortemStatus;
  /** time frame of the incident or outage. */
  timeframe?: InputMaybe<TimeWindowInput>;
  /** title of the postmortem piece. */
  title: Scalars['String']['input'];
  /** user notes as an event. */
  userNotes: Array<AiPostmortemNoteEventInput>;
  /** IDs of the entities affected by the incident or outage. */
  vertexIds: Array<Scalars['ID']['input']>;
  /** a list of vertices relevant to the incident or outage */
  vertices: Array<AiPostmortemVertexTemplateInput>;
};

/** Windowed view of an account's postmortems. */
export type AiPostmortemPostmortemListing = {
  __typename?: 'AiPostmortemPostmortemListing';
  /**
   * Number of postmortems in this window.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  count: Scalars['Int']['output'];
  /**
   * Cursor used to fetch next page.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  nextCursor?: Maybe<Scalars['String']['output']>;
  /**
   * List of postmortems in this window.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  postmortems: Array<AiPostmortemPostmortemTemplate>;
  /**
   * Cursor used to fetch previous page.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  prevCursor?: Maybe<Scalars['String']['output']>;
};

/** Sorting method for postmortems. */
export enum AiPostmortemPostmortemSortMethod {
  /**
   * Sort postmortems by id
   * @deprecated This field is experimental and subject to breaking changes.
   */
  Id = 'ID',
  /**
   * Sort postmortems by latest_created
   * @deprecated This field is experimental and subject to breaking changes.
   */
  LatestCreated = 'LATEST_CREATED'
}

/** A postmortem template piece reported after an outage or incident. */
export type AiPostmortemPostmortemTemplate = {
  __typename?: 'AiPostmortemPostmortemTemplate';
  /**
   * Future action items of the outage or incident.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  actionItems?: Maybe<Scalars['String']['output']>;
  /**
   * IDs of alert conditions involved during the incident or outage
   * @deprecated This field is experimental and subject to breaking changes.
   */
  alertConditionIds: Array<Scalars['ID']['output']>;
  /**
   * IDs of alert policies involved during the incident or outage
   * @deprecated This field is experimental and subject to breaking changes.
   */
  alertPolicyIds: Array<Scalars['ID']['output']>;
  /**
   * Authors contributed to the postmortem.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  authors: Array<AiPostmortemUser>;
  /**
   * Time postmortem was created.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  createdAt: Scalars['EpochMilliseconds']['output'];
  /**
   * Creator of postmortem.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  creator?: Maybe<UserReference>;
  /**
   * Impacted entities names during the incident or outage
   * @deprecated This field is experimental and subject to breaking changes.
   */
  entityNames: Array<Scalars['String']['output']>;
  /**
   * Activity events during the incident or outage.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  events: AiPostmortemEventEntryList;
  /**
   * ID of postmortem.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  id: Scalars['ID']['output'];
  /**
   * Impact description of the outage or incident.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  impact?: Maybe<Scalars['String']['output']>;
  /**
   * Impact level of the outage or incident.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  impactLevel: AiPostmortemImpactLevel;
  /**
   * IDs of issues relevant to the incident or outage
   * @deprecated This field is experimental and subject to breaking changes.
   */
  issueIds: Array<Scalars['ID']['output']>;
  /**
   * A list of issues relevant to the incident or outage
   * @deprecated This field is experimental and subject to breaking changes.
   */
  issues: Array<AiPostmortemIssueTemplate>;
  /**
   * Latest updater of postmortem.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  latestUpdater?: Maybe<UserReference>;
  /**
   * User notes put alongside the postmortem timeline.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  notes: Array<AiPostmortemNoteEvent>;
  /**
   * Recovery actions of the outage or incident.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  recovery?: Maybe<Scalars['String']['output']>;
  /**
   * Root cause of the outage or incident.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  rootCause?: Maybe<Scalars['String']['output']>;
  /**
   * Rosters to resolve the outage or incident.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  rosters: Array<AiPostmortemUser>;
  /**
   * Stat events during the incident or outage.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  stats: AiPostmortemEventEntryList;
  /**
   * Status of the postmortem.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  status: AiPostmortemStatus;
  /**
   * Time frame of the outage or incident to specify.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  timeframe?: Maybe<TimeWindow>;
  /**
   * Title of postmortem.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  title: Scalars['String']['output'];
  /**
   * Time postmortem was last updated.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  updatedAt: Scalars['EpochMilliseconds']['output'];
  /**
   * IDs of impacted entities during the incident or outage
   * @deprecated This field is experimental and subject to breaking changes.
   */
  vertexIds: Array<Scalars['ID']['output']>;
  /**
   * A list of vertices relevant to the incident or outage
   * @deprecated This field is experimental and subject to breaking changes.
   */
  vertices: Array<AiPostmortemVertexTemplate>;
};

/** Status of an operation. */
export enum AiPostmortemResultType {
  /**
   * Failed operation
   * @deprecated This field is experimental and subject to breaking changes.
   */
  Failure = 'FAILURE',
  /**
   * Successful operation
   * @deprecated This field is experimental and subject to breaking changes.
   */
  Success = 'SUCCESS'
}

/** Status of the postmortem. */
export enum AiPostmortemStatus {
  /**
   * Postmortem status is completed
   * @deprecated This field is experimental and subject to breaking changes.
   */
  Completed = 'COMPLETED',
  /**
   * Postmortem status is draft
   * @deprecated This field is experimental and subject to breaking changes.
   */
  Draft = 'DRAFT',
  /**
   * Postmortem status is ongoing_incident
   * @deprecated This field is experimental and subject to breaking changes.
   */
  OngoingIncident = 'ONGOING_INCIDENT',
  /**
   * Postmortem status is under_review
   * @deprecated This field is experimental and subject to breaking changes.
   */
  UnderReview = 'UNDER_REVIEW'
}

/** A user type wrapping StitchBackUser type. */
export type AiPostmortemUser = {
  __typename?: 'AiPostmortemUser';
  /**
   * user information
   * @deprecated This field is experimental and subject to breaking changes.
   */
  user?: Maybe<UserReference>;
};

/** A user comment with timestamp */
export type AiPostmortemUserComment = {
  __typename?: 'AiPostmortemUserComment';
  /**
   * user comment content
   * @deprecated This field is experimental and subject to breaking changes.
   */
  comment: Scalars['String']['output'];
  /**
   * creator of the comment
   * @deprecated This field is experimental and subject to breaking changes.
   */
  creator?: Maybe<UserReference>;
  /**
   * entry timestamp
   * @deprecated This field is experimental and subject to breaking changes.
   */
  timestamp: Scalars['EpochMilliseconds']['output'];
};

/** A user comment for a timeline event. */
export type AiPostmortemUserCommentInput = {
  /** user comment content */
  comment: Scalars['String']['input'];
  /** creator of the comment */
  creator?: InputMaybe<Scalars['String']['input']>;
  /** entry timestamp */
  timestamp: Scalars['EpochMilliseconds']['input'];
};

/** A user type wrapping StitchBackUser type. */
export type AiPostmortemUserInput = {
  /** user ID */
  user: Scalars['String']['input'];
};

/** A vertex template with essential attributes. */
export type AiPostmortemVertexTemplate = {
  __typename?: 'AiPostmortemVertexTemplate';
  /**
   * id of vertex
   * @deprecated This field is experimental and subject to breaking changes.
   */
  id: Scalars['String']['output'];
  /**
   * metadata entry
   * @deprecated This field is experimental and subject to breaking changes.
   */
  metadata: Array<AiPostmortemMetadataEntry>;
  /**
   * name of vertex
   * @deprecated This field is experimental and subject to breaking changes.
   */
  name: Scalars['String']['output'];
};

/** A vertex template with essential attributes. */
export type AiPostmortemVertexTemplateInput = {
  /** id of vertex */
  id: Scalars['String']['input'];
  /** metadata entries */
  metadata: Array<AiPostmortemMetadataEntryInput>;
  /** name of vertex */
  name: Scalars['String']['input'];
};

export type AiProfileAnalysisAccountStitchedFields = {
  __typename?: 'AiProfileAnalysisAccountStitchedFields';
  /**
   * Attribute breakdowns use statistical sampling techniques to summarize a data set.
   *  For each attribute, the results contain a summary of the most common values and
   *  their frequencies. Numeric attribute breakdowns also provide common descriptive
   *  statistics including estimates of the min, max, and average values; the standard
   *  deviation; and rank statistics such as the median, 95th, and 99th percentiles.
   *
   *  Use an attribute breakdown to explore a data set, find the most common values,
   *  visualize the shape of the data, discover unusual or unexpected patterns in the
   *  attribute values, and find relationships between attributes.
   *
   *  Because attribute breakdowns use statistical sampling, the results may differ from
   *  executing an equivalent NRQL query over the complete data set.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  attributeBreakdown: AiProfileAnalysisAttributeBreakdown;
};


export type AiProfileAnalysisAccountStitchedFieldsAttributeBreakdownArgs = {
  breakdown: AiProfileAnalysisAttributeBreakdownInput;
};

/**
 * A summary of the attributes in a data set, and their main characteristics.
 *
 * For each attribute, the breakdown contains a summary of the most common values and
 * their frequencies. Numeric attribute breakdowns also provide common descriptive
 * statistics including estimates of the min, max, and average values; the standard
 * deviation; and rank statistics such as the median, 95th, and 99th percentiles.
 *
 * Use an attribute breakdown to explore a data set, find the most common values,
 * visualize the shape of the data, discover unusual or unexpected patterns in the
 * attribute values, and find relationships between attributes.
 */
export type AiProfileAnalysisAttributeBreakdown = {
  __typename?: 'AiProfileAnalysisAttributeBreakdown';
  /**
   * A summary of each attribute found in a data set.
   *
   *  If the data set was empty, this list will also be empty.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  attributes: Array<AiProfileAnalysisAttributeDetails>;
};

/** AttributeBreakdownInput configures the data set to analyze. */
export type AiProfileAnalysisAttributeBreakdownInput = {
  /**
   * The type of data.
   *
   *  This corresponds to the data type in a NRQL `FROM` clause. Common choices
   *  are `Transaction` for APM application data, `TransactionError` for APM
   *  application error data, and `Metric` for general metric data.
   *
   *  Unlike the NRQL `FROM` clause, specifying multiple data types in a comma separated
   *  list is not supported.
   */
  dataType: Scalars['String']['input'];
  /**
   * A NRQL expression to filter the data that matches the specified data type
   *  and time range.
   *
   *  In NRQL this corresponds to the boolean expression in a `WHERE` clause. When `null`
   *  or unset, matches everything within the specified data type and time window.
   */
  filter?: InputMaybe<Scalars['Nrql']['input']>;
  /**
   * The time range for the data set represented in milliseconds since the Unix epoch.
   *
   *  In NRQL this corresponds to the `SINCE` and `UNTIL` clauses.
   */
  timeWindow: TimeWindowInput;
};

/** Summarizes the most common values for an attribute. */
export type AiProfileAnalysisAttributeDetails = {
  /**
   * The name of the attribute.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  attributeName: Scalars['String']['output'];
};

/** Summarizes the most common values for an attribute. */
export type AiProfileAnalysisCategoricalAttributeDetails = AiProfileAnalysisAttributeDetails & {
  __typename?: 'AiProfileAnalysisCategoricalAttributeDetails';
  /**
   * The name of the attribute.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  attributeName: Scalars['String']['output'];
  /**
   * The most common values for this attribute and their frequencies.
   *  For attributes with high cardinality, the least common attributes may be combined
   *  into a rollup category.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  distribution: AiProfileAnalysisCategoricalDistribution;
};

/**
 * A frequency count breakdown of the unique values for an attribute in a data set.
 *
 * For brevity, the least common values may be combined into a single bin. Their
 * combined frequency count may be accessed in two ways. First, through the `otherValuesCount`
 * field on this object. Second, the `bins` field will contain an element of type
 * `OTHER_VALUES` whose `observedCount` field will match `otherValuesCount`.
 */
export type AiProfileAnalysisCategoricalDistribution = {
  __typename?: 'AiProfileAnalysisCategoricalDistribution';
  /**
   * A frequency count summary of an attribute in a data set.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  bins: Array<AiProfileAnalysisCategoricalDistributionBin>;
  /**
   * The number of examples analyzed where no value was present. When this count is
   *  greater than zero, `bins` will contain a corresponding element of type `MISSING_VALUES`.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  missingValueCount: Scalars['Int']['output'];
  /**
   * The number of examples analyzed where the value was rolled up into a multi-value category.
   *  When this count is greater than zero, `bins` will contain a corresponding element of type
   *  `OTHER_VALUES`.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  otherValuesCount: Scalars['Int']['output'];
  /**
   * The total number of examples summarized by this distribution, including
   *  missing values. This value equals the sum of the `observedCount` fields
   *  from all the elements in `bins`.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  totalCount: Scalars['Int']['output'];
};

/**
 * Describes the frequency of one or more values for an attribute in a data set. Or,
 * may describe the number of examples in a data set where an attribute is not present.
 *
 * When two or more data sets are being compared, the observed frequency is supplemented
 * with an estimate of the expected frequency. The difference between the observed and expected
 * counts helps to quantify how surprising the observed count is.
 */
export type AiProfileAnalysisCategoricalDistributionBin = {
  __typename?: 'AiProfileAnalysisCategoricalDistributionBin';
  /**
   * One of `VALUE`, `MISSING_VALUES`, or `OTHER_VALUES`.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  binType: AiProfileAnalysisDistributionBinType;
  /**
   * A description of the value or values in this bin suitable for display.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  label: Scalars['String']['output'];
  /**
   * The number of examples analyzed that matched this category.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  observedCount: Scalars['Int']['output'];
};

/** Whether a frequency count describes a single value, a combination values, or the absence of a value. */
export enum AiProfileAnalysisDistributionBinType {
  /**
   * A bin that describes the number of occurances where an attribute or a
   *  tuple was not present.
   *
   *  In NRQL, this corresponds to the `IS NULL` operator.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  MissingValues = 'MISSING_VALUES',
  /**
   * A bin that describes the combined number of occurances of a continuous
   *  range of numeric values.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  NumericRange = 'NUMERIC_RANGE',
  /**
   * A bin that describes the combined number of occurances of multiple values.
   *  Rollups are used to reduce noise in the results when an attribute or tuple
   *  has high cardinality, and many or all of the value are uninteresting.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  OtherValues = 'OTHER_VALUES',
  /**
   * A bin that describes the number of occurances of a single scalar value,
   *  or a single tuple value.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  Value = 'VALUE'
}

/** Summarizes an attribute consisting of numeric values. */
export type AiProfileAnalysisNumericAttributeDetails = AiProfileAnalysisAttributeDetails & {
  __typename?: 'AiProfileAnalysisNumericAttributeDetails';
  /**
   * The name of the attribute.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  attributeName: Scalars['String']['output'];
  /**
   * A histogram summary of the attribute values.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  distribution: AiProfileAnalysisNumericDistribution;
  /**
   * Descriptive statistics for the attribute values. Includes the minimum value,
   *  maximum value, average value, standard deviation, and some common percentiles.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  summaryStats: AiProfileAnalysisNumericSummaryStatistics;
};

/**
 * A histogram summary. The histogram bin boundaries are selected to give a good
 * approximation of the underlying distribution, while also being helpful in highlighting
 * changes in a visual comparison.
 */
export type AiProfileAnalysisNumericDistribution = {
  __typename?: 'AiProfileAnalysisNumericDistribution';
  /**
   * The histogram bins. Each bin represents either a single value (type `VALUE`) or
   *  a range of values (type `NUMERIC_RANGE`). The bins are contiguous, meaning there
   *  are no gaps between them. Some bins may be empty.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  bins: Array<AiProfileAnalysisNumericDistributionBin>;
  /**
   * The maximum value summarized by this distribution.
   *
   *  In NRQL, this corresponds to the `max` aggregate function.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  max: Scalars['Float']['output'];
  /**
   * The minimum value summarized by this distribution.
   *
   *  In NRQL, this corresponds to the `min` aggregate function.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  min: Scalars['Float']['output'];
  /**
   * The number of examples analyzed where no value was present.
   *  When this count is greater than zero, `bins` will contain a
   *  corresponding element of type `MISSING_VALUES`.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  missingValueCount: Scalars['Int']['output'];
  /**
   * The total number of values summarized by this distribution, including
   *  the number of missing values. This value equals the sum of the `observedCount`
   *  fields from all the elements in `bins`.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  totalCount: Scalars['Int']['output'];
};

/**
 * Summarizes the number of examples of a numeric attribute that were observed
 * to lie within a continuous numeric range. Similar to a histogram bin.
 */
export type AiProfileAnalysisNumericDistributionBin = {
  __typename?: 'AiProfileAnalysisNumericDistributionBin';
  /**
   * One of `VALUE`, `NUMERIC_RANGE` or `MISSING_VALUES`. A bin type of `VALUE`
   *  indicates the bin contains exactly one unique value.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  binType: AiProfileAnalysisDistributionBinType;
  /**
   * An english description of the numeric range represented by this bin,
   *  suitable for display.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  label: Scalars['String']['output'];
  /**
   * The (inclusive) minimum value for the numeric range represented by this bin.
   *  This will be `null` to indicate the range is unbounded from below, meaning
   *  the range extends downward to negative infinity.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  lowerBound?: Maybe<Scalars['Float']['output']>;
  /**
   * The number of examples analyzed that were observed to lie within the numeric
   *  range represented by this bin.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  observedCount: Scalars['Int']['output'];
  /**
   * The (exclusive) maximum value for the numeric range represented by this bin.
   *  This will be `null` to indicate the range is unbounded from above, meaning
   *  the range extends upward to positive infinity.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  upperBound?: Maybe<Scalars['Float']['output']>;
};

/**
 * Descriptive statistics for a collection of numeric values. Includes the minimum value,
 * maximum value, average value, standard deviation, and some common percentiles.
 */
export type AiProfileAnalysisNumericSummaryStatistics = {
  __typename?: 'AiProfileAnalysisNumericSummaryStatistics';
  /**
   * The mean of the observed values.
   *
   *  Corresponds to the `average` aggregator function in NRQL.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  average: Scalars['Float']['output'];
  /**
   * The maximum value of the observed data.
   *
   *  Corresponds to the `min` aggregator function.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  max: Scalars['Float']['output'];
  /**
   * The minimum value of the observed data.
   *
   *  Corresponds to the `min` aggregator function in NRQL.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  min: Scalars['Float']['output'];
  /**
   * The 25th percentile value (first quartile) of the observed values. In the
   *  analyzed data set, 25% of the examples had a value for this attribute less
   *  than or equal to this value, and 75% had a value for this attribute greater
   *  than or equal to this value.
   *
   *  Corresponds to the `percentile` aggregator function in NRQL.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  p25: Scalars['Float']['output'];
  /**
   * The 50th percentile value of the observed values. This is the middle
   *  value of the analyzed data, separating the data into equal sized
   *  lower and upper halves.
   *
   *  Corresponds to the `percentile` aggregator function in NRQL.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  p50: Scalars['Float']['output'];
  /**
   * The 75th percentile value (third quartile) of the observed values. In the
   *  analyzed data set, 75% of the examples had a value for this attribute less
   *  than or equal to this value, and 25% had a value for this attribute greater
   *  than or equal to this value.
   *
   *  Corresponds to the `percentile` aggregator function in NRQL.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  p75: Scalars['Float']['output'];
  /**
   * The 95th percentile value of the observed values. When the number of values
   *  analyzed is small (fewer than one hundred), this value may be equal to the
   *  maximum.
   *
   *  Corresponds to the `percentile` aggregator function in NRQL.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  p95: Scalars['Float']['output'];
  /**
   * The 99th percentile value of the observed values. When the number of values
   *  analyzed is small (fewer than one hundred), this value may be equal to the
   *  maximum.
   *
   *  Corresponds to the `percentile` aggregator function in NRQL.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  p99: Scalars['Float']['output'];
  /**
   * The standard deviation of the observed values.
   *
   *  Corresponds to the `stddev` aggregator function in NRQL.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  standardDeviation: Scalars['Float']['output'];
};

export type AiTopologyAccountStitchedFields = {
  __typename?: 'AiTopologyAccountStitchedFields';
  /** Returns a list of edges. */
  edges: AiTopologyEdgeListing;
  /** Returns a graph. */
  graph: AiTopologyGraph;
  /** Returns a paginated list of vertices. */
  vertices: AiTopologyVertexListing;
};


export type AiTopologyAccountStitchedFieldsEdgesArgs = {
  cursor?: InputMaybe<Scalars['String']['input']>;
  edgeIds?: InputMaybe<Array<Scalars['ID']['input']>>;
};


export type AiTopologyAccountStitchedFieldsVerticesArgs = {
  cursor?: InputMaybe<Scalars['String']['input']>;
  vertexClasses?: InputMaybe<Array<AiTopologyVertexClass>>;
  vertexIds?: InputMaybe<Array<Scalars['ID']['input']>>;
};

/** A key-value entry. */
export type AiTopologyCollectorAttributeInput = {
  /** Key of entry. */
  key: Scalars['String']['input'];
  /** Value of entry. */
  value: Scalars['String']['input'];
};

/** Blueprint for edge creation. */
export type AiTopologyCollectorEdgeBlueprint = {
  /** Whether or not from and to have any semantic meaning. */
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  /** The source vertex name. */
  fromVertexName: Scalars['String']['input'];
  /** The destination vertex name. */
  toVertexName: Scalars['String']['input'];
};

/** Result of an operation. */
export type AiTopologyCollectorOperationResult = {
  __typename?: 'AiTopologyCollectorOperationResult';
  /** Status of the operation. */
  result: AiTopologyCollectorResultType;
};

/** Status of an operation. */
export enum AiTopologyCollectorResultType {
  /** Failed operation */
  Failure = 'FAILURE',
  /** Successful operation */
  Success = 'SUCCESS'
}

/** Blueprint for vertex creation. */
export type AiTopologyCollectorVertexBlueprint = {
  /** Attributes to define the vertex. */
  definingAttributes: Array<AiTopologyCollectorAttributeInput>;
  /** The name of the vertex. */
  name: Scalars['String']['input'];
  /** The class of the vertex. */
  vertexClass: AiTopologyCollectorVertexClass;
};

/** Class of vertex. */
export enum AiTopologyCollectorVertexClass {
  /** Vertex class is application */
  Application = 'APPLICATION',
  /** Vertex class is cloudservice */
  Cloudservice = 'CLOUDSERVICE',
  /** Vertex class is cluster */
  Cluster = 'CLUSTER',
  /** Vertex class is datastore */
  Datastore = 'DATASTORE',
  /** Vertex class is host */
  Host = 'HOST',
  /** Vertex class is team */
  Team = 'TEAM'
}

/** A key-value entry representing an attribute name and value. */
export type AiTopologyDefiningAttribute = {
  __typename?: 'AiTopologyDefiningAttribute';
  /** Key of entry. */
  key: Scalars['String']['output'];
  /** Value of entry. */
  value: Scalars['String']['output'];
};

/** A connection between two vertices within a graph */
export type AiTopologyEdge = {
  __typename?: 'AiTopologyEdge';
  /** Whether or not the direction of the edge has semantic meaning. */
  directed: Scalars['Boolean']['output'];
  /** ID of parent vertex. */
  fromVertexId: Scalars['ID']['output'];
  /** Name of parent vertex. */
  fromVertexName: Scalars['String']['output'];
  /** ID of edge. */
  id: Scalars['ID']['output'];
  /** ID of child vertex. */
  toVertexId: Scalars['ID']['output'];
  /** Name of child vertex. */
  toVertexName: Scalars['String']['output'];
  /** Time rule was last updated. */
  updatedAt: Scalars['EpochMilliseconds']['output'];
};

/** Listing of edges in a graph. */
export type AiTopologyEdgeListing = {
  __typename?: 'AiTopologyEdgeListing';
  /** Number of edges returned by the query. */
  count: Scalars['Int']['output'];
  /** Next cursor. */
  cursor?: Maybe<Scalars['String']['output']>;
  /** List of edges. */
  edges: Array<AiTopologyEdge>;
};

/** Overview of a graph; all edges and vertices. */
export type AiTopologyGraph = {
  __typename?: 'AiTopologyGraph';
  /** List of all edges in this graph. */
  edges: Array<AiTopologyEdge>;
  /** List of all vertices in this graph. */
  vertices: Array<AiTopologyVertex>;
};

/** A vertex is a representation of a node in a graph: a host; an application; etc. */
export type AiTopologyVertex = {
  __typename?: 'AiTopologyVertex';
  /** The attributes used to define a vertex as a key-value entry. */
  definingAttributes: Array<AiTopologyDefiningAttribute>;
  /** ID of vertex. */
  id: Scalars['ID']['output'];
  /** Name of the vertex. */
  name: Scalars['String']['output'];
  /** Time rule was last updated. */
  updatedAt: Scalars['EpochMilliseconds']['output'];
  /** Class of the vertex. */
  vertexClass: AiTopologyVertexClass;
};

/** Class of vertex. */
export enum AiTopologyVertexClass {
  /** Vertex class is application */
  Application = 'APPLICATION',
  /** Vertex class is cloudservice */
  Cloudservice = 'CLOUDSERVICE',
  /** Vertex class is cluster */
  Cluster = 'CLUSTER',
  /** Vertex class is datastore */
  Datastore = 'DATASTORE',
  /** Vertex class is host */
  Host = 'HOST',
  /** Vertex class is team */
  Team = 'TEAM'
}

/** Listing of vertices in a graph. */
export type AiTopologyVertexListing = {
  __typename?: 'AiTopologyVertexListing';
  /** Number of vertices returned by this query. */
  count: Scalars['Int']['output'];
  /** Next cursor. */
  cursor?: Maybe<Scalars['String']['output']>;
  /** List of vertices. */
  vertices: Array<AiTopologyVertex>;
};

export type AiWorkflowsAccountStitchedFields = {
  __typename?: 'AiWorkflowsAccountStitchedFields';
  /** - Returns a list of workflows matching the criteria provided */
  predictedWorkflowMatches?: Maybe<AiWorkflowsWorkflowMatches>;
  /** Returns a list of workflows with pagination cursor according to account id and filters */
  workflows?: Maybe<AiWorkflowsWorkflows>;
};


export type AiWorkflowsAccountStitchedFieldsPredictedWorkflowMatchesArgs = {
  matchCriteria: AiWorkflowsMatchCriteria;
};


export type AiWorkflowsAccountStitchedFieldsWorkflowsArgs = {
  cursor?: InputMaybe<Scalars['String']['input']>;
  filters?: InputMaybe<AiWorkflowsFilters>;
};

/** Enrichment configuration object */
export type AiWorkflowsConfiguration = AiWorkflowsNrqlConfiguration;

/** Type of create error */
export enum AiWorkflowsCreateErrorType {
  /** We couldn't find a channel with the given id */
  ChannelNotFound = 'CHANNEL_NOT_FOUND',
  /** A workflow with this name already exists */
  Duplicate = 'DUPLICATE',
  /** One or more of the parameters you provided are incorrect */
  InvalidParameter = 'INVALID_PARAMETER',
  /** Reached the maximum number of workflows per account */
  LimitReached = 'LIMIT_REACHED',
  /** This account is missing the required entitlement(s) to perform this action */
  MissingEntitlement = 'MISSING_ENTITLEMENT',
  /** This account in not authorized to perform this action */
  UnauthorizedAccount = 'UNAUTHORIZED_ACCOUNT',
  /** The given channel id represents an unsupported channel type */
  UnsupportedChannelType = 'UNSUPPORTED_CHANNEL_TYPE',
  /** The parameter provided does not have a valid form */
  ValidationError = 'VALIDATION_ERROR'
}

/** Create error description */
export type AiWorkflowsCreateResponseError = AiWorkflowsResponseError & {
  __typename?: 'AiWorkflowsCreateResponseError';
  /** The error description */
  description: Scalars['String']['output'];
  /** The error type */
  type: AiWorkflowsCreateErrorType;
};

/** Workflow input object */
export type AiWorkflowsCreateWorkflowInput = {
  /** destinationConfigurations */
  destinationConfigurations: Array<AiWorkflowsDestinationConfigurationInput>;
  /** destinationsEnabled */
  destinationsEnabled?: InputMaybe<Scalars['Boolean']['input']>;
  /** enrichments */
  enrichments?: InputMaybe<AiWorkflowsEnrichmentsInput>;
  /** enrichmentsEnabled */
  enrichmentsEnabled?: InputMaybe<Scalars['Boolean']['input']>;
  /** issuesFilter */
  issuesFilter?: InputMaybe<AiWorkflowsFilterInput>;
  /** mutingRulesHandling */
  mutingRulesHandling: AiWorkflowsMutingRulesHandling;
  /** name */
  name: Scalars['String']['input'];
  /** workflowEnabled */
  workflowEnabled?: InputMaybe<Scalars['Boolean']['input']>;
};

/** Create workflow mutation response including errors */
export type AiWorkflowsCreateWorkflowResponse = {
  __typename?: 'AiWorkflowsCreateWorkflowResponse';
  /** A list of errors that occurred while performing the create workflow action */
  errors: Array<AiWorkflowsCreateResponseError>;
  /** Successfully created workflow */
  workflow?: Maybe<AiWorkflowsWorkflow>;
};

/** Type of delete error */
export enum AiWorkflowsDeleteErrorType {
  /** One or more of the parameters you provided are incorrect */
  InvalidParameter = 'INVALID_PARAMETER',
  /** This account in not authorized to perform this action */
  UnauthorizedAccount = 'UNAUTHORIZED_ACCOUNT',
  /** The parameter provided does not have a valid form */
  ValidationError = 'VALIDATION_ERROR'
}

/** Delete error description */
export type AiWorkflowsDeleteResponseError = AiWorkflowsResponseError & {
  __typename?: 'AiWorkflowsDeleteResponseError';
  /** The error description */
  description: Scalars['String']['output'];
  /** The error type */
  type: AiWorkflowsDeleteErrorType;
};

/** Delete workflow mutation response including errors */
export type AiWorkflowsDeleteWorkflowResponse = {
  __typename?: 'AiWorkflowsDeleteWorkflowResponse';
  /** A list of errors that occurred while performing the delete workflow action */
  errors: Array<AiWorkflowsDeleteResponseError>;
  /** Id of the successfully deleted workflow */
  id?: Maybe<Scalars['ID']['output']>;
};

/** Destination Configuration Object */
export type AiWorkflowsDestinationConfiguration = {
  __typename?: 'AiWorkflowsDestinationConfiguration';
  /** Channel Id of the Destination Configuration */
  channelId: Scalars['ID']['output'];
  /** Name of the Destination Configuration */
  name: Scalars['String']['output'];
  /** Notification triggers of the Destination Configuration */
  notificationTriggers?: Maybe<Array<AiWorkflowsNotificationTrigger>>;
  /** Type of the Destination Configuration */
  type: AiWorkflowsDestinationType;
};

/** Destination Configuration input object */
export type AiWorkflowsDestinationConfigurationInput = {
  /** channelId */
  channelId: Scalars['ID']['input'];
  /** notificationTriggers */
  notificationTriggers?: InputMaybe<Array<AiWorkflowsNotificationTrigger>>;
};

/** Type of Destination Configuration */
export enum AiWorkflowsDestinationType {
  /** Email Destination Configuration type */
  Email = 'EMAIL',
  /** Event Bridge Destination Configuration type */
  EventBridge = 'EVENT_BRIDGE',
  /** Jira Destination Configuration type */
  Jira = 'JIRA',
  /**
   * New Relic Mobile Push Destination Configuration type
   * @deprecated This type is under development
   */
  MobilePush = 'MOBILE_PUSH',
  /**
   * Pager Duty Destination Configuration type
   * @deprecated Unused destination type
   */
  Pagerduty = 'PAGERDUTY',
  /** Pager Duty with account integration Destination Configuration type */
  PagerdutyAccountIntegration = 'PAGERDUTY_ACCOUNT_INTEGRATION',
  /** Pager Duty with service integration Destination Configuration type */
  PagerdutyServiceIntegration = 'PAGERDUTY_SERVICE_INTEGRATION',
  /** Service Now Destination Configuration type */
  ServiceNow = 'SERVICE_NOW',
  /** ServiceNow official NewRelic app Configuration type */
  ServiceNowApp = 'SERVICE_NOW_APP',
  /** Slack Destination Configuration type */
  Slack = 'SLACK',
  /** Slack legacy Destination Configuration type */
  SlackLegacy = 'SLACK_LEGACY',
  /** Webhook Destination Configuration type */
  Webhook = 'WEBHOOK'
}

/** Makes it possible to augment the notification with additional data from the New Relic platform */
export type AiWorkflowsEnrichment = {
  __typename?: 'AiWorkflowsEnrichment';
  /** Account Id of the Enrichment */
  accountId: Scalars['Int']['output'];
  /** List of configurations for the enrichment */
  configurations: Array<AiWorkflowsConfiguration>;
  /** The time the Enrichment was created */
  createdAt: Scalars['DateTime']['output'];
  /** Enrichment Id */
  id: Scalars['ID']['output'];
  /** Name of the Enrichment */
  name: Scalars['String']['output'];
  /** Type of the Enrichment */
  type: AiWorkflowsEnrichmentType;
  /** The time the Enrichment was last updated */
  updatedAt: Scalars['DateTime']['output'];
};

/** Type of Enrichment */
export enum AiWorkflowsEnrichmentType {
  /** NRQL Enrichment type */
  Nrql = 'NRQL'
}

/** Enrichment input object */
export type AiWorkflowsEnrichmentsInput = {
  /** nrql */
  nrql: Array<AiWorkflowsNrqlEnrichmentInput>;
};

/** Filter Object */
export type AiWorkflowsFilter = {
  __typename?: 'AiWorkflowsFilter';
  /** Account Id of this Filter */
  accountId: Scalars['Int']['output'];
  /** Filter Id */
  id: Scalars['ID']['output'];
  /** Name of the Filter */
  name: Scalars['String']['output'];
  /** Expressions that determine which issues will be handled */
  predicates: Array<AiWorkflowsPredicate>;
  /** The type of the Filter */
  type: AiWorkflowsFilterType;
};

/** Filter input object */
export type AiWorkflowsFilterInput = {
  /** name */
  name?: InputMaybe<Scalars['String']['input']>;
  /** predicates */
  predicates: Array<AiWorkflowsPredicateInput>;
  /** type */
  type: AiWorkflowsFilterType;
};

/** Type of Filter */
export enum AiWorkflowsFilterType {
  /** Standard Filter type */
  Filter = 'FILTER',
  /** View Filter type */
  View = 'VIEW'
}

/** Filter on the workflow objects */
export type AiWorkflowsFilters = {
  /** channelId */
  channelId?: InputMaybe<Scalars['ID']['input']>;
  /** destinationType */
  destinationType?: InputMaybe<AiWorkflowsDestinationType>;
  /** enrichmentId */
  enrichmentId?: InputMaybe<Scalars['ID']['input']>;
  /** filterId */
  filterId?: InputMaybe<Scalars['ID']['input']>;
  /** guid */
  guid?: InputMaybe<Scalars['EntityGuid']['input']>;
  /** id */
  id?: InputMaybe<Scalars['ID']['input']>;
  /** name */
  name?: InputMaybe<Scalars['String']['input']>;
  /** nameLike */
  nameLike?: InputMaybe<Scalars['String']['input']>;
  /** workflowEnabled */
  workflowEnabled?: InputMaybe<Scalars['Boolean']['input']>;
};

/** Criteria for matching workflows, for example, a list of entity guids */
export type AiWorkflowsMatchCriteria = {
  /** entityGuids */
  entityGuids: Array<Scalars['EntityGuid']['input']>;
};

/** The wanted behavior for muted issues in the workflow */
export enum AiWorkflowsMutingRulesHandling {
  /** Notify only about partially muted and unmuted issues */
  DontNotifyFullyMutedIssues = 'DONT_NOTIFY_FULLY_MUTED_ISSUES',
  /** Notify only about unmuted issues */
  DontNotifyFullyOrPartiallyMutedIssues = 'DONT_NOTIFY_FULLY_OR_PARTIALLY_MUTED_ISSUES',
  /** Notify about all issues */
  NotifyAllIssues = 'NOTIFY_ALL_ISSUES'
}

/** Notification Triggers for the Destination Configuration */
export enum AiWorkflowsNotificationTrigger {
  /** Send a notification when the issue is acknowledged */
  Acknowledged = 'ACKNOWLEDGED',
  /** Send a notification when the issue is activated */
  Activated = 'ACTIVATED',
  /** Send a notification when the issue is closed */
  Closed = 'CLOSED',
  /** Sends notification when the issue has other updates */
  OtherUpdates = 'OTHER_UPDATES',
  /** Send a notification when the issue's priority has changed */
  PriorityChanged = 'PRIORITY_CHANGED'
}

/** NRQL enrichment configuration */
export type AiWorkflowsNrqlConfiguration = {
  __typename?: 'AiWorkflowsNrqlConfiguration';
  /** NRQL query */
  query: Scalars['String']['output'];
};

/** NRQL type configuration input object */
export type AiWorkflowsNrqlConfigurationInput = {
  /** query */
  query: Scalars['String']['input'];
};

/** NRQL type enrichment input object */
export type AiWorkflowsNrqlEnrichmentInput = {
  /** configuration */
  configuration: Array<AiWorkflowsNrqlConfigurationInput>;
  /** name */
  name: Scalars['String']['input'];
};

/** NRQL type test enrichment input object */
export type AiWorkflowsNrqlTestEnrichmentInput = {
  /** configuration */
  configuration: Array<AiWorkflowsNrqlConfigurationInput>;
  /** id */
  id?: InputMaybe<Scalars['ID']['input']>;
  /** name */
  name: Scalars['String']['input'];
};

/** NRQL type update enrichment input object */
export type AiWorkflowsNrqlUpdateEnrichmentInput = {
  /** configuration */
  configuration: Array<AiWorkflowsNrqlConfigurationInput>;
  /** id */
  id?: InputMaybe<Scalars['ID']['input']>;
  /** name */
  name: Scalars['String']['input'];
};

/** Type of Filter */
export enum AiWorkflowsOperator {
  /** String or list attribute contains this value */
  Contains = 'CONTAINS',
  /** String or list attribute does not contain this value */
  DoesNotContain = 'DOES_NOT_CONTAIN',
  /** String or Numeric attribute does not equal this value */
  DoesNotEqual = 'DOES_NOT_EQUAL',
  /** Element in list attribute does not exactly match this value */
  DoesNotExactlyMatch = 'DOES_NOT_EXACTLY_MATCH',
  /** String attribute ends with this value */
  EndsWith = 'ENDS_WITH',
  /** String or Numeric attribute equals this value */
  Equal = 'EQUAL',
  /** Element in list attribute exactly matches this value */
  ExactlyMatches = 'EXACTLY_MATCHES',
  /** Numeric attribute is greater or equal to this value */
  GreaterOrEqual = 'GREATER_OR_EQUAL',
  /** Numeric attribute is greater than this value */
  GreaterThan = 'GREATER_THAN',
  /** Boolean attribute equals value */
  Is = 'IS',
  /** Boolean attribute does not equal value */
  IsNot = 'IS_NOT',
  /** Numeric attribute is less or equal to this value */
  LessOrEqual = 'LESS_OR_EQUAL',
  /** Numeric attribute is less than this value */
  LessThan = 'LESS_THAN',
  /** String attribute starts with this value */
  StartsWith = 'STARTS_WITH'
}

/** Predicate Object */
export type AiWorkflowsPredicate = {
  __typename?: 'AiWorkflowsPredicate';
  /** Field name in the issue event */
  attribute: Scalars['String']['output'];
  /** Type of operator used to match the values */
  operator: AiWorkflowsOperator;
  /** Values to compare */
  values: Array<Scalars['String']['output']>;
};

/** PredicateInput input object */
export type AiWorkflowsPredicateInput = {
  /** attribute */
  attribute: Scalars['String']['input'];
  /** operator */
  operator: AiWorkflowsOperator;
  /** values */
  values: Array<Scalars['String']['input']>;
};

/** Error description */
export type AiWorkflowsResponseError = {
  /** The error description */
  description: Scalars['String']['output'];
};

/** Test Enrichment input object */
export type AiWorkflowsTestEnrichmentsInput = {
  /** nrql */
  nrql: Array<AiWorkflowsNrqlTestEnrichmentInput>;
};

/** Type of test error */
export enum AiWorkflowsTestErrorType {
  /** We couldn't find a channel with the given id */
  ChannelNotFound = 'CHANNEL_NOT_FOUND',
  /** Failed running test workflow */
  FailedRunningTest = 'FAILED_RUNNING_TEST',
  /** This account is missing the required entitlement(s) to perform this action */
  MissingEntitlement = 'MISSING_ENTITLEMENT',
  /** This account is not allowed to preform this action */
  UnauthorizedAccount = 'UNAUTHORIZED_ACCOUNT',
  /** The given channel id represents an unsupported channel type */
  UnsupportedChannelType = 'UNSUPPORTED_CHANNEL_TYPE',
  /** The parameter provided does not have a valid form */
  ValidationError = 'VALIDATION_ERROR',
  /** Failed to send a notification to the channel */
  WarningFailedSendingNotification = 'WARNING_FAILED_SENDING_NOTIFICATION',
  /** There are no issues that match this filter */
  WarningNoFilteredIssueFound = 'WARNING_NO_FILTERED_ISSUE_FOUND',
  /** There are no issues that match these dynamic variables */
  WarningNoMatchingDynamicVariablesFound = 'WARNING_NO_MATCHING_DYNAMIC_VARIABLES_FOUND'
}

/** Notification response according to channel id */
export type AiWorkflowsTestNotificationResponse = {
  __typename?: 'AiWorkflowsTestNotificationResponse';
  /** The id of the tested channel */
  channelId: Scalars['ID']['output'];
  /** Evidence for a successful test notification */
  evidence?: Maybe<Scalars['String']['output']>;
  /** Whether the test notification succeeded */
  status: AiWorkflowsTestNotificationResponseStatus;
};

/** Status of the test notification */
export enum AiWorkflowsTestNotificationResponseStatus {
  /** The test notification failed */
  Failure = 'FAILURE',
  /** The test notification succeeded */
  Success = 'SUCCESS'
}

/** Test error description */
export type AiWorkflowsTestResponseError = AiWorkflowsResponseError & {
  __typename?: 'AiWorkflowsTestResponseError';
  /** The error description */
  description: Scalars['String']['output'];
  /** The error type */
  type: AiWorkflowsTestErrorType;
};

/** Status of the test */
export enum AiWorkflowsTestResponseStatus {
  /** The test failed */
  Failure = 'FAILURE',
  /** The test succeeded */
  Success = 'SUCCESS'
}

/** Test Workflow input object */
export type AiWorkflowsTestWorkflowInput = {
  /** destinationConfigurations */
  destinationConfigurations: Array<AiWorkflowsDestinationConfigurationInput>;
  /** enrichments */
  enrichments?: InputMaybe<AiWorkflowsTestEnrichmentsInput>;
  /** issuesFilter */
  issuesFilter?: InputMaybe<AiWorkflowsFilterInput>;
};

/** Test workflow mutation response including errors */
export type AiWorkflowsTestWorkflowResponse = {
  __typename?: 'AiWorkflowsTestWorkflowResponse';
  /** A list of errors that occurred while performing the test workflow action */
  errors?: Maybe<Array<AiWorkflowsTestResponseError>>;
  /** List of responses by channel id */
  notificationResponses?: Maybe<Array<AiWorkflowsTestNotificationResponse>>;
  /** Whether the test was a success or not */
  status: AiWorkflowsTestResponseStatus;
};

/** Update Enrichment input object */
export type AiWorkflowsUpdateEnrichmentsInput = {
  /** nrql */
  nrql: Array<AiWorkflowsNrqlUpdateEnrichmentInput>;
};

/** Type of update error */
export enum AiWorkflowsUpdateErrorType {
  /** We couldn't find a channel with the given id */
  ChannelNotFound = 'CHANNEL_NOT_FOUND',
  /** A workflow with this name already exists */
  Duplicate = 'DUPLICATE',
  /** One or more of the parameters you provided are incorrect */
  InvalidParameter = 'INVALID_PARAMETER',
  /** This account is missing the required entitlement(s) to perform this action */
  MissingEntitlement = 'MISSING_ENTITLEMENT',
  /** This account in not authorized to perform this action */
  UnauthorizedAccount = 'UNAUTHORIZED_ACCOUNT',
  /** The given channel id represents an unsupported channel type */
  UnsupportedChannelType = 'UNSUPPORTED_CHANNEL_TYPE',
  /** The parameter provided does not have a valid form */
  ValidationError = 'VALIDATION_ERROR'
}

/** Update error description */
export type AiWorkflowsUpdateResponseError = AiWorkflowsResponseError & {
  __typename?: 'AiWorkflowsUpdateResponseError';
  /** The error description */
  description: Scalars['String']['output'];
  /** The error type */
  type: AiWorkflowsUpdateErrorType;
};

/** Update Workflow input object */
export type AiWorkflowsUpdateWorkflowInput = {
  /** destinationConfigurations */
  destinationConfigurations?: InputMaybe<Array<AiWorkflowsDestinationConfigurationInput>>;
  /** destinationsEnabled */
  destinationsEnabled?: InputMaybe<Scalars['Boolean']['input']>;
  /** enrichments */
  enrichments?: InputMaybe<AiWorkflowsUpdateEnrichmentsInput>;
  /** enrichmentsEnabled */
  enrichmentsEnabled?: InputMaybe<Scalars['Boolean']['input']>;
  /** id */
  id: Scalars['ID']['input'];
  /** issuesFilter */
  issuesFilter?: InputMaybe<AiWorkflowsUpdatedFilterInput>;
  /** mutingRulesHandling */
  mutingRulesHandling?: InputMaybe<AiWorkflowsMutingRulesHandling>;
  /** name */
  name?: InputMaybe<Scalars['String']['input']>;
  /** workflowEnabled */
  workflowEnabled?: InputMaybe<Scalars['Boolean']['input']>;
};

/** Update workflow mutation response including errors */
export type AiWorkflowsUpdateWorkflowResponse = {
  __typename?: 'AiWorkflowsUpdateWorkflowResponse';
  /** A list of errors that occurred while performing the update workflow action */
  errors: Array<AiWorkflowsUpdateResponseError>;
  /** Successfully updated workflow */
  workflow?: Maybe<AiWorkflowsWorkflow>;
};

/** Update Filter input object */
export type AiWorkflowsUpdatedFilterInput = {
  /** filterInput */
  filterInput: AiWorkflowsFilterInput;
  /** id */
  id?: InputMaybe<Scalars['ID']['input']>;
};

/** Workflow object */
export type AiWorkflowsWorkflow = {
  __typename?: 'AiWorkflowsWorkflow';
  /** Account Id of this Workflow */
  accountId: Scalars['Int']['output'];
  /** The time this workflow was created */
  createdAt: Scalars['DateTime']['output'];
  /** Specifies where to send the notifications */
  destinationConfigurations: Array<AiWorkflowsDestinationConfiguration>;
  /** Are Destinations enabled */
  destinationsEnabled: Scalars['Boolean']['output'];
  /** List of enrichments that are attached to the notifications */
  enrichments: Array<AiWorkflowsEnrichment>;
  /** Are Enrichments enabled */
  enrichmentsEnabled: Scalars['Boolean']['output'];
  /** Entity Id of the workflow */
  guid: Scalars['EntityGuid']['output'];
  /** Workflow Id */
  id: Scalars['ID']['output'];
  /** Specifies which issues the workflow will handle */
  issuesFilter: AiWorkflowsFilter;
  /** Last time a notification was sent regarding this workflow */
  lastRun?: Maybe<Scalars['DateTime']['output']>;
  /** Describes how to handle muted issues */
  mutingRulesHandling: AiWorkflowsMutingRulesHandling;
  /** Name of the Workflow */
  name: Scalars['String']['output'];
  /** The time this workflow was updated */
  updatedAt: Scalars['DateTime']['output'];
  /** Is Workflow enabled */
  workflowEnabled: Scalars['Boolean']['output'];
};

/** All results from workflow matching query */
export type AiWorkflowsWorkflowMatches = {
  __typename?: 'AiWorkflowsWorkflowMatches';
  /** List of all matches */
  matches: Array<AiWorkflowsWorkflowsMatch>;
};

/** Workflows query response */
export type AiWorkflowsWorkflows = {
  __typename?: 'AiWorkflowsWorkflows';
  /** List of all workflows */
  entities: Array<AiWorkflowsWorkflow>;
  /** Cursor to get the next batch of results */
  nextCursor?: Maybe<Scalars['String']['output']>;
  /** Total count of all workflows */
  totalCount: Scalars['Int']['output'];
};

/** Single result for matched workflows */
export type AiWorkflowsWorkflowsMatch = {
  __typename?: 'AiWorkflowsWorkflowsMatch';
  /** The entity guid used for matching */
  matchedEntityGuid: Scalars['EntityGuid']['output'];
  /** Total count of workflows in the match */
  totalCount: Scalars['Int']['output'];
  /** List of workflows in the match */
  workflows: Array<AiWorkflowsWorkflow>;
};

export enum AlertAccessTier {
  /** UI powered by legacy alerting, but has access to Hawthorne alerts. */
  HybridAlerts = 'HYBRID_ALERTS',
  /** UI powered by legacy alerting, NO access to Hawthorne alerts. */
  LegacyAlerts = 'LEGACY_ALERTS',
  /** Access cannot be determined. Internal cache retrieval error or account just created. */
  NotSet = 'NOT_SET',
  /** No alerts access. */
  NoAlerts = 'NO_ALERTS',
  /** UI powered by Hawthorne alerts. */
  NrAlerts = 'NR_ALERTS'
}

export type AlertSettings = {
  __typename?: 'AlertSettings';
  accessTier?: Maybe<AlertAccessTier>;
};

export enum AlertStatus {
  /** Not alerting */
  Green = 'GREEN',
  /** No alerts set up */
  LightGreen = 'LIGHT_GREEN',
  /** Alerts service is unavailable */
  LightGrey = 'LIGHT_GREY',
  /** Critical violation */
  Red = 'RED',
  /** Warning violation */
  Yellow = 'YELLOW'
}

export type AlertableEntity = {
  /** The current alerting severity of the entity. */
  alertSeverity?: Maybe<EntityAlertSeverity>;
  /**
   * The alert status of the entity.
   * @deprecated Please use `alertSeverity` and `reporting`
   */
  alertStatus?: Maybe<EntityAlertStatus>;
  /** Violations on the entity that were open during the specified time window. This will return up to 500 violations - if there are more in the time window selected, you must narrow the timewindow or look at fewer entities. */
  alertViolations?: Maybe<Array<Maybe<EntityAlertViolation>>>;
  /** Recent violations on the entity. */
  recentAlertViolations?: Maybe<Array<Maybe<EntityAlertViolation>>>;
};


export type AlertableEntityAlertViolationsArgs = {
  endTime: Scalars['EpochMilliseconds']['input'];
  startTime: Scalars['EpochMilliseconds']['input'];
};


export type AlertableEntityRecentAlertViolationsArgs = {
  count?: InputMaybe<Scalars['Int']['input']>;
};

export type AlertableEntityOutline = {
  /** The current alerting severity of the entity. */
  alertSeverity?: Maybe<EntityAlertSeverity>;
  /**
   * The alert status of the entity.
   * @deprecated Please use `alertSeverity` and `reporting`
   */
  alertStatus?: Maybe<EntityAlertStatus>;
};

export type AlertsAccountStitchedFields = {
  __typename?: 'AlertsAccountStitchedFields';
  /**
   * Retrieve any condition as a NRQL condition.
   * @deprecated NOT READY FOR PRODUCTION - subject to breaking changes
   */
  condition?: Maybe<AlertsNrqlCondition>;
  /** List condition coverage gaps for an entity name or entity type with a limit in a format useable by Ask Ai. */
  conditionCoverageGapsAskAi?: Maybe<AlertsConditionCoverageGapsAskAiResult>;
  /** Returns whether the account should have access to legacy UX flows. */
  legacyAuthorization?: Maybe<AlertsLegacyAuthorizationResult>;
  /** Retrieve a muting rule for Alerts violations. */
  mutingRule?: Maybe<AlertsMutingRule>;
  /** List the muting rules for an account. */
  mutingRules?: Maybe<Array<Maybe<AlertsMutingRule>>>;
  /**
   * Retrieve a notification channel.
   * @deprecated Support for notification channels is being discontinued as of **Dec 31, 2023**. Use the [`destinations` query](https://docs.newrelic.com/docs/apis/nerdgraph/examples/nerdgraph-api-notifications-destinations/) instead. For more information about the deprecation, [see the EOL announcement](https://forum.newrelic.com/s/hubtopic/aAX8W0000008dKOWAY/plan-to-upgrade-alert-notification-channels-to-workflows-and-destinations).
   */
  notificationChannel?: Maybe<AlertsNotificationChannel>;
  /**
   * List the notification channels for an account.
   * @deprecated Support for notification channels is being discontinued as of **Dec 31, 2023**. Use the [`destinations` query](https://docs.newrelic.com/docs/apis/nerdgraph/examples/nerdgraph-api-notifications-destinations/) instead. For more information about the deprecation, [see the EOL announcement](https://forum.newrelic.com/s/hubtopic/aAX8W0000008dKOWAY/plan-to-upgrade-alert-notification-channels-to-workflows-and-destinations).
   */
  notificationChannels?: Maybe<AlertsNotificationChannelsResultSet>;
  /** Retrieve a specific NRQL condition. */
  nrqlCondition?: Maybe<AlertsNrqlCondition>;
  /** List NRQL conditions according to search criteria. */
  nrqlConditionsSearch?: Maybe<AlertsNrqlConditionsSearchResultSet>;
  /** Compute the number of facets produced by the specified query. */
  nrqlQueryFacetCount?: Maybe<AlertsNrqlQueryFacetCount>;
  /** Remove `SINCE`, `UNTIL`, `TIMESERIES`, and `LIMIT` components from the specified query. */
  nrqlQueryFormatAlertable?: Maybe<AlertsNrqlQueryFormatAlertable>;
  /** List Alerts policies according to search criteria. */
  policiesSearch?: Maybe<AlertsPoliciesSearchResultSet>;
  /** Retrieve a specific Alerts policy. */
  policy?: Maybe<AlertsPolicy>;
  /** Recommendations for alert conditions by entity GUIDs or entity names. */
  recommendConditions?: Maybe<AlertsRecommendConditionsResultSet>;
  /** List recommended conditions for entities in a format useable by Ask Ai. */
  recommendConditionsAskAi?: Maybe<AlertsRecommendConditionsAskAiResult>;
};


export type AlertsAccountStitchedFieldsConditionArgs = {
  id: Scalars['ID']['input'];
};


export type AlertsAccountStitchedFieldsConditionCoverageGapsAskAiArgs = {
  entityName?: InputMaybe<Scalars['String']['input']>;
  entityType?: InputMaybe<Scalars['String']['input']>;
  max?: InputMaybe<Scalars['Int']['input']>;
};


export type AlertsAccountStitchedFieldsMutingRuleArgs = {
  id: Scalars['ID']['input'];
};


export type AlertsAccountStitchedFieldsNotificationChannelArgs = {
  id: Scalars['ID']['input'];
};


export type AlertsAccountStitchedFieldsNotificationChannelsArgs = {
  cursor?: InputMaybe<Scalars['String']['input']>;
};


export type AlertsAccountStitchedFieldsNrqlConditionArgs = {
  id: Scalars['ID']['input'];
};


export type AlertsAccountStitchedFieldsNrqlConditionsSearchArgs = {
  cursor?: InputMaybe<Scalars['String']['input']>;
  searchCriteria?: InputMaybe<AlertsNrqlConditionsSearchCriteriaInput>;
};


export type AlertsAccountStitchedFieldsNrqlQueryFacetCountArgs = {
  query: Scalars['Nrql']['input'];
};


export type AlertsAccountStitchedFieldsNrqlQueryFormatAlertableArgs = {
  query: Scalars['Nrql']['input'];
};


export type AlertsAccountStitchedFieldsPoliciesSearchArgs = {
  cursor?: InputMaybe<Scalars['String']['input']>;
  searchCriteria?: InputMaybe<AlertsPoliciesSearchCriteriaInput>;
};


export type AlertsAccountStitchedFieldsPolicyArgs = {
  id: Scalars['ID']['input'];
};


export type AlertsAccountStitchedFieldsRecommendConditionsArgs = {
  recommend: AlertsRecommendConditionsInput;
};


export type AlertsAccountStitchedFieldsRecommendConditionsAskAiArgs = {
  entityDomain?: InputMaybe<Scalars['String']['input']>;
  entityNames?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  entityType?: InputMaybe<Scalars['String']['input']>;
  operator?: InputMaybe<Scalars['String']['input']>;
  searchString?: InputMaybe<Scalars['String']['input']>;
};

/** Result of the actor legacy authorization access. */
export type AlertsActorLegacyAuthorizationResult = {
  __typename?: 'AlertsActorLegacyAuthorizationResult';
  /** Whether an actor is authorized for legacy Alerts UX flows. */
  isAuthorized: Scalars['Boolean']['output'];
};

export type AlertsActorStitchedFields = {
  __typename?: 'AlertsActorStitchedFields';
  /** Returns whether the user should have access to legacy UX flows. */
  legacyAuthorization?: Maybe<AlertsActorLegacyAuthorizationResult>;
};

/** Card containing elements and actions formatted for Ask Ai. */
export type AlertsAskAiCard = {
  __typename?: 'AlertsAskAiCard';
  /** A list of actions associated with the card. */
  actions: Array<AlertsAskAiCardAction>;
  /** A list of elements to display within the card. */
  body: Array<AlertsAskAiCardBody>;
  /** The type of card being returned. */
  type: Scalars['String']['output'];
  /** The version of the card being returned. */
  version: Scalars['SemVer']['output'];
};

/** Types of card actions that Ask Ai supports. */
export type AlertsAskAiCardAction = AlertsAskAiCardActionLink | AlertsAskAiCardActionOpenEntity | AlertsAskAiCardActionOpenLauncher | AlertsAskAiCardActionOpenNerdlet | AlertsAskAiCardActionOpenStackedNerdlet | AlertsAskAiCardActionQuestion;

/** Show a link. */
export type AlertsAskAiCardActionLink = {
  __typename?: 'AlertsAskAiCardActionLink';
  /** Arguments to pass on link click. */
  args: AlertsAskAiCardActionLinkArgs;
  /** Text to display within link element. */
  title: Scalars['String']['output'];
  /** The type of link being returned. */
  type: Scalars['String']['output'];
};

/** Object containing valid on click arguments for link. */
export type AlertsAskAiCardActionLinkArgs = {
  __typename?: 'AlertsAskAiCardActionLinkArgs';
  /** Location object or url string to link to. */
  to: Scalars['String']['output'];
};

/** Opens an entity. */
export type AlertsAskAiCardActionOpenEntity = {
  __typename?: 'AlertsAskAiCardActionOpenEntity';
  /** Arguments to pass on open entity click. */
  args: AlertsAskAiCardActionOpenEntityArgs;
  /** Text to display within open entity element. */
  title: Scalars['String']['output'];
  /** The type of open entity being returned. */
  type: Scalars['String']['output'];
};

/** Object containing valid on click arguments for open entity. */
export type AlertsAskAiCardActionOpenEntityArgs = {
  __typename?: 'AlertsAskAiCardActionOpenEntityArgs';
  /** Entity guid to open. */
  entityGuid: Scalars['EntityGuid']['output'];
};

/** Opens a launcher. */
export type AlertsAskAiCardActionOpenLauncher = {
  __typename?: 'AlertsAskAiCardActionOpenLauncher';
  /** Arguments to pass on open launcher click. */
  args: AlertsAskAiCardActionOpenLauncherArgs;
  /** Text to display within open launcher element. */
  title: Scalars['String']['output'];
  /** The type of open launcher being returned. */
  type: Scalars['String']['output'];
};

/** Object containing valid on click arguments for open launcher. */
export type AlertsAskAiCardActionOpenLauncherArgs = {
  __typename?: 'AlertsAskAiCardActionOpenLauncherArgs';
  /** Launcher to open. */
  launcher: Scalars['String']['output'];
  /** Nerdlet to open within launcher. */
  nerdlet: Scalars['String']['output'];
  /** State of the nerdlet which is persisted in the url. */
  urlState: Scalars['AlertsRawNerdletState']['output'];
};

/** Opens a nerdlet in the current launcher. */
export type AlertsAskAiCardActionOpenNerdlet = {
  __typename?: 'AlertsAskAiCardActionOpenNerdlet';
  /** Arguments to pass on open nerdlet click. */
  args: AlertsAskAiCardActionOpenNerdletArgs;
  /** Text to display within open nerdlet element. */
  title: Scalars['String']['output'];
  /** The type of open nerdlet being returned. */
  type: Scalars['String']['output'];
};

/** Object containing valid on click arguments for open nerdlet. */
export type AlertsAskAiCardActionOpenNerdletArgs = {
  __typename?: 'AlertsAskAiCardActionOpenNerdletArgs';
  /** Nerdlet to open. */
  nerdlet: Scalars['String']['output'];
  /** State of the platform which is persisted in the url. */
  platformState?: Maybe<Scalars['AlertsRawNerdletState']['output']>;
  /** State of the nerdlet which is persisted in the url. */
  urlState: Scalars['AlertsRawNerdletState']['output'];
};

/** Opens a stacked nerdlet on top of the current launcher. */
export type AlertsAskAiCardActionOpenStackedNerdlet = {
  __typename?: 'AlertsAskAiCardActionOpenStackedNerdlet';
  /** Arguments to pass on open stacked nerdlet click. */
  args: AlertsAskAiCardActionOpenStackedNerdletArgs;
  /** Text to display within open stacked nerdlet element. */
  title: Scalars['String']['output'];
  /** The type of open stacked nerdlet being returned. */
  type: Scalars['String']['output'];
};

/** Object containing valid on click arguments for open stacked nerdlet. */
export type AlertsAskAiCardActionOpenStackedNerdletArgs = {
  __typename?: 'AlertsAskAiCardActionOpenStackedNerdletArgs';
  /** Stacked nerdlet to open. */
  nerdlet: Scalars['String']['output'];
  /** State of the platform which is persisted in the url. */
  platformState?: Maybe<Scalars['AlertsRawNerdletState']['output']>;
  /** State of the nerdlet which is persisted in the url. */
  urlState: Scalars['AlertsRawNerdletState']['output'];
};

/** Ask a follow up question to Ask Ai, shows a button. */
export type AlertsAskAiCardActionQuestion = {
  __typename?: 'AlertsAskAiCardActionQuestion';
  /** Arguments to pass on ask ai question click. */
  args: AlertsAskAiCardActionQuestionArgs;
  /** Text to display within ask ai question element. */
  title: Scalars['String']['output'];
  /** The type of ask ai question being returned. */
  type: Scalars['String']['output'];
};

/** Object containing valid on click arguments for ask ai. */
export type AlertsAskAiCardActionQuestionArgs = {
  __typename?: 'AlertsAskAiCardActionQuestionArgs';
  /** Text to display when ask ai question is clicked. */
  prompt: Scalars['String']['output'];
};

/** Types of card body elements that Ask Ai supports. */
export type AlertsAskAiCardBody = AlertsAskAiCardBodyBlockText | AlertsAskAiCardBodyCodeBlock | AlertsAskAiCardBodyForm | AlertsAskAiCardBodyVisualization;

/** Typographic styles for block level text. */
export type AlertsAskAiCardBodyBlockText = {
  __typename?: 'AlertsAskAiCardBodyBlockText';
  /** The type of block text being returned. */
  type: Scalars['String']['output'];
  /** The value of the component. */
  value: Scalars['String']['output'];
};

/** CodeBlock encapsulates files or large blocks of code while keeping the formatting. */
export type AlertsAskAiCardBodyCodeBlock = {
  __typename?: 'AlertsAskAiCardBodyCodeBlock';
  /** You may use up to two actions to help the user perform common actions like copy to clipboard or download the code. */
  actions: Scalars['String']['output'];
  /** Code to be displayed and highlighted. */
  code: Scalars['String']['output'];
  /** Language used for the syntax highlight. */
  languageType: Scalars['String']['output'];
  /** Name to be used in the header and as the file name when downloading the file. */
  name: Scalars['String']['output'];
  /** The type of code block being returned. */
  type: Scalars['String']['output'];
};

/** Element to group related form fields that allow users to provide data or configure options. */
export type AlertsAskAiCardBodyForm = {
  __typename?: 'AlertsAskAiCardBodyForm';
  /** Form fields to display within the form element. */
  items: Array<AlertsAskAiCardBodyFormItem>;
  /** A string specifying a name for the form control. */
  name: Scalars['String']['output'];
  /** The type of form being returned. */
  type: Scalars['String']['output'];
};

/** Allows users to make a range of selections. */
export type AlertsAskAiCardBodyFormCheckbox = {
  __typename?: 'AlertsAskAiCardBodyFormCheckbox';
  /** Text to display as label. */
  label: Scalars['String']['output'];
  /** A string specifying a name for the form control. */
  name: Scalars['String']['output'];
  /** The type of checkbox being returned. */
  type: Scalars['String']['output'];
  /** The value of the component. */
  value: Scalars['String']['output'];
};

/** Types of form items that Ask Ai supports. */
export type AlertsAskAiCardBodyFormItem = AlertsAskAiCardBodyFormCheckbox | AlertsAskAiCardBodyFormMultilineTextField | AlertsAskAiCardBodyFormSelect | AlertsAskAiCardBodyFormTextField;

/** Allows user to input data to complete a task. */
export type AlertsAskAiCardBodyFormMultilineTextField = {
  __typename?: 'AlertsAskAiCardBodyFormMultilineTextField';
  /** Text to display as label. */
  label: Scalars['String']['output'];
  /** A string specifying a name for the form control. */
  name: Scalars['String']['output'];
  /** Hint displayed in the multiline text field when it has no value. */
  placeholder: Scalars['String']['output'];
  /** The type of multiline text field being returned. */
  type: Scalars['String']['output'];
  /** Value of the multiline text field. */
  value: Scalars['String']['output'];
};

/** Allows users to choose from a list of options. */
export type AlertsAskAiCardBodyFormSelect = {
  __typename?: 'AlertsAskAiCardBodyFormSelect';
  /** Select options to display within the select element. */
  items: Array<AlertsAskAiCardBodyFormSelectItem>;
  /** Text to display as label. */
  label: Scalars['String']['output'];
  /** A string specifying a name for the form control. */
  name: Scalars['String']['output'];
  /** The type of select being returned. */
  type: Scalars['String']['output'];
  /** Value matching the item selected. */
  value: Scalars['String']['output'];
};

/** Child element of the AskAiCardBodyFormSelect component. */
export type AlertsAskAiCardBodyFormSelectItem = {
  __typename?: 'AlertsAskAiCardBodyFormSelectItem';
  /** Text to display as label. */
  label: Scalars['String']['output'];
  /** Value of the selected property. */
  value: Scalars['String']['output'];
};

/** Allows users to input data to complete a task. */
export type AlertsAskAiCardBodyFormTextField = {
  __typename?: 'AlertsAskAiCardBodyFormTextField';
  /** Text to display as label. */
  label: Scalars['String']['output'];
  /** A string specifying a name for the form control. */
  name: Scalars['String']['output'];
  /** Hint displayed in the text field when it has no value. */
  placeholder: Scalars['String']['output'];
  /** The type of text field being returned. */
  type: Scalars['String']['output'];
  /** Value of the text field. */
  value: Scalars['String']['output'];
};

/** Allows users to visualize datasets in an explorative manner, with some enabled user interactions. */
export type AlertsAskAiCardBodyVisualization = {
  __typename?: 'AlertsAskAiCardBodyVisualization';
  /** ID for the visualization to return. */
  id: Scalars['String']['output'];
  /** Object used for fetching data. */
  nrqlQueries: Array<AlertsAskAiCardBodyVisualizationNrqlQuery>;
  /** The type of visualization being returned. */
  type: Scalars['String']['output'];
};

/** Object containing requiremented information to fetch visualization data. */
export type AlertsAskAiCardBodyVisualizationNrqlQuery = {
  __typename?: 'AlertsAskAiCardBodyVisualizationNrqlQuery';
  /** Sets the account IDs to perform the query. */
  accountIds: Array<Scalars['Int']['output']>;
  /** NRQL query used for fetching data. */
  query: Scalars['String']['output'];
};

/** Campfire notification channel. */
export type AlertsCampfireNotificationChannel = AlertsNotificationChannel & {
  __typename?: 'AlertsCampfireNotificationChannel';
  /**
   * Policies associated with the channel.
   * @deprecated This channel type is deprecated
   */
  associatedPolicies: AlertsNotificationChannelPoliciesResultSet;
  /**
   * Campfire channel specific configuration.
   * @deprecated This channel type is deprecated
   */
  config: AlertsCampfireNotificationChannelConfig;
  /**
   * Channel ID.
   * @deprecated This channel type is deprecated
   */
  id: Scalars['ID']['output'];
  /**
   * Channel name.
   * @deprecated This channel type is deprecated
   */
  name: Scalars['String']['output'];
  /**
   * Channel type.
   * @deprecated This channel type is deprecated
   */
  type: AlertsNotificationChannelType;
};

/** Configuration for Campfire notification channel. */
export type AlertsCampfireNotificationChannelConfig = {
  __typename?: 'AlertsCampfireNotificationChannelConfig';
  /**
   * Room.
   * @deprecated This channel type is deprecated
   */
  room: Scalars['String']['output'];
  /**
   * Subdomain.
   * @deprecated This channel type is deprecated
   */
  subdomain: Scalars['String']['output'];
  /**
   * Authentication token.
   * @deprecated This channel type is deprecated
   */
  token: Scalars['SecureValue']['output'];
};

/** Object contains a card formatted for Ask Ai. */
export type AlertsConditionCoverageGapsAskAi = {
  __typename?: 'AlertsConditionCoverageGapsAskAi';
  /** Card formatted for Ask Ai. */
  card: AlertsCoverageGapsAskAiCard;
};

/** Result containing condition coverage gaps formatted for Ask Ai. */
export type AlertsConditionCoverageGapsAskAiResult = {
  __typename?: 'AlertsConditionCoverageGapsAskAiResult';
  /** Condition coverage gaps formatted for Ask Ai. */
  coverageGaps: AlertsConditionCoverageGapsAskAi;
};

/** Success response for deleting an Alerts condition. */
export type AlertsConditionDeleteResponse = {
  __typename?: 'AlertsConditionDeleteResponse';
  /** ID of the deleted Alerts condition. */
  id: Scalars['ID']['output'];
};

/** Success response for updating Alerts condition enablement. */
export type AlertsConditionUpdateEnabledResponse = {
  __typename?: 'AlertsConditionUpdateEnabledResponse';
  /** Enablement status of the Alerts condition. */
  enabled: Scalars['Boolean']['output'];
};

/** Card containing elements and actions formatted for Ask Ai. */
export type AlertsCoverageGapsAskAiCard = {
  __typename?: 'AlertsCoverageGapsAskAiCard';
  /** A list of actions associated with the card. */
  actions: Array<AlertsCoverageGapsAskAiCardAction>;
  /** A list of elements to display within the card. */
  body: Array<AlertsCoverageGapsAskAiCardBody>;
  /** The type of card being returned. */
  type: Scalars['String']['output'];
  /** The version of the card being returned. */
  version: Scalars['SemVer']['output'];
};

/** Types of card actions that Ask Ai supports. */
export type AlertsCoverageGapsAskAiCardAction = AlertsAskAiCardActionLink | AlertsAskAiCardActionOpenNerdlet | AlertsAskAiCardActionQuestion;

/** Types of card body elements that Ask Ai supports. */
export type AlertsCoverageGapsAskAiCardBody = AlertsAskAiCardBodyBlockText | AlertsAskAiCardBodyCodeBlock | AlertsAskAiCardBodyForm | AlertsAskAiCardBodyVisualization;

/** The day of the week used to configure a WEEKLY scheduled MutingRule */
export enum AlertsDayOfWeek {
  /** Friday */
  Friday = 'FRIDAY',
  /** Monday */
  Monday = 'MONDAY',
  /** Saturday */
  Saturday = 'SATURDAY',
  /** Sunday */
  Sunday = 'SUNDAY',
  /** Thursday */
  Thursday = 'THURSDAY',
  /** Tuesday */
  Tuesday = 'TUESDAY',
  /** Wednesday */
  Wednesday = 'WEDNESDAY'
}

/** Email notification channel. */
export type AlertsEmailNotificationChannel = AlertsNotificationChannel & {
  __typename?: 'AlertsEmailNotificationChannel';
  /** Policies associated with the channel. */
  associatedPolicies: AlertsNotificationChannelPoliciesResultSet;
  /** Email channel specific configuration. */
  config: AlertsEmailNotificationChannelConfig;
  /** Channel ID. */
  id: Scalars['ID']['output'];
  /** Channel name. */
  name: Scalars['String']['output'];
  /** Channel type. */
  type: AlertsNotificationChannelType;
};

/** Configuration for Email notification channel. */
export type AlertsEmailNotificationChannelConfig = {
  __typename?: 'AlertsEmailNotificationChannelConfig';
  /** List of email recipients. */
  emails: Array<Scalars['String']['output']>;
  /** Include details about the violation as a JSON attachment. */
  includeJson: Scalars['Boolean']['output'];
};

/** The input for creating a new Email notification channel. */
export type AlertsEmailNotificationChannelCreateInput = {
  /** List of email recipients. */
  emails: Array<Scalars['String']['input']>;
  /** Include details about the violation as a JSON attachment. */
  includeJson: Scalars['Boolean']['input'];
  /** Notification channel name. */
  name: Scalars['String']['input'];
};

/** The input for updating an existing Email notification channel. */
export type AlertsEmailNotificationChannelUpdateInput = {
  /** List of email recipients. */
  emails?: InputMaybe<Array<Scalars['String']['input']>>;
  /** Include details about the violation as a JSON attachment. */
  includeJson?: InputMaybe<Scalars['Boolean']['input']>;
  /** Notification channel name. */
  name?: InputMaybe<Scalars['String']['input']>;
};

/** The available fill options. */
export enum AlertsFillOption {
  /** Fill using the last known value. */
  LastValue = 'LAST_VALUE',
  /** Do not fill data. */
  None = 'NONE',
  /** Fill using a static value. */
  Static = 'STATIC'
}

/** HipChat notification channel. */
export type AlertsHipChatNotificationChannel = AlertsNotificationChannel & {
  __typename?: 'AlertsHipChatNotificationChannel';
  /**
   * Policies associated with the channel.
   * @deprecated This channel type is deprecated
   */
  associatedPolicies: AlertsNotificationChannelPoliciesResultSet;
  /**
   * HipChat channel specific configuration.
   * @deprecated This channel type is deprecated
   */
  config: AlertsHipChatNotificationChannelConfig;
  /**
   * Channel ID.
   * @deprecated This channel type is deprecated
   */
  id: Scalars['ID']['output'];
  /**
   * Channel name.
   * @deprecated This channel type is deprecated
   */
  name: Scalars['String']['output'];
  /**
   * Channel type.
   * @deprecated This channel type is deprecated
   */
  type: AlertsNotificationChannelType;
};

/** Configuration for HipChat notification channel. */
export type AlertsHipChatNotificationChannelConfig = {
  __typename?: 'AlertsHipChatNotificationChannelConfig';
  /**
   * Authentication token.
   * @deprecated This channel type is deprecated
   */
  authToken: Scalars['SecureValue']['output'];
  /**
   * Base URL.
   * @deprecated This channel type is deprecated
   */
  baseUrl: Scalars['String']['output'];
  /**
   * Room ID.
   * @deprecated This channel type is deprecated
   */
  roomId: Scalars['String']['output'];
};

/** Determines how incidents are created for critical violations of the conditions contained in the policy. */
export enum AlertsIncidentPreference {
  /**
   * A condition will create a condition-level incident when it violates its critical threshold.
   * Other violating conditions will create their own incidents.
   */
  PerCondition = 'PER_CONDITION',
  /**
   * Each target of each condition will create an entity-level incident upon critical violation.
   * Other violating targets will create their own incidents (even on the same condition).
   */
  PerConditionAndTarget = 'PER_CONDITION_AND_TARGET',
  /**
   * A condition will create a policy-level incident when it violates its critical threshold.
   * Other violating conditions will be grouped into this incident.
   */
  PerPolicy = 'PER_POLICY'
}

/** Result of the check for account legacy authorization access. */
export type AlertsLegacyAuthorizationResult = {
  __typename?: 'AlertsLegacyAuthorizationResult';
  /** Whether an account is authorized for legacy Alerts UX flows. */
  isAuthorized: Scalars['Boolean']['output'];
  /** List of what is blocking the photon migration */
  migrationBlockers?: Maybe<Array<Scalars['String']['output']>>;
  /** The photon migration eligibility of this account */
  migrationEligible?: Maybe<Scalars['Boolean']['output']>;
  /** The status of the photon migration for this account */
  migrationStatus?: Maybe<AlertsMigrationStatus>;
  /** The time frame in which an account will be migrated. */
  migrationTimeframe?: Maybe<Scalars['String']['output']>;
};

/** Status of the photon migration */
export enum AlertsMigrationStatus {
  /** Account migration blocked */
  Blocked = 'BLOCKED',
  /** Account migration is complete */
  Complete = 'COMPLETE',
  /** Account migration failed */
  Failed = 'FAILED',
  /** Account migration is in progress */
  InProgress = 'IN_PROGRESS',
  /** Migration status field does not match available options. */
  NonMatchableMigrationStatusValue = 'NON_MATCHABLE_MIGRATION_STATUS_VALUE',
  /** Account migration was reset */
  Reset = 'RESET',
  /** Account migration has been rolled back */
  RolledBack = 'ROLLED_BACK',
  /** Account migration has been staged */
  Staged = 'STAGED',
  /** Account migration is being validated */
  Validation = 'VALIDATION'
}

/** A MutingRule for New Relic Alerts Violations. */
export type AlertsMutingRule = {
  __typename?: 'AlertsMutingRule';
  /** The account id of the MutingRule. */
  accountId: Scalars['Int']['output'];
  /** The condition that defines which violations to target. */
  condition: AlertsMutingRuleConditionGroup;
  /** The timestamp of when the MutingRule was created. */
  createdAt: Scalars['DateTime']['output'];
  /**
   * The user id that created the MutingRule.
   * @deprecated Please use 'createdByUser'.
   */
  createdBy: Scalars['ID']['output'];
  /** The user information that created the MutingRule. */
  createdByUser?: Maybe<UserReference>;
  /** The description of the MutingRule. */
  description?: Maybe<Scalars['String']['output']>;
  /** Whether the MutingRule is enabled */
  enabled: Scalars['Boolean']['output'];
  /** The unique identifier for the MutingRule. */
  id: Scalars['ID']['output'];
  /** The name of the MutingRule. */
  name: Scalars['String']['output'];
  /** The time window when the MutingRule should actively mute violations. */
  schedule?: Maybe<AlertsMutingRuleSchedule>;
  /** The status of a MutingRule based on whether it is Enabled and has a Schedule. */
  status: AlertsMutingRuleStatus;
  /** The timestamp of when the MutingRule was last modified. */
  updatedAt: Scalars['DateTime']['output'];
  /**
   * The user id that last modified the MutingRule.
   * @deprecated Please use 'updatedByUser'.
   */
  updatedBy: Scalars['ID']['output'];
  /** The user information that last modified the MutingRule. */
  updatedByUser?: Maybe<UserReference>;
};

/** A condition which describes how to target a New Relic Alerts Violation. */
export type AlertsMutingRuleCondition = {
  __typename?: 'AlertsMutingRuleCondition';
  /**
   * The attribute on a violation. Expects one of:
   *
   * * **accountId** - The account id
   * * **conditionId** - The alert condition id
   * * **conditionName** - The alert condition name
   * * **conditionRunbookUrl** - The alert condition's runbook url
   * * **conditionType** - The alert condition type, such as `metric`
   * * **entity.guid** - The entity GUID
   * * **nrqlEventType** - The NRQL event type
   * * **nrqlQuery** - The NRQL query string
   * * **policyId** - The alert policy id
   * * **policyName** - The alert policy name
   * * **product** - The target product (e.g., `SYNTHETICS`)
   * * **tags.<NAME>** - Arbitrary tags associated with some entity (e.g., FACET from a NRQL query, for example `tags.appName` or `tags.host`)
   * * **targetId** - The ID of the alerts target
   * * **targetName** - The name of the alerts target
   */
  attribute: Scalars['String']['output'];
  /** The operator used to compare the attribute's value with the supplied value(s). */
  operator: AlertsMutingRuleConditionOperator;
  /** The value(s) to compare against the attribute's value. */
  values: Array<Maybe<Scalars['String']['output']>>;
};

/** A group of MutingRuleConditions combined by an operator. */
export type AlertsMutingRuleConditionGroup = {
  __typename?: 'AlertsMutingRuleConditionGroup';
  /** The individual MutingRuleConditions within the group. */
  conditions: Array<AlertsMutingRuleCondition>;
  /** The operator used to combine all the MutingRuleConditions within the group. */
  operator: AlertsMutingRuleConditionGroupOperator;
};

/** A group of MutingRuleConditions combined by an operator. */
export type AlertsMutingRuleConditionGroupInput = {
  /** The individual MutingRuleConditions within the group. */
  conditions: Array<AlertsMutingRuleConditionInput>;
  /** The operator used to combine all the MutingRuleConditions within the group. */
  operator: AlertsMutingRuleConditionGroupOperator;
};

/** An operator used to combine MutingRuleConditions within a MutingRuleConditionGroup. */
export enum AlertsMutingRuleConditionGroupOperator {
  /** Match conditions by AND */
  And = 'AND',
  /** Match conditions by OR */
  Or = 'OR'
}

/** A condition which describes how to target a New Relic Alerts Violation. */
export type AlertsMutingRuleConditionInput = {
  /**
   * The attribute on a violation. Expects one of:
   *
   * * **accountId** - The account id
   * * **conditionId** - The alert condition id
   * * **conditionName** - The alert condition name
   * * **conditionRunbookUrl** - The alert condition's runbook url
   * * **conditionType** - The alert condition type, such as `metric`
   * * **entity.guid** - The entity GUID
   * * **nrqlEventType** - The NRQL event type
   * * **nrqlQuery** - The NRQL query string
   * * **policyId** - The alert policy id
   * * **policyName** - The alert policy name
   * * **product** - The target product (e.g., `SYNTHETICS`)
   * * **tags.<NAME>** - Arbitrary tags associated with some entity (e.g., FACET from a NRQL query, for example `tags.appName` or `tags.host`)
   * * **targetId** - The ID of the alerts target
   * * **targetName** - The name of the alerts target
   */
  attribute: Scalars['String']['input'];
  /** The operator used to compare the attribute's value with the supplied value(s). */
  operator: AlertsMutingRuleConditionOperator;
  /** The value(s) to compare against the attribute's value. */
  values: Array<InputMaybe<Scalars['String']['input']>>;
};

/** The list of operators to be used in a MutingRuleCondition. Each operator is limited to one value in the `values` list unless otherwise specified. */
export enum AlertsMutingRuleConditionOperator {
  /** Where attribute is any. */
  Any = 'ANY',
  /** Where attribute contains value. */
  Contains = 'CONTAINS',
  /** Where attribute ends with value. */
  EndsWith = 'ENDS_WITH',
  /** Where attribute equals value. */
  Equals = 'EQUALS',
  /** Where attribute in values. (Limit 500) */
  In = 'IN',
  /** Where attribute is blank. */
  IsBlank = 'IS_BLANK',
  /** Where attribute is not blank. */
  IsNotBlank = 'IS_NOT_BLANK',
  /** Where attribute does not contain value. */
  NotContains = 'NOT_CONTAINS',
  /** Where attribute does not end with value. */
  NotEndsWith = 'NOT_ENDS_WITH',
  /** Where attribute does not equal value. */
  NotEquals = 'NOT_EQUALS',
  /** Where attribute not in values. (Limit 500) */
  NotIn = 'NOT_IN',
  /** Where attribute does not start with value. */
  NotStartsWith = 'NOT_STARTS_WITH',
  /** Where attribute starts with value. */
  StartsWith = 'STARTS_WITH'
}

/** The success response for deleting a MutingRule. */
export type AlertsMutingRuleDeleteResponse = {
  __typename?: 'AlertsMutingRuleDeleteResponse';
  /** The id of the deleted MutingRule. */
  id: Scalars['ID']['output'];
};

/** Input for creating MutingRules for New Relic Alerts Violations. */
export type AlertsMutingRuleInput = {
  /** The condition that defines which violations to target. */
  condition: AlertsMutingRuleConditionGroupInput;
  /** The description of the MutingRule. */
  description?: InputMaybe<Scalars['String']['input']>;
  /** Whether the MutingRule is enabled */
  enabled: Scalars['Boolean']['input'];
  /** The name of the MutingRule. */
  name: Scalars['String']['input'];
  /** The time window when the MutingRule should actively mute violations. */
  schedule?: InputMaybe<AlertsMutingRuleScheduleInput>;
};

/** The time window when the MutingRule should actively mute violations. */
export type AlertsMutingRuleSchedule = {
  __typename?: 'AlertsMutingRuleSchedule';
  /**
   * The datetime stamp when the MutingRule schedule should stop repeating.
   * This is in ISO 8601 format with offset.
   *
   * Example: `'2020-07-10T15:00:00-07:00'`
   *
   * Note: Either `endRepeat` or `repeatCount` should be used to end a MutingRule schedule.
   * Both fields should not be provided together.
   */
  endRepeat?: Maybe<Scalars['DateTime']['output']>;
  /**
   * The datetime stamp representing when the MutingRule should end.
   * This is in ISO 8601 format with offset.
   *
   * Example: `'2020-07-10T15:00:00-07:00'`
   */
  endTime?: Maybe<Scalars['DateTime']['output']>;
  /**
   * The datetime stamp representing the next scheduled end of a recurring MutingRule.
   * This is in ISO 8601 format with offset.
   *
   * Example: `'2020-07-08T14:30:00-07:00'`
   *
   * Note: If a MutingRule is not set to recur, this will match the `endTime` field.
   */
  nextEndTime?: Maybe<Scalars['DateTime']['output']>;
  /**
   * The datetime stamp representing the next scheduled start of a recurring MutingRule.
   * This is in ISO 8601 format with offset.
   *
   * Example: `'2020-07-08T14:30:00-07:00'`
   *
   * Note: If a MutingRule is not set to recur, this will match the `startTime` field.
   */
  nextStartTime?: Maybe<Scalars['DateTime']['output']>;
  /**
   * The frequency the MutingRule schedule repeats.
   * If the MutingRule repeats `WEEKLY`, be sure to set `weeklyRepeatDays`.
   * If the MutingRule does not repeat, use `null`.
   *
   * Example: `DAILY`
   */
  repeat?: Maybe<AlertsMutingRuleScheduleRepeat>;
  /**
   * The number of times the MutingRule schedule should repeat.
   *
   * Note: Either `repeatCount` or `endRepeat` should be used to end a MutingRule schedule.
   * Both fields should not be provided together.
   */
  repeatCount?: Maybe<Scalars['Int']['output']>;
  /**
   * The datetime stamp representing when the MutingRule should start.
   * This is in ISO 8601 format with offset.
   *
   * Example: `'2020-07-08T14:30:00-07:00'`
   */
  startTime?: Maybe<Scalars['DateTime']['output']>;
  /**
   * The time zone that applies to the MutingRule schedule.
   *
   * Example: `'America/Los_Angeles'`
   *
   * See https://en.wikipedia.org/wiki/List_of_tz_database_time_zones.
   */
  timeZone: Scalars['String']['output'];
  /**
   * The day(s) of the week that a MutingRule should repeat when the repeat field is set to `WEEKLY`.
   *
   * Example: `[MONDAY, WEDNESDAY]`
   */
  weeklyRepeatDays?: Maybe<Array<AlertsDayOfWeek>>;
};

/** The time window when the MutingRule should actively mute violations. */
export type AlertsMutingRuleScheduleInput = {
  /**
   * The datetime stamp when the MutingRule schedule should stop repeating.
   * This is in local ISO 8601 format without an offset.
   *
   * Example: `'2020-07-10T15:00:00'`
   *
   * Note: Either `endRepeat` or `repeatCount` should be used to end a MutingRule schedule.
   * Both fields should not be provided together.
   */
  endRepeat?: InputMaybe<Scalars['NaiveDateTime']['input']>;
  /**
   * The datetime stamp representing when the MutingRule should end.
   * This is in local ISO 8601 format without an offset.
   *
   * Example: `'2020-07-10T15:00:00'`
   */
  endTime?: InputMaybe<Scalars['NaiveDateTime']['input']>;
  /**
   * The frequency the MutingRule schedule repeats.
   * If the MutingRule repeats `WEEKLY`, be sure to set `weeklyRepeatDays`.
   * If the MutingRule does not repeat, use `null`.
   *
   * Example: `DAILY`
   */
  repeat?: InputMaybe<AlertsMutingRuleScheduleRepeat>;
  /**
   * The number of times the MutingRule schedule should repeat.
   *
   * Note: Either `repeatCount` or `endRepeat` should be used to end a MutingRule schedule.
   * Both fields should not be provided together.
   */
  repeatCount?: InputMaybe<Scalars['Int']['input']>;
  /**
   * The datetime stamp representing when the MutingRule should start.
   * This is in local ISO 8601 format without an offset.
   *
   * Example: `'2020-07-08T14:30:00'`
   */
  startTime?: InputMaybe<Scalars['NaiveDateTime']['input']>;
  /**
   * The time zone that applies to the MutingRule schedule.
   *
   * Example: `'America/Los_Angeles'`
   *
   * See https://en.wikipedia.org/wiki/List_of_tz_database_time_zones.
   */
  timeZone: Scalars['String']['input'];
  /**
   * The day(s) of the week that a MutingRule should repeat when the repeat field is set to `WEEKLY`.
   *
   * Example: `[MONDAY, WEDNESDAY]`
   */
  weeklyRepeatDays?: InputMaybe<Array<AlertsDayOfWeek>>;
};

/** Details about if or how frequently a MutingRule's schedule repeats. */
export enum AlertsMutingRuleScheduleRepeat {
  /** Schedule repeats once per calendar day */
  Daily = 'DAILY',
  /** Schedule repeats once per calendar month */
  Monthly = 'MONTHLY',
  /** Schedule repeats once per specified day per calendar week */
  Weekly = 'WEEKLY'
}

/** The time window when the MutingRule should actively mute violations. */
export type AlertsMutingRuleScheduleUpdateInput = {
  /**
   * The datetime stamp when the MutingRule schedule should stop repeating.
   * This is in local ISO 8601 format without an offset.
   *
   * Example: `'2020-07-10T15:00:00'`
   *
   * Note: Either `endRepeat` or `repeatCount` should be used to end a MutingRule schedule.
   * Both fields should not be provided together.
   */
  endRepeat?: InputMaybe<Scalars['NaiveDateTime']['input']>;
  /**
   * The datetime stamp representing when the MutingRule should end.
   * This is in local ISO 8601 format without an offset.
   *
   * Example: `'2020-07-10T15:00:00'`
   */
  endTime?: InputMaybe<Scalars['NaiveDateTime']['input']>;
  /**
   * The frequency the MutingRule schedule repeats.
   * If the MutingRule repeats `WEEKLY`, be sure to set `weeklyRepeatDays`.
   * If the MutingRule does not repeat, use `null`.
   *
   * Example: `DAILY`
   */
  repeat?: InputMaybe<AlertsMutingRuleScheduleRepeat>;
  /**
   * The number of times the MutingRule schedule should repeat.
   *
   * Note: Either `repeatCount` or `endRepeat` should be used to end a MutingRule schedule.
   * Both fields should not be provided together.
   */
  repeatCount?: InputMaybe<Scalars['Int']['input']>;
  /**
   * The datetime stamp representing when the MutingRule should start.
   * This is in local ISO 8601 format without an offset.
   *
   * Example: `'2020-07-08T14:30:00'`
   */
  startTime?: InputMaybe<Scalars['NaiveDateTime']['input']>;
  /**
   * The time zone that applies to the MutingRule schedule.
   *
   * Example: `'America/Los_Angeles'`
   *
   * See https://en.wikipedia.org/wiki/List_of_tz_database_time_zones.
   */
  timeZone?: InputMaybe<Scalars['String']['input']>;
  /**
   * The day(s) of the week that a MutingRule should repeat when the repeat field is set to `WEEKLY`.
   *
   * Example: `[MONDAY, WEDNESDAY]`
   */
  weeklyRepeatDays?: InputMaybe<Array<AlertsDayOfWeek>>;
};

/** The status of a MutingRule based on whether it is Enabled and has a Schedule */
export enum AlertsMutingRuleStatus {
  /** Muting is enabled and active. */
  Active = 'ACTIVE',
  /** Muting is enabled, but no longer active (there's no future schedule). */
  Ended = 'ENDED',
  /** Muting is disabled. */
  Inactive = 'INACTIVE',
  /** Muting is enabled but not active yet (there's a future schedule). */
  Scheduled = 'SCHEDULED'
}

/** Input for updating MutingRules for New Relic Alerts Violations. */
export type AlertsMutingRuleUpdateInput = {
  /** The condition that defines which violations to target. */
  condition?: InputMaybe<AlertsMutingRuleConditionGroupInput>;
  /** The description of the MutingRule. */
  description?: InputMaybe<Scalars['String']['input']>;
  /** Whether the MutingRule is enabled */
  enabled?: InputMaybe<Scalars['Boolean']['input']>;
  /** The name of the MutingRule. */
  name?: InputMaybe<Scalars['String']['input']>;
  /** The time window when the MutingRule should actively mute violations. */
  schedule?: InputMaybe<AlertsMutingRuleScheduleUpdateInput>;
};

/** A notification channel. */
export type AlertsNotificationChannel = {
  /** Policies associated with the channel. */
  associatedPolicies: AlertsNotificationChannelPoliciesResultSet;
  /** Channel ID. */
  id: Scalars['ID']['output'];
  /** Channel name. */
  name: Scalars['String']['output'];
  /** Channel type. */
  type: AlertsNotificationChannelType;
};

/** The input configuration for creating a notification channel. */
export type AlertsNotificationChannelCreateConfiguration = {
  /** The input configuration for creating an Email notification channel. */
  email?: InputMaybe<AlertsEmailNotificationChannelCreateInput>;
  /** The input configuration for creating an OpsGenie notification channel. */
  opsGenie?: InputMaybe<AlertsOpsGenieNotificationChannelCreateInput>;
  /** The input configuration for creating a PagerDuty notification channel. */
  pagerDuty?: InputMaybe<AlertsPagerDutyNotificationChannelCreateInput>;
  /** The input configuration for creating a Slack notification channel. */
  slack?: InputMaybe<AlertsSlackNotificationChannelCreateInput>;
  /** The input configuration for creating a VictorOps notification channel. */
  victorOps?: InputMaybe<AlertsVictorOpsNotificationChannelCreateInput>;
  /** The input configuration for creating a Webhook notification channel. */
  webhook?: InputMaybe<AlertsWebhookNotificationChannelCreateInput>;
  /** The input configuration for creating an xMatters notification channel. */
  xMatters?: InputMaybe<AlertsXMattersNotificationChannelCreateInput>;
};

/** The error for creating a notification channel. */
export type AlertsNotificationChannelCreateError = {
  __typename?: 'AlertsNotificationChannelCreateError';
  /** Error description. */
  description: Scalars['String']['output'];
  /** Error type. */
  errorType: AlertsNotificationChannelCreateErrorType;
};

/** The error type for creating a notification channel. */
export enum AlertsNotificationChannelCreateErrorType {
  /** Bad user input error. */
  BadUserInput = 'BAD_USER_INPUT',
  /** Forbidden error. */
  ForbiddenError = 'FORBIDDEN_ERROR',
  /** Server error. */
  ServerError = 'SERVER_ERROR',
  /** Too many requests error. */
  TooManyRequestsError = 'TOO_MANY_REQUESTS_ERROR'
}

/** The response for creating a notification channel. */
export type AlertsNotificationChannelCreateResponse = {
  __typename?: 'AlertsNotificationChannelCreateResponse';
  /** Error. */
  error?: Maybe<AlertsNotificationChannelCreateError>;
  /** Notification channel. */
  notificationChannel?: Maybe<AlertsNotificationChannelMutation>;
};

/** The error for deleting a notification channel. */
export type AlertsNotificationChannelDeleteError = {
  __typename?: 'AlertsNotificationChannelDeleteError';
  /** Error description. */
  description: Scalars['String']['output'];
  /** Error type. */
  errorType: AlertsNotificationChannelDeleteErrorType;
  /** Notification channel ID. */
  notificationChannelId: Scalars['ID']['output'];
};

/** The error type for deleting a notification channel. */
export enum AlertsNotificationChannelDeleteErrorType {
  /** Bad user input error. */
  BadUserInput = 'BAD_USER_INPUT',
  /** Forbidden error. */
  ForbiddenError = 'FORBIDDEN_ERROR',
  /** Not found error. */
  NotFoundError = 'NOT_FOUND_ERROR',
  /** Server error. */
  ServerError = 'SERVER_ERROR',
  /** Too many requests error. */
  TooManyRequestsError = 'TOO_MANY_REQUESTS_ERROR'
}

/** The response for deleting a notification channel. */
export type AlertsNotificationChannelDeleteResponse = {
  __typename?: 'AlertsNotificationChannelDeleteResponse';
  /** Error. */
  error?: Maybe<AlertsNotificationChannelDeleteError>;
  /** Notification channel ID. */
  id: Scalars['ID']['output'];
};

/** A notification channel ID - temporarily until addToPolicy will support returning full notification channels. */
export type AlertsNotificationChannelId = {
  __typename?: 'AlertsNotificationChannelId';
  /**
   * Channel ID.
   * @deprecated This type will be removed once we add the ability to return full notification channels in addToPolicy
   */
  id: Scalars['ID']['output'];
};

/** Notification channel types that are available for create and update operations. */
export type AlertsNotificationChannelMutation = AlertsEmailNotificationChannel | AlertsOpsGenieNotificationChannel | AlertsPagerDutyNotificationChannel | AlertsSlackNotificationChannel | AlertsVictorOpsNotificationChannel | AlertsWebhookNotificationChannel | AlertsXMattersNotificationChannel;

/** A result set containing associated policies information for a notification channel. */
export type AlertsNotificationChannelPoliciesResultSet = {
  __typename?: 'AlertsNotificationChannelPoliciesResultSet';
  /** A set of policies associated with the channel. */
  policies: Array<AlertsNotificationChannelPolicy>;
  /** Total number of policies associated with the channel. */
  totalCount: Scalars['Int']['output'];
};

/** Information about a policy associated with a notification channel. */
export type AlertsNotificationChannelPolicy = {
  __typename?: 'AlertsNotificationChannelPolicy';
  /** Policy ID. */
  id: Scalars['ID']['output'];
  /** Policy name. */
  name: Scalars['String']['output'];
};

/** The type of the notification channel which determines its configuration field. */
export enum AlertsNotificationChannelType {
  /**
   * Campfire notification channel.
   * @deprecated This channel type is deprecated
   */
  Campfire = 'CAMPFIRE',
  /** Email notification channel. */
  Email = 'EMAIL',
  /**
   * HipChat notification channel.
   * @deprecated This channel type is deprecated
   */
  HipChat = 'HIP_CHAT',
  /** OpsGenie notification channel. */
  Opsgenie = 'OPSGENIE',
  /** PagerDuty notification channel. */
  Pagerduty = 'PAGERDUTY',
  /** Slack notification channel. */
  Slack = 'SLACK',
  /**
   * User notification channel.
   * @deprecated This channel type is deprecated
   */
  User = 'USER',
  /** VictorOps notification channel. */
  Victorops = 'VICTOROPS',
  /** Webhook notification channel. */
  Webhook = 'WEBHOOK',
  /** xMatters notification channel. */
  Xmatters = 'XMATTERS'
}

/** The input configuration for updating a notification channel. */
export type AlertsNotificationChannelUpdateConfiguration = {
  /** The input configuration for updating an Email notification channel. */
  email?: InputMaybe<AlertsEmailNotificationChannelUpdateInput>;
  /** The input configuration for updating an OpsGenie notification channel. */
  opsGenie?: InputMaybe<AlertsOpsGenieNotificationChannelUpdateInput>;
  /** The input configuration for updating a PagerDuty notification channel. */
  pagerDuty?: InputMaybe<AlertsPagerDutyNotificationChannelUpdateInput>;
  /** The input configuration for updating a Slack notification channel. */
  slack?: InputMaybe<AlertsSlackNotificationChannelUpdateInput>;
  /** The input configuration for updating a VictorOps notification channel. */
  victorOps?: InputMaybe<AlertsVictorOpsNotificationChannelUpdateInput>;
  /** The input configuration for updating a Webhook notification channel. */
  webhook?: InputMaybe<AlertsWebhookNotificationChannelUpdateInput>;
  /** The input configuration for updating an xMatters notification channel. */
  xMatters?: InputMaybe<AlertsXMattersNotificationChannelUpdateInput>;
};

/** The error for updating a notification channel. */
export type AlertsNotificationChannelUpdateError = {
  __typename?: 'AlertsNotificationChannelUpdateError';
  /** Error description. */
  description: Scalars['String']['output'];
  /** Error type. */
  errorType: AlertsNotificationChannelUpdateErrorType;
  /** Notification channel ID. */
  notificationChannelId: Scalars['ID']['output'];
};

/** The error type for updating a notification channel. */
export enum AlertsNotificationChannelUpdateErrorType {
  /** Bad user input error. */
  BadUserInput = 'BAD_USER_INPUT',
  /** Forbidden error. */
  ForbiddenError = 'FORBIDDEN_ERROR',
  /** Not found error. */
  NotFoundError = 'NOT_FOUND_ERROR',
  /** Server error. */
  ServerError = 'SERVER_ERROR',
  /** Too many requests error. */
  TooManyRequestsError = 'TOO_MANY_REQUESTS_ERROR'
}

/** The response for updating a notification channel. */
export type AlertsNotificationChannelUpdateResponse = {
  __typename?: 'AlertsNotificationChannelUpdateResponse';
  /** Error. */
  error?: Maybe<AlertsNotificationChannelUpdateError>;
  /** Notification channel. */
  notificationChannel?: Maybe<AlertsNotificationChannelMutation>;
};

/** The error for associating notification channels with a policy. */
export type AlertsNotificationChannelsAddToPolicyError = {
  __typename?: 'AlertsNotificationChannelsAddToPolicyError';
  /** Error description. */
  description: Scalars['String']['output'];
  /** Error type. */
  errorType: AlertsNotificationChannelsAddToPolicyErrorType;
  /** Notification channel ID. */
  notificationChannelId: Scalars['ID']['output'];
};

/** The error type for associating notification channels with a policy. */
export enum AlertsNotificationChannelsAddToPolicyErrorType {
  /** Bad user input error. */
  BadUserInput = 'BAD_USER_INPUT',
  /** Forbidden error. */
  ForbiddenError = 'FORBIDDEN_ERROR',
  /** Not found error. */
  NotFoundError = 'NOT_FOUND_ERROR',
  /** Server error. */
  ServerError = 'SERVER_ERROR',
  /** Too many requests error. */
  TooManyRequestsError = 'TOO_MANY_REQUESTS_ERROR'
}

/** The response for associating notification channels with a policy. */
export type AlertsNotificationChannelsAddToPolicyResponse = {
  __typename?: 'AlertsNotificationChannelsAddToPolicyResponse';
  /** Errors. */
  errors: Array<AlertsNotificationChannelsAddToPolicyError>;
  /** Notification channels. */
  notificationChannels: Array<AlertsNotificationChannelId>;
  /** Policy ID. */
  policyId: Scalars['ID']['output'];
};

/** The error for dissociating notification channels from a policy. */
export type AlertsNotificationChannelsRemoveFromPolicyError = {
  __typename?: 'AlertsNotificationChannelsRemoveFromPolicyError';
  /** Error description. */
  description: Scalars['String']['output'];
  /** Error type. */
  errorType: AlertsNotificationChannelsRemoveFromPolicyErrorType;
  /** Notification channel ID. */
  notificationChannelId: Scalars['ID']['output'];
};

/** The error type for dissociating notification channels from a policy. */
export enum AlertsNotificationChannelsRemoveFromPolicyErrorType {
  /** Bad user input error. */
  BadUserInput = 'BAD_USER_INPUT',
  /** Forbidden error. */
  ForbiddenError = 'FORBIDDEN_ERROR',
  /** Not found error. */
  NotFoundError = 'NOT_FOUND_ERROR',
  /** Server error. */
  ServerError = 'SERVER_ERROR',
  /** Too many requests error. */
  TooManyRequestsError = 'TOO_MANY_REQUESTS_ERROR'
}

/** The response for dissociating notification channels from a policy. */
export type AlertsNotificationChannelsRemoveFromPolicyResponse = {
  __typename?: 'AlertsNotificationChannelsRemoveFromPolicyResponse';
  /** Errors. */
  errors: Array<AlertsNotificationChannelsRemoveFromPolicyError>;
  /** Notification channels. */
  notificationChannels: Array<AlertsNotificationChannelId>;
  /** Policy ID. */
  policyId: Scalars['ID']['output'];
};

/** A result set containing multiple notification channels and pagination info. */
export type AlertsNotificationChannelsResultSet = {
  __typename?: 'AlertsNotificationChannelsResultSet';
  /** A set of channels. */
  channels: Array<AlertsNotificationChannel>;
  /** Cursor pointing to the end of the current page of channels. Null if final page. */
  nextCursor?: Maybe<Scalars['String']['output']>;
  /** Total number of channels available. */
  totalCount: Scalars['Int']['output'];
};

/** A baseline NRQL condition is a self-adjusting condition based on the past behavior of a monitored NRQL query. */
export type AlertsNrqlBaselineCondition = AlertsNrqlCondition & {
  __typename?: 'AlertsNrqlBaselineCondition';
  /** Direction in which the baseline is set on condition. */
  baselineDirection: AlertsNrqlBaselineDirection;
  /** The custom violation description. */
  description?: Maybe<Scalars['String']['output']>;
  /** Whether the condition is enabled. */
  enabled: Scalars['Boolean']['output'];
  /** The Entity associated with the NRQL Condition */
  entity?: Maybe<EntityOutline>;
  /** The condition's entity GUID */
  entityGuid: Scalars['EntityGuid']['output'];
  /** Also known as **loss of signal**, these are settings for how violations are opened or closed when a signal expires. */
  expiration: AlertsNrqlConditionExpiration;
  /** Condition ID. */
  id: Scalars['ID']['output'];
  /**
   * **Preview access:** This field may be viewed and set, but will not be active until the release date.
   *
   * The condition's incident title template. Must be valid Handlebars.
   */
  incidentTitleTemplate?: Maybe<Scalars['String']['output']>;
  /** Name of the condition. */
  name: Scalars['String']['output'];
  /** The NRQL query that defines the signal for the condition. */
  nrql: AlertsNrqlConditionQuery;
  /** Alerts policy ID. */
  policyId: Scalars['ID']['output'];
  /** Runbook URL. */
  runbookUrl?: Maybe<Scalars['String']['output']>;
  /** Settings that determine how the NRQL results are evaluated */
  signal: AlertsNrqlConditionSignal;
  /** List of critical and warning terms for the condition. */
  terms: Array<AlertsNrqlConditionTerms>;
  /** Type of NRQL condition. */
  type: AlertsNrqlConditionType;
  /** The timestamp of the most recent update to the Condition */
  updatedAt?: Maybe<Scalars['EpochMilliseconds']['output']>;
  /** The actor for the most recent Condition update */
  updatedBy?: Maybe<UserReference>;
  /**
   * Deprecated - use violationTimeLimitSeconds for full range of values.
   *
   * Duration after which a violation automatically closes.
   * @deprecated Replaced by `violationTimeLimitSeconds`.
   */
  violationTimeLimit?: Maybe<AlertsViolationTimeLimit>;
  /** Duration after which a violation automatically closes in seconds. */
  violationTimeLimitSeconds?: Maybe<Scalars['Seconds']['output']>;
};

/** Direction for a baseline NRQL condition. */
export enum AlertsNrqlBaselineDirection {
  /** Only lower direction. */
  LowerOnly = 'LOWER_ONLY',
  /** Both upper and lower direction. */
  UpperAndLower = 'UPPER_AND_LOWER',
  /** Only upper direction. */
  UpperOnly = 'UPPER_ONLY'
}

/** A New Relic Alerts condition that uses a NRQL query to determine violations. */
export type AlertsNrqlCondition = {
  /** The custom violation description. */
  description?: Maybe<Scalars['String']['output']>;
  /** Whether the condition is enabled. */
  enabled: Scalars['Boolean']['output'];
  /** The Entity associated with the NRQL Condition */
  entity?: Maybe<EntityOutline>;
  /** The condition's entity GUID */
  entityGuid: Scalars['EntityGuid']['output'];
  /** Also known as **loss of signal**, these are settings for how violations are opened or closed when a signal expires. */
  expiration: AlertsNrqlConditionExpiration;
  /** Condition ID. */
  id: Scalars['ID']['output'];
  /**
   * **Preview access:** This field may be viewed and set, but will not be active until the release date.
   *
   * The condition's incident title template. Must be valid Handlebars.
   */
  incidentTitleTemplate?: Maybe<Scalars['String']['output']>;
  /** Name of the condition. */
  name: Scalars['String']['output'];
  /** The NRQL query that defines the signal for the condition. */
  nrql: AlertsNrqlConditionQuery;
  /** Alerts policy ID. */
  policyId: Scalars['ID']['output'];
  /** Runbook URL. */
  runbookUrl?: Maybe<Scalars['String']['output']>;
  /** Configuration that defines the signal that the NRQL condition will use to evaluate. */
  signal: AlertsNrqlConditionSignal;
  /** List of critical and warning terms for the condition. */
  terms: Array<AlertsNrqlConditionTerms>;
  /** Type of NRQL condition. */
  type: AlertsNrqlConditionType;
  /** The timestamp of the most recent update to the Condition */
  updatedAt?: Maybe<Scalars['EpochMilliseconds']['output']>;
  /** The actor for the most recent Condition update */
  updatedBy?: Maybe<UserReference>;
  /**
   * Deprecated - use violationTimeLimitSeconds for full range of values.
   *
   * Duration after which a violation automatically closes.
   * @deprecated Replaced by `violationTimeLimitSeconds`.
   */
  violationTimeLimit?: Maybe<AlertsViolationTimeLimit>;
  /** Duration after which a violation automatically closes in seconds. */
  violationTimeLimitSeconds?: Maybe<Scalars['Seconds']['output']>;
};

/** Input for creating a baseline NRQL condition. */
export type AlertsNrqlConditionBaselineInput = {
  /** Direction in which the baseline is set on condition. */
  baselineDirection: AlertsNrqlBaselineDirection;
  /** The custom violation description. */
  description?: InputMaybe<Scalars['String']['input']>;
  /** Whether the NRQL condition is enabled. */
  enabled: Scalars['Boolean']['input'];
  /** Also known as **loss of signal**, these are settings for how violations are opened or closed when a signal expires. */
  expiration?: InputMaybe<AlertsNrqlConditionExpirationInput>;
  /**
   * **Preview access:** This field may be viewed and set, but will not be active until the release date.
   *
   * The condition's incident title template. Must be valid Handlebars.
   */
  incidentTitleTemplate?: InputMaybe<Scalars['String']['input']>;
  /** The name of the NRQL condition. */
  name: Scalars['String']['input'];
  /** The NRQL query that defines the signal for the condition. */
  nrql: AlertsNrqlConditionQueryInput;
  /** Runbook URL. */
  runbookUrl?: InputMaybe<Scalars['String']['input']>;
  /** Configuration that defines the signal that the NRQL condition will use to evaluate. */
  signal?: InputMaybe<AlertsNrqlConditionSignalInput>;
  /** List of critical and warning terms for the condition. */
  terms: Array<AlertsNrqlDynamicConditionTermsInput>;
  /**
   * Deprecated - use violationTimeLimitSeconds for full range of values.
   *
   * Duration after which a violation automatically closes. Default is THIRTY_DAYS.
   */
  violationTimeLimit?: InputMaybe<AlertsViolationTimeLimit>;
  /**
   * Duration after which a violation automatically closes in seconds.
   * Accepts values between 300 seconds (5 minutes) and 2592000 seconds (30 days).
   *
   * Default is 3 days (259200 seconds).
   */
  violationTimeLimitSeconds?: InputMaybe<Scalars['Seconds']['input']>;
};

/** Also known as **loss of signal**, these are settings for how violations are opened or closed when a signal expires. */
export type AlertsNrqlConditionExpiration = {
  __typename?: 'AlertsNrqlConditionExpiration';
  /** Whether to close all open violations when the signal expires. Defaults to true. */
  closeViolationsOnExpiration?: Maybe<Scalars['Boolean']['output']>;
  /** The amount of time (in seconds) to wait before considering if the signal has been lost. Max value of 172800 (48 hours). */
  expirationDuration?: Maybe<Scalars['Seconds']['output']>;
  /** Whether clean shutdowns are indicated. Defaults to false. */
  infraHostCleanShutdown?: Maybe<Scalars['Boolean']['output']>;
  /** Whether to create a new "lost signal" violation to capture that the signal expired. Defaults to false. */
  openViolationOnExpiration?: Maybe<Scalars['Boolean']['output']>;
};

/** Also known as **loss of signal**, these are settings for how violations are opened or closed when a signal expires. */
export type AlertsNrqlConditionExpirationInput = {
  /** Whether to close all open violations when the signal expires. Defaults to true. */
  closeViolationsOnExpiration?: InputMaybe<Scalars['Boolean']['input']>;
  /** The amount of time (in seconds) to wait before considering if the signal has been lost. Max value of 172800 (48 hours). */
  expirationDuration?: InputMaybe<Scalars['Seconds']['input']>;
  /** Whether to create a new "lost signal" violation to capture that the signal expired. Defaults to false. */
  openViolationOnExpiration?: InputMaybe<Scalars['Boolean']['input']>;
};

/** Input for creating an outlier NRQL condition. */
export type AlertsNrqlConditionOutlierInput = {
  /** The custom violation description. */
  description?: InputMaybe<Scalars['String']['input']>;
  /** Whether the NRQL condition is enabled. */
  enabled: Scalars['Boolean']['input'];
  /** Number of groups expected in the returned values for the condition. */
  expectedGroups: Scalars['Int']['input'];
  /** Also known as **loss of signal**, these are settings for how violations are opened or closed when a signal expires. */
  expiration?: InputMaybe<AlertsNrqlConditionExpirationInput>;
  /**
   * **Preview access:** This field may be viewed and set, but will not be active until the release date.
   *
   * The condition's incident title template. Must be valid Handlebars.
   */
  incidentTitleTemplate?: InputMaybe<Scalars['String']['input']>;
  /** Name of the NRQL condition. */
  name: Scalars['String']['input'];
  /** The NRQL query that defines the signal for the condition. */
  nrql: AlertsNrqlConditionQueryInput;
  /** Whether overlapping groups should produce a violation. */
  openViolationOnGroupOverlap: Scalars['Boolean']['input'];
  /** Runbook URL. */
  runbookUrl?: InputMaybe<Scalars['String']['input']>;
  /** Configuration that defines the signal that the NRQL condition will use to evaluate. */
  signal?: InputMaybe<AlertsNrqlConditionSignalInput>;
  /** List of critical and warning terms for the condition. */
  terms: Array<AlertsNrqlDynamicConditionTermsInput>;
  /**
   * Deprecated - use violationTimeLimitSeconds for full range of values.
   *
   * Duration after which a violation automatically closes. Default is THIRTY_DAYS.
   */
  violationTimeLimit?: InputMaybe<AlertsViolationTimeLimit>;
  /**
   * Duration after which a violation automatically closes in seconds.
   * Accepts values between 300 seconds (5 minutes) and 2592000 seconds (30 days).
   *
   * Default is 3 days (259200 seconds).
   */
  violationTimeLimitSeconds?: InputMaybe<Scalars['Seconds']['input']>;
};

/** Value determining whether to open a critical or warning incident for a NrqlCondition. */
export enum AlertsNrqlConditionPriority {
  /** Our highest priority. Use a critical priority when system behavior needs immediate attention. */
  Critical = 'CRITICAL',
  /** Lower priority. Use a warning priority when system behavior is noteworthy but not degraded enough to cause problems yet. */
  Warning = 'WARNING'
}

/**
 * Information for generating the condition NRQL query.
 * Output from the evaluated NRQL query will be compared to the condition terms to detect violations.
 */
export type AlertsNrqlConditionQuery = {
  __typename?: 'AlertsNrqlConditionQuery';
  /**
   * Deprecated; superseded by `signal.aggregationMethod` with `signal.aggregationDelay` or `signal.aggregationTimer`.
   *
   * By default, we evaluate the NRQL query in one-minute time windows. The start time depends on the value you select in the NRQL condition's `evaluationOffset`. Evaluation offset cannot be greater than 60 minutes.
   *
   * This value is the number of time windows we look back at the aggregated data.
   *
   * Example: With an `evaluationOffset` of 3, the NRQL time window applied to your query will be:
   *
   * `SINCE 3 minutes ago UNTIL 2 minutes ago`
   * @deprecated Superseded by `signal.aggregationMethod` with `signal.aggregationDelay` or `signal.aggregationTimer`.
   */
  evaluationOffset?: Maybe<Scalars['Int']['output']>;
  /** NRQL syntax that defines the query. */
  query: Scalars['Nrql']['output'];
};

/**
 * Information for generating the condition NRQL query.
 * The output of data from this NRQL query will be compared to the condition terms to detect violations.
 */
export type AlertsNrqlConditionQueryInput = {
  /**
   * Deprecated; superseded by `signal.aggregationMethod` with `signal.aggregationDelay` or `signal.aggregationTimer`.
   *
   * By default, we evaluate the NRQL query in one-minute time windows. Start time depends on the value you select in the NRQL condition's `evaluationOffset`. Evaluation offset cannot be greater than 60 minutes.
   *
   * This value is the number of time windows we look back at the aggregated.
   *
   * Example: With an `evaluationOffset` of 3, the NRQL time window applied to your query will be:
   *
   * `SINCE 3 minutes ago UNTIL 2 minutes ago`
   */
  evaluationOffset?: InputMaybe<Scalars['Int']['input']>;
  /** NRQL syntax that defines the query. */
  query: Scalars['Nrql']['input'];
};

/** Configuration that defines the signal that the NRQL condition will use to evaluate. */
export type AlertsNrqlConditionSignal = {
  __typename?: 'AlertsNrqlConditionSignal';
  /**
   * How long we wait for data that belongs in each aggregation window. Depending
   * on your data, a longer delay may increase accuracy but delay notifications.
   *
   * Use `aggregationDelay` with the `EVENT_FLOW` and `CADENCE` methods. The maximum
   * delay is **1200 seconds** (20 minutes) when using `EVENT_FLOW` and **3600 seconds**
   * (60 minutes) when using `CADENCE`. In both cases, the minimum delay is **0 seconds**
   * and the default is **120 seconds**.
   */
  aggregationDelay?: Maybe<Scalars['Seconds']['output']>;
  /**
   * The method that determines when we consider an aggregation window to be complete
   * so that we can evaluate the signal for violations. Default is `EVENT_FLOW`.
   */
  aggregationMethod?: Maybe<AlertsSignalAggregationMethod>;
  /**
   * How long we wait after each data point arrives to make sure we've processed
   * the whole batch.
   *
   * Use `aggregationTimer` with the `EVENT_TIMER` method. The timer value can range
   * from **5 seconds** to **1200 seconds** (20 minutes); the default is **60 seconds**.
   */
  aggregationTimer?: Maybe<Scalars['Seconds']['output']>;
  /**
   * Aggregation window controls the duration of the time window used to evaluate the NRQL query, in seconds.
   * The value must be at least 30 seconds, and no more than 15 minutes (900 seconds). Default is 60 seconds.
   */
  aggregationWindow?: Maybe<Scalars['Seconds']['output']>;
  /** How long we wait until the signal starts evaluating. The maximum delay is **7200 seconds** (120 minutes). */
  evaluationDelay?: Maybe<Scalars['Seconds']['output']>;
  /**
   * Deprecated; superseded by `signal.aggregationMethod` with `signal.aggregationDelay` or `signal.aggregationTimer`.
   *
   * By default, we evaluate the NRQL query in one-minute time windows. The start time depends on the value you select in the NRQL condition's `evaluationOffset`. Evaluation offset cannot be greater than 60 minutes.
   *
   * This value is the number of time windows we look back at the aggregated data.
   *
   * Example: With an `evaluationOffset` of 3 and a 1 minute aggregation window, the NRQL time window applied to your query will be:
   *
   * `SINCE 3 minutes ago UNTIL 2 minutes ago`
   * @deprecated Superseded by `signal.aggregationMethod` with `signal.aggregationDelay` or `signal.aggregationTimer`.
   */
  evaluationOffset?: Maybe<Scalars['Int']['output']>;
  /**
   * Option that determines the type of value that should be used to fill gaps (empty windows). Defaults to STATIC.
   *
   * Outlier NRQL conditions may only use NONE.
   */
  fillOption?: Maybe<AlertsFillOption>;
  /** If using the static fill option, this the value used for filling. Defaults to 0. */
  fillValue?: Maybe<Scalars['Float']['output']>;
  /**
   * This setting gathers data in overlapping time windows to smooth the chart line, making it easier to spot trends.
   *
   * Not used for Outlier NRQL conditions.
   */
  slideBy?: Maybe<Scalars['Seconds']['output']>;
};

/** Configuration that defines the signal that the NRQL condition will use to evaluate. */
export type AlertsNrqlConditionSignalInput = {
  /**
   * How long we wait for data that belongs in each aggregation window. Depending
   * on your data, a longer delay may increase accuracy but delay notifications.
   *
   * Use `aggregationDelay` with the `EVENT_FLOW` and `CADENCE` methods. The maximum
   * delay is **1200 seconds** (20 minutes) when using `EVENT_FLOW` and **3600 seconds**
   * (60 minutes) when using `CADENCE`. In both cases, the minimum delay is **0 seconds**
   * and the default is **120 seconds**.
   *
   * When using `aggregationDelay`, do **not** use `evaluationOffset`.
   */
  aggregationDelay?: InputMaybe<Scalars['Seconds']['input']>;
  /**
   * The method that determines when we consider an aggregation window to be complete
   * so that we can evaluate the signal for violations. Default is `EVENT_FLOW`.
   *
   * When using any `aggregationMethod`, do **not** use `evaluationOffset`.
   *
   * When using the `aggregationMethod` with `EVENT_TIMER`, use `aggregationTimer`.
   * For `EVENT_FLOW` and `CADENCE`, use `aggregationDelay`.
   */
  aggregationMethod?: InputMaybe<AlertsSignalAggregationMethod>;
  /**
   * How long we wait after each data point arrives to make sure we've processed
   * the whole batch.
   *
   * Use `aggregationTimer` with the `EVENT_TIMER` method. The timer value can range
   * from **5 seconds** to **1200 seconds** (20 minutes); the default is **60 seconds**.
   *
   * When using `aggregationTimer`, do **not** use `evaluationOffset`.
   */
  aggregationTimer?: InputMaybe<Scalars['Seconds']['input']>;
  /**
   * Aggregation window controls the duration of the time window used to evaluate the NRQL query, in seconds.
   * The value must be at least 30 seconds, and no more than 6 hours (21600 seconds). Default is 60 seconds.
   */
  aggregationWindow?: InputMaybe<Scalars['Seconds']['input']>;
  /** How long we wait until the signal starts evaluating. The maximum delay is **7200 seconds** (120 minutes). */
  evaluationDelay?: InputMaybe<Scalars['Seconds']['input']>;
  /**
   * Deprecated; superseded by `signal.aggregationMethod` with `signal.aggregationDelay` or `signal.aggregationTimer`.
   *
   * By default, we evaluate the NRQL query in one-minute time windows. The start time depends on the value you select in the NRQL condition's `evaluationOffset`. Evaluation offset cannot be greater than 60 minutes.
   *
   * This value is the number of time windows we look back at the aggregated data.
   *
   * Example: With an `evaluationOffset` of 3 and a 1 minute aggregation window, the NRQL time window applied to your query will be:
   *
   * `SINCE 3 minutes ago UNTIL 2 minutes ago`
   */
  evaluationOffset?: InputMaybe<Scalars['Int']['input']>;
  /**
   * Option that determines the type of value that should be used to fill gaps (empty windows). Defaults to STATIC.
   *
   * Outlier NRQL conditions may only use NONE.
   */
  fillOption?: InputMaybe<AlertsFillOption>;
  /** If using the static fill option, this the value used for filling. Defaults to 0. */
  fillValue?: InputMaybe<Scalars['Float']['input']>;
  /**
   * This setting gathers data in overlapping time windows to smooth the chart line, making it easier to spot trends.
   *
   * The `slideBy` value is specified in seconds and must be **smaller than** and **a factor of** the `aggregationWindow`.
   *
   * Cannot be used with:
   * - Outlier NRQL conditions
   */
  slideBy?: InputMaybe<Scalars['Seconds']['input']>;
};

/** Input for creating a static NRQL condition. */
export type AlertsNrqlConditionStaticInput = {
  /** The custom violation description. */
  description?: InputMaybe<Scalars['String']['input']>;
  /** Whether the NRQL condition is enabled. */
  enabled: Scalars['Boolean']['input'];
  /** Also known as **loss of signal**, these are settings for how violations are opened or closed when a signal expires. */
  expiration?: InputMaybe<AlertsNrqlConditionExpirationInput>;
  /**
   * **Preview access:** This field may be viewed and set, but will not be active until the release date.
   *
   * The condition's incident title template. Must be valid Handlebars.
   */
  incidentTitleTemplate?: InputMaybe<Scalars['String']['input']>;
  /** Name of the NRQL condition. */
  name: Scalars['String']['input'];
  /** The NRQL query that defines the signal for the condition. */
  nrql: AlertsNrqlConditionQueryInput;
  /** Runbook URL. */
  runbookUrl?: InputMaybe<Scalars['String']['input']>;
  /** Configuration that defines the signal that the NRQL condition will use to evaluate. */
  signal?: InputMaybe<AlertsNrqlConditionSignalInput>;
  /**
   * List of critical and warning terms for the condition.
   *
   * Terms are required in most cases. For conditions monitoring Host Not Reporting signals, it can be blank.
   */
  terms?: InputMaybe<Array<AlertsNrqlConditionTermsInput>>;
  /**
   * Deprecated - use `signal.slideBy` instead.
   *
   * Function used to aggregate the NRQL query value(s) for comparison to the `terms.threshold`. When the result of this aggregate surpasses the `terms.threshold`, a violation is opened.
   */
  valueFunction?: InputMaybe<AlertsNrqlStaticConditionValueFunction>;
  /**
   * Deprecated - use violationTimeLimitSeconds for full range of values.
   *
   * Duration after which a violation automatically closes. Default is THIRTY_DAYS.
   */
  violationTimeLimit?: InputMaybe<AlertsViolationTimeLimit>;
  /**
   * Duration after which a violation automatically closes in seconds.
   * Accepts values between 300 seconds (5 minutes) and 2592000 seconds (30 days).
   *
   * Default is 3 days (259200 seconds).
   */
  violationTimeLimitSeconds?: InputMaybe<Scalars['Seconds']['input']>;
};

/** NRQL condition terms determine when a violation will be opened. */
export type AlertsNrqlConditionTerms = {
  __typename?: 'AlertsNrqlConditionTerms';
  /** Operator used to compare against the threshold. */
  operator: AlertsNrqlConditionTermsOperator;
  /** Priority determines how much attention your incidents need. Your workflow settings then tell us when and where to send notifications for different priorities. */
  priority: AlertsNrqlConditionPriority;
  /** Value that triggers a violation. */
  threshold: Scalars['Float']['output'];
  /** Duration, in seconds, that the condition must violate the threshold before creating a violation. */
  thresholdDuration: Scalars['Int']['output'];
  /** How many data points must be in violation for the specified threshold duration. */
  thresholdOccurrences: AlertsNrqlConditionThresholdOccurrences;
};

/** NRQL condition terms determine when a violation will be opened. */
export type AlertsNrqlConditionTermsInput = {
  /** Operator used to compare against the threshold. */
  operator: AlertsNrqlConditionTermsOperator;
  /** Priority determines how much attention your incidents need. Your workflow settings then tell us when and where to send notifications for different priorities. */
  priority: AlertsNrqlConditionPriority;
  /** Value that triggers a violation. */
  threshold: Scalars['Float']['input'];
  /**
   * The duration, in seconds, that the threshold must violate for in order to create a violation.
   * This value must be within 60-86400 seconds and must be a multiple of the aggregation window.
   * (Default aggregation window duration is 60 seconds.)
   */
  thresholdDuration: Scalars['Int']['input'];
  /** How many data points must be in violation for the specified thresholdDuration. */
  thresholdOccurrences: AlertsNrqlConditionThresholdOccurrences;
};

/** Operator used to compare against the threshold for NrqlConditions. */
export enum AlertsNrqlConditionTermsOperator {
  /** For comparing values above a threshold. */
  Above = 'ABOVE',
  /** For comparing values above or equal to a threshold. */
  AboveOrEquals = 'ABOVE_OR_EQUALS',
  /** For comparing values below a threshold. */
  Below = 'BELOW',
  /** For comparing values below or equal to a threshold. */
  BelowOrEquals = 'BELOW_OR_EQUALS',
  /** For comparing values equal to a threshold. */
  Equals = 'EQUALS',
  /** For comparing values that do not equal a threshold. */
  NotEquals = 'NOT_EQUALS'
}

/** How many data points must be in violation for a NrqlCondition term's threshold duration. */
export enum AlertsNrqlConditionThresholdOccurrences {
  /** All points must be in violation during a term's threshold duration. */
  All = 'ALL',
  /** At least one data point must be in violation during a term's threshold duration. */
  AtLeastOnce = 'AT_LEAST_ONCE'
}

/** Types of NrqlConditions. */
export enum AlertsNrqlConditionType {
  /** Baseline NrqlCondition. */
  Baseline = 'BASELINE',
  /** Outlier NrqlCondition. */
  Outlier = 'OUTLIER',
  /** Static NrqlCondition. */
  Static = 'STATIC'
}

/** Input for updating a baseline NRQL condition. */
export type AlertsNrqlConditionUpdateBaselineInput = {
  /** Direction in which the baseline is set on condition. */
  baselineDirection?: InputMaybe<AlertsNrqlBaselineDirection>;
  /** The custom violation description. */
  description?: InputMaybe<Scalars['String']['input']>;
  /** Whether the NRQL condition is enabled. */
  enabled?: InputMaybe<Scalars['Boolean']['input']>;
  /** Also known as **loss of signal**, these are settings for how violations are opened or closed when a signal expires. */
  expiration?: InputMaybe<AlertsNrqlConditionExpirationInput>;
  /**
   * **Preview access:** This field may be viewed and set, but will not be active until the release date.
   *
   * The condition's incident title template. Must be valid Handlebars.
   */
  incidentTitleTemplate?: InputMaybe<Scalars['String']['input']>;
  /** Name of the NRQL condition. */
  name?: InputMaybe<Scalars['String']['input']>;
  /** The NRQL query that defines the signal for the condition. */
  nrql?: InputMaybe<AlertsNrqlConditionUpdateQueryInput>;
  /** Runbook URL. */
  runbookUrl?: InputMaybe<Scalars['String']['input']>;
  /** Configuration that defines the signal that the NRQL condition will use to evaluate. */
  signal?: InputMaybe<AlertsNrqlConditionSignalInput>;
  /** List of critical and warning terms for the condition. */
  terms?: InputMaybe<Array<AlertsNrqlDynamicConditionTermsInput>>;
  /**
   * Deprecated - use violationTimeLimitSeconds for full range of values.
   *
   * Duration after which a violation automatically closes. Default is THIRTY_DAYS.
   */
  violationTimeLimit?: InputMaybe<AlertsViolationTimeLimit>;
  /**
   * Duration after which a violation automatically closes in seconds.
   * Accepts values between 300 seconds (5 minutes) and 2592000 seconds (30 days).
   *
   * Default is 3 days (259200 seconds).
   */
  violationTimeLimitSeconds?: InputMaybe<Scalars['Seconds']['input']>;
};

/** Input for updating an outlier NRQL condition. */
export type AlertsNrqlConditionUpdateOutlierInput = {
  /** The custom violation description. */
  description?: InputMaybe<Scalars['String']['input']>;
  /** Whether the NRQL condition is enabled. */
  enabled?: InputMaybe<Scalars['Boolean']['input']>;
  /** Number of groups expected in the returned values for the condition. */
  expectedGroups?: InputMaybe<Scalars['Int']['input']>;
  /** Also known as **loss of signal**, these are settings for how violations are opened or closed when a signal expires. */
  expiration?: InputMaybe<AlertsNrqlConditionExpirationInput>;
  /**
   * **Preview access:** This field may be viewed and set, but will not be active until the release date.
   *
   * The condition's incident title template. Must be valid Handlebars.
   */
  incidentTitleTemplate?: InputMaybe<Scalars['String']['input']>;
  /** Name of the NRQL condition. */
  name?: InputMaybe<Scalars['String']['input']>;
  /** The NRQL query that defines the signal for the condition. */
  nrql?: InputMaybe<AlertsNrqlConditionUpdateQueryInput>;
  /** Whether overlapping groups should produce a violation. */
  openViolationOnGroupOverlap?: InputMaybe<Scalars['Boolean']['input']>;
  /** Runbook URL. */
  runbookUrl?: InputMaybe<Scalars['String']['input']>;
  /** Configuration that defines the signal that the NRQL condition will use to evaluate. */
  signal?: InputMaybe<AlertsNrqlConditionSignalInput>;
  /** List of critical and warning terms for the condition. */
  terms?: InputMaybe<Array<AlertsNrqlDynamicConditionTermsInput>>;
  /**
   * Deprecated - use violationTimeLimitSeconds for full range of values.
   *
   * Duration after which a violation automatically closes. Default is THIRTY_DAYS.
   */
  violationTimeLimit?: InputMaybe<AlertsViolationTimeLimit>;
  /**
   * Duration after which a violation automatically closes in seconds.
   * Accepts values between 300 seconds (5 minutes) and 2592000 seconds (30 days).
   *
   * Default is 3 days (259200 seconds).
   */
  violationTimeLimitSeconds?: InputMaybe<Scalars['Seconds']['input']>;
};

/**
 * Information for generating the condition NRQL query.
 * Output from this NRQL query will be compared to the condition terms to detect violations.
 */
export type AlertsNrqlConditionUpdateQueryInput = {
  /**
   * Deprecated; superseded by `signal.aggregationMethod` with `signal.aggregationDelay` or `signal.aggregationTimer`.
   *
   * By default, we evaluate the NRQL query in one-minute time windows. Start time depends on the value you select in the NRQL condition's `evaluationOffset`. Evaluation offset cannot be greater than 60 minutes.
   *
   * This value is the number of time windows we look back at the aggregated data.
   *
   * Example: With an `evaluationOffset` of 3, the NRQL time window applied to your query will be:
   *
   * `SINCE 3 minutes ago UNTIL 2 minutes ago`
   */
  evaluationOffset?: InputMaybe<Scalars['Int']['input']>;
  /** NRQL syntax that defines the query. */
  query?: InputMaybe<Scalars['String']['input']>;
};

/** Input for updating a static NRQL condition. */
export type AlertsNrqlConditionUpdateStaticInput = {
  /** The custom violation description. */
  description?: InputMaybe<Scalars['String']['input']>;
  /** Whether the NRQL condition is enabled. */
  enabled?: InputMaybe<Scalars['Boolean']['input']>;
  /** Also known as **loss of signal**, these are settings for how violations are opened or closed when a signal expires. */
  expiration?: InputMaybe<AlertsNrqlConditionExpirationInput>;
  /**
   * **Preview access:** This field may be viewed and set, but will not be active until the release date.
   *
   * The condition's incident title template. Must be valid Handlebars.
   */
  incidentTitleTemplate?: InputMaybe<Scalars['String']['input']>;
  /** Name of the NRQL condition. */
  name?: InputMaybe<Scalars['String']['input']>;
  /** The NRQL query that defines the signal for the condition. */
  nrql?: InputMaybe<AlertsNrqlConditionUpdateQueryInput>;
  /** Runbook URL. */
  runbookUrl?: InputMaybe<Scalars['String']['input']>;
  /** Configuration that defines the signal that the NRQL condition will use to evaluate. */
  signal?: InputMaybe<AlertsNrqlConditionSignalInput>;
  /**
   * List of critical and warning terms for the condition.
   *
   * Terms are required in most cases. For conditions monitoring Host Not Reporting signals, it can be blank.
   */
  terms?: InputMaybe<Array<AlertsNrqlConditionTermsInput>>;
  /**
   * Deprecated - use `signal.slideBy` instead.
   *
   * Function used to aggregate the NRQL query value(s) for comparison to the `terms.threshold`. When the result of this aggregate surpasses the `terms.threshold`, a violation is opened.
   */
  valueFunction?: InputMaybe<AlertsNrqlStaticConditionValueFunction>;
  /**
   * Deprecated - use violationTimeLimitSeconds for full range of values.
   *
   * Duration after which a violation automatically closes. Default is THIRTY_DAYS.
   */
  violationTimeLimit?: InputMaybe<AlertsViolationTimeLimit>;
  /**
   * Duration after which a violation automatically closes in seconds.
   * Accepts values between 300 seconds (5 minutes) and 2592000 seconds (30 days).
   *
   * Default is 3 days (259200 seconds).
   */
  violationTimeLimitSeconds?: InputMaybe<Scalars['Seconds']['input']>;
};

/** Search criteria for returning specific NRQL conditions. */
export type AlertsNrqlConditionsSearchCriteriaInput = {
  /** Exact name of the NRQL condition. */
  name?: InputMaybe<Scalars['String']['input']>;
  /** String to partially match a NRQL condition name. */
  nameLike?: InputMaybe<Scalars['String']['input']>;
  /** Policy ID associated with the NRQL condition. */
  policyId?: InputMaybe<Scalars['ID']['input']>;
  /** Exact NRQL query used in the NRQL condition. */
  query?: InputMaybe<Scalars['String']['input']>;
  /** String to partially match the NRQL query used in the NRQL condition. */
  queryLike?: InputMaybe<Scalars['String']['input']>;
  /** Terms operator to match while searching for NRQL conditions. */
  termsOperator?: InputMaybe<AlertsNrqlConditionTermsOperator>;
};

/** A collection of NRQL conditions with pagination information. */
export type AlertsNrqlConditionsSearchResultSet = {
  __typename?: 'AlertsNrqlConditionsSearchResultSet';
  /** Cursor pointing to the end of the current page of NrqlCondition records. Null if final page. */
  nextCursor?: Maybe<Scalars['String']['output']>;
  /** A set of `NrqlConditions` for the supplied cursor and criteria. */
  nrqlConditions: Array<AlertsNrqlCondition>;
  /** Total number of `NrqlConditions` for the given search criteria. */
  totalCount: Scalars['Int']['output'];
};

/** NRQL condition terms determine when a violation will be opened. */
export type AlertsNrqlDynamicConditionTermsInput = {
  /** Operator used to compare against the threshold. */
  operator: AlertsNrqlDynamicConditionTermsOperator;
  /** Priority determines how much attention your incidents need. Your workflow settings then tell us when and where to send notifications for different priorities. */
  priority: AlertsNrqlConditionPriority;
  /** Value that triggers a violation. */
  threshold: Scalars['Float']['input'];
  /**
   * The duration, in seconds, that the threshold must violate in order to create a violation.
   * Value must be within 120-86400 seconds and a multiple of the aggregation window for baseline conditions.
   * (Default aggregation window duration is 60 seconds.)
   */
  thresholdDuration: Scalars['Int']['input'];
  /** How many data points must be in violation for the specified threshold duration. */
  thresholdOccurrences: AlertsNrqlConditionThresholdOccurrences;
};

/** Operator used to compare against the threshold for `NrqlConditions`. Only `ABOVE` is allowed for baseline NRQL conditions. */
export enum AlertsNrqlDynamicConditionTermsOperator {
  /** For comparing values above a threshold. */
  Above = 'ABOVE'
}

/**
 * An outlier NRQL condition looks for group behavior and values that are outliers from those
 * groups. Similar to a static NRQL condition, but requires a FACET clause.
 */
export type AlertsNrqlOutlierCondition = AlertsNrqlCondition & {
  __typename?: 'AlertsNrqlOutlierCondition';
  /** The custom violation description. */
  description?: Maybe<Scalars['String']['output']>;
  /** Whether the condition is enabled. */
  enabled: Scalars['Boolean']['output'];
  /** The Entity associated with the NRQL Condition */
  entity?: Maybe<EntityOutline>;
  /** The condition's entity GUID */
  entityGuid: Scalars['EntityGuid']['output'];
  /** Number of groups expected in the returned values for the condition. */
  expectedGroups: Scalars['Int']['output'];
  /** Also known as **loss of signal**, these are settings for how violations are opened or closed when a signal expires. */
  expiration: AlertsNrqlConditionExpiration;
  /** Condition ID. */
  id: Scalars['ID']['output'];
  /**
   * **Preview access:** This field may be viewed and set, but will not be active until the release date.
   *
   * The condition's incident title template. Must be valid Handlebars.
   */
  incidentTitleTemplate?: Maybe<Scalars['String']['output']>;
  /** Name of the condition. */
  name: Scalars['String']['output'];
  /** The NRQL query that defines the signal for the condition. */
  nrql: AlertsNrqlConditionQuery;
  /** Whether overlapping groups should produce a violation. */
  openViolationOnGroupOverlap: Scalars['Boolean']['output'];
  /** Alerts policy ID. */
  policyId: Scalars['ID']['output'];
  /** Runbook URL. */
  runbookUrl?: Maybe<Scalars['String']['output']>;
  /** Settings that determine how the NRQL results are evaluated */
  signal: AlertsNrqlConditionSignal;
  /** List of critical and warning terms for the condition. */
  terms: Array<AlertsNrqlConditionTerms>;
  /** Type of NRQL condition. */
  type: AlertsNrqlConditionType;
  /** The timestamp of the most recent update to the Condition */
  updatedAt?: Maybe<Scalars['EpochMilliseconds']['output']>;
  /** The actor for the most recent Condition update */
  updatedBy?: Maybe<UserReference>;
  /**
   * Deprecated - use violationTimeLimitSeconds for full range of values.
   *
   * Duration after which a violation automatically closes.
   * @deprecated Replaced by `violationTimeLimitSeconds`.
   */
  violationTimeLimit?: Maybe<AlertsViolationTimeLimit>;
  /** Duration after which a violation automatically closes in seconds. */
  violationTimeLimitSeconds?: Maybe<Scalars['Seconds']['output']>;
};

/** How many facets does the provided NRQL query have? */
export type AlertsNrqlQueryFacetCount = {
  __typename?: 'AlertsNrqlQueryFacetCount';
  /** The number of facets produced by the provided NRQL query. */
  count: Scalars['Int']['output'];
};

/** Remove components from a NRQL query which preclude alert condition registration. */
export type AlertsNrqlQueryFormatAlertable = {
  __typename?: 'AlertsNrqlQueryFormatAlertable';
  /** The NRQL query with disallowed components removed. */
  alertableNrqlQuery: Scalars['Nrql']['output'];
};

/** A static NRQL condition is the simplest type of NRQL threshold. It allows you to create a condition based on a NRQL query that returns a numeric value. */
export type AlertsNrqlStaticCondition = AlertsNrqlCondition & {
  __typename?: 'AlertsNrqlStaticCondition';
  /** The custom violation description. */
  description?: Maybe<Scalars['String']['output']>;
  /** Whether the condition is enabled. */
  enabled: Scalars['Boolean']['output'];
  /** The Entity associated with the NRQL Condition */
  entity?: Maybe<EntityOutline>;
  /** The condition's entity GUID */
  entityGuid: Scalars['EntityGuid']['output'];
  /** Also known as **loss of signal**, these are settings for how violations are opened or closed when a signal expires. */
  expiration: AlertsNrqlConditionExpiration;
  /** Condition ID. */
  id: Scalars['ID']['output'];
  /**
   * **Preview access:** This field may be viewed and set, but will not be active until the release date.
   *
   * The condition's incident title template. Must be valid Handlebars.
   */
  incidentTitleTemplate?: Maybe<Scalars['String']['output']>;
  /** Name of the condition. */
  name: Scalars['String']['output'];
  /** The NRQL query that defines the signal for the condition. */
  nrql: AlertsNrqlConditionQuery;
  /** Alerts policy ID. */
  policyId: Scalars['ID']['output'];
  /** Runbook URL. */
  runbookUrl?: Maybe<Scalars['String']['output']>;
  /** Settings that determine how the NRQL results are evaluated */
  signal: AlertsNrqlConditionSignal;
  /** List of critical and warning terms for the condition. */
  terms: Array<AlertsNrqlConditionTerms>;
  /** Type of NRQL condition. */
  type: AlertsNrqlConditionType;
  /** The timestamp of the most recent update to the Condition */
  updatedAt?: Maybe<Scalars['EpochMilliseconds']['output']>;
  /** The actor for the most recent Condition update */
  updatedBy?: Maybe<UserReference>;
  /**
   * Deprecated - use `signal.slideBy` instead.
   *
   * Function used to aggregate the NRQL query value(s) for comparison to the `terms.threshold`. When the result of this aggregate surpasses the `terms.threshold`, a violation is opened.
   * @deprecated Replaced by `signal.slideBy`.
   */
  valueFunction: AlertsNrqlStaticConditionValueFunction;
  /**
   * Deprecated - use violationTimeLimitSeconds for full range of values.
   *
   * Duration after which a violation automatically closes.
   * @deprecated Replaced by `violationTimeLimitSeconds`.
   */
  violationTimeLimit?: Maybe<AlertsViolationTimeLimit>;
  /** Duration after which a violation automatically closes in seconds. */
  violationTimeLimitSeconds?: Maybe<Scalars['Seconds']['output']>;
};

/**
 * Deprecated.  By default, condition is evaluated based on each query's returned value.  To aggregate data in time "windows", use `signal.slideBy`.
 *
 * Function used to aggregate the NRQL query value(s) for comparison to the `terms.threshold`. When the result of this aggregate surpasses the `terms.threshold`, a violation will be opened.
 */
export enum AlertsNrqlStaticConditionValueFunction {
  /**
   * Condition is evaluated based on each query's returned value.
   * @deprecated Default behavior.
   */
  SingleValue = 'SINGLE_VALUE',
  /**
   * Condition is evaluated based on the sum of each query's returned values over the specified thresholdDuration.
   * @deprecated Replaced by `signal.slideBy`.
   */
  Sum = 'SUM'
}

/** OpsGenie data center region */
export enum AlertsOpsGenieDataCenterRegion {
  /** EU data center region */
  Eu = 'EU',
  /** US data center region */
  Us = 'US'
}

/** OpsGenie notification channel. */
export type AlertsOpsGenieNotificationChannel = AlertsNotificationChannel & {
  __typename?: 'AlertsOpsGenieNotificationChannel';
  /** Policies associated with the channel. */
  associatedPolicies: AlertsNotificationChannelPoliciesResultSet;
  /** OpsGenie channel specific configuration. */
  config: AlertsOpsGenieNotificationChannelConfig;
  /** Channel ID. */
  id: Scalars['ID']['output'];
  /** Channel name. */
  name: Scalars['String']['output'];
  /** Channel type. */
  type: AlertsNotificationChannelType;
};

/** Configuration for OpsGenie notification channel. */
export type AlertsOpsGenieNotificationChannelConfig = {
  __typename?: 'AlertsOpsGenieNotificationChannelConfig';
  /** API key. */
  apiKey: Scalars['SecureValue']['output'];
  /** OpsGenie data center region. */
  dataCenterRegion: AlertsOpsGenieDataCenterRegion;
  /** List of email recipients. */
  recipients?: Maybe<Array<Scalars['String']['output']>>;
  /** Tags. */
  tags?: Maybe<Array<Scalars['String']['output']>>;
  /** Teams. */
  teams?: Maybe<Array<Scalars['String']['output']>>;
};

/** The input for creating a new OpsGenie notification channel. */
export type AlertsOpsGenieNotificationChannelCreateInput = {
  /** API key. */
  apiKey: Scalars['SecureValue']['input'];
  /** OpsGenie data center region. */
  dataCenterRegion: AlertsOpsGenieDataCenterRegion;
  /** Notification channel name. */
  name: Scalars['String']['input'];
  /** List of email recipients. */
  recipients?: InputMaybe<Array<Scalars['String']['input']>>;
  /** Tags. */
  tags?: InputMaybe<Array<Scalars['String']['input']>>;
  /** Teams. */
  teams?: InputMaybe<Array<Scalars['String']['input']>>;
};

/** The input for updating an existing OpsGenie notification channel. */
export type AlertsOpsGenieNotificationChannelUpdateInput = {
  /** API key. */
  apiKey?: InputMaybe<Scalars['SecureValue']['input']>;
  /** OpsGenie data center region. */
  dataCenterRegion?: InputMaybe<AlertsOpsGenieDataCenterRegion>;
  /** Notification channel name. */
  name?: InputMaybe<Scalars['String']['input']>;
  /** List of email recipients. */
  recipients?: InputMaybe<Array<Scalars['String']['input']>>;
  /** Tags. */
  tags?: InputMaybe<Array<Scalars['String']['input']>>;
  /** Teams. */
  teams?: InputMaybe<Array<Scalars['String']['input']>>;
};

/** PagerDuty notification channel. */
export type AlertsPagerDutyNotificationChannel = AlertsNotificationChannel & {
  __typename?: 'AlertsPagerDutyNotificationChannel';
  /** Policies associated with the channel. */
  associatedPolicies: AlertsNotificationChannelPoliciesResultSet;
  /** PagerDuty channel specific configuration. */
  config: AlertsPagerDutyNotificationChannelConfig;
  /** Channel ID. */
  id: Scalars['ID']['output'];
  /** Channel name. */
  name: Scalars['String']['output'];
  /** Channel type. */
  type: AlertsNotificationChannelType;
};

/** Configuration for PagerDuty notification channel. */
export type AlertsPagerDutyNotificationChannelConfig = {
  __typename?: 'AlertsPagerDutyNotificationChannelConfig';
  /** API key. */
  apiKey: Scalars['SecureValue']['output'];
};

/** The input for creating a new PagerDuty notification channel. */
export type AlertsPagerDutyNotificationChannelCreateInput = {
  /** API key. */
  apiKey: Scalars['SecureValue']['input'];
  /** Notification channel name. */
  name: Scalars['String']['input'];
};

/** The input for updating an existing PagerDuty notification channel. */
export type AlertsPagerDutyNotificationChannelUpdateInput = {
  /** API key. */
  apiKey?: InputMaybe<Scalars['SecureValue']['input']>;
  /** Notification channel name. */
  name?: InputMaybe<Scalars['String']['input']>;
};

/** Search criteria for returning specific policies. */
export type AlertsPoliciesSearchCriteriaInput = {
  /** The list of policy ids to return. */
  ids?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** Exact name of the policy. */
  name?: InputMaybe<Scalars['String']['input']>;
  /** String to partially match a policy name. */
  nameLike?: InputMaybe<Scalars['String']['input']>;
};

/** Collection of policies with pagination information. */
export type AlertsPoliciesSearchResultSet = {
  __typename?: 'AlertsPoliciesSearchResultSet';
  /** Cursor pointing to the end of the current page of policy records. Null if final page. */
  nextCursor?: Maybe<Scalars['String']['output']>;
  /** Set of policies returned for the supplied cursor and criteria. */
  policies: Array<AlertsPolicy>;
  /** Total number of policy records for the given search criteria. */
  totalCount: Scalars['Int']['output'];
};

/** Container for conditions with associated notifications channels. */
export type AlertsPolicy = {
  __typename?: 'AlertsPolicy';
  /** Account ID of the policy. */
  accountId: Scalars['Int']['output'];
  /** Determines if a policy is connected as an Applied Intelligence input source. */
  connectedToSources?: Maybe<Scalars['Boolean']['output']>;
  /** Primary key for policies. */
  id: Scalars['ID']['output'];
  /** Determines how incidents are created for critical violations of the conditions contained in the policy. */
  incidentPreference: AlertsIncidentPreference;
  /** Description of the policy. */
  name: Scalars['String']['output'];
};

/** Success response when deleting an Alerts policy. */
export type AlertsPolicyDeleteResponse = {
  __typename?: 'AlertsPolicyDeleteResponse';
  /** ID of the deleted policy. */
  id: Scalars['ID']['output'];
};

/** Container for conditions with associated notifications channels. */
export type AlertsPolicyInput = {
  /** Connect a policy as an Applied Intelligence input source. */
  connectedToSources?: InputMaybe<Scalars['Boolean']['input']>;
  /** Determines how incidents are created for critical violations of the conditions contained in the policy. */
  incidentPreference: AlertsIncidentPreference;
  /** Description of the policy. */
  name: Scalars['String']['input'];
};

/** Policy fields to be updated. */
export type AlertsPolicyUpdateInput = {
  /** Connect a policy as an Applied Intelligence input source. */
  connectedToSources?: InputMaybe<Scalars['Boolean']['input']>;
  /** Determines how incidents are created for critical violations of the conditions contained in the policy. */
  incidentPreference?: InputMaybe<AlertsIncidentPreference>;
  /** Description of the policy. */
  name?: InputMaybe<Scalars['String']['input']>;
};

/** The recommended fields for the condition. */
export type AlertsRecommendCondition = {
  __typename?: 'AlertsRecommendCondition';
  /** The recommended baseline direction. (This is only relevant for condition recommendations with anomaly threshold types.) */
  baselineDirection?: Maybe<AlertsNrqlBaselineDirection>;
  /** NRQL query definition. */
  definition: AlertsRecommendConditionDefinition;
  /** Also known as **loss of signal**, these are settings for how violations are opened or closed when a signal expires. */
  expiration: AlertsNrqlConditionExpiration;
  /** Metric value the condition is targeting. */
  metric: AlertsRecommendConditionMetric;
  /** The recommended name for the condition. */
  name: Scalars['String']['output'];
  /** The recommended NRQL query. */
  nrql: Scalars['Nrql']['output'];
  /** Settings that determine how the NRQL results are evaluated */
  signal: AlertsNrqlConditionSignal;
  /** The threshold values recommended for the condition. */
  terms: Array<AlertsNrqlConditionTerms>;
  /** The threshold type for the recommended condition. */
  type: AlertsNrqlConditionType;
  /** Duration after which a violation automatically closes in seconds. */
  violationTimeLimitSeconds?: Maybe<Scalars['Seconds']['output']>;
};

/** NRQL query definitions for the recommended query. */
export type AlertsRecommendConditionDefinition = {
  __typename?: 'AlertsRecommendConditionDefinition';
  /** List of target entity GUIDs or names, indicated by value of eventObjectId. */
  entities: Array<Maybe<Scalars['String']['output']>>;
  /** The attribute to filter target entites by GUIDs. */
  eventId: Scalars['String']['output'];
  /** The attribute to filter target entites by entity names. */
  eventName: Scalars['String']['output'];
  /** Indicates whether eventId is filtering by entity GUIDs or names. */
  eventObjectId: AlertsRecommendConditionEventObjectId;
  /** An optional field to `FACET` by. */
  facet?: Maybe<Scalars['String']['output']>;
  /** The `FROM` clause of the query. */
  from: Scalars['String']['output'];
  /** The `SELECT` clause of the query. */
  select: Scalars['String']['output'];
  /** Optional additional `WHERE` clause for the query. */
  where?: Maybe<Scalars['String']['output']>;
};

/** Indicates if the eventId field references entity GUIDs or entity names. */
export enum AlertsRecommendConditionEventObjectId {
  /** The eventId field references entity GUIDs */
  EntityGuids = 'ENTITY_GUIDS',
  /** The eventId field references entity names. */
  EntityNames = 'ENTITY_NAMES'
}

/** Metric value that the condition targets. */
export type AlertsRecommendConditionMetric = {
  __typename?: 'AlertsRecommendConditionMetric';
  /** UI display value for the metric. */
  title: Scalars['String']['output'];
};

/** A recommendation containing the recommended condition fields and information about the recommendation. */
export type AlertsRecommendConditions = {
  __typename?: 'AlertsRecommendConditions';
  /** The recommended fields for the condition. */
  condition: AlertsRecommendCondition;
};

/** Object contains a card formatted for Ask Ai. */
export type AlertsRecommendConditionsAskAi = {
  __typename?: 'AlertsRecommendConditionsAskAi';
  /** Card formatted for Ask Ai. */
  card: AlertsAskAiCard;
};

/** Result containing recommended conditions formatted for Ask Ai. */
export type AlertsRecommendConditionsAskAiResult = {
  __typename?: 'AlertsRecommendConditionsAskAiResult';
  /** Recommended conditions formatted for Ask Ai. */
  recommendations: AlertsRecommendConditionsAskAi;
};

/** Inputs to build recommended conditions. */
export type AlertsRecommendConditionsInput = {
  /** The prefix to apply to the alert condition name. */
  conditionNamePrefix?: InputMaybe<Scalars['String']['input']>;
  /**
   * A list of `entityGuids` for which we will recommend alert conditions.
   *
   * Note: Use either `entityNames` or `entityGuids`, but not both together.
   */
  entityGuids?: InputMaybe<Array<InputMaybe<Scalars['EntityGuid']['input']>>>;
  /**
   * A list of `entityNames` for which we will recommend alert conditions.
   *
   * Note: Use either `entityNames` or `entityGuids`, but not both together.
   */
  entityNames?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
};

/** A collection of recommendation results for the entity. */
export type AlertsRecommendConditionsResultSet = {
  __typename?: 'AlertsRecommendConditionsResultSet';
  /** Resulting recommendations for the entities. */
  recommendations: Array<AlertsRecommendConditions>;
};

/**
 * The method that determines when we consider an aggregation window to be complete
 * so that we can evaluate the signal for violations. Default is `CADENCE`.
 */
export enum AlertsSignalAggregationMethod {
  /**
   * `CADENCE` streams data points as the clocks at New Relic advance past the end
   * of their window. This ensures a rigorous evaluation cadence, but does not take
   * into account extraneous data latency.
   *
   * Use in conjunction with the `aggregationDelay` field.
   */
  Cadence = 'CADENCE',
  /**
   * `EVENT_FLOW` streams data points for evaluation as data for newer time windows
   * arrive. Whenever data is received, any data points older than the specified
   * delay will be evaluated.
   *
   * Use in conjunction with the `aggregationDelay` field.
   */
  EventFlow = 'EVENT_FLOW',
  /**
   * `EVENT_TIMER` streams data points after the specified timer elapses since data
   * last arrived for that window. Special measures are taken to make sure data
   * points flow in order.
   *
   * Use in conjunction with the `aggregationTimer` field.
   */
  EventTimer = 'EVENT_TIMER'
}

/** Slack notification channel. */
export type AlertsSlackNotificationChannel = AlertsNotificationChannel & {
  __typename?: 'AlertsSlackNotificationChannel';
  /** Policies associated with the channel. */
  associatedPolicies: AlertsNotificationChannelPoliciesResultSet;
  /** Slack channel specific configuration. */
  config: AlertsSlackNotificationChannelConfig;
  /** Channel ID. */
  id: Scalars['ID']['output'];
  /** Channel name. */
  name: Scalars['String']['output'];
  /** Channel type. */
  type: AlertsNotificationChannelType;
};

/** Configuration for Slack notification channel. */
export type AlertsSlackNotificationChannelConfig = {
  __typename?: 'AlertsSlackNotificationChannelConfig';
  /** Slack channel name. */
  teamChannel?: Maybe<Scalars['String']['output']>;
  /** Slack channel URL. */
  url: Scalars['SecureValue']['output'];
};

/** The input for creating a new Slack notification channel. */
export type AlertsSlackNotificationChannelCreateInput = {
  /** Notification channel name. */
  name: Scalars['String']['input'];
  /** Slack channel name. */
  teamChannel?: InputMaybe<Scalars['String']['input']>;
  /** Slack channel URL. */
  url: Scalars['SecureValue']['input'];
};

/** The input for updating an existing Slack notification channel. */
export type AlertsSlackNotificationChannelUpdateInput = {
  /** Notification channel name. */
  name?: InputMaybe<Scalars['String']['input']>;
  /** Slack channel name. */
  teamChannel?: InputMaybe<Scalars['String']['input']>;
  /** Slack channel URL. */
  url?: InputMaybe<Scalars['SecureValue']['input']>;
};

/** User notification channel. */
export type AlertsUserNotificationChannel = AlertsNotificationChannel & {
  __typename?: 'AlertsUserNotificationChannel';
  /**
   * Policies associated with the channel.
   * @deprecated This channel type is deprecated
   */
  associatedPolicies: AlertsNotificationChannelPoliciesResultSet;
  /**
   * User channel specific configuration.
   * @deprecated This channel type is deprecated
   */
  config: AlertsUserNotificationChannelConfig;
  /**
   * Channel ID.
   * @deprecated This channel type is deprecated
   */
  id: Scalars['ID']['output'];
  /**
   * Channel name.
   * @deprecated This channel type is deprecated
   */
  name: Scalars['String']['output'];
  /**
   * Channel type.
   * @deprecated This channel type is deprecated
   */
  type: AlertsNotificationChannelType;
};

/** Configuration for user notification channel. */
export type AlertsUserNotificationChannelConfig = {
  __typename?: 'AlertsUserNotificationChannelConfig';
  /**
   * User ID.
   * @deprecated This channel type is deprecated
   */
  userId: Scalars['String']['output'];
};

/** VictorOps notification channel. */
export type AlertsVictorOpsNotificationChannel = AlertsNotificationChannel & {
  __typename?: 'AlertsVictorOpsNotificationChannel';
  /** Policies associated with the channel. */
  associatedPolicies: AlertsNotificationChannelPoliciesResultSet;
  /** VictorOps channel specific configuration. */
  config: AlertsVictorOpsNotificationChannelConfig;
  /** Channel ID. */
  id: Scalars['ID']['output'];
  /** Channel name. */
  name: Scalars['String']['output'];
  /** Channel type. */
  type: AlertsNotificationChannelType;
};

/** Configuration for VictorOps notification channel. */
export type AlertsVictorOpsNotificationChannelConfig = {
  __typename?: 'AlertsVictorOpsNotificationChannelConfig';
  /** Key. */
  key: Scalars['SecureValue']['output'];
  /** Route key. */
  routeKey: Scalars['String']['output'];
};

/** The input for creating a new VictorOps notification channel. */
export type AlertsVictorOpsNotificationChannelCreateInput = {
  /** Key. */
  key: Scalars['SecureValue']['input'];
  /** Notification channel name. */
  name: Scalars['String']['input'];
  /** Route key. */
  routeKey: Scalars['String']['input'];
};

/** The input for updating an existing VictorOps notification channel. */
export type AlertsVictorOpsNotificationChannelUpdateInput = {
  /** Key. */
  key?: InputMaybe<Scalars['SecureValue']['input']>;
  /** Notification channel name. */
  name?: InputMaybe<Scalars['String']['input']>;
  /** Route key. */
  routeKey?: InputMaybe<Scalars['String']['input']>;
};

/** Duration after which a violation will automatically close. */
export enum AlertsViolationTimeLimit {
  /** Violation will close after eight hours. */
  EightHours = 'EIGHT_HOURS',
  /** Violation will close after four hours. */
  FourHours = 'FOUR_HOURS',
  /** Time limit specified does not match available options. */
  NonMatchableLimitValue = 'NON_MATCHABLE_LIMIT_VALUE',
  /** Violation will close after one hour. */
  OneHour = 'ONE_HOUR',
  /** Violation will close after thirty days. */
  ThirtyDays = 'THIRTY_DAYS',
  /** Violation will close after twelve hours. */
  TwelveHours = 'TWELVE_HOURS',
  /** Violation will close after twenty four hours. */
  TwentyFourHours = 'TWENTY_FOUR_HOURS',
  /** Violation will close after two hours. */
  TwoHours = 'TWO_HOURS'
}

/** Webhook basic auth */
export type AlertsWebhookBasicAuthInput = {
  __typename?: 'AlertsWebhookBasicAuthInput';
  /** Password */
  password: Scalars['SecureValue']['output'];
  /** Username */
  username: Scalars['String']['output'];
};

/** Webhook basic auth */
export type AlertsWebhookBasicAuthMutationInput = {
  /** Password */
  password: Scalars['SecureValue']['input'];
  /** Username */
  username: Scalars['String']['input'];
};

/** Webhook header */
export type AlertsWebhookCustomHeaderInput = {
  __typename?: 'AlertsWebhookCustomHeaderInput';
  /** Header name */
  name: Scalars['String']['output'];
  /** Header value */
  value: Scalars['SecureValue']['output'];
};

/** Webhook header */
export type AlertsWebhookCustomHeaderMutationInput = {
  /** Header name */
  name: Scalars['String']['input'];
  /** Header value */
  value: Scalars['SecureValue']['input'];
};

/** Webhook custom payload type */
export enum AlertsWebhookCustomPayloadType {
  /** FORM payload type */
  Form = 'FORM',
  /** JSON payload type */
  Json = 'JSON'
}

/** Webhook notification channel. */
export type AlertsWebhookNotificationChannel = AlertsNotificationChannel & {
  __typename?: 'AlertsWebhookNotificationChannel';
  /** Policies associated with the channel. */
  associatedPolicies: AlertsNotificationChannelPoliciesResultSet;
  /** Webhook channel specific configuration. */
  config: AlertsWebhookNotificationChannelConfig;
  /** Channel ID. */
  id: Scalars['ID']['output'];
  /** Channel name. */
  name: Scalars['String']['output'];
  /** Channel type. */
  type: AlertsNotificationChannelType;
};

/** Configuration for Webhook notification channel. */
export type AlertsWebhookNotificationChannelConfig = {
  __typename?: 'AlertsWebhookNotificationChannelConfig';
  /** Base URL. */
  baseUrl: Scalars['String']['output'];
  /** Basic auth. */
  basicAuth?: Maybe<AlertsWebhookBasicAuthInput>;
  /** Custom HTTP headers. */
  customHttpHeaders?: Maybe<Array<AlertsWebhookCustomHeaderInput>>;
  /** Custom payload body. */
  customPayloadBody?: Maybe<Scalars['String']['output']>;
  /** Custom payload type. */
  customPayloadType?: Maybe<AlertsWebhookCustomPayloadType>;
};

/** The input for creating a new Webhook notification channel. */
export type AlertsWebhookNotificationChannelCreateInput = {
  /** Base URL. */
  baseUrl: Scalars['String']['input'];
  /** Basic auth. */
  basicAuth?: InputMaybe<AlertsWebhookBasicAuthMutationInput>;
  /** Custom HTTP headers. */
  customHttpHeaders?: InputMaybe<Array<AlertsWebhookCustomHeaderMutationInput>>;
  /** Custom payload body. */
  customPayloadBody?: InputMaybe<Scalars['String']['input']>;
  /** Custom payload type. */
  customPayloadType?: InputMaybe<AlertsWebhookCustomPayloadType>;
  /** Notification channel name. */
  name: Scalars['String']['input'];
};

/** The input for updating an existing Webhook notification channel. */
export type AlertsWebhookNotificationChannelUpdateInput = {
  /** Base URL. */
  baseUrl?: InputMaybe<Scalars['String']['input']>;
  /** Basic auth. */
  basicAuth?: InputMaybe<AlertsWebhookBasicAuthMutationInput>;
  /** Custom HTTP headers. */
  customHttpHeaders?: InputMaybe<Array<AlertsWebhookCustomHeaderMutationInput>>;
  /** Custom payload body. */
  customPayloadBody?: InputMaybe<Scalars['String']['input']>;
  /** Custom payload type. */
  customPayloadType?: InputMaybe<AlertsWebhookCustomPayloadType>;
  /** Notification channel name. */
  name?: InputMaybe<Scalars['String']['input']>;
};

/** xMatters notification channel. */
export type AlertsXMattersNotificationChannel = AlertsNotificationChannel & {
  __typename?: 'AlertsXMattersNotificationChannel';
  /** Policies associated with the channel. */
  associatedPolicies: AlertsNotificationChannelPoliciesResultSet;
  /** xMatters channel specific configuration. */
  config: AlertsXMattersNotificationChannelConfig;
  /** Channel ID. */
  id: Scalars['ID']['output'];
  /** Channel name. */
  name: Scalars['String']['output'];
  /** Channel type. */
  type: AlertsNotificationChannelType;
};

/** Configuration for xMatters notification channel. */
export type AlertsXMattersNotificationChannelConfig = {
  __typename?: 'AlertsXMattersNotificationChannelConfig';
  /** Integration URL. */
  integrationUrl: Scalars['SecureValue']['output'];
};

/** The input for creating a new xMatters notification channel. */
export type AlertsXMattersNotificationChannelCreateInput = {
  /** Integration URL. */
  integrationUrl: Scalars['SecureValue']['input'];
  /** Notification channel name. */
  name: Scalars['String']['input'];
};

/** The input for updating an existing xMatters notification channel. */
export type AlertsXMattersNotificationChannelUpdateInput = {
  /** Integration URL. */
  integrationUrl?: InputMaybe<Scalars['SecureValue']['input']>;
  /** Notification channel name. */
  name?: InputMaybe<Scalars['String']['input']>;
};

/** ActorStitchedFields is a required top-level type for nerdgraph integration */
export type AnomalyDetectorConfigurationsActorStitchedFields = {
  __typename?: 'AnomalyDetectorConfigurationsActorStitchedFields';
  /**
   * Get current signal and global default thresholds. When a configuration does not specify threshold values, default values are used.
   * @deprecated Usage not recommended. Will be removed in future release.
   */
  anomalyDetectorThresholds?: Maybe<Array<Maybe<AnomalyDetectorConfigurationsThreshold>>>;
  /**
   * Get all accessible anomaly detector configurations. An anomaly detector configuration specifies a dataset to be checked for anomalies at a regular interval. The dataset can be created via a workload, an entity type, or a custom NRQL query. Through thresholds and sensitivity, configurations can be adjusted to produce more or less anomalies.
   * @deprecated Usage not recommended. Will be removed in future release.
   */
  anomalyDetectors?: Maybe<Array<Maybe<AnomalyDetectorConfigurationsAnomalyDetector>>>;
};


/** ActorStitchedFields is a required top-level type for nerdgraph integration */
export type AnomalyDetectorConfigurationsActorStitchedFieldsAnomalyDetectorThresholdsArgs = {
  filters?: InputMaybe<AnomalyDetectorConfigurationsThresholdFilterInput>;
};


/** ActorStitchedFields is a required top-level type for nerdgraph integration */
export type AnomalyDetectorConfigurationsActorStitchedFieldsAnomalyDetectorsArgs = {
  filters?: InputMaybe<AnomalyDetectorConfigurationsAnomalyDetectorFilterInput>;
};

/** An object representing the settings used to detect anomalies from a set of entities once a minute. */
export type AnomalyDetectorConfigurationsAnomalyDetector = {
  /** The account in which anomalous results are recorded. */
  accountId: Scalars['Int']['output'];
  /** The time the anomaly detector was created. */
  createdAt: Scalars['EpochMilliseconds']['output'];
  /** The user who created the anomaly detector. */
  createdBy?: Maybe<UserReference>;
  /** A boolean representing whether or not to record data in the provided accountId or a temporary demo account. */
  demoMode: Scalars['Boolean']['output'];
  /** An enum representing the anomaly detections sensitivity to change for all signals in the dataset. If not specified, it defaults to LOW. */
  deviationSensitivity?: Maybe<AnomalyDetectorConfigurationsDeviationSensitivity>;
  /** A unique anomaly detector identifier. */
  id: Scalars['Int']['output'];
  /** A name to describe the dataset being watched. */
  name: Scalars['String']['output'];
  /** A status representing whether anomalies should be collected. */
  status: AnomalyDetectorConfigurationsAnomalyDetectorStatus;
  /** The time any anomaly detector settings were last changed. */
  updatedAt: Scalars['EpochMilliseconds']['output'];
};

/** A description of any errors that occurred while attempting to delete any kind of anomaly detector. */
export type AnomalyDetectorConfigurationsAnomalyDetectorDeleteError = {
  __typename?: 'AnomalyDetectorConfigurationsAnomalyDetectorDeleteError';
  /** An error message. */
  description?: Maybe<Scalars['String']['output']>;
  /** An error type. */
  type?: Maybe<AnomalyDetectorConfigurationsAnomalyDetectorDeleteErrorType>;
};

/** An enum representing errors that occur when deleting any kind of anomaly detector. */
export enum AnomalyDetectorConfigurationsAnomalyDetectorDeleteErrorType {
  /** The user does not have access to delete the anomaly detector. */
  NotAuthorized = 'NOT_AUTHORIZED'
}

/** The details of an attempt to delete a workload anomaly detector. */
export type AnomalyDetectorConfigurationsAnomalyDetectorDeleteResponse = {
  __typename?: 'AnomalyDetectorConfigurationsAnomalyDetectorDeleteResponse';
  /** An array of errors, if any. */
  errors?: Maybe<Array<Maybe<AnomalyDetectorConfigurationsAnomalyDetectorDeleteError>>>;
  /** Whether or not the delete was successful. */
  success?: Maybe<Scalars['Boolean']['output']>;
};

/** An object with filters that can be applied to a list of anomalyDetectors. */
export type AnomalyDetectorConfigurationsAnomalyDetectorFilterInput = {
  /** Filter to one or more anomaly detectors. */
  anomalyDetectorIds?: InputMaybe<Array<Scalars['Int']['input']>>;
  /** Filter to anomalyDetectors associated with specific workload(s). */
  workloadGuids?: InputMaybe<Array<Scalars['EntityGuid']['input']>>;
};

/** Indicates the status of a detector */
export enum AnomalyDetectorConfigurationsAnomalyDetectorStatus {
  /** An active detector's dataset is checked for anomalies at a regular interval */
  Active = 'ACTIVE',
  /** An inactive detector does not produce any anomalous results */
  Inactive = 'INACTIVE'
}

/** An object used to create a type of anomaly detector that uses entities of a single entity type within the accountId as the dataset. */
export type AnomalyDetectorConfigurationsCreateEntityTypeAnomalyDetectorInput = {
  /** A list of additional accountIds from which to pull entities to include in the dataset. Data will not be recorded in these accounts. */
  additionalSourceAccountIds?: InputMaybe<Array<InputMaybe<Scalars['Int']['input']>>>;
  /** A boolean representing whether or not to record data in the provided accountId or a temporary demo account. */
  demoMode?: InputMaybe<Scalars['Boolean']['input']>;
  /** The entity type used to determine entities in the dataset. */
  domainType: DomainTypeInput;
  /** A list of entity guids that should be included in the dataset in cases where only a few entities should be watched - an empty list indicates all entities of the type are included. */
  includedEntityGuids?: InputMaybe<Array<InputMaybe<Scalars['EntityGuid']['input']>>>;
  /** A name to describe the dataset being watched. */
  name: Scalars['String']['input'];
};

/** An object used to create a type of anomaly detector that uses the results of a NRQL query as the dataset. */
export type AnomalyDetectorConfigurationsCreateNrqlAnomalyDetectorInput = {
  /** A boolean representing whether or not to record data in the provided accountId or a temporary demo account. */
  demoMode?: InputMaybe<Scalars['Boolean']['input']>;
  /** A name to describe the dataset being watched. */
  name: Scalars['String']['input'];
  /** A list of custom signals used to detect anomalies. */
  nrqlSignals: Array<AnomalyDetectorConfigurationsNrqlSignalInput>;
};

/** An object used to create a type of anomaly detector that uses entities within a workload as the dataset. */
export type AnomalyDetectorConfigurationsCreateWorkloadAnomalyDetectorInput = {
  /** A boolean representing whether or not to record data in the provided accountId or a temporary demo account. */
  demoMode?: InputMaybe<Scalars['Boolean']['input']>;
  /** A list of entity guids that are present in the workload, but should not be included in the dataset. */
  excludedEntityGuids?: InputMaybe<Array<InputMaybe<Scalars['EntityGuid']['input']>>>;
  /** A name to describe the dataset being watched. */
  name: Scalars['String']['input'];
};

/** Indicates a relative sensitivity to change when detecting anomalies in the dataset */
export enum AnomalyDetectorConfigurationsDeviationSensitivity {
  /** High sensitivity produces more anomalous results */
  High = 'HIGH',
  /** Low sensitivity produces less anomalous results */
  Low = 'LOW',
  /** Medium sensitivity produces some anomalous results */
  Medium = 'MEDIUM',
  /** No sensitivity produces no anomalous results */
  None = 'NONE'
}

/** A type of anomaly detector that uses golden signals for all entities of a single entity type in the provided accountId as the dataset. */
export type AnomalyDetectorConfigurationsEntityTypeAnomalyDetector = AnomalyDetectorConfigurationsAnomalyDetector & {
  __typename?: 'AnomalyDetectorConfigurationsEntityTypeAnomalyDetector';
  /** The account in which anomalous results are recorded. */
  accountId: Scalars['Int']['output'];
  /** A list of additional accountIds from which to pull entities to include in the dataset. */
  additionalSourceAccountIds?: Maybe<Array<Scalars['Int']['output']>>;
  /** The time the anomaly detector was created. */
  createdAt: Scalars['EpochMilliseconds']['output'];
  /** The user who created the anomaly detector. */
  createdBy?: Maybe<UserReference>;
  /** A boolean representing whether or not to record data in the provided accountId or a temporary demo account. */
  demoMode: Scalars['Boolean']['output'];
  /** An enum representing the anomaly detections sensitivity to change for all signals in the dataset. If not specified, it defaults to LOW. */
  deviationSensitivity?: Maybe<AnomalyDetectorConfigurationsDeviationSensitivity>;
  /** The entity type of the dataset. All entities of this type within the accountId and additionalSourceAccountIds will make up the dataset. */
  domainType: DomainType;
  /** A unique anomaly detector identifier. */
  id: Scalars['Int']['output'];
  /** A list of entity guids that should be included in the dataset for use cases where only a few entities should be watched - an empty list indicates all entities of this type are included. */
  includedEntities?: Maybe<Array<EntityOutline>>;
  /** A name to describe the dataset being watched. */
  name: Scalars['String']['output'];
  /** An object representing whether anomalies should be collected. */
  status: AnomalyDetectorConfigurationsAnomalyDetectorStatus;
  /** A list of golden signal thresholds. Null values represent default threshold values. */
  thresholds?: Maybe<Array<AnomalyDetectorConfigurationsThreshold>>;
  /** The time any anomaly detector settings were last changed. */
  updatedAt: Scalars['EpochMilliseconds']['output'];
};

/** A description of any errors that occurred while attempting to update an entity anomaly detector. */
export type AnomalyDetectorConfigurationsEntityTypeAnomalyDetectorCreateError = {
  __typename?: 'AnomalyDetectorConfigurationsEntityTypeAnomalyDetectorCreateError';
  /** An error message. */
  description?: Maybe<Scalars['String']['output']>;
  /** An error type. */
  type?: Maybe<AnomalyDetectorConfigurationsEntityTypeAnomalyDetectorCreateErrorType>;
};

/** An enum representing errors that occur when creating an entity type anomaly detector. */
export enum AnomalyDetectorConfigurationsEntityTypeAnomalyDetectorCreateErrorType {
  /** One or more additionalAccountId provided is not accessible to the user. */
  AdditionalAccountsNotAuthorized = 'ADDITIONAL_ACCOUNTS_NOT_AUTHORIZED',
  /** One or more includedEntityGuid provided is invalid. */
  InvalidEntities = 'INVALID_ENTITIES'
}

/** The details of an attempt to create an entity type anomaly detector. */
export type AnomalyDetectorConfigurationsEntityTypeAnomalyDetectorCreateResponse = {
  __typename?: 'AnomalyDetectorConfigurationsEntityTypeAnomalyDetectorCreateResponse';
  /** A unique anomaly detector identifier if one was successfully created. */
  anomalyDetectorId?: Maybe<Scalars['Int']['output']>;
  /** An array of errors, if any. */
  errors?: Maybe<Array<Maybe<AnomalyDetectorConfigurationsEntityTypeAnomalyDetectorCreateError>>>;
};

/** A description of any errors that occurred while attempting to update an entity anomaly detector. */
export type AnomalyDetectorConfigurationsEntityTypeAnomalyDetectorUpdateError = {
  __typename?: 'AnomalyDetectorConfigurationsEntityTypeAnomalyDetectorUpdateError';
  /** An error message. */
  description?: Maybe<Scalars['String']['output']>;
  /** An error type. */
  type?: Maybe<AnomalyDetectorConfigurationsEntityTypeAnomalyDetectorUpdateErrorType>;
};

/** An enum representing errors that occur when updating an entity type anomaly detector. */
export enum AnomalyDetectorConfigurationsEntityTypeAnomalyDetectorUpdateErrorType {
  /** One or more additionalAccountId provided is not accessible to the user. */
  AdditionalAccountsNotAuthorized = 'ADDITIONAL_ACCOUNTS_NOT_AUTHORIZED',
  /** One or more includedEntityGuid provided is invalid. */
  InvalidEntities = 'INVALID_ENTITIES',
  /** The user does not have access to update the anomaly detector. */
  NotAuthorized = 'NOT_AUTHORIZED'
}

/** The details of an attempt to update an entity anomaly detector. */
export type AnomalyDetectorConfigurationsEntityTypeAnomalyDetectorUpdateResponse = {
  __typename?: 'AnomalyDetectorConfigurationsEntityTypeAnomalyDetectorUpdateResponse';
  /** A unique anomaly detector identifier if one was successfully updated. */
  anomalyDetectorId?: Maybe<Scalars['Int']['output']>;
  /** An array containing errors, if any. */
  errors?: Maybe<Array<Maybe<AnomalyDetectorConfigurationsEntityTypeAnomalyDetectorUpdateError>>>;
};

/** A type of anomaly detector that uses the facet values of a NRQL query as the dataset. */
export type AnomalyDetectorConfigurationsNrqlAnomalyDetector = AnomalyDetectorConfigurationsAnomalyDetector & {
  __typename?: 'AnomalyDetectorConfigurationsNrqlAnomalyDetector';
  /** The account in which anomalous results are recorded. */
  accountId: Scalars['Int']['output'];
  /** The time the anomaly detector was created. */
  createdAt: Scalars['EpochMilliseconds']['output'];
  /** The user who created the anomaly detector. */
  createdBy?: Maybe<UserReference>;
  /** A boolean representing whether or not to record data in the provided accountId or a temporary demo account. */
  demoMode: Scalars['Boolean']['output'];
  /** An enum representing the anomaly detections sensitivity to change for all signals in the dataset. If not specified, it defaults to LOW. */
  deviationSensitivity?: Maybe<AnomalyDetectorConfigurationsDeviationSensitivity>;
  /** A unique anomaly detector identifier. */
  id: Scalars['Int']['output'];
  /** A name to describe the dataset being watched. */
  name: Scalars['String']['output'];
  /** A list of custom signals used to detect anomalies. */
  nrqlSignals: Array<AnomalyDetectorConfigurationsNrqlSignal>;
  /** An object representing whether anomalies should be collected. */
  status: AnomalyDetectorConfigurationsAnomalyDetectorStatus;
  /** The time any anomaly detector settings were last changed. */
  updatedAt: Scalars['EpochMilliseconds']['output'];
};

/** A description of any errors that occurred while attempting to update a nrql anomaly detector. */
export type AnomalyDetectorConfigurationsNrqlAnomalyDetectorCreateError = {
  __typename?: 'AnomalyDetectorConfigurationsNrqlAnomalyDetectorCreateError';
  /** An error message. */
  description?: Maybe<Scalars['String']['output']>;
  /** An array containing errors, if any. */
  type?: Maybe<Array<Maybe<AnomalyDetectorConfigurationsNrqlErrorType>>>;
};

/** The details of an attempt to create a nrql anomaly detector. */
export type AnomalyDetectorConfigurationsNrqlAnomalyDetectorCreateResponse = {
  __typename?: 'AnomalyDetectorConfigurationsNrqlAnomalyDetectorCreateResponse';
  /** A unique anomaly detector identifier. */
  anomalyDetectorId?: Maybe<Scalars['Int']['output']>;
  /** An array containing errors, if any. */
  errors?: Maybe<Array<Maybe<AnomalyDetectorConfigurationsNrqlAnomalyDetectorCreateError>>>;
};

/** An error that occurs while attempting to update a nrql anomaly detector. */
export type AnomalyDetectorConfigurationsNrqlAnomalyDetectorUpdateError = {
  __typename?: 'AnomalyDetectorConfigurationsNrqlAnomalyDetectorUpdateError';
  /** An error message. */
  description?: Maybe<Scalars['String']['output']>;
  /** An error type. */
  type?: Maybe<Array<Maybe<AnomalyDetectorConfigurationsNrqlErrorType>>>;
};

/** The details of an attempt to update a nrql anomaly detector. */
export type AnomalyDetectorConfigurationsNrqlAnomalyDetectorUpdateResponse = {
  __typename?: 'AnomalyDetectorConfigurationsNrqlAnomalyDetectorUpdateResponse';
  /** A unique anomaly detector identifier if one was updated successfully. */
  anomalyDetectorId?: Maybe<Scalars['Int']['output']>;
  /** An array containing errors, if any. */
  errors?: Maybe<Array<Maybe<AnomalyDetectorConfigurationsNrqlAnomalyDetectorUpdateError>>>;
  /** A list of custom nrql signals. */
  nrqlSignals?: Maybe<Array<Maybe<AnomalyDetectorConfigurationsNrqlSignal>>>;
};

/** An enum representing a reason a NRQL query is not valid for anomaly detection. Anomaly detection does not support all valid NRQL features. */
export enum AnomalyDetectorConfigurationsNrqlErrorType {
  /** Cases are not supported. */
  CasesNotSupported = 'CASES_NOT_SUPPORTED',
  /** The COMPARE WITH clause is not supported. */
  CompareWithNotSupported = 'COMPARE_WITH_NOT_SUPPORTED',
  /** The query returned too much data for anomaly detection to support. */
  CouldntCompleteQuery = 'COULDNT_COMPLETE_QUERY',
  /** The query is not supported by DAQS. */
  DaqsNotAllowed = 'DAQS_NOT_ALLOWED',
  /** The query is invalid. */
  InvalidNrql = 'INVALID_NRQL',
  /** The LIMIT clause is not supported. */
  LimitNotSupported = 'LIMIT_NOT_SUPPORTED',
  /** The query is missing a facet value. */
  MissingFacet = 'MISSING_FACET',
  /** Multiple facet attributes per query is not supported. */
  MultipleFacetNotSupported = 'MULTIPLE_FACET_NOT_SUPPORTED',
  /** Multiple SELECT clauses are not supported. */
  MultiselectNotSupported = 'MULTISELECT_NOT_SUPPORTED',
  /** Queries that return non numeric values are not supported. */
  NonNumericAggregateNotSupported = 'NON_NUMERIC_AGGREGATE_NOT_SUPPORTED',
  /** The signal already exists for the provided account. */
  NonUniqueSignalAccount = 'NON_UNIQUE_SIGNAL_ACCOUNT',
  /** The user does not have access the provided account. */
  NotAuthorized = 'NOT_AUTHORIZED',
  /** The SINCE clause is not supported. */
  SinceNotSupported = 'SINCE_NOT_SUPPORTED',
  /** The TIMESERIES clause is not supported. */
  TimeseriesNotSupported = 'TIMESERIES_NOT_SUPPORTED',
  /** The query has surpassed the anomaly detection facet limit. */
  TooManyFacetValues = 'TOO_MANY_FACET_VALUES',
  /** The UNTIL clause is not supported. */
  UntilNotSupported = 'UNTIL_NOT_SUPPORTED'
}

/** A custom signal based off a nrql query registered in DAQS. */
export type AnomalyDetectorConfigurationsNrqlSignal = {
  __typename?: 'AnomalyDetectorConfigurationsNrqlSignal';
  /** The accountId the NRQL query queries. */
  accountId: Scalars['Int']['output'];
  /** An array of facet values that should not be included in the dataset. */
  mutedFacetValues?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
  /** A name for the signal. */
  name: Scalars['String']['output'];
  /** A NRQL query. */
  nrql: Scalars['Nrql']['output'];
  /** A DAQS query identifier. */
  queryId: Scalars['Int']['output'];
  /** An object representing the threshold values that deviate from the global default threshold. */
  threshold?: Maybe<AnomalyDetectorConfigurationsThreshold>;
};

/** A custom signal based off a nrql query to be registered with DAQS. Each signal must be unique to the provided account. Not all NRQL features are supported by anomaly detection. To avoid invalid nrql errors, run the query through validateNrqlSignal first. */
export type AnomalyDetectorConfigurationsNrqlSignalInput = {
  /** The accountId to be queried. */
  accountId: Scalars['Int']['input'];
  /** An array of facet values that are present in the NRQL results but should not be included in the dataset. */
  mutedFacetValues?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  /** A name for the signal. */
  name: Scalars['String']['input'];
  /** A nrql query. */
  nrql: Scalars['Nrql']['input'];
};

/** A response indicating whether or not a custom NRQL signal can be used for anomaly detection. */
export type AnomalyDetectorConfigurationsNrqlValidatorResponse = {
  __typename?: 'AnomalyDetectorConfigurationsNrqlValidatorResponse';
  /** A list of reasons why the NRQL signal provided cannot be used in an anomaly detector -- an empty list indicates the NRQL signal is valid. */
  invalidNrqlReasons?: Maybe<Array<AnomalyDetectorConfigurationsNrqlErrorType>>;
};

/** Indicates the specific direction of change when detecting anomalies in the dataset */
export enum AnomalyDetectorConfigurationsSignificantDeviationDirection {
  /** A result is anomalous only if the relative change is higher */
  Higher = 'HIGHER',
  /** A result is anomalous if the relative change is lower or higher */
  HigherLower = 'HIGHER_LOWER',
  /** A result is anomalous only if the relative change is lower */
  Lower = 'LOWER'
}

/** A description of any errors that occurred while attempting to change an anomaly detector's status. */
export type AnomalyDetectorConfigurationsStatusUpdateError = {
  __typename?: 'AnomalyDetectorConfigurationsStatusUpdateError';
  /** An error message. */
  description?: Maybe<Scalars['String']['output']>;
  /** An error type. */
  type?: Maybe<AnomalyDetectorConfigurationsStatusUpdateErrorType>;
};

/** An enum representing errors that occur when updating an anomaly detector status. */
export enum AnomalyDetectorConfigurationsStatusUpdateErrorType {
  /** The user does not have access to update the anomaly detector's status. */
  NotAuthorized = 'NOT_AUTHORIZED'
}

/** The details of an attempt to update an anomaly detector's status. */
export type AnomalyDetectorConfigurationsStatusUpdateResponse = {
  __typename?: 'AnomalyDetectorConfigurationsStatusUpdateResponse';
  /** An array of errors, if any. */
  errors?: Maybe<Array<Maybe<AnomalyDetectorConfigurationsStatusUpdateError>>>;
  /** A status that reflects whether an anomaly detector is active. */
  status?: Maybe<AnomalyDetectorConfigurationsAnomalyDetectorStatus>;
};

/**
 * An object representing the upper &/or lower boundaries that indicate when a signal is considered anomalous.
 *  A null value within a WorkloadAnomalyDetector or EntityTypeAnomalyDetector indicates a signal default value is being used.
 *  A null signal default value or null value within a NrqlAnomalyDetector indicates a global default value is being used.
 */
export type AnomalyDetectorConfigurationsThreshold = {
  __typename?: 'AnomalyDetectorConfigurationsThreshold';
  /** An enum representing the anomaly detections sensitivity to change for this signal. */
  deviationSensitivity?: Maybe<AnomalyDetectorConfigurationsDeviationSensitivity>;
  /** The signals entity type. */
  domainType?: Maybe<DomainType>;
  /** Any value below this limit value will be considered anomalous when the significant deviation direction is LOWER or HIGHER_LOWER. */
  lowerLimit?: Maybe<AnomalyDetectorConfigurationsThresholdLimitValue>;
  /** Any relative percent change less than this percent value will be considered anomalous when the significant deviation direction is LOWER or HIGHER_LOWER. */
  lowerRelativePercent?: Maybe<AnomalyDetectorConfigurationsThresholdRelativePercentValue>;
  /** A signal name. */
  signalName: Scalars['String']['output'];
  /** An enum representing which direction of change is considered anomalous for this signal. */
  significantDeviationDirection?: Maybe<AnomalyDetectorConfigurationsSignificantDeviationDirection>;
  /** Any value above this limit value will be considered anomalous when the significant deviation direction is HIGHER or HIGHER_LOWER. */
  upperLimit?: Maybe<AnomalyDetectorConfigurationsThresholdLimitValue>;
  /** Any relative percent change higher than this percent value will be considered anomalous when the significant deviation direction is HIGHER or HIGHER_LOWER. */
  upperRelativePercent?: Maybe<AnomalyDetectorConfigurationsThresholdRelativePercentValue>;
};

/** An object with filters that can be applied to a list of thresholds */
export type AnomalyDetectorConfigurationsThresholdFilterInput = {
  /** Filter to defaults set at a point in time, defaults to the current time. */
  createdAt?: InputMaybe<Scalars['EpochMilliseconds']['input']>;
  /** Filter to defaults within a specific entity type. */
  domainTypes?: InputMaybe<Array<DomainTypeInput>>;
};

/** An object representing the upper &/or lower boundaries that indicate when a signal is considered anomalous. */
export type AnomalyDetectorConfigurationsThresholdInput = {
  /** An enum representing the anomaly detections sensitivity to change for this signal. */
  deviationSensitivity?: InputMaybe<AnomalyDetectorConfigurationsDeviationSensitivity>;
  /** The signals entity type. */
  domainType?: InputMaybe<DomainTypeInput>;
  /** Any value below this limit value will be considered anomalous when the significant deviation direction is LOWER or HIGHER_LOWER. */
  lowerLimit?: InputMaybe<AnomalyDetectorConfigurationsThresholdLimitValueInput>;
  /** Any relative percent change less than this percent value will be considered anomalous when the significant deviation direction is LOWER or HIGHER_LOWER. */
  lowerRelativePercent?: InputMaybe<AnomalyDetectorConfigurationsThresholdRelativePercentValueInput>;
  /** A signal name. */
  signalName: Scalars['String']['input'];
  /** An enum representing which direction of change is considered anomalous for this signal. */
  significantDeviationDirection?: InputMaybe<AnomalyDetectorConfigurationsSignificantDeviationDirection>;
  /** Any value above this limit value will be considered anomalous when the significant deviation direction is HIGHER or HIGHER_LOWER. */
  upperLimit?: InputMaybe<AnomalyDetectorConfigurationsThresholdLimitValueInput>;
  /** Any relative percent change higher than this percent value will be considered anomalous when the significant deviation direction is HIGHER or HIGHER_LOWER. */
  upperRelativePercent?: InputMaybe<AnomalyDetectorConfigurationsThresholdRelativePercentValueInput>;
};

/** An object representing a boundary beyond which a signal is considered anomalous. */
export type AnomalyDetectorConfigurationsThresholdLimitValue = {
  __typename?: 'AnomalyDetectorConfigurationsThresholdLimitValue';
  /** A boolean representing whether or not this limit is currently used in anomaly detection. */
  active?: Maybe<Scalars['Boolean']['output']>;
  /** A float representing the limit. */
  value?: Maybe<Scalars['Float']['output']>;
};

/** An object representing a boundary beyond which a signal is considered anomalous. */
export type AnomalyDetectorConfigurationsThresholdLimitValueInput = {
  /** A boolean representing whether or not this limit is currently used in anomaly detection. */
  active?: InputMaybe<Scalars['Boolean']['input']>;
  /** A float representing the limit. */
  value?: InputMaybe<Scalars['Float']['input']>;
};

/** An object representing a boundary beyond which a signal is considered anomalous */
export type AnomalyDetectorConfigurationsThresholdRelativePercentValue = {
  __typename?: 'AnomalyDetectorConfigurationsThresholdRelativePercentValue';
  /** A boolean representing whether or not this limit is currently used in anomaly detection. */
  active?: Maybe<Scalars['Boolean']['output']>;
  /** An integer representing the relative percent. */
  value?: Maybe<Scalars['Int']['output']>;
};

/** An object representing a boundary beyond which a signal is considered anomalous */
export type AnomalyDetectorConfigurationsThresholdRelativePercentValueInput = {
  /** A boolean representing whether or not this limit is currently used in anomaly detection. */
  active?: InputMaybe<Scalars['Boolean']['input']>;
  /** An integer representing the relative percent. */
  value?: InputMaybe<Scalars['Int']['input']>;
};

/** An object used to update a type of anomaly detector that uses entities of a single entity type within the accountId as the dataset. */
export type AnomalyDetectorConfigurationsUpdateEntityTypeAnomalyDetectorInput = {
  /** A list of additional accountIds from which to pull entities to include in the dataset. Data will not be recorded in these accounts. */
  additionalSourceAccountIds?: InputMaybe<Array<InputMaybe<Scalars['Int']['input']>>>;
  /** A boolean representing whether or not to record data in the provided accountId or a temporary demo account. */
  demoMode?: InputMaybe<Scalars['Boolean']['input']>;
  /** An enum representing the anomaly detections sensitivity to change for all signals in the dataset. If not specified, it defaults to LOW. */
  deviationSensitivity?: InputMaybe<AnomalyDetectorConfigurationsDeviationSensitivity>;
  /** A list of entity guids that should be included in the dataset in cases where only a few entities should be watched - an empty list indicates all entities of the type are included. */
  includedEntityGuids?: InputMaybe<Array<InputMaybe<Scalars['EntityGuid']['input']>>>;
  /** A name to describe the dataset being watched. */
  name?: InputMaybe<Scalars['String']['input']>;
  /** A status representing whether anomalies should be collected. */
  status?: InputMaybe<AnomalyDetectorConfigurationsAnomalyDetectorStatus>;
  /** A list of objects, one for each golden signal within the entity type, representing the threshold values that deviate from the signal default threshold. */
  thresholds?: InputMaybe<Array<InputMaybe<AnomalyDetectorConfigurationsThresholdInput>>>;
};

/** An object used to update a type of anomaly detector that uses the results of a nrql query as the dataset. */
export type AnomalyDetectorConfigurationsUpdateNrqlAnomalyDetectorInput = {
  /** A list of custom signal queryIds to delete. */
  deletedQueries?: InputMaybe<Array<InputMaybe<Scalars['Int']['input']>>>;
  /** A boolean representing whether or not to record data in the provided accountId or a temporary demo account. */
  demoMode?: InputMaybe<Scalars['Boolean']['input']>;
  /** An enum representing the anomaly detections sensitivity to change for all signals in the dataset. If not specified, it defaults to LOW. */
  deviationSensitivity?: InputMaybe<AnomalyDetectorConfigurationsDeviationSensitivity>;
  /** A name to describe the dataset being watched. */
  name?: InputMaybe<Scalars['String']['input']>;
  /** A list of custom signals to add. */
  newSignals?: InputMaybe<Array<InputMaybe<AnomalyDetectorConfigurationsNrqlSignalInput>>>;
  /** An enum representing whether anomalies should be collected. */
  status?: InputMaybe<AnomalyDetectorConfigurationsAnomalyDetectorStatus>;
  /** A list of custom signals that have updates. */
  updatedSignals?: InputMaybe<Array<InputMaybe<AnomalyDetectorConfigurationsUpdateNrqlSignalInput>>>;
};

/** An object representing the fields of a nrql signal that support updates. Updating the query itself or the account is not supported - the nrql signal must be deleted and recreated. */
export type AnomalyDetectorConfigurationsUpdateNrqlSignalInput = {
  /** An array of facet values that are present in the NRQL results but should not be included in the dataset. */
  mutedFacetValues?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  /** A name for the signal. */
  name?: InputMaybe<Scalars['String']['input']>;
  /** The signal's DAQS query identifier. */
  queryId: Scalars['Int']['input'];
  /** An object representing the threshold values that deviate from the global default threshold. */
  threshold?: InputMaybe<AnomalyDetectorConfigurationsThresholdInput>;
};

/** An object used to update a type of anomaly detector that uses entities within a workload as the dataset. */
export type AnomalyDetectorConfigurationsUpdateWorkloadAnomalyDetectorInput = {
  /** A boolean representing whether or not to record data in the provided accountId or a temporary demo account. */
  demoMode?: InputMaybe<Scalars['Boolean']['input']>;
  /** An enum representing the anomaly detections sensitivity to change for all signals in the dataset. If not specified, it defaults to LOW. */
  deviationSensitivity?: InputMaybe<AnomalyDetectorConfigurationsDeviationSensitivity>;
  /** A list of entity guids that are present in the workload, but should not be included in the dataset. */
  excludedEntityGuids?: InputMaybe<Array<InputMaybe<Scalars['EntityGuid']['input']>>>;
  /** A name to describe the dataset being watched. */
  name?: InputMaybe<Scalars['String']['input']>;
  /** A status representing whether anomalies should be collected. */
  status?: InputMaybe<AnomalyDetectorConfigurationsAnomalyDetectorStatus>;
  /** A list of objects, one for each golden signal within each entity type present in the dataset, representing the threshold values that deviate from the signal default threshold. */
  thresholds?: InputMaybe<Array<InputMaybe<AnomalyDetectorConfigurationsThresholdInput>>>;
};

/** A type of anomaly detector that uses golden signals for all entities within a workload as the dataset. */
export type AnomalyDetectorConfigurationsWorkloadAnomalyDetector = AnomalyDetectorConfigurationsAnomalyDetector & {
  __typename?: 'AnomalyDetectorConfigurationsWorkloadAnomalyDetector';
  /** The account in which anomalous results are recorded. */
  accountId: Scalars['Int']['output'];
  /** The time the anomaly detector was created. */
  createdAt: Scalars['EpochMilliseconds']['output'];
  /** The user who created the anomaly detector. */
  createdBy?: Maybe<UserReference>;
  /** A boolean representing whether or not to record data in the provided accountId or a temporary demo account. */
  demoMode: Scalars['Boolean']['output'];
  /** An enum representing the anomaly detections sensitivity to change for all signals in the dataset. If not specified, it defaults to LOW. */
  deviationSensitivity?: Maybe<AnomalyDetectorConfigurationsDeviationSensitivity>;
  /** A list of entity guids that should not be included in the dataset. */
  excludedEntities?: Maybe<Array<EntityOutline>>;
  /** A unique anomaly detector identifier. */
  id: Scalars['Int']['output'];
  /** A name to describe the dataset being watched. */
  name: Scalars['String']['output'];
  /** An object representing whether anomalies should be collected. */
  status: AnomalyDetectorConfigurationsAnomalyDetectorStatus;
  /** A list of golden signal thresholds. Null values represent default threshold values. */
  thresholds?: Maybe<Array<AnomalyDetectorConfigurationsThreshold>>;
  /** The time any anomaly detector settings were last changed. */
  updatedAt: Scalars['EpochMilliseconds']['output'];
  /** An entity guid representing the workload. All entities within this workload will make up the dataset. */
  workloadGuid: EntityOutline;
};

/** A description of any errors that occurred while attempting to create a workload anomaly detector. */
export type AnomalyDetectorConfigurationsWorkloadAnomalyDetectorCreateError = {
  __typename?: 'AnomalyDetectorConfigurationsWorkloadAnomalyDetectorCreateError';
  /** An error message. */
  description?: Maybe<Scalars['String']['output']>;
  /** An error type. */
  type?: Maybe<AnomalyDetectorConfigurationsWorkloadAnomalyDetectorCreateErrorType>;
};

/** An enum representing errors that occur when creating a workload anomaly detector. */
export enum AnomalyDetectorConfigurationsWorkloadAnomalyDetectorCreateErrorType {
  /** One or more excludedEntityGuid provided is invalid. */
  InvalidEntities = 'INVALID_ENTITIES'
}

/** The details of an attempt to create a workload anomaly detector. */
export type AnomalyDetectorConfigurationsWorkloadAnomalyDetectorCreateResponse = {
  __typename?: 'AnomalyDetectorConfigurationsWorkloadAnomalyDetectorCreateResponse';
  /** A unique anomaly detector identifier if one was successfully created. */
  anomalyDetectorId?: Maybe<Scalars['Int']['output']>;
  /** An array of errors, if any. */
  errors?: Maybe<Array<Maybe<AnomalyDetectorConfigurationsWorkloadAnomalyDetectorCreateError>>>;
};

/** A description of any errors that occurred while attempting to update a workload anomaly detector. */
export type AnomalyDetectorConfigurationsWorkloadAnomalyDetectorUpdateError = {
  __typename?: 'AnomalyDetectorConfigurationsWorkloadAnomalyDetectorUpdateError';
  /** An error message. */
  description?: Maybe<Scalars['String']['output']>;
  /** An error type. */
  type?: Maybe<AnomalyDetectorConfigurationsWorkloadAnomalyDetectorUpdateErrorType>;
};

/** An enum representing errors that occur when updating a workload anomaly detector. */
export enum AnomalyDetectorConfigurationsWorkloadAnomalyDetectorUpdateErrorType {
  /** One or more excludedEntityGuid provided is invalid. */
  InvalidEntities = 'INVALID_ENTITIES',
  /** The user does not have access to update the anomaly detector. */
  NotAuthorized = 'NOT_AUTHORIZED'
}

/** The details of an attempt to update a workload anomaly detector. */
export type AnomalyDetectorConfigurationsWorkloadAnomalyDetectorUpdateResponse = {
  __typename?: 'AnomalyDetectorConfigurationsWorkloadAnomalyDetectorUpdateResponse';
  /** A unique anomaly detector identifier if one was successfully updated. */
  anomalyDetectorId?: Maybe<Scalars['Int']['output']>;
  /** An array of errors, if any. */
  errors?: Maybe<Array<Maybe<AnomalyDetectorConfigurationsWorkloadAnomalyDetectorUpdateError>>>;
};

export type ApiAccessActorStitchedFields = {
  __typename?: 'ApiAccessActorStitchedFields';
  /** Fetch a single key by ID and type. */
  key?: Maybe<ApiAccessKey>;
  /** A list of keys scoped to the current actor and filter arguments. You can read more about managing keys on [this documentation page](https://docs.newrelic.com/docs/apis/nerdgraph/examples/use-nerdgraph-manage-license-keys-personal-api-keys). */
  keySearch?: Maybe<ApiAccessKeySearchResult>;
};


export type ApiAccessActorStitchedFieldsKeyArgs = {
  id: Scalars['ID']['input'];
  keyType: ApiAccessKeyType;
};


export type ApiAccessActorStitchedFieldsKeySearchArgs = {
  cursor?: InputMaybe<Scalars['String']['input']>;
  query: ApiAccessKeySearchQuery;
};

/** The input for any ingest keys you want to create. Each ingest key must have a type that communicates what kind of data it is for. You can optionally add a name or notes to your key, which can be updated later. */
export type ApiAccessCreateIngestKeyInput = {
  /** The account ID indicating which account you want to make the key for. This cannot be updated once created. */
  accountId: Scalars['Int']['input'];
  /** The type of ingest key you want to create. This cannot be updated once created. */
  ingestType: ApiAccessIngestKeyType;
  /** The name of the key. This can be updated later. */
  name?: InputMaybe<Scalars['String']['input']>;
  /** Any notes about this ingest key. This can be updated later. */
  notes?: InputMaybe<Scalars['String']['input']>;
};

/** The input object to create one or more keys. */
export type ApiAccessCreateInput = {
  /** Ingest keys are used by agents to report data about your applications to New Relic. Each ingest key input entered here must have a type that communicates what kind of data it is for. You can optionally add a name or notes to your key, which can be updated later. */
  ingest?: InputMaybe<Array<InputMaybe<ApiAccessCreateIngestKeyInput>>>;
  /** Create user keys. You can optionally add a name or notes to your key, which can be updated later. */
  user?: InputMaybe<Array<InputMaybe<ApiAccessCreateUserKeyInput>>>;
};

/** The response of the create keys mutation. */
export type ApiAccessCreateKeyResponse = {
  __typename?: 'ApiAccessCreateKeyResponse';
  /** Lists all successfully created keys. */
  createdKeys?: Maybe<Array<Maybe<ApiAccessKey>>>;
  /** Lists all errors for keys that could not be created. Each error maps to a single key input. */
  errors?: Maybe<Array<Maybe<ApiAccessKeyError>>>;
};

/** The input for any ingest keys you want to create. Each ingest key must have a type that communicates what kind of data it is for. You can optionally add a name or notes to your key, which can be updated later. */
export type ApiAccessCreateUserKeyInput = {
  /** The account ID indicating which account you want to make the key for. This cannot be updated once created. */
  accountId: Scalars['Int']['input'];
  /** The name of the key. This can be updated later. */
  name?: InputMaybe<Scalars['String']['input']>;
  /** Any notes about this ingest key. This can be updated later. */
  notes?: InputMaybe<Scalars['String']['input']>;
  /** The user ID indicating which user you want to make the key for. This cannot be updated once created. */
  userId: Scalars['Int']['input'];
};

/** The input to delete keys. */
export type ApiAccessDeleteInput = {
  /** A list of the ingest key `id`s that you want to delete. */
  ingestKeyIds?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  /** A list of the user key `id`s that you want to delete. */
  userKeyIds?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
};

/** The response of the key delete mutation. */
export type ApiAccessDeleteKeyResponse = {
  __typename?: 'ApiAccessDeleteKeyResponse';
  /** The `id`s of the successfully deleted ingest keys and any errors that occurred when deleting keys. */
  deletedKeys?: Maybe<Array<Maybe<ApiAccessDeletedKey>>>;
  /** Lists all errors for keys that could not be deleted. Each error maps to a single key input. */
  errors?: Maybe<Array<Maybe<ApiAccessKeyError>>>;
};

/** The deleted key response of the key delete mutation. */
export type ApiAccessDeletedKey = {
  __typename?: 'ApiAccessDeletedKey';
  /** The `id` of the deleted key. */
  id?: Maybe<Scalars['String']['output']>;
};

/** An ingest key. */
export type ApiAccessIngestKey = ApiAccessKey & {
  __typename?: 'ApiAccessIngestKey';
  /** The account this key is in. */
  account?: Maybe<AccountReference>;
  /** The account attached to the ingest key. Agents using this key will report to the account the key belongs to. */
  accountId?: Maybe<Scalars['Int']['output']>;
  /** The UNIX epoch when the key was created, in seconds. */
  createdAt?: Maybe<Scalars['EpochSeconds']['output']>;
  /** The ID of the ingest key. This can be used to identify a key without revealing the key itself (used to update and delete). */
  id?: Maybe<Scalars['ID']['output']>;
  /** The type of ingest key, which dictates what types of agents can use it to report. */
  ingestType?: Maybe<ApiAccessIngestKeyType>;
  /** The keystring of the key. */
  key?: Maybe<Scalars['String']['output']>;
  /** The name of the key. Limited to 120 characters. */
  name?: Maybe<Scalars['String']['output']>;
  /** Any notes can be attached to an key. Limited to 120 characters. */
  notes?: Maybe<Scalars['String']['output']>;
  /** The obfuscated key. */
  obfuscatedKey?: Maybe<Scalars['String']['output']>;
  /** The type of key, indicating what New Relic APIs it can be used to access. */
  type?: Maybe<ApiAccessKeyType>;
};

/** An ingest key error. Each error maps to a single key input. */
export type ApiAccessIngestKeyError = ApiAccessKeyError & {
  __typename?: 'ApiAccessIngestKeyError';
  /** The account ID of the key. */
  accountId?: Maybe<Scalars['Int']['output']>;
  /** The error type of the error. */
  errorType?: Maybe<ApiAccessIngestKeyErrorType>;
  /** The `id` of the key being updated. */
  id?: Maybe<Scalars['String']['output']>;
  /** The ingest type of the key. */
  ingestType?: Maybe<ApiAccessIngestKeyType>;
  /** A message about why the key creation failed. */
  message?: Maybe<Scalars['String']['output']>;
  /** The type of the key. */
  type?: Maybe<ApiAccessKeyType>;
};

/** The type of error. */
export enum ApiAccessIngestKeyErrorType {
  /** Occurs when the user issuing the mutation does not have sufficient permissions to perform the action for a key. */
  Forbidden = 'FORBIDDEN',
  /** Occurs when the action taken on a key did not successfully pass validation. */
  Invalid = 'INVALID',
  /** Occurs when the requested key `id` was not found. */
  NotFound = 'NOT_FOUND'
}

/** The type of ingest key, which dictates what types of agents can use it to report. */
export enum ApiAccessIngestKeyType {
  /** Ingest keys of type `BROWSER` mean browser agents will use them to report data to New Relic. */
  Browser = 'BROWSER',
  /** For ingest keys of type `LICENSE`: APM and Infrastructure agents use the key to report data to New Relic. */
  License = 'LICENSE'
}

/** A key for accessing New Relic APIs. */
export type ApiAccessKey = {
  /** The UNIX epoch when the key was created, in seconds. */
  createdAt?: Maybe<Scalars['EpochSeconds']['output']>;
  /** The ID of the key. This can be used to identify a key without revealing the key itself (used to update and delete). */
  id?: Maybe<Scalars['ID']['output']>;
  /** The keystring of the key. */
  key?: Maybe<Scalars['String']['output']>;
  /** The name of the key. This can be used as a short identifier for easy reference. */
  name?: Maybe<Scalars['String']['output']>;
  /** Any notes can be attached to a key. This is intended for more a more detailed description of the key use if desired. */
  notes?: Maybe<Scalars['String']['output']>;
  /** The obfuscated key. */
  obfuscatedKey?: Maybe<Scalars['String']['output']>;
  /** The type of key, indicating what New Relic APIs it can be used to access. */
  type?: Maybe<ApiAccessKeyType>;
};

/** A key error. Each error maps to a single key input. */
export type ApiAccessKeyError = {
  /** A message about why the key creation failed. */
  message?: Maybe<Scalars['String']['output']>;
  /** The type of the key. */
  type?: Maybe<ApiAccessKeyType>;
};

/** Parameters by which to filter the search. */
export type ApiAccessKeySearchQuery = {
  /** Criteria by which to narrow the scope of keys to be returned. */
  scope?: InputMaybe<ApiAccessKeySearchScope>;
  /** A list of key types to be included in the search. If no types are provided, all types will be returned by default. */
  types: Array<InputMaybe<ApiAccessKeyType>>;
};

/** A list of all keys scoped to the current actor. */
export type ApiAccessKeySearchResult = {
  __typename?: 'ApiAccessKeySearchResult';
  /** The total number of keys found in scope, irrespective of pagination. */
  count?: Maybe<Scalars['Int']['output']>;
  /** A list of all keys scoped to the current actor. */
  keys?: Maybe<Array<Maybe<ApiAccessKey>>>;
  /** The next cursor, used for pagination. If a cursor is present, it means more keys can be fetched. */
  nextCursor?: Maybe<Scalars['String']['output']>;
};

/** The scope of keys to be returned. Note that some filters only apply to certain key types. */
export type ApiAccessKeySearchScope = {
  /** A list of key account IDs. */
  accountIds?: InputMaybe<Array<InputMaybe<Scalars['Int']['input']>>>;
  /** The ingest type of the key. Only applies to ingest keys, and does not affect user key filtering. */
  ingestTypes?: InputMaybe<Array<InputMaybe<ApiAccessIngestKeyType>>>;
  /** A list of key user ids. Only applies to user keys, and does not affect ingest key filtering. */
  userIds?: InputMaybe<Array<InputMaybe<Scalars['Int']['input']>>>;
};

/** The type of key. */
export enum ApiAccessKeyType {
  /** An ingest key is used by New Relic agents to authenticate with New Relic and send data to the assigned account. */
  Ingest = 'INGEST',
  /** A user key is used by New Relic users to authenticate with New Relic and to interact with the New Relic GraphQL API . */
  User = 'USER'
}

/** The `id` and data to update one or more keys. */
export type ApiAccessUpdateIngestKeyInput = {
  /** The `id` of the key you want to update. */
  keyId: Scalars['String']['input'];
  /** The name you want to assign to the key. */
  name?: InputMaybe<Scalars['String']['input']>;
  /** The notes you want to assign to the key. */
  notes?: InputMaybe<Scalars['String']['input']>;
};

/** The `id` and data to update one or more keys. */
export type ApiAccessUpdateInput = {
  /** A list of the configurations of each ingest key you want to update. */
  ingest?: InputMaybe<Array<InputMaybe<ApiAccessUpdateIngestKeyInput>>>;
  /** A list of the configurations of each user key you want to update. */
  user?: InputMaybe<Array<InputMaybe<ApiAccessUpdateUserKeyInput>>>;
};

/** The response of the update keys mutation. */
export type ApiAccessUpdateKeyResponse = {
  __typename?: 'ApiAccessUpdateKeyResponse';
  /** Lists all errors for keys that could not be updated. Each error maps to a single key input. */
  errors?: Maybe<Array<Maybe<ApiAccessKeyError>>>;
  /** Lists all successfully updated keys. */
  updatedKeys?: Maybe<Array<Maybe<ApiAccessKey>>>;
};

/** The `id` and data to update one or more keys. */
export type ApiAccessUpdateUserKeyInput = {
  /** The `id` of the key you want to update. */
  keyId: Scalars['String']['input'];
  /** The name you want to assign to the key. */
  name?: InputMaybe<Scalars['String']['input']>;
  /** The notes you want to assign to the key. */
  notes?: InputMaybe<Scalars['String']['input']>;
};

/** A user key. */
export type ApiAccessUserKey = ApiAccessKey & {
  __typename?: 'ApiAccessUserKey';
  /** The account this key is in. */
  account?: Maybe<AccountReference>;
  /** The account ID of the key. */
  accountId?: Maybe<Scalars['Int']['output']>;
  /** The UNIX epoch when the key was created, in seconds. */
  createdAt?: Maybe<Scalars['EpochSeconds']['output']>;
  /** The ID of the user key. This can be used to identify a key without revealing the key itself (used to update and delete). */
  id?: Maybe<Scalars['ID']['output']>;
  /** The keystring of the key. */
  key?: Maybe<Scalars['String']['output']>;
  /** The name of the key. Limited to 120 characters. */
  name?: Maybe<Scalars['String']['output']>;
  /** Any notes can be attached to a key. Limited to 120 characters. */
  notes?: Maybe<Scalars['String']['output']>;
  /** The obfuscated key. */
  obfuscatedKey?: Maybe<Scalars['String']['output']>;
  /** The type of key, indicating what New Relic APIs it can be used to access. */
  type?: Maybe<ApiAccessKeyType>;
  /** The user this key belongs to. */
  user?: Maybe<UserReference>;
  /** The user ID of the key. */
  userId?: Maybe<Scalars['Int']['output']>;
};

/** A user key error. Each error maps to a single key input. */
export type ApiAccessUserKeyError = ApiAccessKeyError & {
  __typename?: 'ApiAccessUserKeyError';
  /** The account ID of the key. */
  accountId?: Maybe<Scalars['Int']['output']>;
  /** The error type of the error. */
  errorType?: Maybe<ApiAccessUserKeyErrorType>;
  /** The `id` of the key being updated. */
  id?: Maybe<Scalars['String']['output']>;
  /** A message about why the key creation failed. */
  message?: Maybe<Scalars['String']['output']>;
  /** The type of the key. */
  type?: Maybe<ApiAccessKeyType>;
  /** The user ID of the key. */
  userId?: Maybe<Scalars['Int']['output']>;
};

/** The type of error. */
export enum ApiAccessUserKeyErrorType {
  /** Occurs when the user issuing the mutation does not have sufficient permissions to perform the action for a key. */
  Forbidden = 'FORBIDDEN',
  /** Occurs when the action taken on a key did not successfully pass validation. */
  Invalid = 'INVALID',
  /** Occurs when the requested key `id` was not found. */
  NotFound = 'NOT_FOUND'
}

/** An APM application deployment marker */
export type ApmApplicationDeployment = {
  __typename?: 'ApmApplicationDeployment';
  /** The changelog of the deployment */
  changelog?: Maybe<Scalars['String']['output']>;
  /** Description of the deployment */
  description?: Maybe<Scalars['String']['output']>;
  /** A link to view the deployment in the UI */
  permalink?: Maybe<Scalars['String']['output']>;
  /** The revision of the app that was deployed */
  revision?: Maybe<Scalars['String']['output']>;
  /** The moment the deployment occured */
  timestamp?: Maybe<Scalars['EpochMilliseconds']['output']>;
  /** The user who triggered the deployment */
  user?: Maybe<Scalars['String']['output']>;
};

/** An APM Application entity. */
export type ApmApplicationEntity = AlertableEntity & ApmBrowserApplicationEntity & Entity & {
  __typename?: 'ApmApplicationEntity';
  account?: Maybe<AccountOutline>;
  /** The New Relic account ID associated with this entity. */
  accountId?: Maybe<Scalars['Int']['output']>;
  /** The current alerting severity of the entity. */
  alertSeverity?: Maybe<EntityAlertSeverity>;
  /**
   * The alert status of the entity.
   * @deprecated Please use `alertSeverity` and `reporting`
   */
  alertStatus?: Maybe<EntityAlertStatus>;
  /** Violations on the entity that were open during the specified time window. This will return up to 500 violations - if there are more in the time window selected, you must narrow the time window or look at fewer entities. */
  alertViolations?: Maybe<Array<Maybe<EntityAlertViolation>>>;
  /** Summary statistics about the Browser App injected by an APM Application. */
  apmBrowserSummary?: Maybe<ApmBrowserApplicationSummaryData>;
  /** Settings that are common across APM applications. */
  apmSettings?: Maybe<AgentApplicationSettingsApmBase>;
  /** Summary statistics about the APM App. */
  apmSummary?: Maybe<ApmApplicationSummaryData>;
  /** The ID of the APM Application. */
  applicationId?: Maybe<Scalars['Int']['output']>;
  /** List of APM application instances. */
  applicationInstances?: Maybe<Array<AgentEnvironmentApplicationInstance>>;
  /** Paginated list of APM application instances. */
  applicationInstancesV2: AgentEnvironmentApplicationInstancesResult;
  /**
   * Query upstream and downstream dependencies for an entity
   * @deprecated This field is experimental and subject to breaking changes.
   */
  connections?: Maybe<RelatedExternalsEntityResult>;
  /** Retrieve the deployment event(s). Ordered by timestamp DESC. */
  deploymentSearch?: Maybe<ChangeTrackingDeploymentSearchResult>;
  /**
   * Deployments of the APM Application.
   * @deprecated This field is deprecated and no longer returns data. Please use `deploymentSearch`.
   */
  deployments?: Maybe<Array<Maybe<ApmApplicationDeployment>>>;
  /** The entity's domain */
  domain?: Maybe<Scalars['String']['output']>;
  /** A value representing the combination of the entity's domain and type. */
  entityType?: Maybe<EntityType>;
  /**
   * Retrieve metadata on a specific error group.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  errorGroup?: Maybe<ErrorTrackingErrorGroup>;
  /**
   * Fetch the number of error groups counted within a given time range (default 3 hours).
   * @deprecated This field is experimental and subject to breaking changes.
   */
  errorGroupCount?: Maybe<ErrorTrackingErrorGroupCount>;
  /**
   * Fetch a list of error groups.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  errorGroupListing?: Maybe<Array<ErrorTrackingErrorGroup>>;
  /** Retrieves an error trace given its ID. */
  errorTrace?: Maybe<AgentTracesErrorTrace>;
  /** Retrieve a list of error traces that match the given search query. */
  errorTraces?: Maybe<Array<Maybe<AgentTracesErrorTrace>>>;
  /** An Exception that occurred in your Application. */
  exception?: Maybe<StackTraceApmException>;
  /** The date of last time the entity has updated any of its fields. */
  firstIndexedAt?: Maybe<Scalars['EpochMilliseconds']['output']>;
  /** Retrieves a flamegraph for the specific entity over the time period specified. */
  flamegraph?: Maybe<JavaFlightRecorderFlamegraph>;
  /** The list of golden metrics for a specific entity */
  goldenMetrics?: Maybe<EntityGoldenContextScopedGoldenMetrics>;
  /**
   * For the golden signal on this entity, show correlated signals from related entities.
   * Well inspect the golden signals for all related entities and return a sorted list.
   * You can also filter the results.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  goldenSignalCorrelations?: Maybe<GoldenSignalCorrelationResult>;
  /**
   * The deviation from normal of golden signal(s) for the given entity.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  goldenSignalDeviations?: Maybe<Array<Maybe<GoldenSignalSignalDeviation>>>;
  /**
   * The stored golden signal(s) for the given entity.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  goldenSignalValues?: Maybe<GoldenSignalValues>;
  /**
   * The stored golden signal(s) for the given entity. To be removed, use goldenSignalValues instead.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  goldenSignalValuesV2?: Maybe<GoldenSignalValues>;
  /** The list of golden tags for a specific entityType. */
  goldenTags?: Maybe<EntityGoldenContextScopedGoldenTags>;
  /** A unique entity identifier. */
  guid?: Maybe<Scalars['EntityGuid']['output']>;
  /** The time the entity was indexed. */
  indexedAt?: Maybe<Scalars['EpochMilliseconds']['output']>;
  /** The programming language of the APM Application. */
  language?: Maybe<Scalars['String']['output']>;
  /** The last time the entity's reporting status changed. */
  lastReportingChangeAt?: Maybe<Scalars['EpochMilliseconds']['output']>;
  /** Retrieves the entity metric grouping issues. */
  metricGroupingIssues?: Maybe<Array<MetricNormalizationRuleMetricGroupingIssue>>;
  /** Retrieves a rule. */
  metricNormalizationRule?: Maybe<MetricNormalizationRule>;
  /** Retrieves the rules for the application. */
  metricNormalizationRules?: Maybe<Array<MetricNormalizationRule>>;
  /** The name of this entity. */
  name?: Maybe<Scalars['String']['output']>;
  nerdStorage?: Maybe<NerdStorageEntityScope>;
  nerdStoreCollection?: Maybe<Array<Maybe<NerdStoreCollectionMember>>>;
  nerdStoreDocument?: Maybe<Scalars['NerdStoreDocument']['output']>;
  /**
   * Make an `Entity` scoped query to NRDB with a NRQL string.
   *
   * A relevant `WHERE` clause will be added to your query to scope data to the entity in question.
   *
   * See the [NRQL Docs](https://docs.newrelic.com/docs/insights/nrql-new-relic-query-language/nrql-resources/nrql-syntax-components-functions) for more information about generating a query string.
   */
  nrdbQuery?: Maybe<NrdbResultContainer>;
  /**
   * Poll for the results of a previously-executed asychronous NRDB query.
   *
   * The `queryId` is available in the `queryProgress` data returned by the original asynchronous query.
   *
   * See [this page](https://docs.newrelic.com/docs/apis/nerdgraph/examples/async-queries-nrql-tutorial) for additional asynchronous query documentation.
   * @deprecated This field is experimental! It may change at any time.
   *
   */
  nrdbQueryProgress?: Maybe<NrdbResultContainer>;
  /** The url to the entity. */
  permalink?: Maybe<Scalars['String']['output']>;
  /** Proactive Detection events */
  proactiveDetection?: Maybe<AiOpsProactiveDetection>;
  /**
   * This endpoint attempts to find the root cause on a certain entity
   * @deprecated This field is experimental and subject to breaking changes.
   */
  rcairResults?: Maybe<RootCauseAnalysisResult>;
  /** Recent violations on the entity. */
  recentAlertViolations?: Maybe<Array<Maybe<EntityAlertViolation>>>;
  /** The recommended service levels for the entity. */
  recommendedServiceLevel?: Maybe<ServiceLevelRecommendation>;
  /** Related dashboards results */
  relatedDashboards: RelatedDashboardsRelatedDashboardResult;
  /** Related entities result with optional filtering. */
  relatedEntities?: Maybe<EntityRelationshipRelatedEntitiesResult>;
  /**
   * Query upstream and downstream transaction dependencies for an entity
   * @deprecated This field is experimental and subject to breaking changes.
   */
  relatedTransactions?: Maybe<RelatedExternalsTransactionResult>;
  /** Relationship traversal results with optional filtering. WARNING: this query is still experimental, and subject to breaking changes. */
  relationshipTraversal?: Maybe<EntityRelationshipTraversalResult>;
  /**
   * A list of the entities' relationships.
   *
   * For more information, visit [our docs](https://docs.newrelic.com/docs/apis/graphql-api/tutorials/graphql-relationships-api-tutorial).
   * @deprecated This field is deprecated! Please use `relatedEntities`.
   */
  relationships?: Maybe<Array<Maybe<EntityRelationship>>>;
  /** The reporting status of the entity. If New Relic is successfully collecting data from your application, this will be true. */
  reporting?: Maybe<Scalars['Boolean']['output']>;
  /** The running versions of the language agent in the APM Application. */
  runningAgentVersions?: Maybe<ApmApplicationRunningAgentVersions>;
  /** The service level defined for the entity. */
  serviceLevel?: Maybe<ServiceLevelDefinition>;
  /** Configuration settings for the APM Application */
  settings?: Maybe<ApmApplicationSettings>;
  /** Retrieves a SQL trace given its ID. */
  sqlTrace?: Maybe<AgentTracesSqlTrace>;
  /** Retrieve a list of SQL traces that match the given search query. */
  sqlTraces?: Maybe<Array<Maybe<AgentTracesSqlTrace>>>;
  /** The list of summary metrics. */
  summaryMetrics?: Maybe<Array<Maybe<EntitySummaryMetric>>>;
  /**
   * The tags applied to the entity.
   *
   * For details on tags, as well as query and mutation examples, visit [our docs](https://docs.newrelic.com/docs/apis/graphql-api/tutorials/graphql-tagging-api-tutorial).
   */
  tags?: Maybe<Array<Maybe<EntityTag>>>;
  /** The tags applied to the entity with their metadata. */
  tagsWithMetadata?: Maybe<Array<Maybe<EntityTagWithMetadata>>>;
  /**
   * Thread profiles associated with this application. This is a paginated collection.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  threadProfiles: ThreadProfilerMetadataCollection;
  /** Look up Distributed Tracing summary data for the selected `EntityGuid` */
  tracingSummary?: Maybe<DistributedTracingEntityTracingSummary>;
  /** Retrieves a transaction trace given its ID. */
  transactionTrace?: Maybe<AgentTracesTransactionTrace>;
  /** Retrieve a list of transaction traces that match the given search query. */
  transactionTraces?: Maybe<Array<Maybe<AgentTracesTransactionTrace>>>;
  /** The entity's type */
  type?: Maybe<Scalars['String']['output']>;
  /** List of templates availables for this entity. */
  uiTemplates?: Maybe<Array<EntityDashboardTemplatesUi>>;
};


/** An APM Application entity. */
export type ApmApplicationEntityAlertViolationsArgs = {
  endTime: Scalars['EpochMilliseconds']['input'];
  startTime: Scalars['EpochMilliseconds']['input'];
};


/** An APM Application entity. */
export type ApmApplicationEntityApplicationInstancesArgs = {
  endTime?: InputMaybe<Scalars['EpochMilliseconds']['input']>;
  host?: InputMaybe<Scalars['String']['input']>;
  startTime?: InputMaybe<Scalars['EpochMilliseconds']['input']>;
};


/** An APM Application entity. */
export type ApmApplicationEntityApplicationInstancesV2Args = {
  cursor?: InputMaybe<Scalars['String']['input']>;
};


/** An APM Application entity. */
export type ApmApplicationEntityConnectionsArgs = {
  timeWindow?: InputMaybe<TimeWindowInput>;
};


/** An APM Application entity. */
export type ApmApplicationEntityDeploymentSearchArgs = {
  filter?: InputMaybe<ChangeTrackingSearchFilter>;
};


/** An APM Application entity. */
export type ApmApplicationEntityDeploymentsArgs = {
  timeWindow?: InputMaybe<TimeWindowInput>;
};


/** An APM Application entity. */
export type ApmApplicationEntityErrorGroupArgs = {
  id: Scalars['ID']['input'];
};


/** An APM Application entity. */
export type ApmApplicationEntityErrorGroupCountArgs = {
  timeWindow?: InputMaybe<TimeWindowInput>;
};


/** An APM Application entity. */
export type ApmApplicationEntityErrorGroupListingArgs = {
  ids: Array<Scalars['ID']['input']>;
};


/** An APM Application entity. */
export type ApmApplicationEntityErrorTraceArgs = {
  traceId: Scalars['String']['input'];
};


/** An APM Application entity. */
export type ApmApplicationEntityErrorTracesArgs = {
  query: AgentTracesErrorTraceQuery;
};


/** An APM Application entity. */
export type ApmApplicationEntityExceptionArgs = {
  occurrenceId: Scalars['String']['input'];
};


/** An APM Application entity. */
export type ApmApplicationEntityFlamegraphArgs = {
  hostName: Scalars['String']['input'];
  timeWindow?: InputMaybe<TimeWindowInput>;
};


/** An APM Application entity. */
export type ApmApplicationEntityGoldenMetricsArgs = {
  context?: InputMaybe<EntityGoldenContextInput>;
  timeWindow?: InputMaybe<EntityGoldenNrqlTimeWindowInput>;
};


/** An APM Application entity. */
export type ApmApplicationEntityGoldenSignalCorrelationsArgs = {
  filter?: InputMaybe<GoldenSignalCorrelationsEntityFilter>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  timeWindow?: InputMaybe<TimeWindowInput>;
};


/** An APM Application entity. */
export type ApmApplicationEntityGoldenSignalDeviationsArgs = {
  comparisonTimeWindow?: InputMaybe<TimeWindowInput>;
  evaluationTimeWindow?: InputMaybe<TimeWindowInput>;
};


/** An APM Application entity. */
export type ApmApplicationEntityGoldenSignalValuesArgs = {
  timeWindow?: InputMaybe<TimeWindowInput>;
};


/** An APM Application entity. */
export type ApmApplicationEntityGoldenSignalValuesV2Args = {
  timeWindow?: InputMaybe<TimeWindowInput>;
};


/** An APM Application entity. */
export type ApmApplicationEntityGoldenTagsArgs = {
  context?: InputMaybe<EntityGoldenContextInput>;
};


/** An APM Application entity. */
export type ApmApplicationEntityMetricGroupingIssuesArgs = {
  endTime?: InputMaybe<Scalars['EpochMilliseconds']['input']>;
  metricNormalizationRuleIds?: InputMaybe<Array<InputMaybe<Scalars['Int']['input']>>>;
  startTime?: InputMaybe<Scalars['EpochMilliseconds']['input']>;
};


/** An APM Application entity. */
export type ApmApplicationEntityMetricNormalizationRuleArgs = {
  id: Scalars['Int']['input'];
};


/** An APM Application entity. */
export type ApmApplicationEntityMetricNormalizationRulesArgs = {
  enabled?: InputMaybe<Scalars['Boolean']['input']>;
};


/** An APM Application entity. */
export type ApmApplicationEntityNerdStoreCollectionArgs = {
  collection: Scalars['String']['input'];
  scopeByActor?: InputMaybe<Scalars['Boolean']['input']>;
};


/** An APM Application entity. */
export type ApmApplicationEntityNerdStoreDocumentArgs = {
  collection: Scalars['String']['input'];
  documentId: Scalars['String']['input'];
  scopeByActor?: InputMaybe<Scalars['Boolean']['input']>;
};


/** An APM Application entity. */
export type ApmApplicationEntityNrdbQueryArgs = {
  async?: InputMaybe<Scalars['Boolean']['input']>;
  nrql: Scalars['Nrql']['input'];
  options?: InputMaybe<NrqlQueryOptions>;
  timeout?: InputMaybe<Scalars['Seconds']['input']>;
};


/** An APM Application entity. */
export type ApmApplicationEntityNrdbQueryProgressArgs = {
  queryId: Scalars['ID']['input'];
};


/** An APM Application entity. */
export type ApmApplicationEntityRcairResultsArgs = {
  requestId: Scalars['String']['input'];
};


/** An APM Application entity. */
export type ApmApplicationEntityRecentAlertViolationsArgs = {
  count?: InputMaybe<Scalars['Int']['input']>;
};


/** An APM Application entity. */
export type ApmApplicationEntityRelatedEntitiesArgs = {
  cursor?: InputMaybe<Scalars['String']['input']>;
  filter?: InputMaybe<EntityRelationshipEdgeFilter>;
  limit?: InputMaybe<Scalars['Int']['input']>;
};


/** An APM Application entity. */
export type ApmApplicationEntityRelatedTransactionsArgs = {
  search: RelatedExternalsSearch;
  timeWindow?: InputMaybe<TimeWindowInput>;
};


/** An APM Application entity. */
export type ApmApplicationEntityRelationshipTraversalArgs = {
  cursor?: InputMaybe<Scalars['String']['input']>;
  hopFilters?: InputMaybe<EntityRelationshipTraversalHopFilters>;
  hops?: InputMaybe<Scalars['Int']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
};


/** An APM Application entity. */
export type ApmApplicationEntityRelationshipsArgs = {
  endTime?: InputMaybe<Scalars['EpochMilliseconds']['input']>;
  filter?: InputMaybe<EntityRelationshipFilter>;
};


/** An APM Application entity. */
export type ApmApplicationEntitySqlTraceArgs = {
  traceId: Scalars['String']['input'];
};


/** An APM Application entity. */
export type ApmApplicationEntitySqlTracesArgs = {
  query: AgentTracesSqlTraceQuery;
};


/** An APM Application entity. */
export type ApmApplicationEntitySummaryMetricsArgs = {
  timeWindow?: InputMaybe<TimeWindowInput>;
};


/** An APM Application entity. */
export type ApmApplicationEntityThreadProfilesArgs = {
  cursor?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** An APM Application entity. */
export type ApmApplicationEntityTracingSummaryArgs = {
  timeWindow?: InputMaybe<TimeWindowInput>;
};


/** An APM Application entity. */
export type ApmApplicationEntityTransactionTraceArgs = {
  filter?: InputMaybe<AgentTracesTransactionTraceFilter>;
  traceId: Scalars['String']['input'];
};


/** An APM Application entity. */
export type ApmApplicationEntityTransactionTracesArgs = {
  query: AgentTracesTransactionTraceQuery;
};

/** An APM Application entity outline. */
export type ApmApplicationEntityOutline = AlertableEntityOutline & ApmBrowserApplicationEntityOutline & EntityOutline & {
  __typename?: 'ApmApplicationEntityOutline';
  account?: Maybe<AccountOutline>;
  /** The New Relic account ID associated with this entity. */
  accountId?: Maybe<Scalars['Int']['output']>;
  /** The current alerting severity of the entity. */
  alertSeverity?: Maybe<EntityAlertSeverity>;
  /**
   * The alert status of the entity.
   * @deprecated Please use `alertSeverity` and `reporting`
   */
  alertStatus?: Maybe<EntityAlertStatus>;
  /** Summary statistics about the Browser App injected by an APM Application. */
  apmBrowserSummary?: Maybe<ApmBrowserApplicationSummaryData>;
  /** Summary statistics about the APM App. */
  apmSummary?: Maybe<ApmApplicationSummaryData>;
  /** The ID of the APM Application. */
  applicationId?: Maybe<Scalars['Int']['output']>;
  /** The entity's domain */
  domain?: Maybe<Scalars['String']['output']>;
  /** A value representing the combination of the entity's domain and type. */
  entityType?: Maybe<EntityType>;
  /** The date of last time the entity has updated any of its fields. */
  firstIndexedAt?: Maybe<Scalars['EpochMilliseconds']['output']>;
  /** The list of golden metrics for a specific entity */
  goldenMetrics?: Maybe<EntityGoldenContextScopedGoldenMetrics>;
  /**
   * For the golden signal on this entity, show correlated signals from related entities.
   * Well inspect the golden signals for all related entities and return a sorted list.
   * You can also filter the results.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  goldenSignalCorrelations?: Maybe<GoldenSignalCorrelationResult>;
  /**
   * The deviation from normal of golden signal(s) for the given entity.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  goldenSignalDeviations?: Maybe<Array<Maybe<GoldenSignalSignalDeviation>>>;
  /**
   * The stored golden signal(s) for the given entity.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  goldenSignalValues?: Maybe<GoldenSignalValues>;
  /**
   * The stored golden signal(s) for the given entity. To be removed, use goldenSignalValues instead.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  goldenSignalValuesV2?: Maybe<GoldenSignalValues>;
  /** The list of golden tags for a specific entityType. */
  goldenTags?: Maybe<EntityGoldenContextScopedGoldenTags>;
  /** A unique entity identifier. */
  guid?: Maybe<Scalars['EntityGuid']['output']>;
  /** The time the entity was indexed. */
  indexedAt?: Maybe<Scalars['EpochMilliseconds']['output']>;
  /** The programming language of the APM Application. */
  language?: Maybe<Scalars['String']['output']>;
  /** The last time the entity's reporting status changed. */
  lastReportingChangeAt?: Maybe<Scalars['EpochMilliseconds']['output']>;
  /** The name of this entity. */
  name?: Maybe<Scalars['String']['output']>;
  /** The url to the entity. */
  permalink?: Maybe<Scalars['String']['output']>;
  /** The recommended service levels for the entity. */
  recommendedServiceLevel?: Maybe<ServiceLevelRecommendation>;
  /** Related dashboards results */
  relatedDashboards: RelatedDashboardsRelatedDashboardResult;
  /** The reporting status of the entity. If New Relic is successfully collecting data from your application, this will be true. */
  reporting?: Maybe<Scalars['Boolean']['output']>;
  /** The running versions of the language agent in the APM Application. */
  runningAgentVersions?: Maybe<ApmApplicationRunningAgentVersions>;
  /** The service level defined for the entity. */
  serviceLevel?: Maybe<ServiceLevelDefinition>;
  /** Configuration settings for the APM Application */
  settings?: Maybe<ApmApplicationSettings>;
  /** The list of summary metrics. */
  summaryMetrics?: Maybe<Array<Maybe<EntitySummaryMetric>>>;
  /**
   * The tags applied to the entity.
   *
   * For details on tags, as well as query and mutation examples, visit [our docs](https://docs.newrelic.com/docs/apis/graphql-api/tutorials/graphql-tagging-api-tutorial).
   */
  tags?: Maybe<Array<Maybe<EntityTag>>>;
  /** The entity's type */
  type?: Maybe<Scalars['String']['output']>;
  /** List of templates availables for this entity. */
  uiTemplates?: Maybe<Array<EntityDashboardTemplatesUi>>;
};


/** An APM Application entity outline. */
export type ApmApplicationEntityOutlineGoldenMetricsArgs = {
  context?: InputMaybe<EntityGoldenContextInput>;
  timeWindow?: InputMaybe<EntityGoldenNrqlTimeWindowInput>;
};


/** An APM Application entity outline. */
export type ApmApplicationEntityOutlineGoldenSignalCorrelationsArgs = {
  filter?: InputMaybe<GoldenSignalCorrelationsEntityFilter>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  timeWindow?: InputMaybe<TimeWindowInput>;
};


/** An APM Application entity outline. */
export type ApmApplicationEntityOutlineGoldenSignalDeviationsArgs = {
  comparisonTimeWindow?: InputMaybe<TimeWindowInput>;
  evaluationTimeWindow?: InputMaybe<TimeWindowInput>;
};


/** An APM Application entity outline. */
export type ApmApplicationEntityOutlineGoldenSignalValuesArgs = {
  timeWindow?: InputMaybe<TimeWindowInput>;
};


/** An APM Application entity outline. */
export type ApmApplicationEntityOutlineGoldenSignalValuesV2Args = {
  timeWindow?: InputMaybe<TimeWindowInput>;
};


/** An APM Application entity outline. */
export type ApmApplicationEntityOutlineGoldenTagsArgs = {
  context?: InputMaybe<EntityGoldenContextInput>;
};


/** An APM Application entity outline. */
export type ApmApplicationEntityOutlineSummaryMetricsArgs = {
  timeWindow?: InputMaybe<TimeWindowInput>;
};

/** The ApmApplicationEntity's settings to update. */
export type ApmApplicationEntitySettings = {
  /** The ApmApplicationEntity's apdex target. For documentation on using apdex effectively, visit [our docs about apdex](https://docs.newrelic.com/docs/apm/new-relic-apm/apdex/apdex-measure-user-satisfaction). */
  apdexTarget?: InputMaybe<Scalars['Float']['input']>;
};

/** The updated settings of an ApmApplicationEntity. */
export type ApmApplicationEntitySettingsResult = {
  __typename?: 'ApmApplicationEntitySettingsResult';
  /** The updated entity. You can view the updated apdex target in the `settings` field of an ApmApplicationEntity. */
  entity?: Maybe<ApmApplicationEntity>;
};

/**
 * Represents the currently running agent versions in an APM Application.
 * An application could be running multiple versions of an agent (across different hosts, for example).
 */
export type ApmApplicationRunningAgentVersions = {
  __typename?: 'ApmApplicationRunningAgentVersions';
  /** The maximum (newest) language agent version running in the APM Application. */
  maxVersion?: Maybe<Scalars['String']['output']>;
  /** The minimum (oldest) language agent version running in the APM Application. */
  minVersion?: Maybe<Scalars['String']['output']>;
};

/** Configuration settings for the APM Application */
export type ApmApplicationSettings = {
  __typename?: 'ApmApplicationSettings';
  /** The current Apdex target setting */
  apdexTarget?: Maybe<Scalars['Float']['output']>;
  /** State of server-side configuration setting */
  serverSideConfig?: Maybe<Scalars['Boolean']['output']>;
};

/** Summary statistics about the APM App. */
export type ApmApplicationSummaryData = {
  __typename?: 'ApmApplicationSummaryData';
  /** The apdex score. For more details on the use of apdex, visit [our docs](https://docs.newrelic.com/docs/apm/new-relic-apm/apdex/apdex-measure-user-satisfaction). */
  apdexScore?: Maybe<Scalars['Float']['output']>;
  /** The percentage of responses to all transactions with an error. */
  errorRate?: Maybe<Scalars['Float']['output']>;
  /** The number of hosts this application is running on. */
  hostCount?: Maybe<Scalars['Int']['output']>;
  /** The number of instances of this application running. */
  instanceCount?: Maybe<Scalars['Int']['output']>;
  /** The average response time for non-web transactions in seconds. */
  nonWebResponseTimeAverage?: Maybe<Scalars['Seconds']['output']>;
  /** The number of non-web transactions per minute. */
  nonWebThroughput?: Maybe<Scalars['Float']['output']>;
  /** The average response time for all transactions in seconds. */
  responseTimeAverage?: Maybe<Scalars['Seconds']['output']>;
  /** The number of all transactions per minute. */
  throughput?: Maybe<Scalars['Float']['output']>;
  /** The average response time for web transactions in seconds. */
  webResponseTimeAverage?: Maybe<Scalars['Seconds']['output']>;
  /** The number of web transactions per minute. */
  webThroughput?: Maybe<Scalars['Float']['output']>;
};

/** The `ApmBrowserApplicationEntity` interface provides detailed information for the Browser App injected by an APM Application. */
export type ApmBrowserApplicationEntity = {
  apmBrowserSummary?: Maybe<ApmBrowserApplicationSummaryData>;
};

/** The `ApmBrowserApplicationEntityOutline` interface provides detailed information for the Browser App injected by an APM Application. */
export type ApmBrowserApplicationEntityOutline = {
  apmBrowserSummary?: Maybe<ApmBrowserApplicationSummaryData>;
};

/** Summary statistics about the Browser App injected by the APM Application. */
export type ApmBrowserApplicationSummaryData = {
  __typename?: 'ApmBrowserApplicationSummaryData';
  /** The number of AJAX requests per minute */
  ajaxRequestThroughput?: Maybe<Scalars['Float']['output']>;
  /** The average AJAX response time in seconds. */
  ajaxResponseTimeAverage?: Maybe<Scalars['Seconds']['output']>;
  /** The percentage of page views with a JS error. */
  jsErrorRate?: Maybe<Scalars['Float']['output']>;
  /** The number of page loads per minute */
  pageLoadThroughput?: Maybe<Scalars['Float']['output']>;
  /** The average page view time in seconds. */
  pageLoadTimeAverage?: Maybe<Scalars['Float']['output']>;
};

/** A database instance seen by an APM Application */
export type ApmDatabaseInstanceEntity = AlertableEntity & Entity & {
  __typename?: 'ApmDatabaseInstanceEntity';
  account?: Maybe<AccountOutline>;
  /** The New Relic account ID associated with this entity. */
  accountId?: Maybe<Scalars['Int']['output']>;
  /** The current alerting severity of the entity. */
  alertSeverity?: Maybe<EntityAlertSeverity>;
  /**
   * The alert status of the entity.
   * @deprecated Please use `alertSeverity` and `reporting`
   */
  alertStatus?: Maybe<EntityAlertStatus>;
  /** Violations on the entity that were open during the specified time window. This will return up to 500 violations - if there are more in the time window selected, you must narrow the time window or look at fewer entities. */
  alertViolations?: Maybe<Array<Maybe<EntityAlertViolation>>>;
  /** Retrieve the deployment event(s). Ordered by timestamp DESC. */
  deploymentSearch?: Maybe<ChangeTrackingDeploymentSearchResult>;
  /** The entity's domain */
  domain?: Maybe<Scalars['String']['output']>;
  /** A value representing the combination of the entity's domain and type. */
  entityType?: Maybe<EntityType>;
  /** The date of last time the entity has updated any of its fields. */
  firstIndexedAt?: Maybe<Scalars['EpochMilliseconds']['output']>;
  /** The list of golden metrics for a specific entity */
  goldenMetrics?: Maybe<EntityGoldenContextScopedGoldenMetrics>;
  /**
   * For the golden signal on this entity, show correlated signals from related entities.
   * Well inspect the golden signals for all related entities and return a sorted list.
   * You can also filter the results.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  goldenSignalCorrelations?: Maybe<GoldenSignalCorrelationResult>;
  /**
   * The deviation from normal of golden signal(s) for the given entity.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  goldenSignalDeviations?: Maybe<Array<Maybe<GoldenSignalSignalDeviation>>>;
  /**
   * The stored golden signal(s) for the given entity.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  goldenSignalValues?: Maybe<GoldenSignalValues>;
  /**
   * The stored golden signal(s) for the given entity. To be removed, use goldenSignalValues instead.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  goldenSignalValuesV2?: Maybe<GoldenSignalValues>;
  /** The list of golden tags for a specific entityType. */
  goldenTags?: Maybe<EntityGoldenContextScopedGoldenTags>;
  /** A unique entity identifier. */
  guid?: Maybe<Scalars['EntityGuid']['output']>;
  /** The host the database instance is running on. */
  host?: Maybe<Scalars['String']['output']>;
  /** The time the entity was indexed. */
  indexedAt?: Maybe<Scalars['EpochMilliseconds']['output']>;
  /** The last time the entity's reporting status changed. */
  lastReportingChangeAt?: Maybe<Scalars['EpochMilliseconds']['output']>;
  /** The name of this entity. */
  name?: Maybe<Scalars['String']['output']>;
  nerdStorage?: Maybe<NerdStorageEntityScope>;
  nerdStoreCollection?: Maybe<Array<Maybe<NerdStoreCollectionMember>>>;
  nerdStoreDocument?: Maybe<Scalars['NerdStoreDocument']['output']>;
  /**
   * Make an `Entity` scoped query to NRDB with a NRQL string.
   *
   * A relevant `WHERE` clause will be added to your query to scope data to the entity in question.
   *
   * See the [NRQL Docs](https://docs.newrelic.com/docs/insights/nrql-new-relic-query-language/nrql-resources/nrql-syntax-components-functions) for more information about generating a query string.
   */
  nrdbQuery?: Maybe<NrdbResultContainer>;
  /**
   * Poll for the results of a previously-executed asychronous NRDB query.
   *
   * The `queryId` is available in the `queryProgress` data returned by the original asynchronous query.
   *
   * See [this page](https://docs.newrelic.com/docs/apis/nerdgraph/examples/async-queries-nrql-tutorial) for additional asynchronous query documentation.
   * @deprecated This field is experimental! It may change at any time.
   *
   */
  nrdbQueryProgress?: Maybe<NrdbResultContainer>;
  /** The url to the entity. */
  permalink?: Maybe<Scalars['String']['output']>;
  /** The port or path the database instance is running on. ex: `3306` | `/tmp/mysql.sock` */
  portOrPath?: Maybe<Scalars['String']['output']>;
  /** Recent violations on the entity. */
  recentAlertViolations?: Maybe<Array<Maybe<EntityAlertViolation>>>;
  /** The recommended service levels for the entity. */
  recommendedServiceLevel?: Maybe<ServiceLevelRecommendation>;
  /** Related dashboards results */
  relatedDashboards: RelatedDashboardsRelatedDashboardResult;
  /** Related entities result with optional filtering. */
  relatedEntities?: Maybe<EntityRelationshipRelatedEntitiesResult>;
  /** Relationship traversal results with optional filtering. WARNING: this query is still experimental, and subject to breaking changes. */
  relationshipTraversal?: Maybe<EntityRelationshipTraversalResult>;
  /**
   * A list of the entities' relationships.
   *
   * For more information, visit [our docs](https://docs.newrelic.com/docs/apis/graphql-api/tutorials/graphql-relationships-api-tutorial).
   * @deprecated This field is deprecated! Please use `relatedEntities`.
   */
  relationships?: Maybe<Array<Maybe<EntityRelationship>>>;
  /** The reporting status of the entity. If New Relic is successfully collecting data from your application, this will be true. */
  reporting?: Maybe<Scalars['Boolean']['output']>;
  /** The service level defined for the entity. */
  serviceLevel?: Maybe<ServiceLevelDefinition>;
  /** The list of summary metrics. */
  summaryMetrics?: Maybe<Array<Maybe<EntitySummaryMetric>>>;
  /**
   * The tags applied to the entity.
   *
   * For details on tags, as well as query and mutation examples, visit [our docs](https://docs.newrelic.com/docs/apis/graphql-api/tutorials/graphql-tagging-api-tutorial).
   */
  tags?: Maybe<Array<Maybe<EntityTag>>>;
  /** The tags applied to the entity with their metadata. */
  tagsWithMetadata?: Maybe<Array<Maybe<EntityTagWithMetadata>>>;
  /** Look up Distributed Tracing summary data for the selected `EntityGuid` */
  tracingSummary?: Maybe<DistributedTracingEntityTracingSummary>;
  /** The entity's type */
  type?: Maybe<Scalars['String']['output']>;
  /** List of templates availables for this entity. */
  uiTemplates?: Maybe<Array<EntityDashboardTemplatesUi>>;
  /** The type of database. ex: `Postgres` | `Redis` */
  vendor?: Maybe<Scalars['String']['output']>;
};


/** A database instance seen by an APM Application */
export type ApmDatabaseInstanceEntityAlertViolationsArgs = {
  endTime: Scalars['EpochMilliseconds']['input'];
  startTime: Scalars['EpochMilliseconds']['input'];
};


/** A database instance seen by an APM Application */
export type ApmDatabaseInstanceEntityDeploymentSearchArgs = {
  filter?: InputMaybe<ChangeTrackingSearchFilter>;
};


/** A database instance seen by an APM Application */
export type ApmDatabaseInstanceEntityGoldenMetricsArgs = {
  context?: InputMaybe<EntityGoldenContextInput>;
  timeWindow?: InputMaybe<EntityGoldenNrqlTimeWindowInput>;
};


/** A database instance seen by an APM Application */
export type ApmDatabaseInstanceEntityGoldenSignalCorrelationsArgs = {
  filter?: InputMaybe<GoldenSignalCorrelationsEntityFilter>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  timeWindow?: InputMaybe<TimeWindowInput>;
};


/** A database instance seen by an APM Application */
export type ApmDatabaseInstanceEntityGoldenSignalDeviationsArgs = {
  comparisonTimeWindow?: InputMaybe<TimeWindowInput>;
  evaluationTimeWindow?: InputMaybe<TimeWindowInput>;
};


/** A database instance seen by an APM Application */
export type ApmDatabaseInstanceEntityGoldenSignalValuesArgs = {
  timeWindow?: InputMaybe<TimeWindowInput>;
};


/** A database instance seen by an APM Application */
export type ApmDatabaseInstanceEntityGoldenSignalValuesV2Args = {
  timeWindow?: InputMaybe<TimeWindowInput>;
};


/** A database instance seen by an APM Application */
export type ApmDatabaseInstanceEntityGoldenTagsArgs = {
  context?: InputMaybe<EntityGoldenContextInput>;
};


/** A database instance seen by an APM Application */
export type ApmDatabaseInstanceEntityNerdStoreCollectionArgs = {
  collection: Scalars['String']['input'];
  scopeByActor?: InputMaybe<Scalars['Boolean']['input']>;
};


/** A database instance seen by an APM Application */
export type ApmDatabaseInstanceEntityNerdStoreDocumentArgs = {
  collection: Scalars['String']['input'];
  documentId: Scalars['String']['input'];
  scopeByActor?: InputMaybe<Scalars['Boolean']['input']>;
};


/** A database instance seen by an APM Application */
export type ApmDatabaseInstanceEntityNrdbQueryArgs = {
  async?: InputMaybe<Scalars['Boolean']['input']>;
  nrql: Scalars['Nrql']['input'];
  options?: InputMaybe<NrqlQueryOptions>;
  timeout?: InputMaybe<Scalars['Seconds']['input']>;
};


/** A database instance seen by an APM Application */
export type ApmDatabaseInstanceEntityNrdbQueryProgressArgs = {
  queryId: Scalars['ID']['input'];
};


/** A database instance seen by an APM Application */
export type ApmDatabaseInstanceEntityRecentAlertViolationsArgs = {
  count?: InputMaybe<Scalars['Int']['input']>;
};


/** A database instance seen by an APM Application */
export type ApmDatabaseInstanceEntityRelatedEntitiesArgs = {
  cursor?: InputMaybe<Scalars['String']['input']>;
  filter?: InputMaybe<EntityRelationshipEdgeFilter>;
  limit?: InputMaybe<Scalars['Int']['input']>;
};


/** A database instance seen by an APM Application */
export type ApmDatabaseInstanceEntityRelationshipTraversalArgs = {
  cursor?: InputMaybe<Scalars['String']['input']>;
  hopFilters?: InputMaybe<EntityRelationshipTraversalHopFilters>;
  hops?: InputMaybe<Scalars['Int']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
};


/** A database instance seen by an APM Application */
export type ApmDatabaseInstanceEntityRelationshipsArgs = {
  endTime?: InputMaybe<Scalars['EpochMilliseconds']['input']>;
  filter?: InputMaybe<EntityRelationshipFilter>;
};


/** A database instance seen by an APM Application */
export type ApmDatabaseInstanceEntitySummaryMetricsArgs = {
  timeWindow?: InputMaybe<TimeWindowInput>;
};


/** A database instance seen by an APM Application */
export type ApmDatabaseInstanceEntityTracingSummaryArgs = {
  timeWindow?: InputMaybe<TimeWindowInput>;
};

/** A database instance seen by an APM Application */
export type ApmDatabaseInstanceEntityOutline = AlertableEntityOutline & EntityOutline & {
  __typename?: 'ApmDatabaseInstanceEntityOutline';
  account?: Maybe<AccountOutline>;
  /** The New Relic account ID associated with this entity. */
  accountId?: Maybe<Scalars['Int']['output']>;
  /** The current alerting severity of the entity. */
  alertSeverity?: Maybe<EntityAlertSeverity>;
  /**
   * The alert status of the entity.
   * @deprecated Please use `alertSeverity` and `reporting`
   */
  alertStatus?: Maybe<EntityAlertStatus>;
  /** The entity's domain */
  domain?: Maybe<Scalars['String']['output']>;
  /** A value representing the combination of the entity's domain and type. */
  entityType?: Maybe<EntityType>;
  /** The date of last time the entity has updated any of its fields. */
  firstIndexedAt?: Maybe<Scalars['EpochMilliseconds']['output']>;
  /** The list of golden metrics for a specific entity */
  goldenMetrics?: Maybe<EntityGoldenContextScopedGoldenMetrics>;
  /**
   * For the golden signal on this entity, show correlated signals from related entities.
   * Well inspect the golden signals for all related entities and return a sorted list.
   * You can also filter the results.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  goldenSignalCorrelations?: Maybe<GoldenSignalCorrelationResult>;
  /**
   * The deviation from normal of golden signal(s) for the given entity.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  goldenSignalDeviations?: Maybe<Array<Maybe<GoldenSignalSignalDeviation>>>;
  /**
   * The stored golden signal(s) for the given entity.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  goldenSignalValues?: Maybe<GoldenSignalValues>;
  /**
   * The stored golden signal(s) for the given entity. To be removed, use goldenSignalValues instead.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  goldenSignalValuesV2?: Maybe<GoldenSignalValues>;
  /** The list of golden tags for a specific entityType. */
  goldenTags?: Maybe<EntityGoldenContextScopedGoldenTags>;
  /** A unique entity identifier. */
  guid?: Maybe<Scalars['EntityGuid']['output']>;
  /** The host the database instance is running on. */
  host?: Maybe<Scalars['String']['output']>;
  /** The time the entity was indexed. */
  indexedAt?: Maybe<Scalars['EpochMilliseconds']['output']>;
  /** The last time the entity's reporting status changed. */
  lastReportingChangeAt?: Maybe<Scalars['EpochMilliseconds']['output']>;
  /** The name of this entity. */
  name?: Maybe<Scalars['String']['output']>;
  /** The url to the entity. */
  permalink?: Maybe<Scalars['String']['output']>;
  /** The port or path the database instance is running on. ex: `3306` | `/tmp/mysql.sock` */
  portOrPath?: Maybe<Scalars['String']['output']>;
  /** The recommended service levels for the entity. */
  recommendedServiceLevel?: Maybe<ServiceLevelRecommendation>;
  /** Related dashboards results */
  relatedDashboards: RelatedDashboardsRelatedDashboardResult;
  /** The reporting status of the entity. If New Relic is successfully collecting data from your application, this will be true. */
  reporting?: Maybe<Scalars['Boolean']['output']>;
  /** The service level defined for the entity. */
  serviceLevel?: Maybe<ServiceLevelDefinition>;
  /** The list of summary metrics. */
  summaryMetrics?: Maybe<Array<Maybe<EntitySummaryMetric>>>;
  /**
   * The tags applied to the entity.
   *
   * For details on tags, as well as query and mutation examples, visit [our docs](https://docs.newrelic.com/docs/apis/graphql-api/tutorials/graphql-tagging-api-tutorial).
   */
  tags?: Maybe<Array<Maybe<EntityTag>>>;
  /** The entity's type */
  type?: Maybe<Scalars['String']['output']>;
  /** List of templates availables for this entity. */
  uiTemplates?: Maybe<Array<EntityDashboardTemplatesUi>>;
  /** The type of database. ex: `Postgres` | `Redis` */
  vendor?: Maybe<Scalars['String']['output']>;
};


/** A database instance seen by an APM Application */
export type ApmDatabaseInstanceEntityOutlineGoldenMetricsArgs = {
  context?: InputMaybe<EntityGoldenContextInput>;
  timeWindow?: InputMaybe<EntityGoldenNrqlTimeWindowInput>;
};


/** A database instance seen by an APM Application */
export type ApmDatabaseInstanceEntityOutlineGoldenSignalCorrelationsArgs = {
  filter?: InputMaybe<GoldenSignalCorrelationsEntityFilter>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  timeWindow?: InputMaybe<TimeWindowInput>;
};


/** A database instance seen by an APM Application */
export type ApmDatabaseInstanceEntityOutlineGoldenSignalDeviationsArgs = {
  comparisonTimeWindow?: InputMaybe<TimeWindowInput>;
  evaluationTimeWindow?: InputMaybe<TimeWindowInput>;
};


/** A database instance seen by an APM Application */
export type ApmDatabaseInstanceEntityOutlineGoldenSignalValuesArgs = {
  timeWindow?: InputMaybe<TimeWindowInput>;
};


/** A database instance seen by an APM Application */
export type ApmDatabaseInstanceEntityOutlineGoldenSignalValuesV2Args = {
  timeWindow?: InputMaybe<TimeWindowInput>;
};


/** A database instance seen by an APM Application */
export type ApmDatabaseInstanceEntityOutlineGoldenTagsArgs = {
  context?: InputMaybe<EntityGoldenContextInput>;
};


/** A database instance seen by an APM Application */
export type ApmDatabaseInstanceEntityOutlineSummaryMetricsArgs = {
  timeWindow?: InputMaybe<TimeWindowInput>;
};

/** An external service seen by an APM Application. */
export type ApmExternalServiceEntity = AlertableEntity & Entity & {
  __typename?: 'ApmExternalServiceEntity';
  account?: Maybe<AccountOutline>;
  /** The New Relic account ID associated with this entity. */
  accountId?: Maybe<Scalars['Int']['output']>;
  /** The current alerting severity of the entity. */
  alertSeverity?: Maybe<EntityAlertSeverity>;
  /**
   * The alert status of the entity.
   * @deprecated Please use `alertSeverity` and `reporting`
   */
  alertStatus?: Maybe<EntityAlertStatus>;
  /** Violations on the entity that were open during the specified time window. This will return up to 500 violations - if there are more in the time window selected, you must narrow the time window or look at fewer entities. */
  alertViolations?: Maybe<Array<Maybe<EntityAlertViolation>>>;
  /** Retrieve the deployment event(s). Ordered by timestamp DESC. */
  deploymentSearch?: Maybe<ChangeTrackingDeploymentSearchResult>;
  /** The entity's domain */
  domain?: Maybe<Scalars['String']['output']>;
  /** A value representing the combination of the entity's domain and type. */
  entityType?: Maybe<EntityType>;
  /** @deprecated This field is deprecated. */
  externalSummary?: Maybe<ApmExternalServiceSummaryData>;
  /** The date of last time the entity has updated any of its fields. */
  firstIndexedAt?: Maybe<Scalars['EpochMilliseconds']['output']>;
  /** The list of golden metrics for a specific entity */
  goldenMetrics?: Maybe<EntityGoldenContextScopedGoldenMetrics>;
  /**
   * For the golden signal on this entity, show correlated signals from related entities.
   * Well inspect the golden signals for all related entities and return a sorted list.
   * You can also filter the results.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  goldenSignalCorrelations?: Maybe<GoldenSignalCorrelationResult>;
  /**
   * The deviation from normal of golden signal(s) for the given entity.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  goldenSignalDeviations?: Maybe<Array<Maybe<GoldenSignalSignalDeviation>>>;
  /**
   * The stored golden signal(s) for the given entity.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  goldenSignalValues?: Maybe<GoldenSignalValues>;
  /**
   * The stored golden signal(s) for the given entity. To be removed, use goldenSignalValues instead.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  goldenSignalValuesV2?: Maybe<GoldenSignalValues>;
  /** The list of golden tags for a specific entityType. */
  goldenTags?: Maybe<EntityGoldenContextScopedGoldenTags>;
  /** A unique entity identifier. */
  guid?: Maybe<Scalars['EntityGuid']['output']>;
  /** The host of the external service. */
  host?: Maybe<Scalars['String']['output']>;
  /** The time the entity was indexed. */
  indexedAt?: Maybe<Scalars['EpochMilliseconds']['output']>;
  /** The last time the entity's reporting status changed. */
  lastReportingChangeAt?: Maybe<Scalars['EpochMilliseconds']['output']>;
  /** The name of this entity. */
  name?: Maybe<Scalars['String']['output']>;
  nerdStorage?: Maybe<NerdStorageEntityScope>;
  nerdStoreCollection?: Maybe<Array<Maybe<NerdStoreCollectionMember>>>;
  nerdStoreDocument?: Maybe<Scalars['NerdStoreDocument']['output']>;
  /**
   * Make an `Entity` scoped query to NRDB with a NRQL string.
   *
   * A relevant `WHERE` clause will be added to your query to scope data to the entity in question.
   *
   * See the [NRQL Docs](https://docs.newrelic.com/docs/insights/nrql-new-relic-query-language/nrql-resources/nrql-syntax-components-functions) for more information about generating a query string.
   */
  nrdbQuery?: Maybe<NrdbResultContainer>;
  /**
   * Poll for the results of a previously-executed asychronous NRDB query.
   *
   * The `queryId` is available in the `queryProgress` data returned by the original asynchronous query.
   *
   * See [this page](https://docs.newrelic.com/docs/apis/nerdgraph/examples/async-queries-nrql-tutorial) for additional asynchronous query documentation.
   * @deprecated This field is experimental! It may change at any time.
   *
   */
  nrdbQueryProgress?: Maybe<NrdbResultContainer>;
  /** The url to the entity. */
  permalink?: Maybe<Scalars['String']['output']>;
  /** Recent violations on the entity. */
  recentAlertViolations?: Maybe<Array<Maybe<EntityAlertViolation>>>;
  /** The recommended service levels for the entity. */
  recommendedServiceLevel?: Maybe<ServiceLevelRecommendation>;
  /** Related dashboards results */
  relatedDashboards: RelatedDashboardsRelatedDashboardResult;
  /** Related entities result with optional filtering. */
  relatedEntities?: Maybe<EntityRelationshipRelatedEntitiesResult>;
  /** Relationship traversal results with optional filtering. WARNING: this query is still experimental, and subject to breaking changes. */
  relationshipTraversal?: Maybe<EntityRelationshipTraversalResult>;
  /**
   * A list of the entities' relationships.
   *
   * For more information, visit [our docs](https://docs.newrelic.com/docs/apis/graphql-api/tutorials/graphql-relationships-api-tutorial).
   * @deprecated This field is deprecated! Please use `relatedEntities`.
   */
  relationships?: Maybe<Array<Maybe<EntityRelationship>>>;
  /** The reporting status of the entity. If New Relic is successfully collecting data from your application, this will be true. */
  reporting?: Maybe<Scalars['Boolean']['output']>;
  /** The service level defined for the entity. */
  serviceLevel?: Maybe<ServiceLevelDefinition>;
  /** The list of summary metrics. */
  summaryMetrics?: Maybe<Array<Maybe<EntitySummaryMetric>>>;
  /**
   * The tags applied to the entity.
   *
   * For details on tags, as well as query and mutation examples, visit [our docs](https://docs.newrelic.com/docs/apis/graphql-api/tutorials/graphql-tagging-api-tutorial).
   */
  tags?: Maybe<Array<Maybe<EntityTag>>>;
  /** The tags applied to the entity with their metadata. */
  tagsWithMetadata?: Maybe<Array<Maybe<EntityTagWithMetadata>>>;
  /** Look up Distributed Tracing summary data for the selected `EntityGuid` */
  tracingSummary?: Maybe<DistributedTracingEntityTracingSummary>;
  /** The entity's type */
  type?: Maybe<Scalars['String']['output']>;
  /** List of templates availables for this entity. */
  uiTemplates?: Maybe<Array<EntityDashboardTemplatesUi>>;
};


/** An external service seen by an APM Application. */
export type ApmExternalServiceEntityAlertViolationsArgs = {
  endTime: Scalars['EpochMilliseconds']['input'];
  startTime: Scalars['EpochMilliseconds']['input'];
};


/** An external service seen by an APM Application. */
export type ApmExternalServiceEntityDeploymentSearchArgs = {
  filter?: InputMaybe<ChangeTrackingSearchFilter>;
};


/** An external service seen by an APM Application. */
export type ApmExternalServiceEntityGoldenMetricsArgs = {
  context?: InputMaybe<EntityGoldenContextInput>;
  timeWindow?: InputMaybe<EntityGoldenNrqlTimeWindowInput>;
};


/** An external service seen by an APM Application. */
export type ApmExternalServiceEntityGoldenSignalCorrelationsArgs = {
  filter?: InputMaybe<GoldenSignalCorrelationsEntityFilter>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  timeWindow?: InputMaybe<TimeWindowInput>;
};


/** An external service seen by an APM Application. */
export type ApmExternalServiceEntityGoldenSignalDeviationsArgs = {
  comparisonTimeWindow?: InputMaybe<TimeWindowInput>;
  evaluationTimeWindow?: InputMaybe<TimeWindowInput>;
};


/** An external service seen by an APM Application. */
export type ApmExternalServiceEntityGoldenSignalValuesArgs = {
  timeWindow?: InputMaybe<TimeWindowInput>;
};


/** An external service seen by an APM Application. */
export type ApmExternalServiceEntityGoldenSignalValuesV2Args = {
  timeWindow?: InputMaybe<TimeWindowInput>;
};


/** An external service seen by an APM Application. */
export type ApmExternalServiceEntityGoldenTagsArgs = {
  context?: InputMaybe<EntityGoldenContextInput>;
};


/** An external service seen by an APM Application. */
export type ApmExternalServiceEntityNerdStoreCollectionArgs = {
  collection: Scalars['String']['input'];
  scopeByActor?: InputMaybe<Scalars['Boolean']['input']>;
};


/** An external service seen by an APM Application. */
export type ApmExternalServiceEntityNerdStoreDocumentArgs = {
  collection: Scalars['String']['input'];
  documentId: Scalars['String']['input'];
  scopeByActor?: InputMaybe<Scalars['Boolean']['input']>;
};


/** An external service seen by an APM Application. */
export type ApmExternalServiceEntityNrdbQueryArgs = {
  async?: InputMaybe<Scalars['Boolean']['input']>;
  nrql: Scalars['Nrql']['input'];
  options?: InputMaybe<NrqlQueryOptions>;
  timeout?: InputMaybe<Scalars['Seconds']['input']>;
};


/** An external service seen by an APM Application. */
export type ApmExternalServiceEntityNrdbQueryProgressArgs = {
  queryId: Scalars['ID']['input'];
};


/** An external service seen by an APM Application. */
export type ApmExternalServiceEntityRecentAlertViolationsArgs = {
  count?: InputMaybe<Scalars['Int']['input']>;
};


/** An external service seen by an APM Application. */
export type ApmExternalServiceEntityRelatedEntitiesArgs = {
  cursor?: InputMaybe<Scalars['String']['input']>;
  filter?: InputMaybe<EntityRelationshipEdgeFilter>;
  limit?: InputMaybe<Scalars['Int']['input']>;
};


/** An external service seen by an APM Application. */
export type ApmExternalServiceEntityRelationshipTraversalArgs = {
  cursor?: InputMaybe<Scalars['String']['input']>;
  hopFilters?: InputMaybe<EntityRelationshipTraversalHopFilters>;
  hops?: InputMaybe<Scalars['Int']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
};


/** An external service seen by an APM Application. */
export type ApmExternalServiceEntityRelationshipsArgs = {
  endTime?: InputMaybe<Scalars['EpochMilliseconds']['input']>;
  filter?: InputMaybe<EntityRelationshipFilter>;
};


/** An external service seen by an APM Application. */
export type ApmExternalServiceEntitySummaryMetricsArgs = {
  timeWindow?: InputMaybe<TimeWindowInput>;
};


/** An external service seen by an APM Application. */
export type ApmExternalServiceEntityTracingSummaryArgs = {
  timeWindow?: InputMaybe<TimeWindowInput>;
};

/** An external service seen by an APM Application. */
export type ApmExternalServiceEntityOutline = AlertableEntityOutline & EntityOutline & {
  __typename?: 'ApmExternalServiceEntityOutline';
  account?: Maybe<AccountOutline>;
  /** The New Relic account ID associated with this entity. */
  accountId?: Maybe<Scalars['Int']['output']>;
  /** The current alerting severity of the entity. */
  alertSeverity?: Maybe<EntityAlertSeverity>;
  /**
   * The alert status of the entity.
   * @deprecated Please use `alertSeverity` and `reporting`
   */
  alertStatus?: Maybe<EntityAlertStatus>;
  /** The entity's domain */
  domain?: Maybe<Scalars['String']['output']>;
  /** A value representing the combination of the entity's domain and type. */
  entityType?: Maybe<EntityType>;
  /** @deprecated This field is deprecated. */
  externalSummary?: Maybe<ApmExternalServiceSummaryData>;
  /** The date of last time the entity has updated any of its fields. */
  firstIndexedAt?: Maybe<Scalars['EpochMilliseconds']['output']>;
  /** The list of golden metrics for a specific entity */
  goldenMetrics?: Maybe<EntityGoldenContextScopedGoldenMetrics>;
  /**
   * For the golden signal on this entity, show correlated signals from related entities.
   * Well inspect the golden signals for all related entities and return a sorted list.
   * You can also filter the results.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  goldenSignalCorrelations?: Maybe<GoldenSignalCorrelationResult>;
  /**
   * The deviation from normal of golden signal(s) for the given entity.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  goldenSignalDeviations?: Maybe<Array<Maybe<GoldenSignalSignalDeviation>>>;
  /**
   * The stored golden signal(s) for the given entity.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  goldenSignalValues?: Maybe<GoldenSignalValues>;
  /**
   * The stored golden signal(s) for the given entity. To be removed, use goldenSignalValues instead.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  goldenSignalValuesV2?: Maybe<GoldenSignalValues>;
  /** The list of golden tags for a specific entityType. */
  goldenTags?: Maybe<EntityGoldenContextScopedGoldenTags>;
  /** A unique entity identifier. */
  guid?: Maybe<Scalars['EntityGuid']['output']>;
  /** The host of the external service. */
  host?: Maybe<Scalars['String']['output']>;
  /** The time the entity was indexed. */
  indexedAt?: Maybe<Scalars['EpochMilliseconds']['output']>;
  /** The last time the entity's reporting status changed. */
  lastReportingChangeAt?: Maybe<Scalars['EpochMilliseconds']['output']>;
  /** The name of this entity. */
  name?: Maybe<Scalars['String']['output']>;
  /** The url to the entity. */
  permalink?: Maybe<Scalars['String']['output']>;
  /** The recommended service levels for the entity. */
  recommendedServiceLevel?: Maybe<ServiceLevelRecommendation>;
  /** Related dashboards results */
  relatedDashboards: RelatedDashboardsRelatedDashboardResult;
  /** The reporting status of the entity. If New Relic is successfully collecting data from your application, this will be true. */
  reporting?: Maybe<Scalars['Boolean']['output']>;
  /** The service level defined for the entity. */
  serviceLevel?: Maybe<ServiceLevelDefinition>;
  /** The list of summary metrics. */
  summaryMetrics?: Maybe<Array<Maybe<EntitySummaryMetric>>>;
  /**
   * The tags applied to the entity.
   *
   * For details on tags, as well as query and mutation examples, visit [our docs](https://docs.newrelic.com/docs/apis/graphql-api/tutorials/graphql-tagging-api-tutorial).
   */
  tags?: Maybe<Array<Maybe<EntityTag>>>;
  /** The entity's type */
  type?: Maybe<Scalars['String']['output']>;
  /** List of templates availables for this entity. */
  uiTemplates?: Maybe<Array<EntityDashboardTemplatesUi>>;
};


/** An external service seen by an APM Application. */
export type ApmExternalServiceEntityOutlineGoldenMetricsArgs = {
  context?: InputMaybe<EntityGoldenContextInput>;
  timeWindow?: InputMaybe<EntityGoldenNrqlTimeWindowInput>;
};


/** An external service seen by an APM Application. */
export type ApmExternalServiceEntityOutlineGoldenSignalCorrelationsArgs = {
  filter?: InputMaybe<GoldenSignalCorrelationsEntityFilter>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  timeWindow?: InputMaybe<TimeWindowInput>;
};


/** An external service seen by an APM Application. */
export type ApmExternalServiceEntityOutlineGoldenSignalDeviationsArgs = {
  comparisonTimeWindow?: InputMaybe<TimeWindowInput>;
  evaluationTimeWindow?: InputMaybe<TimeWindowInput>;
};


/** An external service seen by an APM Application. */
export type ApmExternalServiceEntityOutlineGoldenSignalValuesArgs = {
  timeWindow?: InputMaybe<TimeWindowInput>;
};


/** An external service seen by an APM Application. */
export type ApmExternalServiceEntityOutlineGoldenSignalValuesV2Args = {
  timeWindow?: InputMaybe<TimeWindowInput>;
};


/** An external service seen by an APM Application. */
export type ApmExternalServiceEntityOutlineGoldenTagsArgs = {
  context?: InputMaybe<EntityGoldenContextInput>;
};


/** An external service seen by an APM Application. */
export type ApmExternalServiceEntityOutlineSummaryMetricsArgs = {
  timeWindow?: InputMaybe<TimeWindowInput>;
};

/** Summary statistics about an External Service called by an APM App. */
export type ApmExternalServiceSummaryData = {
  __typename?: 'ApmExternalServiceSummaryData';
  /** The average response time for external service calls in seconds. */
  responseTimeAverage?: Maybe<Scalars['Seconds']['output']>;
  /** The number of external service calls per minute. */
  throughput?: Maybe<Scalars['Float']['output']>;
};

/** The Attributes type */
export type AuthorizationAttributes = {
  /** The account that the target entity belongs to. */
  accountId: Scalars['Int']['input'];
};

/** The AuthorizeEntityResult type. */
export type AuthorizationAuthorizeEntityResult = {
  __typename?: 'AuthorizationAuthorizeEntityResult';
  /** The result of the access check. */
  allowed?: Maybe<Scalars['Boolean']['output']>;
};

/** The list of Billable Core User Accounts this user is authorized to access. */
export type AuthorizationBillableCoreUserAccount = {
  __typename?: 'AuthorizationBillableCoreUserAccount';
  /** ID of the account. */
  accountId: Scalars['Int']['output'];
  /** Name of the account. */
  accountName: Scalars['String']['output'];
  /** ID of the organization for this account. */
  organizationId: Scalars['ID']['output'];
};

/** The authorization capability for a given scope context. */
export type AuthorizationCapability = {
  __typename?: 'AuthorizationCapability';
  /** Name of the capability. */
  name: Scalars['String']['output'];
};

/** Contextual data only for this request. */
export type AuthorizationContext = {
  /** An object of attributes. */
  attributes: AuthorizationAttributes;
  /** An array of relations. */
  relations?: InputMaybe<Array<InputMaybe<AuthorizationRelation>>>;
};

/** The filter to to apply when listing capabilities for an authorization scope type. */
export type AuthorizationFilter = {
  /** An array of the specific capability names for which you want results. */
  names: Array<InputMaybe<Scalars['String']['input']>>;
};

/** The Account and Role a Group should have access to */
export type AuthorizationManagementAccountAccessGrant = {
  /** The Account ID the Role will grant access to */
  accountId: Scalars['Int']['input'];
  /** The Role ID that will define the access */
  roleId: Scalars['ID']['input'];
};

/** An "authentication domain" is a grouping of New Relic users governed by the same user management settings, like how they're provisioned (added and updated), how they're authenticated (logged in), session settings, and how user upgrades are managed. */
export type AuthorizationManagementAuthenticationDomain = {
  __typename?: 'AuthorizationManagementAuthenticationDomain';
  /** container for groups enabling cursor based pagination */
  groups: AuthorizationManagementGroupSearch;
  /** a value that uniquely identifies this object */
  id: Scalars['ID']['output'];
  /** the name of the object */
  name: Scalars['String']['output'];
};


/** An "authentication domain" is a grouping of New Relic users governed by the same user management settings, like how they're provisioned (added and updated), how they're authenticated (logged in), session settings, and how user upgrades are managed. */
export type AuthorizationManagementAuthenticationDomainGroupsArgs = {
  cursor?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Array<Scalars['ID']['input']>>;
};

/** container for authentication domains enabling cursor based pagination */
export type AuthorizationManagementAuthenticationDomainSearch = {
  __typename?: 'AuthorizationManagementAuthenticationDomainSearch';
  /** containers of users and groups */
  authenticationDomains: Array<AuthorizationManagementAuthenticationDomain>;
  /** an opaque cursor to supply with subsequent   requests to get the next page of results, null if there are no more pages */
  nextCursor?: Maybe<Scalars['String']['output']>;
  /** the total number of results */
  totalCount: Scalars['Int']['output'];
};

/** The input object representing the access to grant for the group */
export type AuthorizationManagementGrantAccess = {
  /** The Role and the Account the Target Group should have access to */
  accountAccessGrants?: InputMaybe<Array<AuthorizationManagementAccountAccessGrant>>;
  /** The Role and the Group the Target Group should have access to */
  groupAccessGrants?: InputMaybe<Array<AuthorizationManagementGroupAccessGrant>>;
  /** The Group ID that will have access granted */
  groupId: Scalars['ID']['input'];
  /** The Role and the Organization the Target Group should have access to */
  organizationAccessGrants?: InputMaybe<Array<AuthorizationManagementOrganizationAccessGrant>>;
};

/** Autogenerated return type of GrantAccess */
export type AuthorizationManagementGrantAccessPayload = {
  __typename?: 'AuthorizationManagementGrantAccessPayload';
  /** the roles that were granted to this group */
  roles: Array<AuthorizationManagementGrantedRole>;
};

/** A Granted Role represents the access given to a group. */
export type AuthorizationManagementGrantedRole = {
  __typename?: 'AuthorizationManagementGrantedRole';
  /** the account that this role grants access to */
  accountId?: Maybe<Scalars['Int']['output']>;
  /** the name of the object */
  displayName?: Maybe<Scalars['String']['output']>;
  /** the group that this role grants access to */
  groupId?: Maybe<Scalars['ID']['output']>;
  /** a value that uniquely identifies this object */
  id: Scalars['ID']['output'];
  /** the name of the object */
  name: Scalars['String']['output'];
  /** the organization this role grants access to */
  organizationId?: Maybe<Scalars['ID']['output']>;
  /** the role that defines this access */
  roleId: Scalars['Int']['output'];
  /** the type of the role */
  type: Scalars['ID']['output'];
};

/** container for roles enabling cursor based pagination */
export type AuthorizationManagementGrantedRoleSearch = {
  __typename?: 'AuthorizationManagementGrantedRoleSearch';
  /** an opaque cursor to supply with subsequent   requests to get the next page of results, null if there are no more pages */
  nextCursor?: Maybe<Scalars['String']['output']>;
  /** the roles granted to this group */
  roles: Array<AuthorizationManagementGrantedRole>;
  /** the total number of results */
  totalCount: Scalars['Int']['output'];
};

/** For users on our New Relic One user model, a "group" represents a group of users. Putting users in a group allows the managing of permissions for multiple users at the same time. */
export type AuthorizationManagementGroup = {
  __typename?: 'AuthorizationManagementGroup';
  /** the name of the object */
  displayName: Scalars['String']['output'];
  /** a value that uniquely identifies this object */
  id: Scalars['ID']['output'];
  /** container for roles enabling cursor based pagination */
  roles: AuthorizationManagementGrantedRoleSearch;
};


/** For users on our New Relic One user model, a "group" represents a group of users. Putting users in a group allows the managing of permissions for multiple users at the same time. */
export type AuthorizationManagementGroupRolesArgs = {
  cursor?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Array<Scalars['ID']['input']>>;
  roleId?: InputMaybe<Array<Scalars['ID']['input']>>;
};

/** The Group and Role another Group should have access to */
export type AuthorizationManagementGroupAccessGrant = {
  /** The Group ID the Role will grant access to */
  groupId: Scalars['ID']['input'];
  /** The Role ID that will define the access */
  roleId: Scalars['ID']['input'];
};

/** container for groups enabling cursor based pagination */
export type AuthorizationManagementGroupSearch = {
  __typename?: 'AuthorizationManagementGroupSearch';
  /** contains roles granted to users's groups */
  groups: Array<AuthorizationManagementGroup>;
  /** an opaque cursor to supply with subsequent   requests to get the next page of results, null if there are no more pages */
  nextCursor?: Maybe<Scalars['String']['output']>;
  /** the total number of results */
  totalCount: Scalars['Int']['output'];
};

/** The Organization Role a Group should have access to */
export type AuthorizationManagementOrganizationAccessGrant = {
  /** The Role ID that will define the Organization access */
  roleId: Scalars['ID']['input'];
};

export type AuthorizationManagementOrganizationStitchedFields = {
  __typename?: 'AuthorizationManagementOrganizationStitchedFields';
  /** list of authentication domains */
  authenticationDomains?: Maybe<AuthorizationManagementAuthenticationDomainSearch>;
  /** list of roles */
  roles?: Maybe<AuthorizationManagementRoleSearch>;
};


export type AuthorizationManagementOrganizationStitchedFieldsAuthenticationDomainsArgs = {
  cursor?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Array<Scalars['ID']['input']>>;
};


export type AuthorizationManagementOrganizationStitchedFieldsRolesArgs = {
  cursor?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Array<Scalars['ID']['input']>>;
};

/** The input object representing the access to revoke for the group */
export type AuthorizationManagementRevokeAccess = {
  /** The Role and the Account the Target Group should no longer have access to */
  accountAccessGrants?: InputMaybe<Array<AuthorizationManagementAccountAccessGrant>>;
  /** The Role and the Group the Target Group should no longer have access to */
  groupAccessGrants?: InputMaybe<Array<AuthorizationManagementGroupAccessGrant>>;
  /** The Group ID that will have access revoked */
  groupId: Scalars['ID']['input'];
  /** The Role and the Organization the Target Group should no longer have access to */
  organizationAccessGrants?: InputMaybe<Array<AuthorizationManagementOrganizationAccessGrant>>;
};

/** Autogenerated return type of RevokeAccess */
export type AuthorizationManagementRevokeAccessPayload = {
  __typename?: 'AuthorizationManagementRevokeAccessPayload';
  /** the roles that were revoked from this group */
  roles: Array<AuthorizationManagementGrantedRole>;
};

/** a role grants access on an account or organization to groups of users */
export type AuthorizationManagementRole = {
  __typename?: 'AuthorizationManagementRole';
  /** the name of the object */
  displayName?: Maybe<Scalars['String']['output']>;
  /** a value that uniquely identifies this object */
  id: Scalars['ID']['output'];
  /** the name of the object */
  name: Scalars['String']['output'];
  /** the scope of the role */
  scope: Scalars['String']['output'];
  /** the type of the role */
  type: Scalars['ID']['output'];
};

/** container for roles enabling cursor based pagination */
export type AuthorizationManagementRoleSearch = {
  __typename?: 'AuthorizationManagementRoleSearch';
  /** an opaque cursor to supply with subsequent   requests to get the next page of results, null if there are no more pages */
  nextCursor?: Maybe<Scalars['String']['output']>;
  /** control the access granted to groups */
  roles: Array<AuthorizationManagementRole>;
  /** the total number of results */
  totalCount: Scalars['Int']['output'];
};

/** The Object type. */
export type AuthorizationObject = {
  /** FGA identifier path. */
  path: Scalars['String']['input'];
  /** FGA type. */
  type: Scalars['String']['input'];
};

/** The Relation type */
export type AuthorizationRelation = {
  /** Name of FGA relation. */
  relation: Scalars['String']['input'];
  /** A string of the source. */
  source: AuthorizationObject;
  /** A string of the target. */
  target: AuthorizationObject;
};

/** The authorization scope type for listing capabilities. */
export enum AuthorizationScopeType {
  /** Capabilities for acting on the account. */
  Account = 'ACCOUNT',
  /** Capabilities for acting on the actor themselves. */
  Actor = 'ACTOR',
  /** Capabilities for acting globally. */
  Global = 'GLOBAL',
  /** Capabilities for acting on the group. */
  Group = 'GROUP',
  /** Capabilities for acting on the organization. */
  Organization = 'ORGANIZATION'
}

/** Apply filters to the list of authorized accounts. */
export type AuthorizedAccountsFilter = {
  /** Only return a specific subset of accounts, specified by account ID. */
  accountIds?: InputMaybe<Array<Scalars['Int']['input']>>;
};

/** Browser agent install types. */
export enum BrowserAgentInstallType {
  /** Lite agent install type. */
  Lite = 'LITE',
  /** Pro agent install type. */
  Pro = 'PRO',
  /** Pro + SPA agent install type. */
  ProSpa = 'PRO_SPA'
}

/** A Browser Application entity. */
export type BrowserApplicationEntity = AlertableEntity & Entity & {
  __typename?: 'BrowserApplicationEntity';
  account?: Maybe<AccountOutline>;
  /** The New Relic account ID associated with this entity. */
  accountId?: Maybe<Scalars['Int']['output']>;
  /** The type of Browser agent installed for this application. */
  agentInstallType?: Maybe<BrowserAgentInstallType>;
  /** The current alerting severity of the entity. */
  alertSeverity?: Maybe<EntityAlertSeverity>;
  /**
   * The alert status of the entity.
   * @deprecated Please use `alertSeverity` and `reporting`
   */
  alertStatus?: Maybe<EntityAlertStatus>;
  /** Violations on the entity that were open during the specified time window. This will return up to 500 violations - if there are more in the time window selected, you must narrow the time window or look at fewer entities. */
  alertViolations?: Maybe<Array<Maybe<EntityAlertViolation>>>;
  /** The ID of the Browser App. */
  applicationId?: Maybe<Scalars['Int']['output']>;
  /** Access general properties for the application. */
  browserProperties?: Maybe<AgentApplicationSettingsBrowserProperties>;
  /** Settings that are common across browser applications. */
  browserSettings?: Maybe<AgentApplicationSettingsBrowserBase>;
  /** Summary statistics about the Browser App. */
  browserSummary?: Maybe<BrowserApplicationSummaryData>;
  /**
   * Query upstream and downstream dependencies for an entity
   * @deprecated This field is experimental and subject to breaking changes.
   */
  connections?: Maybe<RelatedExternalsEntityResult>;
  /** Retrieve the deployment event(s). Ordered by timestamp DESC. */
  deploymentSearch?: Maybe<ChangeTrackingDeploymentSearchResult>;
  /** The entity's domain */
  domain?: Maybe<Scalars['String']['output']>;
  /** A value representing the combination of the entity's domain and type. */
  entityType?: Maybe<EntityType>;
  /** An Exception that occurred in your Browser Application. */
  exception?: Maybe<StackTraceBrowserException>;
  /** The date of last time the entity has updated any of its fields. */
  firstIndexedAt?: Maybe<Scalars['EpochMilliseconds']['output']>;
  /** The list of golden metrics for a specific entity */
  goldenMetrics?: Maybe<EntityGoldenContextScopedGoldenMetrics>;
  /**
   * For the golden signal on this entity, show correlated signals from related entities.
   * Well inspect the golden signals for all related entities and return a sorted list.
   * You can also filter the results.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  goldenSignalCorrelations?: Maybe<GoldenSignalCorrelationResult>;
  /**
   * The deviation from normal of golden signal(s) for the given entity.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  goldenSignalDeviations?: Maybe<Array<Maybe<GoldenSignalSignalDeviation>>>;
  /**
   * The stored golden signal(s) for the given entity.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  goldenSignalValues?: Maybe<GoldenSignalValues>;
  /**
   * The stored golden signal(s) for the given entity. To be removed, use goldenSignalValues instead.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  goldenSignalValuesV2?: Maybe<GoldenSignalValues>;
  /** The list of golden tags for a specific entityType. */
  goldenTags?: Maybe<EntityGoldenContextScopedGoldenTags>;
  /** A unique entity identifier. */
  guid?: Maybe<Scalars['EntityGuid']['output']>;
  /** The time the entity was indexed. */
  indexedAt?: Maybe<Scalars['EpochMilliseconds']['output']>;
  /** The last time the entity's reporting status changed. */
  lastReportingChangeAt?: Maybe<Scalars['EpochMilliseconds']['output']>;
  /** Retrieves the entity metric grouping issues. */
  metricGroupingIssues?: Maybe<Array<MetricNormalizationRuleMetricGroupingIssue>>;
  /** Retrieves a rule */
  metricNormalizationRule?: Maybe<MetricNormalizationRule>;
  /** Retrieves the rules for the application. */
  metricNormalizationRules?: Maybe<Array<MetricNormalizationRule>>;
  /** The name of this entity. */
  name?: Maybe<Scalars['String']['output']>;
  nerdStorage?: Maybe<NerdStorageEntityScope>;
  nerdStoreCollection?: Maybe<Array<Maybe<NerdStoreCollectionMember>>>;
  nerdStoreDocument?: Maybe<Scalars['NerdStoreDocument']['output']>;
  /**
   * Make an `Entity` scoped query to NRDB with a NRQL string.
   *
   * A relevant `WHERE` clause will be added to your query to scope data to the entity in question.
   *
   * See the [NRQL Docs](https://docs.newrelic.com/docs/insights/nrql-new-relic-query-language/nrql-resources/nrql-syntax-components-functions) for more information about generating a query string.
   */
  nrdbQuery?: Maybe<NrdbResultContainer>;
  /**
   * Poll for the results of a previously-executed asychronous NRDB query.
   *
   * The `queryId` is available in the `queryProgress` data returned by the original asynchronous query.
   *
   * See [this page](https://docs.newrelic.com/docs/apis/nerdgraph/examples/async-queries-nrql-tutorial) for additional asynchronous query documentation.
   * @deprecated This field is experimental! It may change at any time.
   *
   */
  nrdbQueryProgress?: Maybe<NrdbResultContainer>;
  /** The url to the entity. */
  permalink?: Maybe<Scalars['String']['output']>;
  /** Recent violations on the entity. */
  recentAlertViolations?: Maybe<Array<Maybe<EntityAlertViolation>>>;
  /** The recommended service levels for the entity. */
  recommendedServiceLevel?: Maybe<ServiceLevelRecommendation>;
  /** Related dashboards results */
  relatedDashboards: RelatedDashboardsRelatedDashboardResult;
  /** Related entities result with optional filtering. */
  relatedEntities?: Maybe<EntityRelationshipRelatedEntitiesResult>;
  /**
   * Query upstream and downstream transaction dependencies for an entity
   * @deprecated This field is experimental and subject to breaking changes.
   */
  relatedTransactions?: Maybe<RelatedExternalsTransactionResult>;
  /** Relationship traversal results with optional filtering. WARNING: this query is still experimental, and subject to breaking changes. */
  relationshipTraversal?: Maybe<EntityRelationshipTraversalResult>;
  /**
   * A list of the entities' relationships.
   *
   * For more information, visit [our docs](https://docs.newrelic.com/docs/apis/graphql-api/tutorials/graphql-relationships-api-tutorial).
   * @deprecated This field is deprecated! Please use `relatedEntities`.
   */
  relationships?: Maybe<Array<Maybe<EntityRelationship>>>;
  /** The reporting status of the entity. If New Relic is successfully collecting data from your application, this will be true. */
  reporting?: Maybe<Scalars['Boolean']['output']>;
  /** The running versions of the agent in the Browser App. */
  runningAgentVersions?: Maybe<BrowserApplicationRunningAgentVersions>;
  /** The allow list for browser applications that contains a set of allowed url segments that will appear in groupings on the Page views and AJAX pages. */
  segmentAllowListAggregate?: Maybe<AgentApplicationSegmentsBrowserSegmentAllowList>;
  /** The service level defined for the entity. */
  serviceLevel?: Maybe<ServiceLevelDefinition>;
  /** The ID of the APM Application that serves this Browser App. */
  servingApmApplicationId?: Maybe<Scalars['Int']['output']>;
  /** Configuration settings for the Browser App */
  settings?: Maybe<BrowserApplicationSettings>;
  /** The list of summary metrics. */
  summaryMetrics?: Maybe<Array<Maybe<EntitySummaryMetric>>>;
  /**
   * The tags applied to the entity.
   *
   * For details on tags, as well as query and mutation examples, visit [our docs](https://docs.newrelic.com/docs/apis/graphql-api/tutorials/graphql-tagging-api-tutorial).
   */
  tags?: Maybe<Array<Maybe<EntityTag>>>;
  /** The tags applied to the entity with their metadata. */
  tagsWithMetadata?: Maybe<Array<Maybe<EntityTagWithMetadata>>>;
  /** Look up Distributed Tracing summary data for the selected `EntityGuid` */
  tracingSummary?: Maybe<DistributedTracingEntityTracingSummary>;
  /** The entity's type */
  type?: Maybe<Scalars['String']['output']>;
  /** List of templates availables for this entity. */
  uiTemplates?: Maybe<Array<EntityDashboardTemplatesUi>>;
};


/** A Browser Application entity. */
export type BrowserApplicationEntityAlertViolationsArgs = {
  endTime: Scalars['EpochMilliseconds']['input'];
  startTime: Scalars['EpochMilliseconds']['input'];
};


/** A Browser Application entity. */
export type BrowserApplicationEntityConnectionsArgs = {
  timeWindow?: InputMaybe<TimeWindowInput>;
};


/** A Browser Application entity. */
export type BrowserApplicationEntityDeploymentSearchArgs = {
  filter?: InputMaybe<ChangeTrackingSearchFilter>;
};


/** A Browser Application entity. */
export type BrowserApplicationEntityExceptionArgs = {
  fingerprint: Scalars['Int']['input'];
  timeWindow?: InputMaybe<TimeWindowInput>;
};


/** A Browser Application entity. */
export type BrowserApplicationEntityGoldenMetricsArgs = {
  context?: InputMaybe<EntityGoldenContextInput>;
  timeWindow?: InputMaybe<EntityGoldenNrqlTimeWindowInput>;
};


/** A Browser Application entity. */
export type BrowserApplicationEntityGoldenSignalCorrelationsArgs = {
  filter?: InputMaybe<GoldenSignalCorrelationsEntityFilter>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  timeWindow?: InputMaybe<TimeWindowInput>;
};


/** A Browser Application entity. */
export type BrowserApplicationEntityGoldenSignalDeviationsArgs = {
  comparisonTimeWindow?: InputMaybe<TimeWindowInput>;
  evaluationTimeWindow?: InputMaybe<TimeWindowInput>;
};


/** A Browser Application entity. */
export type BrowserApplicationEntityGoldenSignalValuesArgs = {
  timeWindow?: InputMaybe<TimeWindowInput>;
};


/** A Browser Application entity. */
export type BrowserApplicationEntityGoldenSignalValuesV2Args = {
  timeWindow?: InputMaybe<TimeWindowInput>;
};


/** A Browser Application entity. */
export type BrowserApplicationEntityGoldenTagsArgs = {
  context?: InputMaybe<EntityGoldenContextInput>;
};


/** A Browser Application entity. */
export type BrowserApplicationEntityMetricGroupingIssuesArgs = {
  endTime?: InputMaybe<Scalars['EpochMilliseconds']['input']>;
  metricNormalizationRuleIds?: InputMaybe<Array<InputMaybe<Scalars['Int']['input']>>>;
  startTime?: InputMaybe<Scalars['EpochMilliseconds']['input']>;
};


/** A Browser Application entity. */
export type BrowserApplicationEntityMetricNormalizationRuleArgs = {
  id: Scalars['Int']['input'];
};


/** A Browser Application entity. */
export type BrowserApplicationEntityMetricNormalizationRulesArgs = {
  enabled?: InputMaybe<Scalars['Boolean']['input']>;
};


/** A Browser Application entity. */
export type BrowserApplicationEntityNerdStoreCollectionArgs = {
  collection: Scalars['String']['input'];
  scopeByActor?: InputMaybe<Scalars['Boolean']['input']>;
};


/** A Browser Application entity. */
export type BrowserApplicationEntityNerdStoreDocumentArgs = {
  collection: Scalars['String']['input'];
  documentId: Scalars['String']['input'];
  scopeByActor?: InputMaybe<Scalars['Boolean']['input']>;
};


/** A Browser Application entity. */
export type BrowserApplicationEntityNrdbQueryArgs = {
  async?: InputMaybe<Scalars['Boolean']['input']>;
  nrql: Scalars['Nrql']['input'];
  options?: InputMaybe<NrqlQueryOptions>;
  timeout?: InputMaybe<Scalars['Seconds']['input']>;
};


/** A Browser Application entity. */
export type BrowserApplicationEntityNrdbQueryProgressArgs = {
  queryId: Scalars['ID']['input'];
};


/** A Browser Application entity. */
export type BrowserApplicationEntityRecentAlertViolationsArgs = {
  count?: InputMaybe<Scalars['Int']['input']>;
};


/** A Browser Application entity. */
export type BrowserApplicationEntityRelatedEntitiesArgs = {
  cursor?: InputMaybe<Scalars['String']['input']>;
  filter?: InputMaybe<EntityRelationshipEdgeFilter>;
  limit?: InputMaybe<Scalars['Int']['input']>;
};


/** A Browser Application entity. */
export type BrowserApplicationEntityRelatedTransactionsArgs = {
  search: RelatedExternalsSearch;
  timeWindow?: InputMaybe<TimeWindowInput>;
};


/** A Browser Application entity. */
export type BrowserApplicationEntityRelationshipTraversalArgs = {
  cursor?: InputMaybe<Scalars['String']['input']>;
  hopFilters?: InputMaybe<EntityRelationshipTraversalHopFilters>;
  hops?: InputMaybe<Scalars['Int']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
};


/** A Browser Application entity. */
export type BrowserApplicationEntityRelationshipsArgs = {
  endTime?: InputMaybe<Scalars['EpochMilliseconds']['input']>;
  filter?: InputMaybe<EntityRelationshipFilter>;
};


/** A Browser Application entity. */
export type BrowserApplicationEntitySegmentAllowListAggregateArgs = {
  filters?: InputMaybe<AgentApplicationSegmentsSegmentAllowListFilters>;
};


/** A Browser Application entity. */
export type BrowserApplicationEntitySummaryMetricsArgs = {
  timeWindow?: InputMaybe<TimeWindowInput>;
};


/** A Browser Application entity. */
export type BrowserApplicationEntityTracingSummaryArgs = {
  timeWindow?: InputMaybe<TimeWindowInput>;
};

/** A Browser Application entity outline. */
export type BrowserApplicationEntityOutline = AlertableEntityOutline & EntityOutline & {
  __typename?: 'BrowserApplicationEntityOutline';
  account?: Maybe<AccountOutline>;
  /** The New Relic account ID associated with this entity. */
  accountId?: Maybe<Scalars['Int']['output']>;
  /** The type of Browser agent installed for this application. */
  agentInstallType?: Maybe<BrowserAgentInstallType>;
  /** The current alerting severity of the entity. */
  alertSeverity?: Maybe<EntityAlertSeverity>;
  /**
   * The alert status of the entity.
   * @deprecated Please use `alertSeverity` and `reporting`
   */
  alertStatus?: Maybe<EntityAlertStatus>;
  /** The ID of the Browser App. */
  applicationId?: Maybe<Scalars['Int']['output']>;
  /** Summary statistics about the Browser App. */
  browserSummary?: Maybe<BrowserApplicationSummaryData>;
  /** The entity's domain */
  domain?: Maybe<Scalars['String']['output']>;
  /** A value representing the combination of the entity's domain and type. */
  entityType?: Maybe<EntityType>;
  /** The date of last time the entity has updated any of its fields. */
  firstIndexedAt?: Maybe<Scalars['EpochMilliseconds']['output']>;
  /** The list of golden metrics for a specific entity */
  goldenMetrics?: Maybe<EntityGoldenContextScopedGoldenMetrics>;
  /**
   * For the golden signal on this entity, show correlated signals from related entities.
   * Well inspect the golden signals for all related entities and return a sorted list.
   * You can also filter the results.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  goldenSignalCorrelations?: Maybe<GoldenSignalCorrelationResult>;
  /**
   * The deviation from normal of golden signal(s) for the given entity.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  goldenSignalDeviations?: Maybe<Array<Maybe<GoldenSignalSignalDeviation>>>;
  /**
   * The stored golden signal(s) for the given entity.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  goldenSignalValues?: Maybe<GoldenSignalValues>;
  /**
   * The stored golden signal(s) for the given entity. To be removed, use goldenSignalValues instead.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  goldenSignalValuesV2?: Maybe<GoldenSignalValues>;
  /** The list of golden tags for a specific entityType. */
  goldenTags?: Maybe<EntityGoldenContextScopedGoldenTags>;
  /** A unique entity identifier. */
  guid?: Maybe<Scalars['EntityGuid']['output']>;
  /** The time the entity was indexed. */
  indexedAt?: Maybe<Scalars['EpochMilliseconds']['output']>;
  /** The last time the entity's reporting status changed. */
  lastReportingChangeAt?: Maybe<Scalars['EpochMilliseconds']['output']>;
  /** The name of this entity. */
  name?: Maybe<Scalars['String']['output']>;
  /** The url to the entity. */
  permalink?: Maybe<Scalars['String']['output']>;
  /** The recommended service levels for the entity. */
  recommendedServiceLevel?: Maybe<ServiceLevelRecommendation>;
  /** Related dashboards results */
  relatedDashboards: RelatedDashboardsRelatedDashboardResult;
  /** The reporting status of the entity. If New Relic is successfully collecting data from your application, this will be true. */
  reporting?: Maybe<Scalars['Boolean']['output']>;
  /** The running versions of the agent in the Browser App. */
  runningAgentVersions?: Maybe<BrowserApplicationRunningAgentVersions>;
  /** The service level defined for the entity. */
  serviceLevel?: Maybe<ServiceLevelDefinition>;
  /** The ID of the APM Application that serves this Browser App. */
  servingApmApplicationId?: Maybe<Scalars['Int']['output']>;
  /** Configuration settings for the Browser App */
  settings?: Maybe<BrowserApplicationSettings>;
  /** The list of summary metrics. */
  summaryMetrics?: Maybe<Array<Maybe<EntitySummaryMetric>>>;
  /**
   * The tags applied to the entity.
   *
   * For details on tags, as well as query and mutation examples, visit [our docs](https://docs.newrelic.com/docs/apis/graphql-api/tutorials/graphql-tagging-api-tutorial).
   */
  tags?: Maybe<Array<Maybe<EntityTag>>>;
  /** The entity's type */
  type?: Maybe<Scalars['String']['output']>;
  /** List of templates availables for this entity. */
  uiTemplates?: Maybe<Array<EntityDashboardTemplatesUi>>;
};


/** A Browser Application entity outline. */
export type BrowserApplicationEntityOutlineGoldenMetricsArgs = {
  context?: InputMaybe<EntityGoldenContextInput>;
  timeWindow?: InputMaybe<EntityGoldenNrqlTimeWindowInput>;
};


/** A Browser Application entity outline. */
export type BrowserApplicationEntityOutlineGoldenSignalCorrelationsArgs = {
  filter?: InputMaybe<GoldenSignalCorrelationsEntityFilter>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  timeWindow?: InputMaybe<TimeWindowInput>;
};


/** A Browser Application entity outline. */
export type BrowserApplicationEntityOutlineGoldenSignalDeviationsArgs = {
  comparisonTimeWindow?: InputMaybe<TimeWindowInput>;
  evaluationTimeWindow?: InputMaybe<TimeWindowInput>;
};


/** A Browser Application entity outline. */
export type BrowserApplicationEntityOutlineGoldenSignalValuesArgs = {
  timeWindow?: InputMaybe<TimeWindowInput>;
};


/** A Browser Application entity outline. */
export type BrowserApplicationEntityOutlineGoldenSignalValuesV2Args = {
  timeWindow?: InputMaybe<TimeWindowInput>;
};


/** A Browser Application entity outline. */
export type BrowserApplicationEntityOutlineGoldenTagsArgs = {
  context?: InputMaybe<EntityGoldenContextInput>;
};


/** A Browser Application entity outline. */
export type BrowserApplicationEntityOutlineSummaryMetricsArgs = {
  timeWindow?: InputMaybe<TimeWindowInput>;
};

/**
 * Represents the currently running agent versions in a Browser App.
 * An app could be running multiple versions of an agent (across different browsers, for example).
 */
export type BrowserApplicationRunningAgentVersions = {
  __typename?: 'BrowserApplicationRunningAgentVersions';
  /** The maximum (newest) agent version running in the Browser App, represented as a semantic version string. */
  maxSemanticVersion?: Maybe<Scalars['SemVer']['output']>;
  /** The maximum (newest) agent version running in the Browser App. */
  maxVersion?: Maybe<Scalars['Int']['output']>;
  /** The minimum (oldest) agent version running in the Browser App, represented as a semantic version string. */
  minSemanticVersion?: Maybe<Scalars['SemVer']['output']>;
  /** The minimum (oldest) agent version running in the Browser App. */
  minVersion?: Maybe<Scalars['Int']['output']>;
};

/** Configuration settings for the Browser App */
export type BrowserApplicationSettings = {
  __typename?: 'BrowserApplicationSettings';
  /** The current Apdex target setting */
  apdexTarget?: Maybe<Scalars['Float']['output']>;
};

/** Summary statistics about the Browser App. */
export type BrowserApplicationSummaryData = {
  __typename?: 'BrowserApplicationSummaryData';
  /** The number of AJAX requests per minute */
  ajaxRequestThroughput?: Maybe<Scalars['Float']['output']>;
  /** The average AJAX response time in seconds. */
  ajaxResponseTimeAverage?: Maybe<Scalars['Seconds']['output']>;
  /** The percentage of page views with a JS error. */
  jsErrorRate?: Maybe<Scalars['Float']['output']>;
  /** The number of page loads per minute */
  pageLoadThroughput?: Maybe<Scalars['Float']['output']>;
  /** The average page view time in seconds. */
  pageLoadTimeAverage?: Maybe<Scalars['Float']['output']>;
  /** The median page view time in seconds. */
  pageLoadTimeMedian?: Maybe<Scalars['Float']['output']>;
  /** The average SPA response time in seconds. */
  spaResponseTimeAverage?: Maybe<Scalars['Seconds']['output']>;
  /** The median SPA response time in seconds. */
  spaResponseTimeMedian?: Maybe<Scalars['Seconds']['output']>;
};

export type Capability = {
  __typename?: 'Capability';
  name?: Maybe<Scalars['String']['output']>;
};

export type CartographerAccountStitchedFields = {
  __typename?: 'CartographerAccountStitchedFields';
  /**
   * Returns a list of edges.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  edges: CartographerEdgeListing;
  /**
   * Returns a graph.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  graph: CartographerGraph;
  /**
   * Returns a paginated list of vertices.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  vertices: CartographerVertexListing;
};


export type CartographerAccountStitchedFieldsEdgesArgs = {
  cursor?: InputMaybe<Scalars['String']['input']>;
  edgeIds?: InputMaybe<Array<Scalars['ID']['input']>>;
  graphId?: InputMaybe<Scalars['ID']['input']>;
};


export type CartographerAccountStitchedFieldsGraphArgs = {
  graphId?: InputMaybe<Scalars['ID']['input']>;
};


export type CartographerAccountStitchedFieldsVerticesArgs = {
  cursor?: InputMaybe<Scalars['String']['input']>;
  graphId?: InputMaybe<Scalars['ID']['input']>;
  vertexClasses?: InputMaybe<Array<CartographerVertexClass>>;
  vertexIds?: InputMaybe<Array<Scalars['ID']['input']>>;
};

/** A key-value entry. */
export type CartographerCollectorAttributeInput = {
  /** Key of entry. */
  key: Scalars['String']['input'];
  /** Value of entry. */
  value: Scalars['String']['input'];
};

/** Blueprint for edge creation. */
export type CartographerCollectorEdgeBlueprint = {
  /** Whether or not from & to has any semantic meaning. */
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  /** The source vertex name. */
  fromVertexName: Scalars['String']['input'];
  /** The id of the graph to store */
  graphId: Scalars['String']['input'];
  /** The destination vertex name. */
  toVertexName: Scalars['String']['input'];
};

/** Result of an operation. */
export type CartographerCollectorOperationResult = {
  __typename?: 'CartographerCollectorOperationResult';
  /**
   * Status of the operation.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  result: CartographerCollectorResultType;
};

/** Status of an operation. */
export enum CartographerCollectorResultType {
  /**
   * Failed operation
   * @deprecated This field is experimental and subject to breaking changes.
   */
  Failure = 'FAILURE',
  /**
   * Successful operation
   * @deprecated This field is experimental and subject to breaking changes.
   */
  Success = 'SUCCESS'
}

/** Blueprint for vertex creation. */
export type CartographerCollectorVertexBlueprint = {
  /** Attributes to define the vertex. */
  definingAttributes: Array<CartographerCollectorAttributeInput>;
  /** The name of the vertex. */
  name: Scalars['String']['input'];
  /** The class of the vertex. */
  vertexClass: CartographerCollectorVertexClass;
};

/** Class of vertex. */
export enum CartographerCollectorVertexClass {
  /**
   * Vertex class is application
   * @deprecated This field is experimental and subject to breaking changes.
   */
  Application = 'APPLICATION',
  /**
   * Vertex class is cloudservice
   * @deprecated This field is experimental and subject to breaking changes.
   */
  Cloudservice = 'CLOUDSERVICE',
  /**
   * Vertex class is cluster
   * @deprecated This field is experimental and subject to breaking changes.
   */
  Cluster = 'CLUSTER',
  /**
   * Vertex class is datastore
   * @deprecated This field is experimental and subject to breaking changes.
   */
  Datastore = 'DATASTORE',
  /**
   * Vertex class is host
   * @deprecated This field is experimental and subject to breaking changes.
   */
  Host = 'HOST',
  /**
   * Vertex class is team
   * @deprecated This field is experimental and subject to breaking changes.
   */
  Team = 'TEAM'
}

/** A key-value entry representing an attribute name and value. */
export type CartographerDefiningAttribute = {
  __typename?: 'CartographerDefiningAttribute';
  /**
   * Key of entry.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  key: Scalars['String']['output'];
  /**
   * Value of entry.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  value: Scalars['String']['output'];
};

/** A connection between two vertices within a graph */
export type CartographerEdge = {
  __typename?: 'CartographerEdge';
  /**
   * Whether or not the direction of the edge has semantic meaning.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  directed: Scalars['Boolean']['output'];
  /**
   * ID of parent vertex.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  fromVertexId: Scalars['ID']['output'];
  /**
   * List of all edges in this graph.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  graphId: Scalars['String']['output'];
  /**
   * ID of edge.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  id: Scalars['ID']['output'];
  /**
   * ID of child vertex.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  toVertexId: Scalars['ID']['output'];
  /**
   * Time rule was last updated.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  updatedAt: Scalars['EpochMilliseconds']['output'];
};

/** Listing of edges in a graph. */
export type CartographerEdgeListing = {
  __typename?: 'CartographerEdgeListing';
  /**
   * Number of edges returned by the query.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  count: Scalars['Int']['output'];
  /**
   * Next cursor.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  cursor?: Maybe<Scalars['String']['output']>;
  /**
   * List of edges.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  edges: Array<CartographerEdge>;
};

/** Overview of a graph; all edges and vertices. */
export type CartographerGraph = {
  __typename?: 'CartographerGraph';
  /**
   * List of all edges in this graph.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  edges: Array<CartographerEdge>;
  /**
   * ID of the graph.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  id: Scalars['ID']['output'];
  /**
   * List of all vertices in this graph.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  vertices: Array<CartographerVertex>;
};

/** A vertex is a representation of a node in a graph: a host; an application; etc. */
export type CartographerVertex = {
  __typename?: 'CartographerVertex';
  /**
   * The attributes used to define a vertex as a key-value entry.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  definingAttributes: Array<CartographerDefiningAttribute>;
  /**
   * ID of vertex.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  id: Scalars['ID']['output'];
  /**
   * Name of the vertex.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  name: Scalars['String']['output'];
  /**
   * Time rule was last updated.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  updatedAt: Scalars['EpochMilliseconds']['output'];
  /**
   * Class of the vertex.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  vertexClass: CartographerVertexClass;
};

/** Class of vertex. */
export enum CartographerVertexClass {
  /**
   * Vertex class is application
   * @deprecated This field is experimental and subject to breaking changes.
   */
  Application = 'APPLICATION',
  /**
   * Vertex class is cloudservice
   * @deprecated This field is experimental and subject to breaking changes.
   */
  Cloudservice = 'CLOUDSERVICE',
  /**
   * Vertex class is cluster
   * @deprecated This field is experimental and subject to breaking changes.
   */
  Cluster = 'CLUSTER',
  /**
   * Vertex class is datastore
   * @deprecated This field is experimental and subject to breaking changes.
   */
  Datastore = 'DATASTORE',
  /**
   * Vertex class is host
   * @deprecated This field is experimental and subject to breaking changes.
   */
  Host = 'HOST',
  /**
   * Vertex class is team
   * @deprecated This field is experimental and subject to breaking changes.
   */
  Team = 'TEAM'
}

/** Listing of vertices in a graph. */
export type CartographerVertexListing = {
  __typename?: 'CartographerVertexListing';
  /**
   * Number of vertices returned by this query.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  count: Scalars['Int']['output'];
  /**
   * Next cursor.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  cursor?: Maybe<Scalars['String']['output']>;
  /**
   * List of vertices.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  vertices: Array<CartographerVertex>;
};

/** A summary of the results for this account. */
export type ChangeTrackingAccountSummary = {
  __typename?: 'ChangeTrackingAccountSummary';
  /** The account that results were found in. */
  account?: Maybe<AccountReference>;
  /** The total number of results returned from NRDB for this account. This number is limited by NRDB's LIMIT MAX and is not the result of a count(*) query. */
  count: Scalars['Int']['output'];
  /** The number of records included in the ChangeTrackingSearchResult results. */
  countIncludedInResults: Scalars['Int']['output'];
};

export type ChangeTrackingActorStitchedFields = {
  __typename?: 'ChangeTrackingActorStitchedFields';
  /** Search for change tracking event(s) across all authorized accounts. Ordered by timestamp DESC. */
  changeTrackingSearch?: Maybe<ChangeTrackingChangeTrackingSearchResult>;
};


export type ChangeTrackingActorStitchedFieldsChangeTrackingSearchArgs = {
  filter?: InputMaybe<ChangeTrackingChangeTrackingSearchFilter>;
};

/** A combination of category and type. A category will often have multiple types. */
export enum ChangeTrackingCategoryType {
  /** Convention */
  BusinessEventConvention = 'BUSINESS_EVENT__CONVENTION',
  /** Marketing campaign */
  BusinessEventMarketingCampaign = 'BUSINESS_EVENT__MARKETING_CAMPAIGN',
  /** Other types of business events */
  BusinessEventOther = 'BUSINESS_EVENT__OTHER',
  /**
   * This is a special type that allows you to set your own custom type as an override. To use this CategoryType you must
   * also pass in a value for the `customType` field as part of your `input`.
   */
  CustomerDefinedCustom = 'CUSTOMER_DEFINED__CUSTOM',
  /** Artifact copy */
  DeploymentLifecycleArtifactCopy = 'DEPLOYMENT_LIFECYCLE__ARTIFACT_COPY',
  /** Artifact deletion */
  DeploymentLifecycleArtifactDeletion = 'DEPLOYMENT_LIFECYCLE__ARTIFACT_DELETION',
  /** Artifact deployment */
  DeploymentLifecycleArtifactDeployment = 'DEPLOYMENT_LIFECYCLE__ARTIFACT_DEPLOYMENT',
  /** Artifact move */
  DeploymentLifecycleArtifactMove = 'DEPLOYMENT_LIFECYCLE__ARTIFACT_MOVE',
  /** Build deletion */
  DeploymentLifecycleBuildDeletion = 'DEPLOYMENT_LIFECYCLE__BUILD_DELETION',
  /** Build promotion */
  DeploymentLifecycleBuildPromotion = 'DEPLOYMENT_LIFECYCLE__BUILD_PROMOTION',
  /** Build upload */
  DeploymentLifecycleBuildUpload = 'DEPLOYMENT_LIFECYCLE__BUILD_UPLOAD',
  /** Image deletion */
  DeploymentLifecycleImageDeletion = 'DEPLOYMENT_LIFECYCLE__IMAGE_DELETION',
  /** Image promotion */
  DeploymentLifecycleImagePromotion = 'DEPLOYMENT_LIFECYCLE__IMAGE_PROMOTION',
  /** Image push */
  DeploymentLifecycleImagePush = 'DEPLOYMENT_LIFECYCLE__IMAGE_PUSH',
  /** Release bundle creation */
  DeploymentLifecycleReleaseBundleCreation = 'DEPLOYMENT_LIFECYCLE__RELEASE_BUNDLE_CREATION',
  /** Release bundle deletion */
  DeploymentLifecycleReleaseBundleDeletion = 'DEPLOYMENT_LIFECYCLE__RELEASE_BUNDLE_DELETION',
  /** Release bundle sign */
  DeploymentLifecycleReleaseBundleSign = 'DEPLOYMENT_LIFECYCLE__RELEASE_BUNDLE_SIGN',
  /** A vanilla deployment */
  DeploymentBasic = 'DEPLOYMENT__BASIC',
  /** Blue-green deployment */
  DeploymentBlueGreen = 'DEPLOYMENT__BLUE_GREEN',
  /** Canary deployment */
  DeploymentCanary = 'DEPLOYMENT__CANARY',
  /** Other types of deployment. */
  DeploymentOther = 'DEPLOYMENT__OTHER',
  /** Rolling deployment. */
  DeploymentRolling = 'DEPLOYMENT__ROLLING',
  /** Shadow deployment */
  DeploymentShadow = 'DEPLOYMENT__SHADOW',
  /** Crash */
  OperationalCrash = 'OPERATIONAL__CRASH',
  /** Other types of operational events */
  OperationalOther = 'OPERATIONAL__OTHER',
  /** Scheduled maintenance period */
  OperationalScheduledMaintenancePeriod = 'OPERATIONAL__SCHEDULED_MAINTENANCE_PERIOD',
  /** Server reboot */
  OperationalServerReboot = 'OPERATIONAL__SERVER_REBOOT'
}

/** A summary of the results for this CategoryType. */
export type ChangeTrackingCategoryTypeSummary = {
  __typename?: 'ChangeTrackingCategoryTypeSummary';
  /** The CategoryType that results were associated with. */
  categoryType: ChangeTrackingCategoryType;
  /** The total number of results returned from NRDB for this CategoryType. This number is limited by NRDB's LIMIT MAX and is not the result of a count(*) query. */
  count: Scalars['Int']['output'];
  /** The number of records included in the ChangeTrackingSearchResult results. */
  countIncludedInResults: Scalars['Int']['output'];
};

/** A change tracking event. */
export type ChangeTrackingChangeTrackingEvent = {
  __typename?: 'ChangeTrackingChangeTrackingEvent';
  /** The category of change event */
  category: Scalars['String']['output'];
  /** The category and type of the change. */
  categoryType: ChangeTrackingCategoryType;
  /** A unique change tracking identifier. */
  changeTrackingId: Scalars['String']['output'];
  /** Represents key-value pairs of custom attributes in JSON format. */
  customAttributes?: Maybe<Scalars['ChangeTrackingRawCustomAttributesMap']['output']>;
  /** A description of the event. */
  description?: Maybe<Scalars['String']['output']>;
  /** The NR entity associated with the event. */
  entity?: Maybe<EntityOutline>;
  /** An identifier used to correlate two or more events. */
  groupId?: Maybe<Scalars['String']['output']>;
  /** The start time of the change tracking event as the number of milliseconds since the Unix epoch.  Defaults to now. */
  timestamp: Scalars['EpochMilliseconds']['output'];
  /** The type of the change event */
  type: Scalars['String']['output'];
  /** The username of the person responsible for the change. */
  user?: Maybe<Scalars['String']['output']>;
};

/** The data necessary to create a change tracking event. */
export type ChangeTrackingChangeTrackingInput = {
  /** The category and type of the change. */
  categoryType: ChangeTrackingCategoryType;
  /**
   * Represents key-value pairs of custom attributes in JSON format. Attribute values can be of type string, boolean, int, or float.
   *
   * For more information on limitations, see [our docs](https://docs.newrelic.com/docs/change-tracking/change-tracking-graphql/)
   *
   * **Examples:**
   *
   *  {cloud_vendor : "vendor_name", region : "us-east-1", environment : "staging"}
   *  {isProd : true, region : "us-east-1", instances: 2, deploy_time : 10.5}
   */
  customAttributes?: InputMaybe<Scalars['ChangeTrackingRawCustomAttributesMap']['input']>;
  /** The custom type that you define. This may only be passed with a `categoryType` of `CUSTOMER_DEFINED__CUSTOM`. */
  customType?: InputMaybe<Scalars['String']['input']>;
  /** A description of the event. */
  description?: InputMaybe<Scalars['String']['input']>;
  /** An identifier used to correlate two or more events. */
  groupId?: InputMaybe<Scalars['String']['input']>;
  /** The start time of the change tracking event as the number of milliseconds since the Unix epoch.  Defaults to now. */
  timestamp?: InputMaybe<Scalars['EpochMilliseconds']['input']>;
  /** The username of the person responsible for the change. */
  user?: InputMaybe<Scalars['String']['input']>;
};

/** The response for creating a ChangeTrackingEvent. */
export type ChangeTrackingChangeTrackingResponse = {
  __typename?: 'ChangeTrackingChangeTrackingResponse';
  /** The change tracking event that was created. */
  changeTrackingEvent?: Maybe<ChangeTrackingChangeTrackingEvent>;
  /**
   * Any related messages associated with creation of the change tracking event. Track these to see if there are details
   * to consider for future calls.
   */
  messages?: Maybe<Array<Scalars['String']['output']>>;
};

/** The object contains the filters to be applied to the search. */
export type ChangeTrackingChangeTrackingSearchFilter = {
  /** A list of account ids to search. If none provided, all authorized accounts will be searched. */
  accountIds?: InputMaybe<Array<Scalars['Int']['input']>>;
  /**
   * Maximum number of deployments to be returned. Default value is 100 deployments.
   * There is a maximum limit value of 2,000. If you set the limit greater than 2,000, the service will only return the latest 2,000 deployments."
   */
  limit?: InputMaybe<Scalars['Int']['input']>;
  /**
   * Change tracking search query string. The query string can search for a match on users and change tracking IDs, and any other change tracking event attributes.
   *
   * Operators available: Any valid NRQL operators, other than subqueries. For example, =, OR, AND, IN, LIKE, RLIKE, NO.
   *
   * For the full list of operators, see the where clause documentation [here](https://docs.newrelic.com/docs/query-your-data/nrql-new-relic-query-language/get-started/nrql-syntax-clauses-functions/#sel-where)
   *
   * Note: Do not include keywords like SELECT, WHERE, SINCE, FACET, and TIMESERIES.
   *
   * Examples:
   *
   *  "user = 'Test User'"
   *  "user RLIKE r'Test.*|test.*'"
   *  "version = '1.0' OR categoryType IN ('DEPLOYMENT__BLUE_GREEN, DEPLOYMENT__ROLLING')"
   *  "changeTrackingId IN ('1234', '4567')"
   */
  query?: InputMaybe<Scalars['String']['input']>;
  /** Search time window. If not specified, defaults to the past hour. */
  timeWindow?: InputMaybe<ChangeTrackingTimeWindowInputWithDefaults>;
};

/** The result of the change tracking search query. */
export type ChangeTrackingChangeTrackingSearchResult = {
  __typename?: 'ChangeTrackingChangeTrackingSearchResult';
  /** The list of change tracking events in the given time window. */
  results: Array<Maybe<ChangeTrackingChangeTrackingEvent>>;
  /** The summary of the results we found for this query. */
  summary?: Maybe<ChangeTrackingResultSummary>;
};

/** Validation and data handling rules to be applied to deployment input data. */
export type ChangeTrackingDataHandlingRules = {
  /** Flags for validation, for example, FAIL_ON_FIELD_LENGTH. */
  validationFlags?: InputMaybe<Array<ChangeTrackingValidationFlag>>;
};

/** A deployment. */
export type ChangeTrackingDeployment = {
  __typename?: 'ChangeTrackingDeployment';
  /** A URL to the changelog or, if not linkable, a list of changes. */
  changelog?: Maybe<Scalars['String']['output']>;
  /** The commit identifier, for example, a Git commit SHA. */
  commit?: Maybe<Scalars['String']['output']>;
  /** Represents key-value pairs of custom attributes in JSON format. */
  customAttributes?: Maybe<Scalars['ChangeTrackingRawCustomAttributesMap']['output']>;
  /** A link to the system that generated the deployment. */
  deepLink?: Maybe<Scalars['String']['output']>;
  /** A unique deployment identifier. */
  deploymentId?: Maybe<Scalars['String']['output']>;
  /** The type of deployment, for example, Blue green or Rolling. */
  deploymentType?: Maybe<ChangeTrackingDeploymentType>;
  /** A description of the deployment. */
  description?: Maybe<Scalars['String']['output']>;
  /** The NR entity that was deployed. */
  entityGuid: Scalars['EntityGuid']['output'];
  /** An identifier used to correlate two or more events. */
  groupId?: Maybe<Scalars['String']['output']>;
  /** The start time of the deployment as the number of milliseconds since the Unix epoch. */
  timestamp: Scalars['EpochMilliseconds']['output'];
  /** The username of the deployer or bot. */
  user?: Maybe<Scalars['String']['output']>;
  /** The version of the deployed software, for example, something like v1.1. */
  version: Scalars['String']['output'];
};

/** A deployment. */
export type ChangeTrackingDeploymentInput = {
  /** A URL for the changelog or, if not linkable, a list of changes. */
  changelog?: InputMaybe<Scalars['String']['input']>;
  /** The commit identifier, for example, a Git commit SHA. */
  commit?: InputMaybe<Scalars['String']['input']>;
  /**
   * Represents key-value pairs of custom attributes in JSON format. Attribute values can be of type string, boolean, or numeric.
   *
   * **Restricted attributes names:**  accountId, appID, changelog, commit, customAttributes, deepLink, deploymentType, description, entity.guid, entity.name, entity.type, entityGuid, entityName, eventType, groupId, timestamp, user, version
   *
   * **Restricted attribute name prefixes:**  'nr.', 'newrelic.'
   *
   * For more information on limitations, see [our docs](https://docs.newrelic.com/docs/change-tracking/change-tracking-graphql/)
   *
   * **Examples:**
   *
   *      {cloudVendor : "vendorName", region : "us-east-1", environment : "staging"}
   *      {isProd : true, region : "us-east-1", instances: 2, deployTime : 10.5}
   */
  customAttributes?: InputMaybe<Scalars['ChangeTrackingRawCustomAttributesMap']['input']>;
  /** A URL to the system that generated the deployment. */
  deepLink?: InputMaybe<Scalars['String']['input']>;
  /** The type of deployment, for example, Blue green or Rolling. */
  deploymentType?: InputMaybe<ChangeTrackingDeploymentType>;
  /** A description of the deployment. */
  description?: InputMaybe<Scalars['String']['input']>;
  /** The NR entity that was deployed. */
  entityGuid: Scalars['EntityGuid']['input'];
  /** An identifier used to correlate two or more events. */
  groupId?: InputMaybe<Scalars['String']['input']>;
  /** The start time of the deployment as the number of milliseconds since the Unix epoch. Should be within the boundary of the past or future 24 hours. Defaults to now. */
  timestamp?: InputMaybe<Scalars['EpochMilliseconds']['input']>;
  /** The username of the deployer or bot. */
  user?: InputMaybe<Scalars['String']['input']>;
  /** The version of the deployed software, for example, something like v1.1 */
  version: Scalars['String']['input'];
};

/** The result of the deployment search query. */
export type ChangeTrackingDeploymentSearchResult = {
  __typename?: 'ChangeTrackingDeploymentSearchResult';
  /** The list of deployment events in the given time window. */
  results?: Maybe<Array<Maybe<ChangeTrackingDeployment>>>;
};

/** Type of deployment. */
export enum ChangeTrackingDeploymentType {
  /** A vanilla deployment */
  Basic = 'BASIC',
  /** Blue-green deployment */
  BlueGreen = 'BLUE_GREEN',
  /** Canary deployment */
  Canary = 'CANARY',
  /** Other types of deployment. */
  Other = 'OTHER',
  /** Rolling deployment. */
  Rolling = 'ROLLING',
  /** Shadow deployment */
  Shadow = 'SHADOW'
}

/** A summary of the results for this entity. */
export type ChangeTrackingEntitySummary = {
  __typename?: 'ChangeTrackingEntitySummary';
  /** The total number of results returned from NRDB for this entity. This number is limited by NRDB's LIMIT MAX and is not the result of a count(*) query. */
  count: Scalars['Int']['output'];
  /** The number of records included in the ChangeTrackingSearchResult results. */
  countIncludedInResults: Scalars['Int']['output'];
  /** The entity that results were associated with. */
  entity?: Maybe<EntityOutline>;
};

/** A summary of the results that we found. This information may be useful to our UIs to help a customer filter their results further. */
export type ChangeTrackingResultSummary = {
  __typename?: 'ChangeTrackingResultSummary';
  /** The list of AccountSummary results for this query. */
  accountSummary: Array<ChangeTrackingAccountSummary>;
  /** The list of CategoryTypeSummary results for this query. */
  categoryTypeSummary: Array<ChangeTrackingCategoryTypeSummary>;
  /** The list of EntitySummary results for this query. */
  entitySummary: Array<ChangeTrackingEntitySummary>;
};

/** The object contains the filters to be applied to the search. */
export type ChangeTrackingSearchFilter = {
  /**
   * Maximum number of deployments to be returned. Default value is 100 deployments.
   * There is a maximum limit value of 2,000. If you set the limit greater than 2,000, the service will only return the latest 2,000 deployments."
   */
  limit?: InputMaybe<Scalars['Int']['input']>;
  /**
   * Deployment search query string. The query string can search for a match on users and deployment IDs, and any other deployment event attributes.
   *
   * Operators available: Any valid NRQL operators, other than subqueries. For example, =, OR, AND, IN, LIKE, RLIKE, NO.
   *
   * For the full list of operators, see the where clause documentation [here](https://docs.newrelic.com/docs/query-your-data/nrql-new-relic-query-language/get-started/nrql-syntax-clauses-functions/#sel-where)
   *
   * Note: Do not include keywords like SELECT, WHERE, SINCE, FACET, and TIMESERIES.
   *
   * Examples:
   *
   *      "user = 'Test User'"
   *      "user LIKE '%Test User%' AND deploymentType IN ('BLUE_GREEN', 'CANARY')"
   *      "user RLIKE r'Test.*|test.*'"
   *      "version = '1.0' OR deploymentType IN ('BASIC')"
   *      "deploymentId IN ('1234', '4567')"
   *      "((user = 'Test User' AND version = '1.0') OR deploymentType in ('BLUE_GREEN', 'CANARY'))"
   */
  query?: InputMaybe<Scalars['String']['input']>;
  /** IDs of the RPM legacy deployments. */
  rpmIds?: InputMaybe<Array<Scalars['Int']['input']>>;
  /** Search time window. If not specified, defaults to the past hour. */
  timeWindow?: InputMaybe<ChangeTrackingTimeWindowInputWithDefaults>;
};

/** A time window input with default values. */
export type ChangeTrackingTimeWindowInputWithDefaults = {
  /** The end time of the time window. If not specified, it defaults to the current time. */
  endTime?: InputMaybe<Scalars['EpochMilliseconds']['input']>;
  /** The start time of the time window. If not specified, it defaults to 60 minutes before the endTime. */
  startTime?: InputMaybe<Scalars['EpochMilliseconds']['input']>;
};

/** Validation flags to determine how we handle input data. */
export enum ChangeTrackingValidationFlag {
  /** Will validate all string fields to be within max size limit. An error is returned and data is not saved if any of the fields exceeds max size limit. */
  FailOnFieldLength = 'FAIL_ON_FIELD_LENGTH',
  /** For APM entities, a call is made to the legacy New Relic v2 REST API. When this flag is set, if the call fails for any reason, an error will be returned containing the failure message. */
  FailOnRestApiFailures = 'FAIL_ON_REST_API_FAILURES'
}

export type ChaosConfiguration = {
  /** The fields in NerdGraph to error in subsequent queries. */
  fieldErrors?: InputMaybe<Array<InputMaybe<ChaosFieldError>>>;
  /** The duration in milliseconds of latency the query will experience before returning results. Can be used alone or in tandem with error configuration. */
  latency?: InputMaybe<Scalars['Milliseconds']['input']>;
  /** Optional: when provided, the chaos test will only affect requests coming from this client or service. The `nerd_graph_key` is derived from the incoming `newrelic-requesting-services` header. For example, `service-gateway` or `nr1-ui.apm.overview`. This option should be used when possible to prevent the chaos from impacting other services involved in fulfilling requests by the test user. */
  nerdGraphKey?: InputMaybe<Scalars['String']['input']>;
};

export type ChaosFieldError = {
  /** The name of the field in NerdGraph. */
  name: Scalars['String']['input'];
  /** The probability that this field in a query will error. Can be set from 0 to 1. */
  probability?: InputMaybe<Scalars['Float']['input']>;
};

/** Represents all the format types available for static charts. */
export enum ChartFormatType {
  Pdf = 'PDF',
  Png = 'PNG'
}

/** Represents all the visualization types available for static charts. */
export enum ChartImageType {
  Apdex = 'APDEX',
  Area = 'AREA',
  Bar = 'BAR',
  Baseline = 'BASELINE',
  Billboard = 'BILLBOARD',
  Bullet = 'BULLET',
  EventFeed = 'EVENT_FEED',
  Funnel = 'FUNNEL',
  Heatmap = 'HEATMAP',
  Histogram = 'HISTOGRAM',
  Line = 'LINE',
  Pie = 'PIE',
  Scatter = 'SCATTER',
  StackedHorizontalBar = 'STACKED_HORIZONTAL_BAR',
  Table = 'TABLE',
  VerticalBar = 'VERTICAL_BAR'
}

export type ClassicNavigationFeature = {
  __typename?: 'ClassicNavigationFeature';
  group?: Maybe<Scalars['String']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  pathPattern?: Maybe<Scalars['String']['output']>;
  section?: Maybe<Scalars['Boolean']['output']>;
};

export type ClassicNavigationProduct = {
  __typename?: 'ClassicNavigationProduct';
  alignment?: Maybe<Scalars['String']['output']>;
  category?: Maybe<Scalars['String']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  urlPattern?: Maybe<Scalars['String']['output']>;
};

/**
 * Cloud integrations related data, including configured integrations and
 * all available cloud provider service integrations.
 */
export type CloudAccountFields = {
  __typename?: 'CloudAccountFields';
  /** Get one linked provider account. */
  linkedAccount?: Maybe<CloudLinkedAccount>;
  /** Get all linked cloud provider accounts. */
  linkedAccounts?: Maybe<Array<Maybe<CloudLinkedAccount>>>;
  /** Get one cloud provider by short name. */
  provider?: Maybe<CloudProvider>;
  /** Get all available cloud providers. */
  providers?: Maybe<Array<Maybe<CloudProvider>>>;
};


/**
 * Cloud integrations related data, including configured integrations and
 * all available cloud provider service integrations.
 */
export type CloudAccountFieldsLinkedAccountArgs = {
  id?: InputMaybe<Scalars['Int']['input']>;
};


/**
 * Cloud integrations related data, including configured integrations and
 * all available cloud provider service integrations.
 */
export type CloudAccountFieldsProviderArgs = {
  slug?: InputMaybe<Scalars['String']['input']>;
};

/** Account Mutation Error */
export type CloudAccountMutationError = {
  __typename?: 'CloudAccountMutationError';
  /** The passed linked account identifier. */
  linkedAccountId?: Maybe<Scalars['Int']['output']>;
  /** The error message. */
  message: Scalars['String']['output'];
  /** The passed newrelic account identifier. */
  nrAccountId: Scalars['Int']['output'];
  /** The passed provider slug. */
  providerSlug?: Maybe<Scalars['String']['output']>;
  /** The error status. */
  type: Scalars['String']['output'];
};

export type CloudActorFields = {
  __typename?: 'CloudActorFields';
  /** Get all linked cloud provider accounts scoped to the Actor. */
  linkedAccounts?: Maybe<Array<Maybe<CloudLinkedAccount>>>;
};


export type CloudActorFieldsLinkedAccountsArgs = {
  provider?: InputMaybe<Scalars['String']['input']>;
};

/** ALB/NLB Integration */
export type CloudAlbIntegration = CloudIntegration & {
  __typename?: 'CloudAlbIntegration';
  /** Specify each AWS region that includes the resources that you want to monitor. */
  awsRegions?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
  /** The object creation date, in epoch (Unix) time */
  createdAt: Scalars['EpochSeconds']['output'];
  /** Determine if extra inventory data be collected or not. May affect total data collection time and contribute to the Cloud provider API rate limit. */
  fetchExtendedInventory?: Maybe<Scalars['Boolean']['output']>;
  /** Specify if tags should be collected. May affect total data collection time and contribute to the Cloud provider API rate limit. */
  fetchTags?: Maybe<Scalars['Boolean']['output']>;
  /** The cloud service integration identifier. */
  id?: Maybe<Scalars['Int']['output']>;
  /**
   * [DEPRECATED] Multiple polling interval is no longer supported, use only metrics_polling_interval
   * @deprecated [DEPRECATED] Multiple polling interval is no longer supported, use only metrics_polling_interval
   */
  inventoryPollingInterval?: Maybe<Scalars['Int']['output']>;
  /** The parent linked account identifier. */
  linkedAccount?: Maybe<CloudLinkedAccount>;
  /** Specify each name or prefix for the LBs that you want to monitor. Filter values are case-sensitive. */
  loadBalancerPrefixes?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
  /** The data polling interval in seconds. */
  metricsPollingInterval?: Maybe<Scalars['Int']['output']>;
  /** The cloud service integration name. */
  name?: Maybe<Scalars['String']['output']>;
  /** The parent NewRelic account identifier. */
  nrAccountId: Scalars['Int']['output'];
  /** The cloud service used in the integration. */
  service?: Maybe<CloudService>;
  /** Specify a Tag key associated with the resources that you want to monitor. Filter values are case-sensitive. */
  tagKey?: Maybe<Scalars['String']['output']>;
  /** Specify a Tag value associated with the resources that you want to monitor. Filter values are case-sensitive. */
  tagValue?: Maybe<Scalars['String']['output']>;
  /** The object last update date, in epoch (Unix) time */
  updatedAt: Scalars['EpochSeconds']['output'];
};

/** Elastic Load Balancing - Application Load Balancer (ALB) */
export type CloudAlbIntegrationInput = {
  /** Specify each AWS region that includes the resources that you want to monitor. */
  awsRegions?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  /** Determine if extra inventory data be collected or not. May affect total data collection time and contribute to the Cloud provider API rate limit. */
  fetchExtendedInventory?: InputMaybe<Scalars['Boolean']['input']>;
  /** Specify if tags should be collected. May affect total data collection time and contribute to the Cloud provider API rate limit. */
  fetchTags?: InputMaybe<Scalars['Boolean']['input']>;
  /** [DEPRECATED] Multiple polling interval is no longer supported, use only metrics_polling_interval */
  inventoryPollingInterval?: InputMaybe<Scalars['Int']['input']>;
  /** The linked account identifier. */
  linkedAccountId: Scalars['Int']['input'];
  /** Specify each name or prefix for the LBs that you want to monitor. Filter values are case-sensitive. */
  loadBalancerPrefixes?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  /** The data polling interval in seconds. */
  metricsPollingInterval?: InputMaybe<Scalars['Int']['input']>;
  /** Specify a Tag key associated with the resources that you want to monitor. Filter values are case-sensitive. */
  tagKey?: InputMaybe<Scalars['String']['input']>;
  /** Specify a Tag value associated with the resources that you want to monitor. Filter values are case-sensitive. */
  tagValue?: InputMaybe<Scalars['String']['input']>;
};

/** API Gateway Integration */
export type CloudApigatewayIntegration = CloudIntegration & {
  __typename?: 'CloudApigatewayIntegration';
  /** Specify each AWS region that includes the resources that you want to monitor. */
  awsRegions?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
  /** The object creation date, in epoch (Unix) time */
  createdAt: Scalars['EpochSeconds']['output'];
  /** The cloud service integration identifier. */
  id?: Maybe<Scalars['Int']['output']>;
  /**
   * [DEPRECATED] Multiple polling interval is no longer supported, use only metrics_polling_interval
   * @deprecated [DEPRECATED] Multiple polling interval is no longer supported, use only metrics_polling_interval
   */
  inventoryPollingInterval?: Maybe<Scalars['Int']['output']>;
  /** The parent linked account identifier. */
  linkedAccount?: Maybe<CloudLinkedAccount>;
  /** The data polling interval in seconds. */
  metricsPollingInterval?: Maybe<Scalars['Int']['output']>;
  /** The cloud service integration name. */
  name?: Maybe<Scalars['String']['output']>;
  /** The parent NewRelic account identifier. */
  nrAccountId: Scalars['Int']['output'];
  /** The cloud service used in the integration. */
  service?: Maybe<CloudService>;
  /** Specify each name or prefix for the Stages that you want to monitor. Filter values are case-sensitive. */
  stagePrefixes?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
  /** Specify a Tag key associated with the resources that you want to monitor. Filter values are case-sensitive. */
  tagKey?: Maybe<Scalars['String']['output']>;
  /** Specify a Tag value associated with the resources that you want to monitor. Filter values are case-sensitive. */
  tagValue?: Maybe<Scalars['String']['output']>;
  /** The object last update date, in epoch (Unix) time */
  updatedAt: Scalars['EpochSeconds']['output'];
};

/** Amazon API Gateway */
export type CloudApigatewayIntegrationInput = {
  /** Specify each AWS region that includes the resources that you want to monitor. */
  awsRegions?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  /** [DEPRECATED] Multiple polling interval is no longer supported, use only metrics_polling_interval */
  inventoryPollingInterval?: InputMaybe<Scalars['Int']['input']>;
  /** The linked account identifier. */
  linkedAccountId: Scalars['Int']['input'];
  /** The data polling interval in seconds. */
  metricsPollingInterval?: InputMaybe<Scalars['Int']['input']>;
  /** Specify each name or prefix for the Stages that you want to monitor. Filter values are case-sensitive. */
  stagePrefixes?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  /** Specify a Tag key associated with the resources that you want to monitor. Filter values are case-sensitive. */
  tagKey?: InputMaybe<Scalars['String']['input']>;
  /** Specify a Tag value associated with the resources that you want to monitor. Filter values are case-sensitive. */
  tagValue?: InputMaybe<Scalars['String']['input']>;
};

/** AutoScaling Integration */
export type CloudAutoscalingIntegration = CloudIntegration & {
  __typename?: 'CloudAutoscalingIntegration';
  /** Specify each AWS region that includes the resources that you want to monitor. */
  awsRegions?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
  /** The object creation date, in epoch (Unix) time */
  createdAt: Scalars['EpochSeconds']['output'];
  /** The cloud service integration identifier. */
  id?: Maybe<Scalars['Int']['output']>;
  /**
   * [DEPRECATED] Multiple polling interval is no longer supported, use only metrics_polling_interval
   * @deprecated [DEPRECATED] Multiple polling interval is no longer supported, use only metrics_polling_interval
   */
  inventoryPollingInterval?: Maybe<Scalars['Int']['output']>;
  /** The parent linked account identifier. */
  linkedAccount?: Maybe<CloudLinkedAccount>;
  /** The data polling interval in seconds. */
  metricsPollingInterval?: Maybe<Scalars['Int']['output']>;
  /** The cloud service integration name. */
  name?: Maybe<Scalars['String']['output']>;
  /** The parent NewRelic account identifier. */
  nrAccountId: Scalars['Int']['output'];
  /** The cloud service used in the integration. */
  service?: Maybe<CloudService>;
  /** The object last update date, in epoch (Unix) time */
  updatedAt: Scalars['EpochSeconds']['output'];
};

/** AWS Auto Scaling */
export type CloudAutoscalingIntegrationInput = {
  /** Specify each AWS region that includes the resources that you want to monitor. */
  awsRegions?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  /** [DEPRECATED] Multiple polling interval is no longer supported, use only metrics_polling_interval */
  inventoryPollingInterval?: InputMaybe<Scalars['Int']['input']>;
  /** The linked account identifier. */
  linkedAccountId: Scalars['Int']['input'];
  /** The data polling interval in seconds. */
  metricsPollingInterval?: InputMaybe<Scalars['Int']['input']>;
};

/** AppSync Integration */
export type CloudAwsAppsyncIntegration = CloudIntegration & {
  __typename?: 'CloudAwsAppsyncIntegration';
  /** Specify each AWS region that includes the resources that you want to monitor. */
  awsRegions?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
  /** The object creation date, in epoch (Unix) time */
  createdAt: Scalars['EpochSeconds']['output'];
  /** The cloud service integration identifier. */
  id?: Maybe<Scalars['Int']['output']>;
  /**
   * [DEPRECATED] Multiple polling interval is no longer supported, use only metrics_polling_interval
   * @deprecated [DEPRECATED] Multiple polling interval is no longer supported, use only metrics_polling_interval
   */
  inventoryPollingInterval?: Maybe<Scalars['Int']['output']>;
  /** The parent linked account identifier. */
  linkedAccount?: Maybe<CloudLinkedAccount>;
  /** The data polling interval in seconds. */
  metricsPollingInterval?: Maybe<Scalars['Int']['output']>;
  /** The cloud service integration name. */
  name?: Maybe<Scalars['String']['output']>;
  /** The parent NewRelic account identifier. */
  nrAccountId: Scalars['Int']['output'];
  /** The cloud service used in the integration. */
  service?: Maybe<CloudService>;
  /** The object last update date, in epoch (Unix) time */
  updatedAt: Scalars['EpochSeconds']['output'];
};

/** AppSync */
export type CloudAwsAppsyncIntegrationInput = {
  /** Specify each AWS region that includes the resources that you want to monitor. */
  awsRegions?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  /** [DEPRECATED] Multiple polling interval is no longer supported, use only metrics_polling_interval */
  inventoryPollingInterval?: InputMaybe<Scalars['Int']['input']>;
  /** The linked account identifier. */
  linkedAccountId: Scalars['Int']['input'];
  /** The data polling interval in seconds. */
  metricsPollingInterval?: InputMaybe<Scalars['Int']['input']>;
};

/** Athena Integration */
export type CloudAwsAthenaIntegration = CloudIntegration & {
  __typename?: 'CloudAwsAthenaIntegration';
  /** Specify each AWS region that includes the resources that you want to monitor. */
  awsRegions?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
  /** The object creation date, in epoch (Unix) time */
  createdAt: Scalars['EpochSeconds']['output'];
  /** The cloud service integration identifier. */
  id?: Maybe<Scalars['Int']['output']>;
  /**
   * [DEPRECATED] Multiple polling interval is no longer supported, use only metrics_polling_interval
   * @deprecated [DEPRECATED] Multiple polling interval is no longer supported, use only metrics_polling_interval
   */
  inventoryPollingInterval?: Maybe<Scalars['Int']['output']>;
  /** The parent linked account identifier. */
  linkedAccount?: Maybe<CloudLinkedAccount>;
  /** The data polling interval in seconds. */
  metricsPollingInterval?: Maybe<Scalars['Int']['output']>;
  /** The cloud service integration name. */
  name?: Maybe<Scalars['String']['output']>;
  /** The parent NewRelic account identifier. */
  nrAccountId: Scalars['Int']['output'];
  /** The cloud service used in the integration. */
  service?: Maybe<CloudService>;
  /** The object last update date, in epoch (Unix) time */
  updatedAt: Scalars['EpochSeconds']['output'];
};

/** Athena */
export type CloudAwsAthenaIntegrationInput = {
  /** Specify each AWS region that includes the resources that you want to monitor. */
  awsRegions?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  /** [DEPRECATED] Multiple polling interval is no longer supported, use only metrics_polling_interval */
  inventoryPollingInterval?: InputMaybe<Scalars['Int']['input']>;
  /** The linked account identifier. */
  linkedAccountId: Scalars['Int']['input'];
  /** The data polling interval in seconds. */
  metricsPollingInterval?: InputMaybe<Scalars['Int']['input']>;
};

/** Cognito Integration */
export type CloudAwsCognitoIntegration = CloudIntegration & {
  __typename?: 'CloudAwsCognitoIntegration';
  /** Specify each AWS region that includes the resources that you want to monitor. */
  awsRegions?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
  /** The object creation date, in epoch (Unix) time */
  createdAt: Scalars['EpochSeconds']['output'];
  /** The cloud service integration identifier. */
  id?: Maybe<Scalars['Int']['output']>;
  /**
   * [DEPRECATED] Multiple polling interval is no longer supported, use only metrics_polling_interval
   * @deprecated [DEPRECATED] Multiple polling interval is no longer supported, use only metrics_polling_interval
   */
  inventoryPollingInterval?: Maybe<Scalars['Int']['output']>;
  /** The parent linked account identifier. */
  linkedAccount?: Maybe<CloudLinkedAccount>;
  /** The data polling interval in seconds. */
  metricsPollingInterval?: Maybe<Scalars['Int']['output']>;
  /** The cloud service integration name. */
  name?: Maybe<Scalars['String']['output']>;
  /** The parent NewRelic account identifier. */
  nrAccountId: Scalars['Int']['output'];
  /** The cloud service used in the integration. */
  service?: Maybe<CloudService>;
  /** The object last update date, in epoch (Unix) time */
  updatedAt: Scalars['EpochSeconds']['output'];
};

/** Cognito */
export type CloudAwsCognitoIntegrationInput = {
  /** Specify each AWS region that includes the resources that you want to monitor. */
  awsRegions?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  /** [DEPRECATED] Multiple polling interval is no longer supported, use only metrics_polling_interval */
  inventoryPollingInterval?: InputMaybe<Scalars['Int']['input']>;
  /** The linked account identifier. */
  linkedAccountId: Scalars['Int']['input'];
  /** The data polling interval in seconds. */
  metricsPollingInterval?: InputMaybe<Scalars['Int']['input']>;
};

/** Connect Integration */
export type CloudAwsConnectIntegration = CloudIntegration & {
  __typename?: 'CloudAwsConnectIntegration';
  /** Specify each AWS region that includes the resources that you want to monitor. */
  awsRegions?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
  /** The object creation date, in epoch (Unix) time */
  createdAt: Scalars['EpochSeconds']['output'];
  /** The cloud service integration identifier. */
  id?: Maybe<Scalars['Int']['output']>;
  /**
   * [DEPRECATED] Multiple polling interval is no longer supported, use only metrics_polling_interval
   * @deprecated [DEPRECATED] Multiple polling interval is no longer supported, use only metrics_polling_interval
   */
  inventoryPollingInterval?: Maybe<Scalars['Int']['output']>;
  /** The parent linked account identifier. */
  linkedAccount?: Maybe<CloudLinkedAccount>;
  /** The data polling interval in seconds. */
  metricsPollingInterval?: Maybe<Scalars['Int']['output']>;
  /** The cloud service integration name. */
  name?: Maybe<Scalars['String']['output']>;
  /** The parent NewRelic account identifier. */
  nrAccountId: Scalars['Int']['output'];
  /** The cloud service used in the integration. */
  service?: Maybe<CloudService>;
  /** The object last update date, in epoch (Unix) time */
  updatedAt: Scalars['EpochSeconds']['output'];
};

/** Connect */
export type CloudAwsConnectIntegrationInput = {
  /** Specify each AWS region that includes the resources that you want to monitor. */
  awsRegions?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  /** [DEPRECATED] Multiple polling interval is no longer supported, use only metrics_polling_interval */
  inventoryPollingInterval?: InputMaybe<Scalars['Int']['input']>;
  /** The linked account identifier. */
  linkedAccountId: Scalars['Int']['input'];
  /** The data polling interval in seconds. */
  metricsPollingInterval?: InputMaybe<Scalars['Int']['input']>;
};

/** Direct Connect Integration */
export type CloudAwsDirectconnectIntegration = CloudIntegration & {
  __typename?: 'CloudAwsDirectconnectIntegration';
  /** Specify each AWS region that includes the resources that you want to monitor. */
  awsRegions?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
  /** The object creation date, in epoch (Unix) time */
  createdAt: Scalars['EpochSeconds']['output'];
  /** The cloud service integration identifier. */
  id?: Maybe<Scalars['Int']['output']>;
  /**
   * [DEPRECATED] Multiple polling interval is no longer supported, use only metrics_polling_interval
   * @deprecated [DEPRECATED] Multiple polling interval is no longer supported, use only metrics_polling_interval
   */
  inventoryPollingInterval?: Maybe<Scalars['Int']['output']>;
  /** The parent linked account identifier. */
  linkedAccount?: Maybe<CloudLinkedAccount>;
  /** The data polling interval in seconds. */
  metricsPollingInterval?: Maybe<Scalars['Int']['output']>;
  /** The cloud service integration name. */
  name?: Maybe<Scalars['String']['output']>;
  /** The parent NewRelic account identifier. */
  nrAccountId: Scalars['Int']['output'];
  /** The cloud service used in the integration. */
  service?: Maybe<CloudService>;
  /** The object last update date, in epoch (Unix) time */
  updatedAt: Scalars['EpochSeconds']['output'];
};

/** Direct Connect */
export type CloudAwsDirectconnectIntegrationInput = {
  /** Specify each AWS region that includes the resources that you want to monitor. */
  awsRegions?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  /** [DEPRECATED] Multiple polling interval is no longer supported, use only metrics_polling_interval */
  inventoryPollingInterval?: InputMaybe<Scalars['Int']['input']>;
  /** The linked account identifier. */
  linkedAccountId: Scalars['Int']['input'];
  /** The data polling interval in seconds. */
  metricsPollingInterval?: InputMaybe<Scalars['Int']['input']>;
};

/** List of integrations */
export type CloudAwsDisableIntegrationsInput = {
  /** ALB/NLB integration */
  alb?: InputMaybe<Array<InputMaybe<CloudDisableAccountIntegrationInput>>>;
  /** API Gateway integration */
  apigateway?: InputMaybe<Array<InputMaybe<CloudDisableAccountIntegrationInput>>>;
  /** AutoScaling integration */
  autoscaling?: InputMaybe<Array<InputMaybe<CloudDisableAccountIntegrationInput>>>;
  /** AppSync integration */
  awsAppsync?: InputMaybe<Array<InputMaybe<CloudDisableAccountIntegrationInput>>>;
  /** Athena integration */
  awsAthena?: InputMaybe<Array<InputMaybe<CloudDisableAccountIntegrationInput>>>;
  /** Cognito integration */
  awsCognito?: InputMaybe<Array<InputMaybe<CloudDisableAccountIntegrationInput>>>;
  /** Connect integration */
  awsConnect?: InputMaybe<Array<InputMaybe<CloudDisableAccountIntegrationInput>>>;
  /** Direct Connect integration */
  awsDirectconnect?: InputMaybe<Array<InputMaybe<CloudDisableAccountIntegrationInput>>>;
  /** DocumentDB integration */
  awsDocdb?: InputMaybe<Array<InputMaybe<CloudDisableAccountIntegrationInput>>>;
  /** FSx integration */
  awsFsx?: InputMaybe<Array<InputMaybe<CloudDisableAccountIntegrationInput>>>;
  /** Glue integration */
  awsGlue?: InputMaybe<Array<InputMaybe<CloudDisableAccountIntegrationInput>>>;
  /** Kinesis Data Analytics integration */
  awsKinesisanalytics?: InputMaybe<Array<InputMaybe<CloudDisableAccountIntegrationInput>>>;
  /** Elemental MediaConvert integration */
  awsMediaconvert?: InputMaybe<Array<InputMaybe<CloudDisableAccountIntegrationInput>>>;
  /** MediaPackage VOD integration */
  awsMediapackagevod?: InputMaybe<Array<InputMaybe<CloudDisableAccountIntegrationInput>>>;
  /** Fetch Metadata for AWS integrations integration */
  awsMetadata?: InputMaybe<Array<InputMaybe<CloudDisableAccountIntegrationInput>>>;
  /** MQ integration */
  awsMq?: InputMaybe<Array<InputMaybe<CloudDisableAccountIntegrationInput>>>;
  /** Managed Kafka integration */
  awsMsk?: InputMaybe<Array<InputMaybe<CloudDisableAccountIntegrationInput>>>;
  /** Neptune integration */
  awsNeptune?: InputMaybe<Array<InputMaybe<CloudDisableAccountIntegrationInput>>>;
  /** QLDB integration */
  awsQldb?: InputMaybe<Array<InputMaybe<CloudDisableAccountIntegrationInput>>>;
  /** Route53 Resolver integration */
  awsRoute53resolver?: InputMaybe<Array<InputMaybe<CloudDisableAccountIntegrationInput>>>;
  /** Step Functions integration */
  awsStates?: InputMaybe<Array<InputMaybe<CloudDisableAccountIntegrationInput>>>;
  /** Fetch tags for all integrations integration */
  awsTagsGlobal?: InputMaybe<Array<InputMaybe<CloudDisableAccountIntegrationInput>>>;
  /** Transit Gateway integration */
  awsTransitgateway?: InputMaybe<Array<InputMaybe<CloudDisableAccountIntegrationInput>>>;
  /** WAF integration */
  awsWaf?: InputMaybe<Array<InputMaybe<CloudDisableAccountIntegrationInput>>>;
  /** WAFV2 integration */
  awsWafv2?: InputMaybe<Array<InputMaybe<CloudDisableAccountIntegrationInput>>>;
  /** X-Ray integration */
  awsXray?: InputMaybe<Array<InputMaybe<CloudDisableAccountIntegrationInput>>>;
  /** Billing integration */
  billing?: InputMaybe<Array<InputMaybe<CloudDisableAccountIntegrationInput>>>;
  /** CloudFront integration */
  cloudfront?: InputMaybe<Array<InputMaybe<CloudDisableAccountIntegrationInput>>>;
  /** CloudTrail integration */
  cloudtrail?: InputMaybe<Array<InputMaybe<CloudDisableAccountIntegrationInput>>>;
  /** DynamoDB integration */
  dynamodb?: InputMaybe<Array<InputMaybe<CloudDisableAccountIntegrationInput>>>;
  /** EBS integration */
  ebs?: InputMaybe<Array<InputMaybe<CloudDisableAccountIntegrationInput>>>;
  /** EC2 integration */
  ec2?: InputMaybe<Array<InputMaybe<CloudDisableAccountIntegrationInput>>>;
  /** ECS integration */
  ecs?: InputMaybe<Array<InputMaybe<CloudDisableAccountIntegrationInput>>>;
  /** EFS integration */
  efs?: InputMaybe<Array<InputMaybe<CloudDisableAccountIntegrationInput>>>;
  /** ElastiCache integration */
  elasticache?: InputMaybe<Array<InputMaybe<CloudDisableAccountIntegrationInput>>>;
  /** Elastic Beanstalk integration */
  elasticbeanstalk?: InputMaybe<Array<InputMaybe<CloudDisableAccountIntegrationInput>>>;
  /** Elasticsearch Service integration */
  elasticsearch?: InputMaybe<Array<InputMaybe<CloudDisableAccountIntegrationInput>>>;
  /** ELB (Classic) integration */
  elb?: InputMaybe<Array<InputMaybe<CloudDisableAccountIntegrationInput>>>;
  /** EMR integration */
  emr?: InputMaybe<Array<InputMaybe<CloudDisableAccountIntegrationInput>>>;
  /** Health integration */
  health?: InputMaybe<Array<InputMaybe<CloudDisableAccountIntegrationInput>>>;
  /** IAM integration */
  iam?: InputMaybe<Array<InputMaybe<CloudDisableAccountIntegrationInput>>>;
  /** IoT integration */
  iot?: InputMaybe<Array<InputMaybe<CloudDisableAccountIntegrationInput>>>;
  /** Kinesis Streams integration */
  kinesis?: InputMaybe<Array<InputMaybe<CloudDisableAccountIntegrationInput>>>;
  /** Kinesis Firehose integration */
  kinesisFirehose?: InputMaybe<Array<InputMaybe<CloudDisableAccountIntegrationInput>>>;
  /** Lambda integration */
  lambda?: InputMaybe<Array<InputMaybe<CloudDisableAccountIntegrationInput>>>;
  /** RDS integration */
  rds?: InputMaybe<Array<InputMaybe<CloudDisableAccountIntegrationInput>>>;
  /** Redshift integration */
  redshift?: InputMaybe<Array<InputMaybe<CloudDisableAccountIntegrationInput>>>;
  /** Route 53 integration */
  route53?: InputMaybe<Array<InputMaybe<CloudDisableAccountIntegrationInput>>>;
  /** S3 integration */
  s3?: InputMaybe<Array<InputMaybe<CloudDisableAccountIntegrationInput>>>;
  /** SES integration */
  ses?: InputMaybe<Array<InputMaybe<CloudDisableAccountIntegrationInput>>>;
  /** SNS integration */
  sns?: InputMaybe<Array<InputMaybe<CloudDisableAccountIntegrationInput>>>;
  /** SQS integration */
  sqs?: InputMaybe<Array<InputMaybe<CloudDisableAccountIntegrationInput>>>;
  /** Trusted Advisor integration */
  trustedadvisor?: InputMaybe<Array<InputMaybe<CloudDisableAccountIntegrationInput>>>;
  /** VPC integration */
  vpc?: InputMaybe<Array<InputMaybe<CloudDisableAccountIntegrationInput>>>;
};

/** DocumentDB Integration */
export type CloudAwsDocdbIntegration = CloudIntegration & {
  __typename?: 'CloudAwsDocdbIntegration';
  /** Specify each AWS region that includes the resources that you want to monitor. */
  awsRegions?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
  /** The object creation date, in epoch (Unix) time */
  createdAt: Scalars['EpochSeconds']['output'];
  /** The cloud service integration identifier. */
  id?: Maybe<Scalars['Int']['output']>;
  /**
   * [DEPRECATED] Multiple polling interval is no longer supported, use only metrics_polling_interval
   * @deprecated [DEPRECATED] Multiple polling interval is no longer supported, use only metrics_polling_interval
   */
  inventoryPollingInterval?: Maybe<Scalars['Int']['output']>;
  /** The parent linked account identifier. */
  linkedAccount?: Maybe<CloudLinkedAccount>;
  /** The data polling interval in seconds. */
  metricsPollingInterval?: Maybe<Scalars['Int']['output']>;
  /** The cloud service integration name. */
  name?: Maybe<Scalars['String']['output']>;
  /** The parent NewRelic account identifier. */
  nrAccountId: Scalars['Int']['output'];
  /** The cloud service used in the integration. */
  service?: Maybe<CloudService>;
  /** The object last update date, in epoch (Unix) time */
  updatedAt: Scalars['EpochSeconds']['output'];
};

/** DocumentDB */
export type CloudAwsDocdbIntegrationInput = {
  /** Specify each AWS region that includes the resources that you want to monitor. */
  awsRegions?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  /** [DEPRECATED] Multiple polling interval is no longer supported, use only metrics_polling_interval */
  inventoryPollingInterval?: InputMaybe<Scalars['Int']['input']>;
  /** The linked account identifier. */
  linkedAccountId: Scalars['Int']['input'];
  /** The data polling interval in seconds. */
  metricsPollingInterval?: InputMaybe<Scalars['Int']['input']>;
};

/** FSx Integration */
export type CloudAwsFsxIntegration = CloudIntegration & {
  __typename?: 'CloudAwsFsxIntegration';
  /** Specify each AWS region that includes the resources that you want to monitor. */
  awsRegions?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
  /** The object creation date, in epoch (Unix) time */
  createdAt: Scalars['EpochSeconds']['output'];
  /** The cloud service integration identifier. */
  id?: Maybe<Scalars['Int']['output']>;
  /**
   * [DEPRECATED] Multiple polling interval is no longer supported, use only metrics_polling_interval
   * @deprecated [DEPRECATED] Multiple polling interval is no longer supported, use only metrics_polling_interval
   */
  inventoryPollingInterval?: Maybe<Scalars['Int']['output']>;
  /** The parent linked account identifier. */
  linkedAccount?: Maybe<CloudLinkedAccount>;
  /** The data polling interval in seconds. */
  metricsPollingInterval?: Maybe<Scalars['Int']['output']>;
  /** The cloud service integration name. */
  name?: Maybe<Scalars['String']['output']>;
  /** The parent NewRelic account identifier. */
  nrAccountId: Scalars['Int']['output'];
  /** The cloud service used in the integration. */
  service?: Maybe<CloudService>;
  /** The object last update date, in epoch (Unix) time */
  updatedAt: Scalars['EpochSeconds']['output'];
};

/** FSx */
export type CloudAwsFsxIntegrationInput = {
  /** Specify each AWS region that includes the resources that you want to monitor. */
  awsRegions?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  /** [DEPRECATED] Multiple polling interval is no longer supported, use only metrics_polling_interval */
  inventoryPollingInterval?: InputMaybe<Scalars['Int']['input']>;
  /** The linked account identifier. */
  linkedAccountId: Scalars['Int']['input'];
  /** The data polling interval in seconds. */
  metricsPollingInterval?: InputMaybe<Scalars['Int']['input']>;
};

/** Glue Integration */
export type CloudAwsGlueIntegration = CloudIntegration & {
  __typename?: 'CloudAwsGlueIntegration';
  /** Specify each AWS region that includes the resources that you want to monitor. */
  awsRegions?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
  /** The object creation date, in epoch (Unix) time */
  createdAt: Scalars['EpochSeconds']['output'];
  /** The cloud service integration identifier. */
  id?: Maybe<Scalars['Int']['output']>;
  /**
   * [DEPRECATED] Multiple polling interval is no longer supported, use only metrics_polling_interval
   * @deprecated [DEPRECATED] Multiple polling interval is no longer supported, use only metrics_polling_interval
   */
  inventoryPollingInterval?: Maybe<Scalars['Int']['output']>;
  /** The parent linked account identifier. */
  linkedAccount?: Maybe<CloudLinkedAccount>;
  /** The data polling interval in seconds. */
  metricsPollingInterval?: Maybe<Scalars['Int']['output']>;
  /** The cloud service integration name. */
  name?: Maybe<Scalars['String']['output']>;
  /** The parent NewRelic account identifier. */
  nrAccountId: Scalars['Int']['output'];
  /** The cloud service used in the integration. */
  service?: Maybe<CloudService>;
  /** The object last update date, in epoch (Unix) time */
  updatedAt: Scalars['EpochSeconds']['output'];
};

/** Glue */
export type CloudAwsGlueIntegrationInput = {
  /** Specify each AWS region that includes the resources that you want to monitor. */
  awsRegions?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  /** [DEPRECATED] Multiple polling interval is no longer supported, use only metrics_polling_interval */
  inventoryPollingInterval?: InputMaybe<Scalars['Int']['input']>;
  /** The linked account identifier. */
  linkedAccountId: Scalars['Int']['input'];
  /** The data polling interval in seconds. */
  metricsPollingInterval?: InputMaybe<Scalars['Int']['input']>;
};

/** Information required to link an AWS GovCloud account to a NewRelic account. */
export type CloudAwsGovCloudLinkAccountInput = {
  /** The key used to make requests to AWS service APIs */
  accessKeyId: Scalars['String']['input'];
  /** The AWS account id */
  awsAccountId: Scalars['String']['input'];
  /** How metrics will be collected. */
  metricCollectionMode?: InputMaybe<CloudMetricCollectionMode>;
  /** The linked account name. */
  name: Scalars['String']['input'];
  /** The secret key used to make requests to AWS service APIs */
  secretAccessKey: Scalars['SecureValue']['input'];
};

/** Information required to migrate an existing AWS GovCloud account to use AssumeRole Authentication. */
export type CloudAwsGovCloudMigrateToAssumeroleInput = {
  /** The AWS role ARN (used to fetch data). */
  arn: Scalars['String']['input'];
  /** The linked account identifier. */
  linkedAccountId: Scalars['Int']['input'];
};

/** The Amazon Web Services cloud provider (GovCloud) */
export type CloudAwsGovCloudProvider = CloudProvider & {
  __typename?: 'CloudAwsGovCloudProvider';
  /** The AWS Account ID */
  awsAccountId: Scalars['String']['output'];
  /** The object creation date, in epoch (Unix) time */
  createdAt: Scalars['EpochSeconds']['output'];
  /** The cloud provider icon name. */
  icon: Scalars['String']['output'];
  /** The cloud provider identifier in NewRelic. */
  id: Scalars['Int']['output'];
  /** The cloud provider name. */
  name: Scalars['String']['output'];
  /** Get details of one cloud provider service. */
  service?: Maybe<CloudService>;
  /** Get details of all the cloud provider services available for integration. */
  services: Array<CloudService>;
  /** The cloud provider short name. */
  slug: Scalars['String']['output'];
  /** The object last update date, in epoch (Unix) time */
  updatedAt: Scalars['EpochSeconds']['output'];
};


/** The Amazon Web Services cloud provider (GovCloud) */
export type CloudAwsGovCloudProviderServiceArgs = {
  slug: Scalars['String']['input'];
};

/** List of integrations */
export type CloudAwsGovcloudDisableIntegrationsInput = {
  /** ALB/NLB integration */
  alb?: InputMaybe<Array<InputMaybe<CloudDisableAccountIntegrationInput>>>;
  /** API Gateway integration */
  apigateway?: InputMaybe<Array<InputMaybe<CloudDisableAccountIntegrationInput>>>;
  /** AutoScaling integration */
  autoscaling?: InputMaybe<Array<InputMaybe<CloudDisableAccountIntegrationInput>>>;
  /** Direct Connect integration */
  awsDirectconnect?: InputMaybe<Array<InputMaybe<CloudDisableAccountIntegrationInput>>>;
  /** Step Functions integration */
  awsStates?: InputMaybe<Array<InputMaybe<CloudDisableAccountIntegrationInput>>>;
  /** CloudTrail integration */
  cloudtrail?: InputMaybe<Array<InputMaybe<CloudDisableAccountIntegrationInput>>>;
  /** DynamoDB integration */
  dynamodb?: InputMaybe<Array<InputMaybe<CloudDisableAccountIntegrationInput>>>;
  /** EBS integration */
  ebs?: InputMaybe<Array<InputMaybe<CloudDisableAccountIntegrationInput>>>;
  /** EC2 integration */
  ec2?: InputMaybe<Array<InputMaybe<CloudDisableAccountIntegrationInput>>>;
  /** Elasticsearch Service integration */
  elasticsearch?: InputMaybe<Array<InputMaybe<CloudDisableAccountIntegrationInput>>>;
  /** ELB (Classic) integration */
  elb?: InputMaybe<Array<InputMaybe<CloudDisableAccountIntegrationInput>>>;
  /** EMR integration */
  emr?: InputMaybe<Array<InputMaybe<CloudDisableAccountIntegrationInput>>>;
  /** IAM integration */
  iam?: InputMaybe<Array<InputMaybe<CloudDisableAccountIntegrationInput>>>;
  /** Lambda integration */
  lambda?: InputMaybe<Array<InputMaybe<CloudDisableAccountIntegrationInput>>>;
  /** RDS integration */
  rds?: InputMaybe<Array<InputMaybe<CloudDisableAccountIntegrationInput>>>;
  /** Redshift integration */
  redshift?: InputMaybe<Array<InputMaybe<CloudDisableAccountIntegrationInput>>>;
  /** Route 53 integration */
  route53?: InputMaybe<Array<InputMaybe<CloudDisableAccountIntegrationInput>>>;
  /** S3 integration */
  s3?: InputMaybe<Array<InputMaybe<CloudDisableAccountIntegrationInput>>>;
  /** SNS integration */
  sns?: InputMaybe<Array<InputMaybe<CloudDisableAccountIntegrationInput>>>;
  /** SQS integration */
  sqs?: InputMaybe<Array<InputMaybe<CloudDisableAccountIntegrationInput>>>;
};

/** List of integrations */
export type CloudAwsGovcloudIntegrationsInput = {
  /** ALB/NLB integration */
  alb?: InputMaybe<Array<InputMaybe<CloudAlbIntegrationInput>>>;
  /** API Gateway integration */
  apigateway?: InputMaybe<Array<InputMaybe<CloudApigatewayIntegrationInput>>>;
  /** AutoScaling integration */
  autoscaling?: InputMaybe<Array<InputMaybe<CloudAutoscalingIntegrationInput>>>;
  /** Direct Connect integration */
  awsDirectconnect?: InputMaybe<Array<InputMaybe<CloudAwsDirectconnectIntegrationInput>>>;
  /** Step Functions integration */
  awsStates?: InputMaybe<Array<InputMaybe<CloudAwsStatesIntegrationInput>>>;
  /** CloudTrail integration */
  cloudtrail?: InputMaybe<Array<InputMaybe<CloudCloudtrailIntegrationInput>>>;
  /** DynamoDB integration */
  dynamodb?: InputMaybe<Array<InputMaybe<CloudDynamodbIntegrationInput>>>;
  /** EBS integration */
  ebs?: InputMaybe<Array<InputMaybe<CloudEbsIntegrationInput>>>;
  /** EC2 integration */
  ec2?: InputMaybe<Array<InputMaybe<CloudEc2IntegrationInput>>>;
  /** Elasticsearch Service integration */
  elasticsearch?: InputMaybe<Array<InputMaybe<CloudElasticsearchIntegrationInput>>>;
  /** ELB (Classic) integration */
  elb?: InputMaybe<Array<InputMaybe<CloudElbIntegrationInput>>>;
  /** EMR integration */
  emr?: InputMaybe<Array<InputMaybe<CloudEmrIntegrationInput>>>;
  /** IAM integration */
  iam?: InputMaybe<Array<InputMaybe<CloudIamIntegrationInput>>>;
  /** Lambda integration */
  lambda?: InputMaybe<Array<InputMaybe<CloudLambdaIntegrationInput>>>;
  /** RDS integration */
  rds?: InputMaybe<Array<InputMaybe<CloudRdsIntegrationInput>>>;
  /** Redshift integration */
  redshift?: InputMaybe<Array<InputMaybe<CloudRedshiftIntegrationInput>>>;
  /** Route 53 integration */
  route53?: InputMaybe<Array<InputMaybe<CloudRoute53IntegrationInput>>>;
  /** S3 integration */
  s3?: InputMaybe<Array<InputMaybe<CloudS3IntegrationInput>>>;
  /** SNS integration */
  sns?: InputMaybe<Array<InputMaybe<CloudSnsIntegrationInput>>>;
  /** SQS integration */
  sqs?: InputMaybe<Array<InputMaybe<CloudSqsIntegrationInput>>>;
};

/** List of integrations */
export type CloudAwsIntegrationsInput = {
  /** ALB/NLB integration */
  alb?: InputMaybe<Array<InputMaybe<CloudAlbIntegrationInput>>>;
  /** API Gateway integration */
  apigateway?: InputMaybe<Array<InputMaybe<CloudApigatewayIntegrationInput>>>;
  /** AutoScaling integration */
  autoscaling?: InputMaybe<Array<InputMaybe<CloudAutoscalingIntegrationInput>>>;
  /** AppSync integration */
  awsAppsync?: InputMaybe<Array<InputMaybe<CloudAwsAppsyncIntegrationInput>>>;
  /** Athena integration */
  awsAthena?: InputMaybe<Array<InputMaybe<CloudAwsAthenaIntegrationInput>>>;
  /** Cognito integration */
  awsCognito?: InputMaybe<Array<InputMaybe<CloudAwsCognitoIntegrationInput>>>;
  /** Connect integration */
  awsConnect?: InputMaybe<Array<InputMaybe<CloudAwsConnectIntegrationInput>>>;
  /** Direct Connect integration */
  awsDirectconnect?: InputMaybe<Array<InputMaybe<CloudAwsDirectconnectIntegrationInput>>>;
  /** DocumentDB integration */
  awsDocdb?: InputMaybe<Array<InputMaybe<CloudAwsDocdbIntegrationInput>>>;
  /** FSx integration */
  awsFsx?: InputMaybe<Array<InputMaybe<CloudAwsFsxIntegrationInput>>>;
  /** Glue integration */
  awsGlue?: InputMaybe<Array<InputMaybe<CloudAwsGlueIntegrationInput>>>;
  /** Kinesis Data Analytics integration */
  awsKinesisanalytics?: InputMaybe<Array<InputMaybe<CloudAwsKinesisanalyticsIntegrationInput>>>;
  /** Elemental MediaConvert integration */
  awsMediaconvert?: InputMaybe<Array<InputMaybe<CloudAwsMediaconvertIntegrationInput>>>;
  /** MediaPackage VOD integration */
  awsMediapackagevod?: InputMaybe<Array<InputMaybe<CloudAwsMediapackagevodIntegrationInput>>>;
  /** Fetch Metadata for AWS integrations integration */
  awsMetadata?: InputMaybe<Array<InputMaybe<CloudAwsMetadataIntegrationInput>>>;
  /** MQ integration */
  awsMq?: InputMaybe<Array<InputMaybe<CloudAwsMqIntegrationInput>>>;
  /** Managed Kafka integration */
  awsMsk?: InputMaybe<Array<InputMaybe<CloudAwsMskIntegrationInput>>>;
  /** Neptune integration */
  awsNeptune?: InputMaybe<Array<InputMaybe<CloudAwsNeptuneIntegrationInput>>>;
  /** QLDB integration */
  awsQldb?: InputMaybe<Array<InputMaybe<CloudAwsQldbIntegrationInput>>>;
  /** Route53 Resolver integration */
  awsRoute53resolver?: InputMaybe<Array<InputMaybe<CloudAwsRoute53resolverIntegrationInput>>>;
  /** Step Functions integration */
  awsStates?: InputMaybe<Array<InputMaybe<CloudAwsStatesIntegrationInput>>>;
  /** Fetch tags for all integrations integration */
  awsTagsGlobal?: InputMaybe<Array<InputMaybe<CloudAwsTagsGlobalIntegrationInput>>>;
  /** Transit Gateway integration */
  awsTransitgateway?: InputMaybe<Array<InputMaybe<CloudAwsTransitgatewayIntegrationInput>>>;
  /** WAF integration */
  awsWaf?: InputMaybe<Array<InputMaybe<CloudAwsWafIntegrationInput>>>;
  /** WAFV2 integration */
  awsWafv2?: InputMaybe<Array<InputMaybe<CloudAwsWafv2IntegrationInput>>>;
  /** X-Ray integration */
  awsXray?: InputMaybe<Array<InputMaybe<CloudAwsXrayIntegrationInput>>>;
  /** Billing integration */
  billing?: InputMaybe<Array<InputMaybe<CloudBillingIntegrationInput>>>;
  /** CloudFront integration */
  cloudfront?: InputMaybe<Array<InputMaybe<CloudCloudfrontIntegrationInput>>>;
  /** CloudTrail integration */
  cloudtrail?: InputMaybe<Array<InputMaybe<CloudCloudtrailIntegrationInput>>>;
  /** DynamoDB integration */
  dynamodb?: InputMaybe<Array<InputMaybe<CloudDynamodbIntegrationInput>>>;
  /** EBS integration */
  ebs?: InputMaybe<Array<InputMaybe<CloudEbsIntegrationInput>>>;
  /** EC2 integration */
  ec2?: InputMaybe<Array<InputMaybe<CloudEc2IntegrationInput>>>;
  /** ECS integration */
  ecs?: InputMaybe<Array<InputMaybe<CloudEcsIntegrationInput>>>;
  /** EFS integration */
  efs?: InputMaybe<Array<InputMaybe<CloudEfsIntegrationInput>>>;
  /** ElastiCache integration */
  elasticache?: InputMaybe<Array<InputMaybe<CloudElasticacheIntegrationInput>>>;
  /** Elastic Beanstalk integration */
  elasticbeanstalk?: InputMaybe<Array<InputMaybe<CloudElasticbeanstalkIntegrationInput>>>;
  /** Elasticsearch Service integration */
  elasticsearch?: InputMaybe<Array<InputMaybe<CloudElasticsearchIntegrationInput>>>;
  /** ELB (Classic) integration */
  elb?: InputMaybe<Array<InputMaybe<CloudElbIntegrationInput>>>;
  /** EMR integration */
  emr?: InputMaybe<Array<InputMaybe<CloudEmrIntegrationInput>>>;
  /** Health integration */
  health?: InputMaybe<Array<InputMaybe<CloudHealthIntegrationInput>>>;
  /** IAM integration */
  iam?: InputMaybe<Array<InputMaybe<CloudIamIntegrationInput>>>;
  /** IoT integration */
  iot?: InputMaybe<Array<InputMaybe<CloudIotIntegrationInput>>>;
  /** Kinesis Streams integration */
  kinesis?: InputMaybe<Array<InputMaybe<CloudKinesisIntegrationInput>>>;
  /** Kinesis Firehose integration */
  kinesisFirehose?: InputMaybe<Array<InputMaybe<CloudKinesisFirehoseIntegrationInput>>>;
  /** Lambda integration */
  lambda?: InputMaybe<Array<InputMaybe<CloudLambdaIntegrationInput>>>;
  /** RDS integration */
  rds?: InputMaybe<Array<InputMaybe<CloudRdsIntegrationInput>>>;
  /** Redshift integration */
  redshift?: InputMaybe<Array<InputMaybe<CloudRedshiftIntegrationInput>>>;
  /** Route 53 integration */
  route53?: InputMaybe<Array<InputMaybe<CloudRoute53IntegrationInput>>>;
  /** S3 integration */
  s3?: InputMaybe<Array<InputMaybe<CloudS3IntegrationInput>>>;
  /** SES integration */
  ses?: InputMaybe<Array<InputMaybe<CloudSesIntegrationInput>>>;
  /** SNS integration */
  sns?: InputMaybe<Array<InputMaybe<CloudSnsIntegrationInput>>>;
  /** SQS integration */
  sqs?: InputMaybe<Array<InputMaybe<CloudSqsIntegrationInput>>>;
  /** Trusted Advisor integration */
  trustedadvisor?: InputMaybe<Array<InputMaybe<CloudTrustedadvisorIntegrationInput>>>;
  /** VPC integration */
  vpc?: InputMaybe<Array<InputMaybe<CloudVpcIntegrationInput>>>;
};

/** Kinesis Data Analytics Integration */
export type CloudAwsKinesisanalyticsIntegration = CloudIntegration & {
  __typename?: 'CloudAwsKinesisanalyticsIntegration';
  /** Specify each AWS region that includes the resources that you want to monitor. */
  awsRegions?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
  /** The object creation date, in epoch (Unix) time */
  createdAt: Scalars['EpochSeconds']['output'];
  /** The cloud service integration identifier. */
  id?: Maybe<Scalars['Int']['output']>;
  /**
   * [DEPRECATED] Multiple polling interval is no longer supported, use only metrics_polling_interval
   * @deprecated [DEPRECATED] Multiple polling interval is no longer supported, use only metrics_polling_interval
   */
  inventoryPollingInterval?: Maybe<Scalars['Int']['output']>;
  /** The parent linked account identifier. */
  linkedAccount?: Maybe<CloudLinkedAccount>;
  /** The data polling interval in seconds. */
  metricsPollingInterval?: Maybe<Scalars['Int']['output']>;
  /** The cloud service integration name. */
  name?: Maybe<Scalars['String']['output']>;
  /** The parent NewRelic account identifier. */
  nrAccountId: Scalars['Int']['output'];
  /** The cloud service used in the integration. */
  service?: Maybe<CloudService>;
  /** The object last update date, in epoch (Unix) time */
  updatedAt: Scalars['EpochSeconds']['output'];
};

/** Kinesis Data Analytics */
export type CloudAwsKinesisanalyticsIntegrationInput = {
  /** Specify each AWS region that includes the resources that you want to monitor. */
  awsRegions?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  /** [DEPRECATED] Multiple polling interval is no longer supported, use only metrics_polling_interval */
  inventoryPollingInterval?: InputMaybe<Scalars['Int']['input']>;
  /** The linked account identifier. */
  linkedAccountId: Scalars['Int']['input'];
  /** The data polling interval in seconds. */
  metricsPollingInterval?: InputMaybe<Scalars['Int']['input']>;
};

/** Information required to link a AWS account to a NewRelic account. */
export type CloudAwsLinkAccountInput = {
  /** The AWS role ARN (used to fetch data). */
  arn: Scalars['String']['input'];
  /** How metrics will be collected. */
  metricCollectionMode?: InputMaybe<CloudMetricCollectionMode>;
  /** The linked account name. */
  name: Scalars['String']['input'];
};

/** Elemental MediaConvert Integration */
export type CloudAwsMediaconvertIntegration = CloudIntegration & {
  __typename?: 'CloudAwsMediaconvertIntegration';
  /** Specify each AWS region that includes the resources that you want to monitor. */
  awsRegions?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
  /** The object creation date, in epoch (Unix) time */
  createdAt: Scalars['EpochSeconds']['output'];
  /** The cloud service integration identifier. */
  id?: Maybe<Scalars['Int']['output']>;
  /**
   * [DEPRECATED] Multiple polling interval is no longer supported, use only metrics_polling_interval
   * @deprecated [DEPRECATED] Multiple polling interval is no longer supported, use only metrics_polling_interval
   */
  inventoryPollingInterval?: Maybe<Scalars['Int']['output']>;
  /** The parent linked account identifier. */
  linkedAccount?: Maybe<CloudLinkedAccount>;
  /** The data polling interval in seconds. */
  metricsPollingInterval?: Maybe<Scalars['Int']['output']>;
  /** The cloud service integration name. */
  name?: Maybe<Scalars['String']['output']>;
  /** The parent NewRelic account identifier. */
  nrAccountId: Scalars['Int']['output'];
  /** The cloud service used in the integration. */
  service?: Maybe<CloudService>;
  /** The object last update date, in epoch (Unix) time */
  updatedAt: Scalars['EpochSeconds']['output'];
};

/** Elemental MediaConvert */
export type CloudAwsMediaconvertIntegrationInput = {
  /** Specify each AWS region that includes the resources that you want to monitor. */
  awsRegions?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  /** [DEPRECATED] Multiple polling interval is no longer supported, use only metrics_polling_interval */
  inventoryPollingInterval?: InputMaybe<Scalars['Int']['input']>;
  /** The linked account identifier. */
  linkedAccountId: Scalars['Int']['input'];
  /** The data polling interval in seconds. */
  metricsPollingInterval?: InputMaybe<Scalars['Int']['input']>;
};

/** MediaPackage VOD Integration */
export type CloudAwsMediapackagevodIntegration = CloudIntegration & {
  __typename?: 'CloudAwsMediapackagevodIntegration';
  /** Specify each AWS region that includes the resources that you want to monitor. */
  awsRegions?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
  /** The object creation date, in epoch (Unix) time */
  createdAt: Scalars['EpochSeconds']['output'];
  /** The cloud service integration identifier. */
  id?: Maybe<Scalars['Int']['output']>;
  /**
   * [DEPRECATED] Multiple polling interval is no longer supported, use only metrics_polling_interval
   * @deprecated [DEPRECATED] Multiple polling interval is no longer supported, use only metrics_polling_interval
   */
  inventoryPollingInterval?: Maybe<Scalars['Int']['output']>;
  /** The parent linked account identifier. */
  linkedAccount?: Maybe<CloudLinkedAccount>;
  /** The data polling interval in seconds. */
  metricsPollingInterval?: Maybe<Scalars['Int']['output']>;
  /** The cloud service integration name. */
  name?: Maybe<Scalars['String']['output']>;
  /** The parent NewRelic account identifier. */
  nrAccountId: Scalars['Int']['output'];
  /** The cloud service used in the integration. */
  service?: Maybe<CloudService>;
  /** The object last update date, in epoch (Unix) time */
  updatedAt: Scalars['EpochSeconds']['output'];
};

/** MediaPackage VOD */
export type CloudAwsMediapackagevodIntegrationInput = {
  /** Specify each AWS region that includes the resources that you want to monitor. */
  awsRegions?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  /** [DEPRECATED] Multiple polling interval is no longer supported, use only metrics_polling_interval */
  inventoryPollingInterval?: InputMaybe<Scalars['Int']['input']>;
  /** The linked account identifier. */
  linkedAccountId: Scalars['Int']['input'];
  /** The data polling interval in seconds. */
  metricsPollingInterval?: InputMaybe<Scalars['Int']['input']>;
};

/** Fetch Metadata for AWS integrations Integration */
export type CloudAwsMetadataIntegration = CloudIntegration & {
  __typename?: 'CloudAwsMetadataIntegration';
  /** The object creation date, in epoch (Unix) time */
  createdAt: Scalars['EpochSeconds']['output'];
  /** The cloud service integration identifier. */
  id?: Maybe<Scalars['Int']['output']>;
  /**
   * [DEPRECATED] Multiple polling interval is no longer supported, use only metrics_polling_interval
   * @deprecated [DEPRECATED] Multiple polling interval is no longer supported, use only metrics_polling_interval
   */
  inventoryPollingInterval?: Maybe<Scalars['Int']['output']>;
  /** The parent linked account identifier. */
  linkedAccount?: Maybe<CloudLinkedAccount>;
  /** The data polling interval in seconds. */
  metricsPollingInterval?: Maybe<Scalars['Int']['output']>;
  /** The cloud service integration name. */
  name?: Maybe<Scalars['String']['output']>;
  /** The parent NewRelic account identifier. */
  nrAccountId: Scalars['Int']['output'];
  /** The cloud service used in the integration. */
  service?: Maybe<CloudService>;
  /** The object last update date, in epoch (Unix) time */
  updatedAt: Scalars['EpochSeconds']['output'];
};

/** Fetch Metadata for AWS integrations */
export type CloudAwsMetadataIntegrationInput = {
  /** [DEPRECATED] Multiple polling interval is no longer supported, use only metrics_polling_interval */
  inventoryPollingInterval?: InputMaybe<Scalars['Int']['input']>;
  /** The linked account identifier. */
  linkedAccountId: Scalars['Int']['input'];
  /** The data polling interval in seconds. */
  metricsPollingInterval?: InputMaybe<Scalars['Int']['input']>;
};

/** MQ Integration */
export type CloudAwsMqIntegration = CloudIntegration & {
  __typename?: 'CloudAwsMqIntegration';
  /** Specify each AWS region that includes the resources that you want to monitor. */
  awsRegions?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
  /** The object creation date, in epoch (Unix) time */
  createdAt: Scalars['EpochSeconds']['output'];
  /** The cloud service integration identifier. */
  id?: Maybe<Scalars['Int']['output']>;
  /**
   * [DEPRECATED] Multiple polling interval is no longer supported, use only metrics_polling_interval
   * @deprecated [DEPRECATED] Multiple polling interval is no longer supported, use only metrics_polling_interval
   */
  inventoryPollingInterval?: Maybe<Scalars['Int']['output']>;
  /** The parent linked account identifier. */
  linkedAccount?: Maybe<CloudLinkedAccount>;
  /** The data polling interval in seconds. */
  metricsPollingInterval?: Maybe<Scalars['Int']['output']>;
  /** The cloud service integration name. */
  name?: Maybe<Scalars['String']['output']>;
  /** The parent NewRelic account identifier. */
  nrAccountId: Scalars['Int']['output'];
  /** The cloud service used in the integration. */
  service?: Maybe<CloudService>;
  /** The object last update date, in epoch (Unix) time */
  updatedAt: Scalars['EpochSeconds']['output'];
};

/** MQ */
export type CloudAwsMqIntegrationInput = {
  /** Specify each AWS region that includes the resources that you want to monitor. */
  awsRegions?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  /** [DEPRECATED] Multiple polling interval is no longer supported, use only metrics_polling_interval */
  inventoryPollingInterval?: InputMaybe<Scalars['Int']['input']>;
  /** The linked account identifier. */
  linkedAccountId: Scalars['Int']['input'];
  /** The data polling interval in seconds. */
  metricsPollingInterval?: InputMaybe<Scalars['Int']['input']>;
};

/** Managed Kafka Integration */
export type CloudAwsMskIntegration = CloudIntegration & {
  __typename?: 'CloudAwsMskIntegration';
  /** Specify each AWS region that includes the resources that you want to monitor. */
  awsRegions?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
  /** The object creation date, in epoch (Unix) time */
  createdAt: Scalars['EpochSeconds']['output'];
  /** The cloud service integration identifier. */
  id?: Maybe<Scalars['Int']['output']>;
  /**
   * [DEPRECATED] Multiple polling interval is no longer supported, use only metrics_polling_interval
   * @deprecated [DEPRECATED] Multiple polling interval is no longer supported, use only metrics_polling_interval
   */
  inventoryPollingInterval?: Maybe<Scalars['Int']['output']>;
  /** The parent linked account identifier. */
  linkedAccount?: Maybe<CloudLinkedAccount>;
  /** The data polling interval in seconds. */
  metricsPollingInterval?: Maybe<Scalars['Int']['output']>;
  /** The cloud service integration name. */
  name?: Maybe<Scalars['String']['output']>;
  /** The parent NewRelic account identifier. */
  nrAccountId: Scalars['Int']['output'];
  /** The cloud service used in the integration. */
  service?: Maybe<CloudService>;
  /** The object last update date, in epoch (Unix) time */
  updatedAt: Scalars['EpochSeconds']['output'];
};

/** Managed Kafka */
export type CloudAwsMskIntegrationInput = {
  /** Specify each AWS region that includes the resources that you want to monitor. */
  awsRegions?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  /** [DEPRECATED] Multiple polling interval is no longer supported, use only metrics_polling_interval */
  inventoryPollingInterval?: InputMaybe<Scalars['Int']['input']>;
  /** The linked account identifier. */
  linkedAccountId: Scalars['Int']['input'];
  /** The data polling interval in seconds. */
  metricsPollingInterval?: InputMaybe<Scalars['Int']['input']>;
};

/** Neptune Integration */
export type CloudAwsNeptuneIntegration = CloudIntegration & {
  __typename?: 'CloudAwsNeptuneIntegration';
  /** Specify each AWS region that includes the resources that you want to monitor. */
  awsRegions?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
  /** The object creation date, in epoch (Unix) time */
  createdAt: Scalars['EpochSeconds']['output'];
  /** The cloud service integration identifier. */
  id?: Maybe<Scalars['Int']['output']>;
  /**
   * [DEPRECATED] Multiple polling interval is no longer supported, use only metrics_polling_interval
   * @deprecated [DEPRECATED] Multiple polling interval is no longer supported, use only metrics_polling_interval
   */
  inventoryPollingInterval?: Maybe<Scalars['Int']['output']>;
  /** The parent linked account identifier. */
  linkedAccount?: Maybe<CloudLinkedAccount>;
  /** The data polling interval in seconds. */
  metricsPollingInterval?: Maybe<Scalars['Int']['output']>;
  /** The cloud service integration name. */
  name?: Maybe<Scalars['String']['output']>;
  /** The parent NewRelic account identifier. */
  nrAccountId: Scalars['Int']['output'];
  /** The cloud service used in the integration. */
  service?: Maybe<CloudService>;
  /** The object last update date, in epoch (Unix) time */
  updatedAt: Scalars['EpochSeconds']['output'];
};

/** Neptune */
export type CloudAwsNeptuneIntegrationInput = {
  /** Specify each AWS region that includes the resources that you want to monitor. */
  awsRegions?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  /** [DEPRECATED] Multiple polling interval is no longer supported, use only metrics_polling_interval */
  inventoryPollingInterval?: InputMaybe<Scalars['Int']['input']>;
  /** The linked account identifier. */
  linkedAccountId: Scalars['Int']['input'];
  /** The data polling interval in seconds. */
  metricsPollingInterval?: InputMaybe<Scalars['Int']['input']>;
};

/** The Amazon Web Services cloud provider */
export type CloudAwsProvider = CloudProvider & {
  __typename?: 'CloudAwsProvider';
  /** The object creation date, in epoch (Unix) time */
  createdAt: Scalars['EpochSeconds']['output'];
  /** The cloud provider icon name. */
  icon: Scalars['String']['output'];
  /** The cloud provider identifier in NewRelic. */
  id: Scalars['Int']['output'];
  /** The cloud provider name. */
  name: Scalars['String']['output'];
  /** The New Relic AWS Account ID that will use the Role. */
  roleAccountId: Scalars['String']['output'];
  /** The external ID required to assume the Role by the New Relic Account. */
  roleExternalId: Scalars['String']['output'];
  /** Get details of one cloud provider service. */
  service?: Maybe<CloudService>;
  /** Get details of all the cloud provider services available for integration. */
  services: Array<CloudService>;
  /** The cloud provider short name. */
  slug: Scalars['String']['output'];
  /** The object last update date, in epoch (Unix) time */
  updatedAt: Scalars['EpochSeconds']['output'];
};


/** The Amazon Web Services cloud provider */
export type CloudAwsProviderServiceArgs = {
  slug: Scalars['String']['input'];
};

/** QLDB Integration */
export type CloudAwsQldbIntegration = CloudIntegration & {
  __typename?: 'CloudAwsQldbIntegration';
  /** Specify each AWS region that includes the resources that you want to monitor. */
  awsRegions?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
  /** The object creation date, in epoch (Unix) time */
  createdAt: Scalars['EpochSeconds']['output'];
  /** The cloud service integration identifier. */
  id?: Maybe<Scalars['Int']['output']>;
  /**
   * [DEPRECATED] Multiple polling interval is no longer supported, use only metrics_polling_interval
   * @deprecated [DEPRECATED] Multiple polling interval is no longer supported, use only metrics_polling_interval
   */
  inventoryPollingInterval?: Maybe<Scalars['Int']['output']>;
  /** The parent linked account identifier. */
  linkedAccount?: Maybe<CloudLinkedAccount>;
  /** The data polling interval in seconds. */
  metricsPollingInterval?: Maybe<Scalars['Int']['output']>;
  /** The cloud service integration name. */
  name?: Maybe<Scalars['String']['output']>;
  /** The parent NewRelic account identifier. */
  nrAccountId: Scalars['Int']['output'];
  /** The cloud service used in the integration. */
  service?: Maybe<CloudService>;
  /** The object last update date, in epoch (Unix) time */
  updatedAt: Scalars['EpochSeconds']['output'];
};

/** QLDB */
export type CloudAwsQldbIntegrationInput = {
  /** Specify each AWS region that includes the resources that you want to monitor. */
  awsRegions?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  /** [DEPRECATED] Multiple polling interval is no longer supported, use only metrics_polling_interval */
  inventoryPollingInterval?: InputMaybe<Scalars['Int']['input']>;
  /** The linked account identifier. */
  linkedAccountId: Scalars['Int']['input'];
  /** The data polling interval in seconds. */
  metricsPollingInterval?: InputMaybe<Scalars['Int']['input']>;
};

/** Route53 Resolver Integration */
export type CloudAwsRoute53resolverIntegration = CloudIntegration & {
  __typename?: 'CloudAwsRoute53resolverIntegration';
  /** Specify each AWS region that includes the resources that you want to monitor. */
  awsRegions?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
  /** The object creation date, in epoch (Unix) time */
  createdAt: Scalars['EpochSeconds']['output'];
  /** The cloud service integration identifier. */
  id?: Maybe<Scalars['Int']['output']>;
  /**
   * [DEPRECATED] Multiple polling interval is no longer supported, use only metrics_polling_interval
   * @deprecated [DEPRECATED] Multiple polling interval is no longer supported, use only metrics_polling_interval
   */
  inventoryPollingInterval?: Maybe<Scalars['Int']['output']>;
  /** The parent linked account identifier. */
  linkedAccount?: Maybe<CloudLinkedAccount>;
  /** The data polling interval in seconds. */
  metricsPollingInterval?: Maybe<Scalars['Int']['output']>;
  /** The cloud service integration name. */
  name?: Maybe<Scalars['String']['output']>;
  /** The parent NewRelic account identifier. */
  nrAccountId: Scalars['Int']['output'];
  /** The cloud service used in the integration. */
  service?: Maybe<CloudService>;
  /** The object last update date, in epoch (Unix) time */
  updatedAt: Scalars['EpochSeconds']['output'];
};

/** Route53 Resolver */
export type CloudAwsRoute53resolverIntegrationInput = {
  /** Specify each AWS region that includes the resources that you want to monitor. */
  awsRegions?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  /** [DEPRECATED] Multiple polling interval is no longer supported, use only metrics_polling_interval */
  inventoryPollingInterval?: InputMaybe<Scalars['Int']['input']>;
  /** The linked account identifier. */
  linkedAccountId: Scalars['Int']['input'];
  /** The data polling interval in seconds. */
  metricsPollingInterval?: InputMaybe<Scalars['Int']['input']>;
};

/** Step Functions Integration */
export type CloudAwsStatesIntegration = CloudIntegration & {
  __typename?: 'CloudAwsStatesIntegration';
  /** Specify each AWS region that includes the resources that you want to monitor. */
  awsRegions?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
  /** The object creation date, in epoch (Unix) time */
  createdAt: Scalars['EpochSeconds']['output'];
  /** The cloud service integration identifier. */
  id?: Maybe<Scalars['Int']['output']>;
  /**
   * [DEPRECATED] Multiple polling interval is no longer supported, use only metrics_polling_interval
   * @deprecated [DEPRECATED] Multiple polling interval is no longer supported, use only metrics_polling_interval
   */
  inventoryPollingInterval?: Maybe<Scalars['Int']['output']>;
  /** The parent linked account identifier. */
  linkedAccount?: Maybe<CloudLinkedAccount>;
  /** The data polling interval in seconds. */
  metricsPollingInterval?: Maybe<Scalars['Int']['output']>;
  /** The cloud service integration name. */
  name?: Maybe<Scalars['String']['output']>;
  /** The parent NewRelic account identifier. */
  nrAccountId: Scalars['Int']['output'];
  /** The cloud service used in the integration. */
  service?: Maybe<CloudService>;
  /** The object last update date, in epoch (Unix) time */
  updatedAt: Scalars['EpochSeconds']['output'];
};

/** Step Functions */
export type CloudAwsStatesIntegrationInput = {
  /** Specify each AWS region that includes the resources that you want to monitor. */
  awsRegions?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  /** [DEPRECATED] Multiple polling interval is no longer supported, use only metrics_polling_interval */
  inventoryPollingInterval?: InputMaybe<Scalars['Int']['input']>;
  /** The linked account identifier. */
  linkedAccountId: Scalars['Int']['input'];
  /** The data polling interval in seconds. */
  metricsPollingInterval?: InputMaybe<Scalars['Int']['input']>;
};

/** Fetch tags for all integrations Integration */
export type CloudAwsTagsGlobalIntegration = CloudIntegration & {
  __typename?: 'CloudAwsTagsGlobalIntegration';
  /** The object creation date, in epoch (Unix) time */
  createdAt: Scalars['EpochSeconds']['output'];
  /** The cloud service integration identifier. */
  id?: Maybe<Scalars['Int']['output']>;
  /**
   * [DEPRECATED] Multiple polling interval is no longer supported, use only metrics_polling_interval
   * @deprecated [DEPRECATED] Multiple polling interval is no longer supported, use only metrics_polling_interval
   */
  inventoryPollingInterval?: Maybe<Scalars['Int']['output']>;
  /** The parent linked account identifier. */
  linkedAccount?: Maybe<CloudLinkedAccount>;
  /** The data polling interval in seconds. */
  metricsPollingInterval?: Maybe<Scalars['Int']['output']>;
  /** The cloud service integration name. */
  name?: Maybe<Scalars['String']['output']>;
  /** The parent NewRelic account identifier. */
  nrAccountId: Scalars['Int']['output'];
  /** The cloud service used in the integration. */
  service?: Maybe<CloudService>;
  /** The object last update date, in epoch (Unix) time */
  updatedAt: Scalars['EpochSeconds']['output'];
};

/** Fetch tags for all integrations */
export type CloudAwsTagsGlobalIntegrationInput = {
  /** [DEPRECATED] Multiple polling interval is no longer supported, use only metrics_polling_interval */
  inventoryPollingInterval?: InputMaybe<Scalars['Int']['input']>;
  /** The linked account identifier. */
  linkedAccountId: Scalars['Int']['input'];
  /** The data polling interval in seconds. */
  metricsPollingInterval?: InputMaybe<Scalars['Int']['input']>;
};

/** Transit Gateway Integration */
export type CloudAwsTransitgatewayIntegration = CloudIntegration & {
  __typename?: 'CloudAwsTransitgatewayIntegration';
  /** Specify each AWS region that includes the resources that you want to monitor. */
  awsRegions?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
  /** The object creation date, in epoch (Unix) time */
  createdAt: Scalars['EpochSeconds']['output'];
  /** The cloud service integration identifier. */
  id?: Maybe<Scalars['Int']['output']>;
  /**
   * [DEPRECATED] Multiple polling interval is no longer supported, use only metrics_polling_interval
   * @deprecated [DEPRECATED] Multiple polling interval is no longer supported, use only metrics_polling_interval
   */
  inventoryPollingInterval?: Maybe<Scalars['Int']['output']>;
  /** The parent linked account identifier. */
  linkedAccount?: Maybe<CloudLinkedAccount>;
  /** The data polling interval in seconds. */
  metricsPollingInterval?: Maybe<Scalars['Int']['output']>;
  /** The cloud service integration name. */
  name?: Maybe<Scalars['String']['output']>;
  /** The parent NewRelic account identifier. */
  nrAccountId: Scalars['Int']['output'];
  /** The cloud service used in the integration. */
  service?: Maybe<CloudService>;
  /** The object last update date, in epoch (Unix) time */
  updatedAt: Scalars['EpochSeconds']['output'];
};

/** Transit Gateway */
export type CloudAwsTransitgatewayIntegrationInput = {
  /** Specify each AWS region that includes the resources that you want to monitor. */
  awsRegions?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  /** [DEPRECATED] Multiple polling interval is no longer supported, use only metrics_polling_interval */
  inventoryPollingInterval?: InputMaybe<Scalars['Int']['input']>;
  /** The linked account identifier. */
  linkedAccountId: Scalars['Int']['input'];
  /** The data polling interval in seconds. */
  metricsPollingInterval?: InputMaybe<Scalars['Int']['input']>;
};

/** WAF Integration */
export type CloudAwsWafIntegration = CloudIntegration & {
  __typename?: 'CloudAwsWafIntegration';
  /** Specify each AWS region that includes the resources that you want to monitor. */
  awsRegions?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
  /** The object creation date, in epoch (Unix) time */
  createdAt: Scalars['EpochSeconds']['output'];
  /** The cloud service integration identifier. */
  id?: Maybe<Scalars['Int']['output']>;
  /**
   * [DEPRECATED] Multiple polling interval is no longer supported, use only metrics_polling_interval
   * @deprecated [DEPRECATED] Multiple polling interval is no longer supported, use only metrics_polling_interval
   */
  inventoryPollingInterval?: Maybe<Scalars['Int']['output']>;
  /** The parent linked account identifier. */
  linkedAccount?: Maybe<CloudLinkedAccount>;
  /** The data polling interval in seconds. */
  metricsPollingInterval?: Maybe<Scalars['Int']['output']>;
  /** The cloud service integration name. */
  name?: Maybe<Scalars['String']['output']>;
  /** The parent NewRelic account identifier. */
  nrAccountId: Scalars['Int']['output'];
  /** The cloud service used in the integration. */
  service?: Maybe<CloudService>;
  /** The object last update date, in epoch (Unix) time */
  updatedAt: Scalars['EpochSeconds']['output'];
};

/** WAF */
export type CloudAwsWafIntegrationInput = {
  /** Specify each AWS region that includes the resources that you want to monitor. */
  awsRegions?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  /** [DEPRECATED] Multiple polling interval is no longer supported, use only metrics_polling_interval */
  inventoryPollingInterval?: InputMaybe<Scalars['Int']['input']>;
  /** The linked account identifier. */
  linkedAccountId: Scalars['Int']['input'];
  /** The data polling interval in seconds. */
  metricsPollingInterval?: InputMaybe<Scalars['Int']['input']>;
};

/** WAFV2 Integration */
export type CloudAwsWafv2Integration = CloudIntegration & {
  __typename?: 'CloudAwsWafv2Integration';
  /** Specify each AWS region that includes the resources that you want to monitor. */
  awsRegions?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
  /** The object creation date, in epoch (Unix) time */
  createdAt: Scalars['EpochSeconds']['output'];
  /** The cloud service integration identifier. */
  id?: Maybe<Scalars['Int']['output']>;
  /**
   * [DEPRECATED] Multiple polling interval is no longer supported, use only metrics_polling_interval
   * @deprecated [DEPRECATED] Multiple polling interval is no longer supported, use only metrics_polling_interval
   */
  inventoryPollingInterval?: Maybe<Scalars['Int']['output']>;
  /** The parent linked account identifier. */
  linkedAccount?: Maybe<CloudLinkedAccount>;
  /** The data polling interval in seconds. */
  metricsPollingInterval?: Maybe<Scalars['Int']['output']>;
  /** The cloud service integration name. */
  name?: Maybe<Scalars['String']['output']>;
  /** The parent NewRelic account identifier. */
  nrAccountId: Scalars['Int']['output'];
  /** The cloud service used in the integration. */
  service?: Maybe<CloudService>;
  /** The object last update date, in epoch (Unix) time */
  updatedAt: Scalars['EpochSeconds']['output'];
};

/** WAFV2 */
export type CloudAwsWafv2IntegrationInput = {
  /** Specify each AWS region that includes the resources that you want to monitor. */
  awsRegions?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  /** [DEPRECATED] Multiple polling interval is no longer supported, use only metrics_polling_interval */
  inventoryPollingInterval?: InputMaybe<Scalars['Int']['input']>;
  /** The linked account identifier. */
  linkedAccountId: Scalars['Int']['input'];
  /** The data polling interval in seconds. */
  metricsPollingInterval?: InputMaybe<Scalars['Int']['input']>;
};

/** X-Ray Integration */
export type CloudAwsXrayIntegration = CloudIntegration & {
  __typename?: 'CloudAwsXrayIntegration';
  /** Specify each AWS region that includes the resources that you want to monitor. */
  awsRegions?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
  /** The object creation date, in epoch (Unix) time */
  createdAt: Scalars['EpochSeconds']['output'];
  /** The cloud service integration identifier. */
  id?: Maybe<Scalars['Int']['output']>;
  /**
   * [DEPRECATED] Multiple polling interval is no longer supported, use only metrics_polling_interval
   * @deprecated [DEPRECATED] Multiple polling interval is no longer supported, use only metrics_polling_interval
   */
  inventoryPollingInterval?: Maybe<Scalars['Int']['output']>;
  /** The parent linked account identifier. */
  linkedAccount?: Maybe<CloudLinkedAccount>;
  /** The data polling interval in seconds. */
  metricsPollingInterval?: Maybe<Scalars['Int']['output']>;
  /** The cloud service integration name. */
  name?: Maybe<Scalars['String']['output']>;
  /** The parent NewRelic account identifier. */
  nrAccountId: Scalars['Int']['output'];
  /** The cloud service used in the integration. */
  service?: Maybe<CloudService>;
  /** The object last update date, in epoch (Unix) time */
  updatedAt: Scalars['EpochSeconds']['output'];
};

/** X-Ray */
export type CloudAwsXrayIntegrationInput = {
  /** Specify each AWS region that includes the resources that you want to monitor. */
  awsRegions?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  /** [DEPRECATED] Multiple polling interval is no longer supported, use only metrics_polling_interval */
  inventoryPollingInterval?: InputMaybe<Scalars['Int']['input']>;
  /** The linked account identifier. */
  linkedAccountId: Scalars['Int']['input'];
  /** The data polling interval in seconds. */
  metricsPollingInterval?: InputMaybe<Scalars['Int']['input']>;
};

/** Api Management Integration */
export type CloudAzureApimanagementIntegration = CloudIntegration & {
  __typename?: 'CloudAzureApimanagementIntegration';
  /** The object creation date, in epoch (Unix) time */
  createdAt: Scalars['EpochSeconds']['output'];
  /** The cloud service integration identifier. */
  id?: Maybe<Scalars['Int']['output']>;
  /**
   * [DEPRECATED] Multiple polling interval is no longer supported, use only metrics_polling_interval
   * @deprecated [DEPRECATED] Multiple polling interval is no longer supported, use only metrics_polling_interval
   */
  inventoryPollingInterval?: Maybe<Scalars['Int']['output']>;
  /** The parent linked account identifier. */
  linkedAccount?: Maybe<CloudLinkedAccount>;
  /** The data polling interval in seconds. */
  metricsPollingInterval?: Maybe<Scalars['Int']['output']>;
  /** The cloud service integration name. */
  name?: Maybe<Scalars['String']['output']>;
  /** The parent NewRelic account identifier. */
  nrAccountId: Scalars['Int']['output'];
  /** Specify each Resource group associated with the resources that you want to monitor. Filter values are case-sensitive. */
  resourceGroups?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
  /** The cloud service used in the integration. */
  service?: Maybe<CloudService>;
  /** The object last update date, in epoch (Unix) time */
  updatedAt: Scalars['EpochSeconds']['output'];
};

/** Api Management */
export type CloudAzureApimanagementIntegrationInput = {
  /** [DEPRECATED] Multiple polling interval is no longer supported, use only metrics_polling_interval */
  inventoryPollingInterval?: InputMaybe<Scalars['Int']['input']>;
  /** The linked account identifier. */
  linkedAccountId: Scalars['Int']['input'];
  /** The data polling interval in seconds. */
  metricsPollingInterval?: InputMaybe<Scalars['Int']['input']>;
  /** Specify each Resource group associated with the resources that you want to monitor. Filter values are case-sensitive. */
  resourceGroups?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
};

/** App Gateway Integration */
export type CloudAzureAppgatewayIntegration = CloudIntegration & {
  __typename?: 'CloudAzureAppgatewayIntegration';
  /** The object creation date, in epoch (Unix) time */
  createdAt: Scalars['EpochSeconds']['output'];
  /** The cloud service integration identifier. */
  id?: Maybe<Scalars['Int']['output']>;
  /**
   * [DEPRECATED] Multiple polling interval is no longer supported, use only metrics_polling_interval
   * @deprecated [DEPRECATED] Multiple polling interval is no longer supported, use only metrics_polling_interval
   */
  inventoryPollingInterval?: Maybe<Scalars['Int']['output']>;
  /** The parent linked account identifier. */
  linkedAccount?: Maybe<CloudLinkedAccount>;
  /** The data polling interval in seconds. */
  metricsPollingInterval?: Maybe<Scalars['Int']['output']>;
  /** The cloud service integration name. */
  name?: Maybe<Scalars['String']['output']>;
  /** The parent NewRelic account identifier. */
  nrAccountId: Scalars['Int']['output'];
  /** Specify each Resource group associated with the resources that you want to monitor. Filter values are case-sensitive. */
  resourceGroups?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
  /** The cloud service used in the integration. */
  service?: Maybe<CloudService>;
  /** The object last update date, in epoch (Unix) time */
  updatedAt: Scalars['EpochSeconds']['output'];
};

/** App Gateway */
export type CloudAzureAppgatewayIntegrationInput = {
  /** [DEPRECATED] Multiple polling interval is no longer supported, use only metrics_polling_interval */
  inventoryPollingInterval?: InputMaybe<Scalars['Int']['input']>;
  /** The linked account identifier. */
  linkedAccountId: Scalars['Int']['input'];
  /** The data polling interval in seconds. */
  metricsPollingInterval?: InputMaybe<Scalars['Int']['input']>;
  /** Specify each Resource group associated with the resources that you want to monitor. Filter values are case-sensitive. */
  resourceGroups?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
};

/** App Service Integration */
export type CloudAzureAppserviceIntegration = CloudIntegration & {
  __typename?: 'CloudAzureAppserviceIntegration';
  /** The object creation date, in epoch (Unix) time */
  createdAt: Scalars['EpochSeconds']['output'];
  /** The cloud service integration identifier. */
  id?: Maybe<Scalars['Int']['output']>;
  /**
   * [DEPRECATED] Multiple polling interval is no longer supported, use only metrics_polling_interval
   * @deprecated [DEPRECATED] Multiple polling interval is no longer supported, use only metrics_polling_interval
   */
  inventoryPollingInterval?: Maybe<Scalars['Int']['output']>;
  /** The parent linked account identifier. */
  linkedAccount?: Maybe<CloudLinkedAccount>;
  /** The data polling interval in seconds. */
  metricsPollingInterval?: Maybe<Scalars['Int']['output']>;
  /** The cloud service integration name. */
  name?: Maybe<Scalars['String']['output']>;
  /** The parent NewRelic account identifier. */
  nrAccountId: Scalars['Int']['output'];
  /** Specify each Resource group associated with the resources that you want to monitor. Filter values are case-sensitive. */
  resourceGroups?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
  /** The cloud service used in the integration. */
  service?: Maybe<CloudService>;
  /** The object last update date, in epoch (Unix) time */
  updatedAt: Scalars['EpochSeconds']['output'];
};

/** Azure App Service */
export type CloudAzureAppserviceIntegrationInput = {
  /** [DEPRECATED] Multiple polling interval is no longer supported, use only metrics_polling_interval */
  inventoryPollingInterval?: InputMaybe<Scalars['Int']['input']>;
  /** The linked account identifier. */
  linkedAccountId: Scalars['Int']['input'];
  /** The data polling interval in seconds. */
  metricsPollingInterval?: InputMaybe<Scalars['Int']['input']>;
  /** Specify each Resource group associated with the resources that you want to monitor. Filter values are case-sensitive. */
  resourceGroups?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
};

/** Containers Integration */
export type CloudAzureContainersIntegration = CloudIntegration & {
  __typename?: 'CloudAzureContainersIntegration';
  /** The object creation date, in epoch (Unix) time */
  createdAt: Scalars['EpochSeconds']['output'];
  /** The cloud service integration identifier. */
  id?: Maybe<Scalars['Int']['output']>;
  /**
   * [DEPRECATED] Multiple polling interval is no longer supported, use only metrics_polling_interval
   * @deprecated [DEPRECATED] Multiple polling interval is no longer supported, use only metrics_polling_interval
   */
  inventoryPollingInterval?: Maybe<Scalars['Int']['output']>;
  /** The parent linked account identifier. */
  linkedAccount?: Maybe<CloudLinkedAccount>;
  /** The data polling interval in seconds. */
  metricsPollingInterval?: Maybe<Scalars['Int']['output']>;
  /** The cloud service integration name. */
  name?: Maybe<Scalars['String']['output']>;
  /** The parent NewRelic account identifier. */
  nrAccountId: Scalars['Int']['output'];
  /** Specify each Resource group associated with the resources that you want to monitor. Filter values are case-sensitive. */
  resourceGroups?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
  /** The cloud service used in the integration. */
  service?: Maybe<CloudService>;
  /** The object last update date, in epoch (Unix) time */
  updatedAt: Scalars['EpochSeconds']['output'];
};

/** Containers */
export type CloudAzureContainersIntegrationInput = {
  /** [DEPRECATED] Multiple polling interval is no longer supported, use only metrics_polling_interval */
  inventoryPollingInterval?: InputMaybe<Scalars['Int']['input']>;
  /** The linked account identifier. */
  linkedAccountId: Scalars['Int']['input'];
  /** The data polling interval in seconds. */
  metricsPollingInterval?: InputMaybe<Scalars['Int']['input']>;
  /** Specify each Resource group associated with the resources that you want to monitor. Filter values are case-sensitive. */
  resourceGroups?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
};

/** Cosmos DB Integration */
export type CloudAzureCosmosdbIntegration = CloudIntegration & {
  __typename?: 'CloudAzureCosmosdbIntegration';
  /** The object creation date, in epoch (Unix) time */
  createdAt: Scalars['EpochSeconds']['output'];
  /** The cloud service integration identifier. */
  id?: Maybe<Scalars['Int']['output']>;
  /**
   * [DEPRECATED] Multiple polling interval is no longer supported, use only metrics_polling_interval
   * @deprecated [DEPRECATED] Multiple polling interval is no longer supported, use only metrics_polling_interval
   */
  inventoryPollingInterval?: Maybe<Scalars['Int']['output']>;
  /** The parent linked account identifier. */
  linkedAccount?: Maybe<CloudLinkedAccount>;
  /** The data polling interval in seconds. */
  metricsPollingInterval?: Maybe<Scalars['Int']['output']>;
  /** The cloud service integration name. */
  name?: Maybe<Scalars['String']['output']>;
  /** The parent NewRelic account identifier. */
  nrAccountId: Scalars['Int']['output'];
  /** Specify each Resource group associated with the resources that you want to monitor. Filter values are case-sensitive. */
  resourceGroups?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
  /** The cloud service used in the integration. */
  service?: Maybe<CloudService>;
  /** The object last update date, in epoch (Unix) time */
  updatedAt: Scalars['EpochSeconds']['output'];
};

/** Azure Cosmos DB */
export type CloudAzureCosmosdbIntegrationInput = {
  /** [DEPRECATED] Multiple polling interval is no longer supported, use only metrics_polling_interval */
  inventoryPollingInterval?: InputMaybe<Scalars['Int']['input']>;
  /** The linked account identifier. */
  linkedAccountId: Scalars['Int']['input'];
  /** The data polling interval in seconds. */
  metricsPollingInterval?: InputMaybe<Scalars['Int']['input']>;
  /** Specify each Resource group associated with the resources that you want to monitor. Filter values are case-sensitive. */
  resourceGroups?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
};

/** Cost Management Integration */
export type CloudAzureCostmanagementIntegration = CloudIntegration & {
  __typename?: 'CloudAzureCostmanagementIntegration';
  /** The object creation date, in epoch (Unix) time */
  createdAt: Scalars['EpochSeconds']['output'];
  /** The cloud service integration identifier. */
  id?: Maybe<Scalars['Int']['output']>;
  /**
   * [DEPRECATED] Multiple polling interval is no longer supported, use only metrics_polling_interval
   * @deprecated [DEPRECATED] Multiple polling interval is no longer supported, use only metrics_polling_interval
   */
  inventoryPollingInterval?: Maybe<Scalars['Int']['output']>;
  /** The parent linked account identifier. */
  linkedAccount?: Maybe<CloudLinkedAccount>;
  /** The data polling interval in seconds. */
  metricsPollingInterval?: Maybe<Scalars['Int']['output']>;
  /** The cloud service integration name. */
  name?: Maybe<Scalars['String']['output']>;
  /** The parent NewRelic account identifier. */
  nrAccountId: Scalars['Int']['output'];
  /** The cloud service used in the integration. */
  service?: Maybe<CloudService>;
  /** Specify if additional cost data per tag should be collected. This field is case sensitive. */
  tagKeys?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
  /** The object last update date, in epoch (Unix) time */
  updatedAt: Scalars['EpochSeconds']['output'];
};

/** Cost Management */
export type CloudAzureCostmanagementIntegrationInput = {
  /** [DEPRECATED] Multiple polling interval is no longer supported, use only metrics_polling_interval */
  inventoryPollingInterval?: InputMaybe<Scalars['Int']['input']>;
  /** The linked account identifier. */
  linkedAccountId: Scalars['Int']['input'];
  /** The data polling interval in seconds. */
  metricsPollingInterval?: InputMaybe<Scalars['Int']['input']>;
  /** Specify if additional cost data per tag should be collected. This field is case sensitive. */
  tagKeys?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
};

/** Data Factory Integration */
export type CloudAzureDatafactoryIntegration = CloudIntegration & {
  __typename?: 'CloudAzureDatafactoryIntegration';
  /** The object creation date, in epoch (Unix) time */
  createdAt: Scalars['EpochSeconds']['output'];
  /** The cloud service integration identifier. */
  id?: Maybe<Scalars['Int']['output']>;
  /**
   * [DEPRECATED] Multiple polling interval is no longer supported, use only metrics_polling_interval
   * @deprecated [DEPRECATED] Multiple polling interval is no longer supported, use only metrics_polling_interval
   */
  inventoryPollingInterval?: Maybe<Scalars['Int']['output']>;
  /** The parent linked account identifier. */
  linkedAccount?: Maybe<CloudLinkedAccount>;
  /** The data polling interval in seconds. */
  metricsPollingInterval?: Maybe<Scalars['Int']['output']>;
  /** The cloud service integration name. */
  name?: Maybe<Scalars['String']['output']>;
  /** The parent NewRelic account identifier. */
  nrAccountId: Scalars['Int']['output'];
  /** Specify each Resource group associated with the resources that you want to monitor. Filter values are case-sensitive. */
  resourceGroups?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
  /** The cloud service used in the integration. */
  service?: Maybe<CloudService>;
  /** The object last update date, in epoch (Unix) time */
  updatedAt: Scalars['EpochSeconds']['output'];
};

/** Data Factory */
export type CloudAzureDatafactoryIntegrationInput = {
  /** [DEPRECATED] Multiple polling interval is no longer supported, use only metrics_polling_interval */
  inventoryPollingInterval?: InputMaybe<Scalars['Int']['input']>;
  /** The linked account identifier. */
  linkedAccountId: Scalars['Int']['input'];
  /** The data polling interval in seconds. */
  metricsPollingInterval?: InputMaybe<Scalars['Int']['input']>;
  /** Specify each Resource group associated with the resources that you want to monitor. Filter values are case-sensitive. */
  resourceGroups?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
};

/** List of integrations */
export type CloudAzureDisableIntegrationsInput = {
  /** Api Management integration */
  azureApimanagement?: InputMaybe<Array<InputMaybe<CloudDisableAccountIntegrationInput>>>;
  /** App Gateway integration */
  azureAppgateway?: InputMaybe<Array<InputMaybe<CloudDisableAccountIntegrationInput>>>;
  /** App Service integration */
  azureAppservice?: InputMaybe<Array<InputMaybe<CloudDisableAccountIntegrationInput>>>;
  /** Containers integration */
  azureContainers?: InputMaybe<Array<InputMaybe<CloudDisableAccountIntegrationInput>>>;
  /** Cosmos DB integration */
  azureCosmosdb?: InputMaybe<Array<InputMaybe<CloudDisableAccountIntegrationInput>>>;
  /** Cost Management integration */
  azureCostmanagement?: InputMaybe<Array<InputMaybe<CloudDisableAccountIntegrationInput>>>;
  /** Data Factory integration */
  azureDatafactory?: InputMaybe<Array<InputMaybe<CloudDisableAccountIntegrationInput>>>;
  /** Event Hub integration */
  azureEventhub?: InputMaybe<Array<InputMaybe<CloudDisableAccountIntegrationInput>>>;
  /** Express Route integration */
  azureExpressroute?: InputMaybe<Array<InputMaybe<CloudDisableAccountIntegrationInput>>>;
  /** Firewalls integration */
  azureFirewalls?: InputMaybe<Array<InputMaybe<CloudDisableAccountIntegrationInput>>>;
  /** Front Door integration */
  azureFrontdoor?: InputMaybe<Array<InputMaybe<CloudDisableAccountIntegrationInput>>>;
  /** Functions integration */
  azureFunctions?: InputMaybe<Array<InputMaybe<CloudDisableAccountIntegrationInput>>>;
  /** Key Vault integration */
  azureKeyvault?: InputMaybe<Array<InputMaybe<CloudDisableAccountIntegrationInput>>>;
  /** Load Balancer integration */
  azureLoadbalancer?: InputMaybe<Array<InputMaybe<CloudDisableAccountIntegrationInput>>>;
  /** Logic Apps integration */
  azureLogicapps?: InputMaybe<Array<InputMaybe<CloudDisableAccountIntegrationInput>>>;
  /** Machine Learning integration */
  azureMachinelearning?: InputMaybe<Array<InputMaybe<CloudDisableAccountIntegrationInput>>>;
  /** Database for MariaDB integration */
  azureMariadb?: InputMaybe<Array<InputMaybe<CloudDisableAccountIntegrationInput>>>;
  /** Azure Monitor metrics integration */
  azureMonitor?: InputMaybe<Array<InputMaybe<CloudDisableAccountIntegrationInput>>>;
  /** Database for MySQL integration */
  azureMysql?: InputMaybe<Array<InputMaybe<CloudDisableAccountIntegrationInput>>>;
  /** MySQL Flexible Server integration */
  azureMysqlflexible?: InputMaybe<Array<InputMaybe<CloudDisableAccountIntegrationInput>>>;
  /** Database for PostgreSQL integration */
  azurePostgresql?: InputMaybe<Array<InputMaybe<CloudDisableAccountIntegrationInput>>>;
  /** PostgreSQL Flexible Server integration */
  azurePostgresqlflexible?: InputMaybe<Array<InputMaybe<CloudDisableAccountIntegrationInput>>>;
  /** Power BI Dedicated integration */
  azurePowerbidedicated?: InputMaybe<Array<InputMaybe<CloudDisableAccountIntegrationInput>>>;
  /** Redis Cache integration */
  azureRediscache?: InputMaybe<Array<InputMaybe<CloudDisableAccountIntegrationInput>>>;
  /** Service Bus integration */
  azureServicebus?: InputMaybe<Array<InputMaybe<CloudDisableAccountIntegrationInput>>>;
  /** SQL Database integration */
  azureSql?: InputMaybe<Array<InputMaybe<CloudDisableAccountIntegrationInput>>>;
  /** SQL Managed Instances integration */
  azureSqlmanaged?: InputMaybe<Array<InputMaybe<CloudDisableAccountIntegrationInput>>>;
  /** Storage integration */
  azureStorage?: InputMaybe<Array<InputMaybe<CloudDisableAccountIntegrationInput>>>;
  /** Virtual machine scale sets integration */
  azureVirtualmachine?: InputMaybe<Array<InputMaybe<CloudDisableAccountIntegrationInput>>>;
  /** Virtual Network integration */
  azureVirtualnetworks?: InputMaybe<Array<InputMaybe<CloudDisableAccountIntegrationInput>>>;
  /** Virtual Machines integration */
  azureVms?: InputMaybe<Array<InputMaybe<CloudDisableAccountIntegrationInput>>>;
  /** VPN Gateways integration */
  azureVpngateways?: InputMaybe<Array<InputMaybe<CloudDisableAccountIntegrationInput>>>;
};

/** Event Hub Integration */
export type CloudAzureEventhubIntegration = CloudIntegration & {
  __typename?: 'CloudAzureEventhubIntegration';
  /** The object creation date, in epoch (Unix) time */
  createdAt: Scalars['EpochSeconds']['output'];
  /** The cloud service integration identifier. */
  id?: Maybe<Scalars['Int']['output']>;
  /**
   * [DEPRECATED] Multiple polling interval is no longer supported, use only metrics_polling_interval
   * @deprecated [DEPRECATED] Multiple polling interval is no longer supported, use only metrics_polling_interval
   */
  inventoryPollingInterval?: Maybe<Scalars['Int']['output']>;
  /** The parent linked account identifier. */
  linkedAccount?: Maybe<CloudLinkedAccount>;
  /** The data polling interval in seconds. */
  metricsPollingInterval?: Maybe<Scalars['Int']['output']>;
  /** The cloud service integration name. */
  name?: Maybe<Scalars['String']['output']>;
  /** The parent NewRelic account identifier. */
  nrAccountId: Scalars['Int']['output'];
  /** Specify each Resource group associated with the resources that you want to monitor. Filter values are case-sensitive. */
  resourceGroups?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
  /** The cloud service used in the integration. */
  service?: Maybe<CloudService>;
  /** The object last update date, in epoch (Unix) time */
  updatedAt: Scalars['EpochSeconds']['output'];
};

/** Event Hub */
export type CloudAzureEventhubIntegrationInput = {
  /** [DEPRECATED] Multiple polling interval is no longer supported, use only metrics_polling_interval */
  inventoryPollingInterval?: InputMaybe<Scalars['Int']['input']>;
  /** The linked account identifier. */
  linkedAccountId: Scalars['Int']['input'];
  /** The data polling interval in seconds. */
  metricsPollingInterval?: InputMaybe<Scalars['Int']['input']>;
  /** Specify each Resource group associated with the resources that you want to monitor. Filter values are case-sensitive. */
  resourceGroups?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
};

/** Express Route Integration */
export type CloudAzureExpressrouteIntegration = CloudIntegration & {
  __typename?: 'CloudAzureExpressrouteIntegration';
  /** The object creation date, in epoch (Unix) time */
  createdAt: Scalars['EpochSeconds']['output'];
  /** The cloud service integration identifier. */
  id?: Maybe<Scalars['Int']['output']>;
  /**
   * [DEPRECATED] Multiple polling interval is no longer supported, use only metrics_polling_interval
   * @deprecated [DEPRECATED] Multiple polling interval is no longer supported, use only metrics_polling_interval
   */
  inventoryPollingInterval?: Maybe<Scalars['Int']['output']>;
  /** The parent linked account identifier. */
  linkedAccount?: Maybe<CloudLinkedAccount>;
  /** The data polling interval in seconds. */
  metricsPollingInterval?: Maybe<Scalars['Int']['output']>;
  /** The cloud service integration name. */
  name?: Maybe<Scalars['String']['output']>;
  /** The parent NewRelic account identifier. */
  nrAccountId: Scalars['Int']['output'];
  /** Specify each Resource group associated with the resources that you want to monitor. Filter values are case-sensitive. */
  resourceGroups?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
  /** The cloud service used in the integration. */
  service?: Maybe<CloudService>;
  /** The object last update date, in epoch (Unix) time */
  updatedAt: Scalars['EpochSeconds']['output'];
};

/** Express Route */
export type CloudAzureExpressrouteIntegrationInput = {
  /** [DEPRECATED] Multiple polling interval is no longer supported, use only metrics_polling_interval */
  inventoryPollingInterval?: InputMaybe<Scalars['Int']['input']>;
  /** The linked account identifier. */
  linkedAccountId: Scalars['Int']['input'];
  /** The data polling interval in seconds. */
  metricsPollingInterval?: InputMaybe<Scalars['Int']['input']>;
  /** Specify each Resource group associated with the resources that you want to monitor. Filter values are case-sensitive. */
  resourceGroups?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
};

/** Firewalls Integration */
export type CloudAzureFirewallsIntegration = CloudIntegration & {
  __typename?: 'CloudAzureFirewallsIntegration';
  /** The object creation date, in epoch (Unix) time */
  createdAt: Scalars['EpochSeconds']['output'];
  /** The cloud service integration identifier. */
  id?: Maybe<Scalars['Int']['output']>;
  /**
   * [DEPRECATED] Multiple polling interval is no longer supported, use only metrics_polling_interval
   * @deprecated [DEPRECATED] Multiple polling interval is no longer supported, use only metrics_polling_interval
   */
  inventoryPollingInterval?: Maybe<Scalars['Int']['output']>;
  /** The parent linked account identifier. */
  linkedAccount?: Maybe<CloudLinkedAccount>;
  /** The data polling interval in seconds. */
  metricsPollingInterval?: Maybe<Scalars['Int']['output']>;
  /** The cloud service integration name. */
  name?: Maybe<Scalars['String']['output']>;
  /** The parent NewRelic account identifier. */
  nrAccountId: Scalars['Int']['output'];
  /** Specify each Resource group associated with the resources that you want to monitor. Filter values are case-sensitive. */
  resourceGroups?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
  /** The cloud service used in the integration. */
  service?: Maybe<CloudService>;
  /** The object last update date, in epoch (Unix) time */
  updatedAt: Scalars['EpochSeconds']['output'];
};

/** Firewalls */
export type CloudAzureFirewallsIntegrationInput = {
  /** [DEPRECATED] Multiple polling interval is no longer supported, use only metrics_polling_interval */
  inventoryPollingInterval?: InputMaybe<Scalars['Int']['input']>;
  /** The linked account identifier. */
  linkedAccountId: Scalars['Int']['input'];
  /** The data polling interval in seconds. */
  metricsPollingInterval?: InputMaybe<Scalars['Int']['input']>;
  /** Specify each Resource group associated with the resources that you want to monitor. Filter values are case-sensitive. */
  resourceGroups?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
};

/** Front Door Integration */
export type CloudAzureFrontdoorIntegration = CloudIntegration & {
  __typename?: 'CloudAzureFrontdoorIntegration';
  /** The object creation date, in epoch (Unix) time */
  createdAt: Scalars['EpochSeconds']['output'];
  /** The cloud service integration identifier. */
  id?: Maybe<Scalars['Int']['output']>;
  /**
   * [DEPRECATED] Multiple polling interval is no longer supported, use only metrics_polling_interval
   * @deprecated [DEPRECATED] Multiple polling interval is no longer supported, use only metrics_polling_interval
   */
  inventoryPollingInterval?: Maybe<Scalars['Int']['output']>;
  /** The parent linked account identifier. */
  linkedAccount?: Maybe<CloudLinkedAccount>;
  /** The data polling interval in seconds. */
  metricsPollingInterval?: Maybe<Scalars['Int']['output']>;
  /** The cloud service integration name. */
  name?: Maybe<Scalars['String']['output']>;
  /** The parent NewRelic account identifier. */
  nrAccountId: Scalars['Int']['output'];
  /** Specify each Resource group associated with the resources that you want to monitor. Filter values are case-sensitive. */
  resourceGroups?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
  /** The cloud service used in the integration. */
  service?: Maybe<CloudService>;
  /** The object last update date, in epoch (Unix) time */
  updatedAt: Scalars['EpochSeconds']['output'];
};

/** Front Door */
export type CloudAzureFrontdoorIntegrationInput = {
  /** [DEPRECATED] Multiple polling interval is no longer supported, use only metrics_polling_interval */
  inventoryPollingInterval?: InputMaybe<Scalars['Int']['input']>;
  /** The linked account identifier. */
  linkedAccountId: Scalars['Int']['input'];
  /** The data polling interval in seconds. */
  metricsPollingInterval?: InputMaybe<Scalars['Int']['input']>;
  /** Specify each Resource group associated with the resources that you want to monitor. Filter values are case-sensitive. */
  resourceGroups?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
};

/** Functions Integration */
export type CloudAzureFunctionsIntegration = CloudIntegration & {
  __typename?: 'CloudAzureFunctionsIntegration';
  /** The object creation date, in epoch (Unix) time */
  createdAt: Scalars['EpochSeconds']['output'];
  /** The cloud service integration identifier. */
  id?: Maybe<Scalars['Int']['output']>;
  /**
   * [DEPRECATED] Multiple polling interval is no longer supported, use only metrics_polling_interval
   * @deprecated [DEPRECATED] Multiple polling interval is no longer supported, use only metrics_polling_interval
   */
  inventoryPollingInterval?: Maybe<Scalars['Int']['output']>;
  /** The parent linked account identifier. */
  linkedAccount?: Maybe<CloudLinkedAccount>;
  /** The data polling interval in seconds. */
  metricsPollingInterval?: Maybe<Scalars['Int']['output']>;
  /** The cloud service integration name. */
  name?: Maybe<Scalars['String']['output']>;
  /** The parent NewRelic account identifier. */
  nrAccountId: Scalars['Int']['output'];
  /** Specify each Resource group associated with the resources that you want to monitor. Filter values are case-sensitive. */
  resourceGroups?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
  /** The cloud service used in the integration. */
  service?: Maybe<CloudService>;
  /** The object last update date, in epoch (Unix) time */
  updatedAt: Scalars['EpochSeconds']['output'];
};

/** Azure Functions */
export type CloudAzureFunctionsIntegrationInput = {
  /** [DEPRECATED] Multiple polling interval is no longer supported, use only metrics_polling_interval */
  inventoryPollingInterval?: InputMaybe<Scalars['Int']['input']>;
  /** The linked account identifier. */
  linkedAccountId: Scalars['Int']['input'];
  /** The data polling interval in seconds. */
  metricsPollingInterval?: InputMaybe<Scalars['Int']['input']>;
  /** Specify each Resource group associated with the resources that you want to monitor. Filter values are case-sensitive. */
  resourceGroups?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
};

/** List of integrations */
export type CloudAzureIntegrationsInput = {
  /** Api Management integration */
  azureApimanagement?: InputMaybe<Array<InputMaybe<CloudAzureApimanagementIntegrationInput>>>;
  /** App Gateway integration */
  azureAppgateway?: InputMaybe<Array<InputMaybe<CloudAzureAppgatewayIntegrationInput>>>;
  /** App Service integration */
  azureAppservice?: InputMaybe<Array<InputMaybe<CloudAzureAppserviceIntegrationInput>>>;
  /** Containers integration */
  azureContainers?: InputMaybe<Array<InputMaybe<CloudAzureContainersIntegrationInput>>>;
  /** Cosmos DB integration */
  azureCosmosdb?: InputMaybe<Array<InputMaybe<CloudAzureCosmosdbIntegrationInput>>>;
  /** Cost Management integration */
  azureCostmanagement?: InputMaybe<Array<InputMaybe<CloudAzureCostmanagementIntegrationInput>>>;
  /** Data Factory integration */
  azureDatafactory?: InputMaybe<Array<InputMaybe<CloudAzureDatafactoryIntegrationInput>>>;
  /** Event Hub integration */
  azureEventhub?: InputMaybe<Array<InputMaybe<CloudAzureEventhubIntegrationInput>>>;
  /** Express Route integration */
  azureExpressroute?: InputMaybe<Array<InputMaybe<CloudAzureExpressrouteIntegrationInput>>>;
  /** Firewalls integration */
  azureFirewalls?: InputMaybe<Array<InputMaybe<CloudAzureFirewallsIntegrationInput>>>;
  /** Front Door integration */
  azureFrontdoor?: InputMaybe<Array<InputMaybe<CloudAzureFrontdoorIntegrationInput>>>;
  /** Functions integration */
  azureFunctions?: InputMaybe<Array<InputMaybe<CloudAzureFunctionsIntegrationInput>>>;
  /** Key Vault integration */
  azureKeyvault?: InputMaybe<Array<InputMaybe<CloudAzureKeyvaultIntegrationInput>>>;
  /** Load Balancer integration */
  azureLoadbalancer?: InputMaybe<Array<InputMaybe<CloudAzureLoadbalancerIntegrationInput>>>;
  /** Logic Apps integration */
  azureLogicapps?: InputMaybe<Array<InputMaybe<CloudAzureLogicappsIntegrationInput>>>;
  /** Machine Learning integration */
  azureMachinelearning?: InputMaybe<Array<InputMaybe<CloudAzureMachinelearningIntegrationInput>>>;
  /** Database for MariaDB integration */
  azureMariadb?: InputMaybe<Array<InputMaybe<CloudAzureMariadbIntegrationInput>>>;
  /** Azure Monitor metrics integration */
  azureMonitor?: InputMaybe<Array<InputMaybe<CloudAzureMonitorIntegrationInput>>>;
  /** Database for MySQL integration */
  azureMysql?: InputMaybe<Array<InputMaybe<CloudAzureMysqlIntegrationInput>>>;
  /** MySQL Flexible Server integration */
  azureMysqlflexible?: InputMaybe<Array<InputMaybe<CloudAzureMysqlflexibleIntegrationInput>>>;
  /** Database for PostgreSQL integration */
  azurePostgresql?: InputMaybe<Array<InputMaybe<CloudAzurePostgresqlIntegrationInput>>>;
  /** PostgreSQL Flexible Server integration */
  azurePostgresqlflexible?: InputMaybe<Array<InputMaybe<CloudAzurePostgresqlflexibleIntegrationInput>>>;
  /** Power BI Dedicated integration */
  azurePowerbidedicated?: InputMaybe<Array<InputMaybe<CloudAzurePowerbidedicatedIntegrationInput>>>;
  /** Redis Cache integration */
  azureRediscache?: InputMaybe<Array<InputMaybe<CloudAzureRediscacheIntegrationInput>>>;
  /** Service Bus integration */
  azureServicebus?: InputMaybe<Array<InputMaybe<CloudAzureServicebusIntegrationInput>>>;
  /** SQL Database integration */
  azureSql?: InputMaybe<Array<InputMaybe<CloudAzureSqlIntegrationInput>>>;
  /** SQL Managed Instances integration */
  azureSqlmanaged?: InputMaybe<Array<InputMaybe<CloudAzureSqlmanagedIntegrationInput>>>;
  /** Storage integration */
  azureStorage?: InputMaybe<Array<InputMaybe<CloudAzureStorageIntegrationInput>>>;
  /** Virtual machine scale sets integration */
  azureVirtualmachine?: InputMaybe<Array<InputMaybe<CloudAzureVirtualmachineIntegrationInput>>>;
  /** Virtual Network integration */
  azureVirtualnetworks?: InputMaybe<Array<InputMaybe<CloudAzureVirtualnetworksIntegrationInput>>>;
  /** Virtual Machines integration */
  azureVms?: InputMaybe<Array<InputMaybe<CloudAzureVmsIntegrationInput>>>;
  /** VPN Gateways integration */
  azureVpngateways?: InputMaybe<Array<InputMaybe<CloudAzureVpngatewaysIntegrationInput>>>;
};

/** Key Vault Integration */
export type CloudAzureKeyvaultIntegration = CloudIntegration & {
  __typename?: 'CloudAzureKeyvaultIntegration';
  /** The object creation date, in epoch (Unix) time */
  createdAt: Scalars['EpochSeconds']['output'];
  /** The cloud service integration identifier. */
  id?: Maybe<Scalars['Int']['output']>;
  /**
   * [DEPRECATED] Multiple polling interval is no longer supported, use only metrics_polling_interval
   * @deprecated [DEPRECATED] Multiple polling interval is no longer supported, use only metrics_polling_interval
   */
  inventoryPollingInterval?: Maybe<Scalars['Int']['output']>;
  /** The parent linked account identifier. */
  linkedAccount?: Maybe<CloudLinkedAccount>;
  /** The data polling interval in seconds. */
  metricsPollingInterval?: Maybe<Scalars['Int']['output']>;
  /** The cloud service integration name. */
  name?: Maybe<Scalars['String']['output']>;
  /** The parent NewRelic account identifier. */
  nrAccountId: Scalars['Int']['output'];
  /** Specify each Resource group associated with the resources that you want to monitor. Filter values are case-sensitive. */
  resourceGroups?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
  /** The cloud service used in the integration. */
  service?: Maybe<CloudService>;
  /** The object last update date, in epoch (Unix) time */
  updatedAt: Scalars['EpochSeconds']['output'];
};

/** Key Vault */
export type CloudAzureKeyvaultIntegrationInput = {
  /** [DEPRECATED] Multiple polling interval is no longer supported, use only metrics_polling_interval */
  inventoryPollingInterval?: InputMaybe<Scalars['Int']['input']>;
  /** The linked account identifier. */
  linkedAccountId: Scalars['Int']['input'];
  /** The data polling interval in seconds. */
  metricsPollingInterval?: InputMaybe<Scalars['Int']['input']>;
  /** Specify each Resource group associated with the resources that you want to monitor. Filter values are case-sensitive. */
  resourceGroups?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
};

/** Information required to link a Azure account to a NewRelic account. */
export type CloudAzureLinkAccountInput = {
  /** The Azure account application identifier (used to fetch data). */
  applicationId: Scalars['String']['input'];
  /** The Azure account application secret key. */
  clientSecret: Scalars['SecureValue']['input'];
  /** The linked account name. */
  name: Scalars['String']['input'];
  /** The Azure account subscription identifier. */
  subscriptionId: Scalars['String']['input'];
  /** The Azure account tenant identifier. */
  tenantId: Scalars['String']['input'];
};

/** Load Balancer Integration */
export type CloudAzureLoadbalancerIntegration = CloudIntegration & {
  __typename?: 'CloudAzureLoadbalancerIntegration';
  /** The object creation date, in epoch (Unix) time */
  createdAt: Scalars['EpochSeconds']['output'];
  /** The cloud service integration identifier. */
  id?: Maybe<Scalars['Int']['output']>;
  /**
   * [DEPRECATED] Multiple polling interval is no longer supported, use only metrics_polling_interval
   * @deprecated [DEPRECATED] Multiple polling interval is no longer supported, use only metrics_polling_interval
   */
  inventoryPollingInterval?: Maybe<Scalars['Int']['output']>;
  /** The parent linked account identifier. */
  linkedAccount?: Maybe<CloudLinkedAccount>;
  /** The data polling interval in seconds. */
  metricsPollingInterval?: Maybe<Scalars['Int']['output']>;
  /** The cloud service integration name. */
  name?: Maybe<Scalars['String']['output']>;
  /** The parent NewRelic account identifier. */
  nrAccountId: Scalars['Int']['output'];
  /** Specify each Resource group associated with the resources that you want to monitor. Filter values are case-sensitive. */
  resourceGroups?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
  /** The cloud service used in the integration. */
  service?: Maybe<CloudService>;
  /** The object last update date, in epoch (Unix) time */
  updatedAt: Scalars['EpochSeconds']['output'];
};

/** Azure Load Balancer */
export type CloudAzureLoadbalancerIntegrationInput = {
  /** [DEPRECATED] Multiple polling interval is no longer supported, use only metrics_polling_interval */
  inventoryPollingInterval?: InputMaybe<Scalars['Int']['input']>;
  /** The linked account identifier. */
  linkedAccountId: Scalars['Int']['input'];
  /** The data polling interval in seconds. */
  metricsPollingInterval?: InputMaybe<Scalars['Int']['input']>;
  /** Specify each Resource group associated with the resources that you want to monitor. Filter values are case-sensitive. */
  resourceGroups?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
};

/** Logic Apps Integration */
export type CloudAzureLogicappsIntegration = CloudIntegration & {
  __typename?: 'CloudAzureLogicappsIntegration';
  /** The object creation date, in epoch (Unix) time */
  createdAt: Scalars['EpochSeconds']['output'];
  /** The cloud service integration identifier. */
  id?: Maybe<Scalars['Int']['output']>;
  /**
   * [DEPRECATED] Multiple polling interval is no longer supported, use only metrics_polling_interval
   * @deprecated [DEPRECATED] Multiple polling interval is no longer supported, use only metrics_polling_interval
   */
  inventoryPollingInterval?: Maybe<Scalars['Int']['output']>;
  /** The parent linked account identifier. */
  linkedAccount?: Maybe<CloudLinkedAccount>;
  /** The data polling interval in seconds. */
  metricsPollingInterval?: Maybe<Scalars['Int']['output']>;
  /** The cloud service integration name. */
  name?: Maybe<Scalars['String']['output']>;
  /** The parent NewRelic account identifier. */
  nrAccountId: Scalars['Int']['output'];
  /** Specify each Resource group associated with the resources that you want to monitor. Filter values are case-sensitive. */
  resourceGroups?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
  /** The cloud service used in the integration. */
  service?: Maybe<CloudService>;
  /** The object last update date, in epoch (Unix) time */
  updatedAt: Scalars['EpochSeconds']['output'];
};

/** Logic Apps */
export type CloudAzureLogicappsIntegrationInput = {
  /** [DEPRECATED] Multiple polling interval is no longer supported, use only metrics_polling_interval */
  inventoryPollingInterval?: InputMaybe<Scalars['Int']['input']>;
  /** The linked account identifier. */
  linkedAccountId: Scalars['Int']['input'];
  /** The data polling interval in seconds. */
  metricsPollingInterval?: InputMaybe<Scalars['Int']['input']>;
  /** Specify each Resource group associated with the resources that you want to monitor. Filter values are case-sensitive. */
  resourceGroups?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
};

/** Machine Learning Integration */
export type CloudAzureMachinelearningIntegration = CloudIntegration & {
  __typename?: 'CloudAzureMachinelearningIntegration';
  /** The object creation date, in epoch (Unix) time */
  createdAt: Scalars['EpochSeconds']['output'];
  /** The cloud service integration identifier. */
  id?: Maybe<Scalars['Int']['output']>;
  /**
   * [DEPRECATED] Multiple polling interval is no longer supported, use only metrics_polling_interval
   * @deprecated [DEPRECATED] Multiple polling interval is no longer supported, use only metrics_polling_interval
   */
  inventoryPollingInterval?: Maybe<Scalars['Int']['output']>;
  /** The parent linked account identifier. */
  linkedAccount?: Maybe<CloudLinkedAccount>;
  /** The data polling interval in seconds. */
  metricsPollingInterval?: Maybe<Scalars['Int']['output']>;
  /** The cloud service integration name. */
  name?: Maybe<Scalars['String']['output']>;
  /** The parent NewRelic account identifier. */
  nrAccountId: Scalars['Int']['output'];
  /** Specify each Resource group associated with the resources that you want to monitor. Filter values are case-sensitive. */
  resourceGroups?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
  /** The cloud service used in the integration. */
  service?: Maybe<CloudService>;
  /** The object last update date, in epoch (Unix) time */
  updatedAt: Scalars['EpochSeconds']['output'];
};

/** Machine Learning */
export type CloudAzureMachinelearningIntegrationInput = {
  /** [DEPRECATED] Multiple polling interval is no longer supported, use only metrics_polling_interval */
  inventoryPollingInterval?: InputMaybe<Scalars['Int']['input']>;
  /** The linked account identifier. */
  linkedAccountId: Scalars['Int']['input'];
  /** The data polling interval in seconds. */
  metricsPollingInterval?: InputMaybe<Scalars['Int']['input']>;
  /** Specify each Resource group associated with the resources that you want to monitor. Filter values are case-sensitive. */
  resourceGroups?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
};

/** Database for MariaDB Integration */
export type CloudAzureMariadbIntegration = CloudIntegration & {
  __typename?: 'CloudAzureMariadbIntegration';
  /** The object creation date, in epoch (Unix) time */
  createdAt: Scalars['EpochSeconds']['output'];
  /** The cloud service integration identifier. */
  id?: Maybe<Scalars['Int']['output']>;
  /**
   * [DEPRECATED] Multiple polling interval is no longer supported, use only metrics_polling_interval
   * @deprecated [DEPRECATED] Multiple polling interval is no longer supported, use only metrics_polling_interval
   */
  inventoryPollingInterval?: Maybe<Scalars['Int']['output']>;
  /** The parent linked account identifier. */
  linkedAccount?: Maybe<CloudLinkedAccount>;
  /** The data polling interval in seconds. */
  metricsPollingInterval?: Maybe<Scalars['Int']['output']>;
  /** The cloud service integration name. */
  name?: Maybe<Scalars['String']['output']>;
  /** The parent NewRelic account identifier. */
  nrAccountId: Scalars['Int']['output'];
  /** Specify each Resource group associated with the resources that you want to monitor. Filter values are case-sensitive. */
  resourceGroups?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
  /** The cloud service used in the integration. */
  service?: Maybe<CloudService>;
  /** The object last update date, in epoch (Unix) time */
  updatedAt: Scalars['EpochSeconds']['output'];
};

/** Database for MariaDB */
export type CloudAzureMariadbIntegrationInput = {
  /** [DEPRECATED] Multiple polling interval is no longer supported, use only metrics_polling_interval */
  inventoryPollingInterval?: InputMaybe<Scalars['Int']['input']>;
  /** The linked account identifier. */
  linkedAccountId: Scalars['Int']['input'];
  /** The data polling interval in seconds. */
  metricsPollingInterval?: InputMaybe<Scalars['Int']['input']>;
  /** Specify each Resource group associated with the resources that you want to monitor. Filter values are case-sensitive. */
  resourceGroups?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
};

/** Azure Monitor metrics Integration */
export type CloudAzureMonitorIntegration = CloudIntegration & {
  __typename?: 'CloudAzureMonitorIntegration';
  /** The object creation date, in epoch (Unix) time */
  createdAt: Scalars['EpochSeconds']['output'];
  /** Specify if integration is active */
  enabled?: Maybe<Scalars['Boolean']['output']>;
  /** Specify resource tags (in 'key:value' form) associated with the resources that you want to exclude from monitoring. Exclusion takes precedence over inclusion. */
  excludeTags?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
  /** The cloud service integration identifier. */
  id?: Maybe<Scalars['Int']['output']>;
  /** Specify resource tags (in 'key:value' form) associated with the resources that you want to monitor. If empty, all resources will be monitored. */
  includeTags?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
  /** The polling interval for metadata and tags, in seconds. */
  inventoryPollingInterval?: Maybe<Scalars['Int']['output']>;
  /** The parent linked account identifier. */
  linkedAccount?: Maybe<CloudLinkedAccount>;
  /** The polling interval for metrics, in seconds. */
  metricsPollingInterval?: Maybe<Scalars['Int']['output']>;
  /** The cloud service integration name. */
  name?: Maybe<Scalars['String']['output']>;
  /** The parent NewRelic account identifier. */
  nrAccountId: Scalars['Int']['output'];
  /** Specify each Resource group associated with the resources that you want to monitor. Filter values are case-sensitive. */
  resourceGroups?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
  /** Specify each Azure resource type that you want to monitor. */
  resourceTypes?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
  /** The cloud service used in the integration. */
  service?: Maybe<CloudService>;
  /** The object last update date, in epoch (Unix) time */
  updatedAt: Scalars['EpochSeconds']['output'];
};

/** Azure Monitor metrics */
export type CloudAzureMonitorIntegrationInput = {
  /** Specify if integration is active */
  enabled?: InputMaybe<Scalars['Boolean']['input']>;
  /** Specify resource tags (in 'key:value' form) associated with the resources that you want to exclude from monitoring. Exclusion takes precedence over inclusion. */
  excludeTags?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  /** Specify resource tags (in 'key:value' form) associated with the resources that you want to monitor. If empty, all resources will be monitored. */
  includeTags?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  /** The polling interval for metadata and tags, in seconds. */
  inventoryPollingInterval?: InputMaybe<Scalars['Int']['input']>;
  /** The linked account identifier. */
  linkedAccountId: Scalars['Int']['input'];
  /** The polling interval for metrics, in seconds. */
  metricsPollingInterval?: InputMaybe<Scalars['Int']['input']>;
  /** Specify each Resource group associated with the resources that you want to monitor. Filter values are case-sensitive. */
  resourceGroups?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  /** Specify each Azure resource type that you want to monitor. */
  resourceTypes?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
};

/** Database for MySQL Integration */
export type CloudAzureMysqlIntegration = CloudIntegration & {
  __typename?: 'CloudAzureMysqlIntegration';
  /** The object creation date, in epoch (Unix) time */
  createdAt: Scalars['EpochSeconds']['output'];
  /** The cloud service integration identifier. */
  id?: Maybe<Scalars['Int']['output']>;
  /**
   * [DEPRECATED] Multiple polling interval is no longer supported, use only metrics_polling_interval
   * @deprecated [DEPRECATED] Multiple polling interval is no longer supported, use only metrics_polling_interval
   */
  inventoryPollingInterval?: Maybe<Scalars['Int']['output']>;
  /** The parent linked account identifier. */
  linkedAccount?: Maybe<CloudLinkedAccount>;
  /** The data polling interval in seconds. */
  metricsPollingInterval?: Maybe<Scalars['Int']['output']>;
  /** The cloud service integration name. */
  name?: Maybe<Scalars['String']['output']>;
  /** The parent NewRelic account identifier. */
  nrAccountId: Scalars['Int']['output'];
  /** Specify each Resource group associated with the resources that you want to monitor. Filter values are case-sensitive. */
  resourceGroups?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
  /** The cloud service used in the integration. */
  service?: Maybe<CloudService>;
  /** The object last update date, in epoch (Unix) time */
  updatedAt: Scalars['EpochSeconds']['output'];
};

/** Database for MySQL */
export type CloudAzureMysqlIntegrationInput = {
  /** [DEPRECATED] Multiple polling interval is no longer supported, use only metrics_polling_interval */
  inventoryPollingInterval?: InputMaybe<Scalars['Int']['input']>;
  /** The linked account identifier. */
  linkedAccountId: Scalars['Int']['input'];
  /** The data polling interval in seconds. */
  metricsPollingInterval?: InputMaybe<Scalars['Int']['input']>;
  /** Specify each Resource group associated with the resources that you want to monitor. Filter values are case-sensitive. */
  resourceGroups?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
};

/** MySQL Flexible Server Integration */
export type CloudAzureMysqlflexibleIntegration = CloudIntegration & {
  __typename?: 'CloudAzureMysqlflexibleIntegration';
  /** The object creation date, in epoch (Unix) time */
  createdAt: Scalars['EpochSeconds']['output'];
  /** The cloud service integration identifier. */
  id?: Maybe<Scalars['Int']['output']>;
  /**
   * [DEPRECATED] Multiple polling interval is no longer supported, use only metrics_polling_interval
   * @deprecated [DEPRECATED] Multiple polling interval is no longer supported, use only metrics_polling_interval
   */
  inventoryPollingInterval?: Maybe<Scalars['Int']['output']>;
  /** The parent linked account identifier. */
  linkedAccount?: Maybe<CloudLinkedAccount>;
  /** The data polling interval in seconds. */
  metricsPollingInterval?: Maybe<Scalars['Int']['output']>;
  /** The cloud service integration name. */
  name?: Maybe<Scalars['String']['output']>;
  /** The parent NewRelic account identifier. */
  nrAccountId: Scalars['Int']['output'];
  /** Specify each Resource group associated with the resources that you want to monitor. Filter values are case-sensitive. */
  resourceGroups?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
  /** The cloud service used in the integration. */
  service?: Maybe<CloudService>;
  /** The object last update date, in epoch (Unix) time */
  updatedAt: Scalars['EpochSeconds']['output'];
};

/** MySQL Flexible Server */
export type CloudAzureMysqlflexibleIntegrationInput = {
  /** [DEPRECATED] Multiple polling interval is no longer supported, use only metrics_polling_interval */
  inventoryPollingInterval?: InputMaybe<Scalars['Int']['input']>;
  /** The linked account identifier. */
  linkedAccountId: Scalars['Int']['input'];
  /** The data polling interval in seconds. */
  metricsPollingInterval?: InputMaybe<Scalars['Int']['input']>;
  /** Specify each Resource group associated with the resources that you want to monitor. Filter values are case-sensitive. */
  resourceGroups?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
};

/** Database for PostgreSQL Integration */
export type CloudAzurePostgresqlIntegration = CloudIntegration & {
  __typename?: 'CloudAzurePostgresqlIntegration';
  /** The object creation date, in epoch (Unix) time */
  createdAt: Scalars['EpochSeconds']['output'];
  /** The cloud service integration identifier. */
  id?: Maybe<Scalars['Int']['output']>;
  /**
   * [DEPRECATED] Multiple polling interval is no longer supported, use only metrics_polling_interval
   * @deprecated [DEPRECATED] Multiple polling interval is no longer supported, use only metrics_polling_interval
   */
  inventoryPollingInterval?: Maybe<Scalars['Int']['output']>;
  /** The parent linked account identifier. */
  linkedAccount?: Maybe<CloudLinkedAccount>;
  /** The data polling interval in seconds. */
  metricsPollingInterval?: Maybe<Scalars['Int']['output']>;
  /** The cloud service integration name. */
  name?: Maybe<Scalars['String']['output']>;
  /** The parent NewRelic account identifier. */
  nrAccountId: Scalars['Int']['output'];
  /** Specify each Resource group associated with the resources that you want to monitor. Filter values are case-sensitive. */
  resourceGroups?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
  /** The cloud service used in the integration. */
  service?: Maybe<CloudService>;
  /** The object last update date, in epoch (Unix) time */
  updatedAt: Scalars['EpochSeconds']['output'];
};

/** Database for PostgreSQL */
export type CloudAzurePostgresqlIntegrationInput = {
  /** [DEPRECATED] Multiple polling interval is no longer supported, use only metrics_polling_interval */
  inventoryPollingInterval?: InputMaybe<Scalars['Int']['input']>;
  /** The linked account identifier. */
  linkedAccountId: Scalars['Int']['input'];
  /** The data polling interval in seconds. */
  metricsPollingInterval?: InputMaybe<Scalars['Int']['input']>;
  /** Specify each Resource group associated with the resources that you want to monitor. Filter values are case-sensitive. */
  resourceGroups?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
};

/** PostgreSQL Flexible Server Integration */
export type CloudAzurePostgresqlflexibleIntegration = CloudIntegration & {
  __typename?: 'CloudAzurePostgresqlflexibleIntegration';
  /** The object creation date, in epoch (Unix) time */
  createdAt: Scalars['EpochSeconds']['output'];
  /** The cloud service integration identifier. */
  id?: Maybe<Scalars['Int']['output']>;
  /**
   * [DEPRECATED] Multiple polling interval is no longer supported, use only metrics_polling_interval
   * @deprecated [DEPRECATED] Multiple polling interval is no longer supported, use only metrics_polling_interval
   */
  inventoryPollingInterval?: Maybe<Scalars['Int']['output']>;
  /** The parent linked account identifier. */
  linkedAccount?: Maybe<CloudLinkedAccount>;
  /** The data polling interval in seconds. */
  metricsPollingInterval?: Maybe<Scalars['Int']['output']>;
  /** The cloud service integration name. */
  name?: Maybe<Scalars['String']['output']>;
  /** The parent NewRelic account identifier. */
  nrAccountId: Scalars['Int']['output'];
  /** Specify each Resource group associated with the resources that you want to monitor. Filter values are case-sensitive. */
  resourceGroups?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
  /** The cloud service used in the integration. */
  service?: Maybe<CloudService>;
  /** The object last update date, in epoch (Unix) time */
  updatedAt: Scalars['EpochSeconds']['output'];
};

/** PostgreSQL Flexible Server */
export type CloudAzurePostgresqlflexibleIntegrationInput = {
  /** [DEPRECATED] Multiple polling interval is no longer supported, use only metrics_polling_interval */
  inventoryPollingInterval?: InputMaybe<Scalars['Int']['input']>;
  /** The linked account identifier. */
  linkedAccountId: Scalars['Int']['input'];
  /** The data polling interval in seconds. */
  metricsPollingInterval?: InputMaybe<Scalars['Int']['input']>;
  /** Specify each Resource group associated with the resources that you want to monitor. Filter values are case-sensitive. */
  resourceGroups?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
};

/** Power BI Dedicated Integration */
export type CloudAzurePowerbidedicatedIntegration = CloudIntegration & {
  __typename?: 'CloudAzurePowerbidedicatedIntegration';
  /** The object creation date, in epoch (Unix) time */
  createdAt: Scalars['EpochSeconds']['output'];
  /** The cloud service integration identifier. */
  id?: Maybe<Scalars['Int']['output']>;
  /**
   * [DEPRECATED] Multiple polling interval is no longer supported, use only metrics_polling_interval
   * @deprecated [DEPRECATED] Multiple polling interval is no longer supported, use only metrics_polling_interval
   */
  inventoryPollingInterval?: Maybe<Scalars['Int']['output']>;
  /** The parent linked account identifier. */
  linkedAccount?: Maybe<CloudLinkedAccount>;
  /** The data polling interval in seconds. */
  metricsPollingInterval?: Maybe<Scalars['Int']['output']>;
  /** The cloud service integration name. */
  name?: Maybe<Scalars['String']['output']>;
  /** The parent NewRelic account identifier. */
  nrAccountId: Scalars['Int']['output'];
  /** Specify each Resource group associated with the resources that you want to monitor. Filter values are case-sensitive. */
  resourceGroups?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
  /** The cloud service used in the integration. */
  service?: Maybe<CloudService>;
  /** The object last update date, in epoch (Unix) time */
  updatedAt: Scalars['EpochSeconds']['output'];
};

/** Power BI Dedicated */
export type CloudAzurePowerbidedicatedIntegrationInput = {
  /** [DEPRECATED] Multiple polling interval is no longer supported, use only metrics_polling_interval */
  inventoryPollingInterval?: InputMaybe<Scalars['Int']['input']>;
  /** The linked account identifier. */
  linkedAccountId: Scalars['Int']['input'];
  /** The data polling interval in seconds. */
  metricsPollingInterval?: InputMaybe<Scalars['Int']['input']>;
  /** Specify each Resource group associated with the resources that you want to monitor. Filter values are case-sensitive. */
  resourceGroups?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
};

/** Redis Cache Integration */
export type CloudAzureRediscacheIntegration = CloudIntegration & {
  __typename?: 'CloudAzureRediscacheIntegration';
  /** The object creation date, in epoch (Unix) time */
  createdAt: Scalars['EpochSeconds']['output'];
  /** The cloud service integration identifier. */
  id?: Maybe<Scalars['Int']['output']>;
  /**
   * [DEPRECATED] Multiple polling interval is no longer supported, use only metrics_polling_interval
   * @deprecated [DEPRECATED] Multiple polling interval is no longer supported, use only metrics_polling_interval
   */
  inventoryPollingInterval?: Maybe<Scalars['Int']['output']>;
  /** The parent linked account identifier. */
  linkedAccount?: Maybe<CloudLinkedAccount>;
  /** The data polling interval in seconds. */
  metricsPollingInterval?: Maybe<Scalars['Int']['output']>;
  /** The cloud service integration name. */
  name?: Maybe<Scalars['String']['output']>;
  /** The parent NewRelic account identifier. */
  nrAccountId: Scalars['Int']['output'];
  /** Specify each Resource group associated with the resources that you want to monitor. Filter values are case-sensitive. */
  resourceGroups?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
  /** The cloud service used in the integration. */
  service?: Maybe<CloudService>;
  /** The object last update date, in epoch (Unix) time */
  updatedAt: Scalars['EpochSeconds']['output'];
};

/** Azure Redis Cache */
export type CloudAzureRediscacheIntegrationInput = {
  /** [DEPRECATED] Multiple polling interval is no longer supported, use only metrics_polling_interval */
  inventoryPollingInterval?: InputMaybe<Scalars['Int']['input']>;
  /** The linked account identifier. */
  linkedAccountId: Scalars['Int']['input'];
  /** The data polling interval in seconds. */
  metricsPollingInterval?: InputMaybe<Scalars['Int']['input']>;
  /** Specify each Resource group associated with the resources that you want to monitor. Filter values are case-sensitive. */
  resourceGroups?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
};

/** Service Bus Integration */
export type CloudAzureServicebusIntegration = CloudIntegration & {
  __typename?: 'CloudAzureServicebusIntegration';
  /** The object creation date, in epoch (Unix) time */
  createdAt: Scalars['EpochSeconds']['output'];
  /** The cloud service integration identifier. */
  id?: Maybe<Scalars['Int']['output']>;
  /**
   * [DEPRECATED] Multiple polling interval is no longer supported, use only metrics_polling_interval
   * @deprecated [DEPRECATED] Multiple polling interval is no longer supported, use only metrics_polling_interval
   */
  inventoryPollingInterval?: Maybe<Scalars['Int']['output']>;
  /** The parent linked account identifier. */
  linkedAccount?: Maybe<CloudLinkedAccount>;
  /** The data polling interval in seconds. */
  metricsPollingInterval?: Maybe<Scalars['Int']['output']>;
  /** The cloud service integration name. */
  name?: Maybe<Scalars['String']['output']>;
  /** The parent NewRelic account identifier. */
  nrAccountId: Scalars['Int']['output'];
  /** Specify each Resource group associated with the resources that you want to monitor. Filter values are case-sensitive. */
  resourceGroups?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
  /** The cloud service used in the integration. */
  service?: Maybe<CloudService>;
  /** The object last update date, in epoch (Unix) time */
  updatedAt: Scalars['EpochSeconds']['output'];
};

/** Azure Service Bus */
export type CloudAzureServicebusIntegrationInput = {
  /** [DEPRECATED] Multiple polling interval is no longer supported, use only metrics_polling_interval */
  inventoryPollingInterval?: InputMaybe<Scalars['Int']['input']>;
  /** The linked account identifier. */
  linkedAccountId: Scalars['Int']['input'];
  /** The data polling interval in seconds. */
  metricsPollingInterval?: InputMaybe<Scalars['Int']['input']>;
  /** Specify each Resource group associated with the resources that you want to monitor. Filter values are case-sensitive. */
  resourceGroups?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
};

/** SQL Database Integration */
export type CloudAzureSqlIntegration = CloudIntegration & {
  __typename?: 'CloudAzureSqlIntegration';
  /** The object creation date, in epoch (Unix) time */
  createdAt: Scalars['EpochSeconds']['output'];
  /** The cloud service integration identifier. */
  id?: Maybe<Scalars['Int']['output']>;
  /**
   * [DEPRECATED] Multiple polling interval is no longer supported, use only metrics_polling_interval
   * @deprecated [DEPRECATED] Multiple polling interval is no longer supported, use only metrics_polling_interval
   */
  inventoryPollingInterval?: Maybe<Scalars['Int']['output']>;
  /** The parent linked account identifier. */
  linkedAccount?: Maybe<CloudLinkedAccount>;
  /** The data polling interval in seconds. */
  metricsPollingInterval?: Maybe<Scalars['Int']['output']>;
  /** The cloud service integration name. */
  name?: Maybe<Scalars['String']['output']>;
  /** The parent NewRelic account identifier. */
  nrAccountId: Scalars['Int']['output'];
  /** Specify each Resource group associated with the resources that you want to monitor. Filter values are case-sensitive. */
  resourceGroups?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
  /** The cloud service used in the integration. */
  service?: Maybe<CloudService>;
  /** The object last update date, in epoch (Unix) time */
  updatedAt: Scalars['EpochSeconds']['output'];
};

/** Azure SQL Database */
export type CloudAzureSqlIntegrationInput = {
  /** [DEPRECATED] Multiple polling interval is no longer supported, use only metrics_polling_interval */
  inventoryPollingInterval?: InputMaybe<Scalars['Int']['input']>;
  /** The linked account identifier. */
  linkedAccountId: Scalars['Int']['input'];
  /** The data polling interval in seconds. */
  metricsPollingInterval?: InputMaybe<Scalars['Int']['input']>;
  /** Specify each Resource group associated with the resources that you want to monitor. Filter values are case-sensitive. */
  resourceGroups?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
};

/** SQL Managed Instances Integration */
export type CloudAzureSqlmanagedIntegration = CloudIntegration & {
  __typename?: 'CloudAzureSqlmanagedIntegration';
  /** The object creation date, in epoch (Unix) time */
  createdAt: Scalars['EpochSeconds']['output'];
  /** The cloud service integration identifier. */
  id?: Maybe<Scalars['Int']['output']>;
  /**
   * [DEPRECATED] Multiple polling interval is no longer supported, use only metrics_polling_interval
   * @deprecated [DEPRECATED] Multiple polling interval is no longer supported, use only metrics_polling_interval
   */
  inventoryPollingInterval?: Maybe<Scalars['Int']['output']>;
  /** The parent linked account identifier. */
  linkedAccount?: Maybe<CloudLinkedAccount>;
  /** The data polling interval in seconds. */
  metricsPollingInterval?: Maybe<Scalars['Int']['output']>;
  /** The cloud service integration name. */
  name?: Maybe<Scalars['String']['output']>;
  /** The parent NewRelic account identifier. */
  nrAccountId: Scalars['Int']['output'];
  /** Specify each Resource group associated with the resources that you want to monitor. Filter values are case-sensitive. */
  resourceGroups?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
  /** The cloud service used in the integration. */
  service?: Maybe<CloudService>;
  /** The object last update date, in epoch (Unix) time */
  updatedAt: Scalars['EpochSeconds']['output'];
};

/** SQL Managed Instances */
export type CloudAzureSqlmanagedIntegrationInput = {
  /** [DEPRECATED] Multiple polling interval is no longer supported, use only metrics_polling_interval */
  inventoryPollingInterval?: InputMaybe<Scalars['Int']['input']>;
  /** The linked account identifier. */
  linkedAccountId: Scalars['Int']['input'];
  /** The data polling interval in seconds. */
  metricsPollingInterval?: InputMaybe<Scalars['Int']['input']>;
  /** Specify each Resource group associated with the resources that you want to monitor. Filter values are case-sensitive. */
  resourceGroups?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
};

/** Storage Integration */
export type CloudAzureStorageIntegration = CloudIntegration & {
  __typename?: 'CloudAzureStorageIntegration';
  /** The object creation date, in epoch (Unix) time */
  createdAt: Scalars['EpochSeconds']['output'];
  /** The cloud service integration identifier. */
  id?: Maybe<Scalars['Int']['output']>;
  /**
   * [DEPRECATED] Multiple polling interval is no longer supported, use only metrics_polling_interval
   * @deprecated [DEPRECATED] Multiple polling interval is no longer supported, use only metrics_polling_interval
   */
  inventoryPollingInterval?: Maybe<Scalars['Int']['output']>;
  /** The parent linked account identifier. */
  linkedAccount?: Maybe<CloudLinkedAccount>;
  /** The data polling interval in seconds. */
  metricsPollingInterval?: Maybe<Scalars['Int']['output']>;
  /** The cloud service integration name. */
  name?: Maybe<Scalars['String']['output']>;
  /** The parent NewRelic account identifier. */
  nrAccountId: Scalars['Int']['output'];
  /** Specify each Resource group associated with the resources that you want to monitor. Filter values are case-sensitive. */
  resourceGroups?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
  /** The cloud service used in the integration. */
  service?: Maybe<CloudService>;
  /** The object last update date, in epoch (Unix) time */
  updatedAt: Scalars['EpochSeconds']['output'];
};

/** Azure Storage */
export type CloudAzureStorageIntegrationInput = {
  /** [DEPRECATED] Multiple polling interval is no longer supported, use only metrics_polling_interval */
  inventoryPollingInterval?: InputMaybe<Scalars['Int']['input']>;
  /** The linked account identifier. */
  linkedAccountId: Scalars['Int']['input'];
  /** The data polling interval in seconds. */
  metricsPollingInterval?: InputMaybe<Scalars['Int']['input']>;
  /** Specify each Resource group associated with the resources that you want to monitor. Filter values are case-sensitive. */
  resourceGroups?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
};

/** Virtual machine scale sets Integration */
export type CloudAzureVirtualmachineIntegration = CloudIntegration & {
  __typename?: 'CloudAzureVirtualmachineIntegration';
  /** The object creation date, in epoch (Unix) time */
  createdAt: Scalars['EpochSeconds']['output'];
  /** The cloud service integration identifier. */
  id?: Maybe<Scalars['Int']['output']>;
  /**
   * [DEPRECATED] Multiple polling interval is no longer supported, use only metrics_polling_interval
   * @deprecated [DEPRECATED] Multiple polling interval is no longer supported, use only metrics_polling_interval
   */
  inventoryPollingInterval?: Maybe<Scalars['Int']['output']>;
  /** The parent linked account identifier. */
  linkedAccount?: Maybe<CloudLinkedAccount>;
  /** The data polling interval in seconds. */
  metricsPollingInterval?: Maybe<Scalars['Int']['output']>;
  /** The cloud service integration name. */
  name?: Maybe<Scalars['String']['output']>;
  /** The parent NewRelic account identifier. */
  nrAccountId: Scalars['Int']['output'];
  /** Specify each Resource group associated with the resources that you want to monitor. Filter values are case-sensitive. */
  resourceGroups?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
  /** The cloud service used in the integration. */
  service?: Maybe<CloudService>;
  /** The object last update date, in epoch (Unix) time */
  updatedAt: Scalars['EpochSeconds']['output'];
};

/** Virtual machine scale sets */
export type CloudAzureVirtualmachineIntegrationInput = {
  /** [DEPRECATED] Multiple polling interval is no longer supported, use only metrics_polling_interval */
  inventoryPollingInterval?: InputMaybe<Scalars['Int']['input']>;
  /** The linked account identifier. */
  linkedAccountId: Scalars['Int']['input'];
  /** The data polling interval in seconds. */
  metricsPollingInterval?: InputMaybe<Scalars['Int']['input']>;
  /** Specify each Resource group associated with the resources that you want to monitor. Filter values are case-sensitive. */
  resourceGroups?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
};

/** Virtual Network Integration */
export type CloudAzureVirtualnetworksIntegration = CloudIntegration & {
  __typename?: 'CloudAzureVirtualnetworksIntegration';
  /** The object creation date, in epoch (Unix) time */
  createdAt: Scalars['EpochSeconds']['output'];
  /** The cloud service integration identifier. */
  id?: Maybe<Scalars['Int']['output']>;
  /**
   * [DEPRECATED] Multiple polling interval is no longer supported, use only metrics_polling_interval
   * @deprecated [DEPRECATED] Multiple polling interval is no longer supported, use only metrics_polling_interval
   */
  inventoryPollingInterval?: Maybe<Scalars['Int']['output']>;
  /** The parent linked account identifier. */
  linkedAccount?: Maybe<CloudLinkedAccount>;
  /** The data polling interval in seconds. */
  metricsPollingInterval?: Maybe<Scalars['Int']['output']>;
  /** The cloud service integration name. */
  name?: Maybe<Scalars['String']['output']>;
  /** The parent NewRelic account identifier. */
  nrAccountId: Scalars['Int']['output'];
  /** Specify each Resource group associated with the resources that you want to monitor. Filter values are case-sensitive. */
  resourceGroups?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
  /** The cloud service used in the integration. */
  service?: Maybe<CloudService>;
  /** The object last update date, in epoch (Unix) time */
  updatedAt: Scalars['EpochSeconds']['output'];
};

/** Azure Virtual Network */
export type CloudAzureVirtualnetworksIntegrationInput = {
  /** [DEPRECATED] Multiple polling interval is no longer supported, use only metrics_polling_interval */
  inventoryPollingInterval?: InputMaybe<Scalars['Int']['input']>;
  /** The linked account identifier. */
  linkedAccountId: Scalars['Int']['input'];
  /** The data polling interval in seconds. */
  metricsPollingInterval?: InputMaybe<Scalars['Int']['input']>;
  /** Specify each Resource group associated with the resources that you want to monitor. Filter values are case-sensitive. */
  resourceGroups?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
};

/** Virtual Machines Integration */
export type CloudAzureVmsIntegration = CloudIntegration & {
  __typename?: 'CloudAzureVmsIntegration';
  /** The object creation date, in epoch (Unix) time */
  createdAt: Scalars['EpochSeconds']['output'];
  /** The cloud service integration identifier. */
  id?: Maybe<Scalars['Int']['output']>;
  /**
   * [DEPRECATED] Multiple polling interval is no longer supported, use only metrics_polling_interval
   * @deprecated [DEPRECATED] Multiple polling interval is no longer supported, use only metrics_polling_interval
   */
  inventoryPollingInterval?: Maybe<Scalars['Int']['output']>;
  /** The parent linked account identifier. */
  linkedAccount?: Maybe<CloudLinkedAccount>;
  /** The data polling interval in seconds. */
  metricsPollingInterval?: Maybe<Scalars['Int']['output']>;
  /** The cloud service integration name. */
  name?: Maybe<Scalars['String']['output']>;
  /** The parent NewRelic account identifier. */
  nrAccountId: Scalars['Int']['output'];
  /** Specify each Resource group associated with the resources that you want to monitor. Filter values are case-sensitive. */
  resourceGroups?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
  /** The cloud service used in the integration. */
  service?: Maybe<CloudService>;
  /** The object last update date, in epoch (Unix) time */
  updatedAt: Scalars['EpochSeconds']['output'];
};

/** Azure Virtual Machines */
export type CloudAzureVmsIntegrationInput = {
  /** [DEPRECATED] Multiple polling interval is no longer supported, use only metrics_polling_interval */
  inventoryPollingInterval?: InputMaybe<Scalars['Int']['input']>;
  /** The linked account identifier. */
  linkedAccountId: Scalars['Int']['input'];
  /** The data polling interval in seconds. */
  metricsPollingInterval?: InputMaybe<Scalars['Int']['input']>;
  /** Specify each Resource group associated with the resources that you want to monitor. Filter values are case-sensitive. */
  resourceGroups?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
};

/** VPN Gateways Integration */
export type CloudAzureVpngatewaysIntegration = CloudIntegration & {
  __typename?: 'CloudAzureVpngatewaysIntegration';
  /** The object creation date, in epoch (Unix) time */
  createdAt: Scalars['EpochSeconds']['output'];
  /** The cloud service integration identifier. */
  id?: Maybe<Scalars['Int']['output']>;
  /**
   * [DEPRECATED] Multiple polling interval is no longer supported, use only metrics_polling_interval
   * @deprecated [DEPRECATED] Multiple polling interval is no longer supported, use only metrics_polling_interval
   */
  inventoryPollingInterval?: Maybe<Scalars['Int']['output']>;
  /** The parent linked account identifier. */
  linkedAccount?: Maybe<CloudLinkedAccount>;
  /** The data polling interval in seconds. */
  metricsPollingInterval?: Maybe<Scalars['Int']['output']>;
  /** The cloud service integration name. */
  name?: Maybe<Scalars['String']['output']>;
  /** The parent NewRelic account identifier. */
  nrAccountId: Scalars['Int']['output'];
  /** Specify each Resource group associated with the resources that you want to monitor. Filter values are case-sensitive. */
  resourceGroups?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
  /** The cloud service used in the integration. */
  service?: Maybe<CloudService>;
  /** The object last update date, in epoch (Unix) time */
  updatedAt: Scalars['EpochSeconds']['output'];
};

/** VPN Gateways */
export type CloudAzureVpngatewaysIntegrationInput = {
  /** [DEPRECATED] Multiple polling interval is no longer supported, use only metrics_polling_interval */
  inventoryPollingInterval?: InputMaybe<Scalars['Int']['input']>;
  /** The linked account identifier. */
  linkedAccountId: Scalars['Int']['input'];
  /** The data polling interval in seconds. */
  metricsPollingInterval?: InputMaybe<Scalars['Int']['input']>;
  /** Specify each Resource group associated with the resources that you want to monitor. Filter values are case-sensitive. */
  resourceGroups?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
};

/** Base Integration Object */
export type CloudBaseIntegration = CloudIntegration & {
  __typename?: 'CloudBaseIntegration';
  /** The object creation date, in epoch (Unix) time */
  createdAt: Scalars['EpochSeconds']['output'];
  /** The cloud service integration identifier. */
  id?: Maybe<Scalars['Int']['output']>;
  /** The parent linked account identifier. */
  linkedAccount?: Maybe<CloudLinkedAccount>;
  /** The cloud service integration name. */
  name?: Maybe<Scalars['String']['output']>;
  /** The parent NewRelic account identifier. */
  nrAccountId: Scalars['Int']['output'];
  /** The cloud service used in the integration. */
  service?: Maybe<CloudService>;
  /** The object last update date, in epoch (Unix) time */
  updatedAt: Scalars['EpochSeconds']['output'];
};

/** Base Provider Object */
export type CloudBaseProvider = CloudProvider & {
  __typename?: 'CloudBaseProvider';
  /** The object creation date, in epoch (Unix) time */
  createdAt: Scalars['EpochSeconds']['output'];
  /** The cloud provider icon name. */
  icon: Scalars['String']['output'];
  /** The cloud provider identifier in NewRelic. */
  id: Scalars['Int']['output'];
  /** The cloud provider name. */
  name: Scalars['String']['output'];
  /** Get details of one cloud provider service. */
  service?: Maybe<CloudService>;
  /** Get details of all the cloud provider services available for integration. */
  services: Array<CloudService>;
  /** The cloud provider short name. */
  slug: Scalars['String']['output'];
  /** The object last update date, in epoch (Unix) time */
  updatedAt: Scalars['EpochSeconds']['output'];
};


/** Base Provider Object */
export type CloudBaseProviderServiceArgs = {
  slug: Scalars['String']['input'];
};

/** Billing Integration */
export type CloudBillingIntegration = CloudIntegration & {
  __typename?: 'CloudBillingIntegration';
  /** The object creation date, in epoch (Unix) time */
  createdAt: Scalars['EpochSeconds']['output'];
  /** The cloud service integration identifier. */
  id?: Maybe<Scalars['Int']['output']>;
  /**
   * [DEPRECATED] Multiple polling interval is no longer supported, use only metrics_polling_interval
   * @deprecated [DEPRECATED] Multiple polling interval is no longer supported, use only metrics_polling_interval
   */
  inventoryPollingInterval?: Maybe<Scalars['Int']['output']>;
  /** The parent linked account identifier. */
  linkedAccount?: Maybe<CloudLinkedAccount>;
  /** The data polling interval in seconds. */
  metricsPollingInterval?: Maybe<Scalars['Int']['output']>;
  /** The cloud service integration name. */
  name?: Maybe<Scalars['String']['output']>;
  /** The parent NewRelic account identifier. */
  nrAccountId: Scalars['Int']['output'];
  /** The cloud service used in the integration. */
  service?: Maybe<CloudService>;
  /** The object last update date, in epoch (Unix) time */
  updatedAt: Scalars['EpochSeconds']['output'];
};

/** AWS Billing */
export type CloudBillingIntegrationInput = {
  /** [DEPRECATED] Multiple polling interval is no longer supported, use only metrics_polling_interval */
  inventoryPollingInterval?: InputMaybe<Scalars['Int']['input']>;
  /** The linked account identifier. */
  linkedAccountId: Scalars['Int']['input'];
  /** The data polling interval in seconds. */
  metricsPollingInterval?: InputMaybe<Scalars['Int']['input']>;
};

/** CloudFront Integration */
export type CloudCloudfrontIntegration = CloudIntegration & {
  __typename?: 'CloudCloudfrontIntegration';
  /** The object creation date, in epoch (Unix) time */
  createdAt: Scalars['EpochSeconds']['output'];
  /** Specify if Lambdas@Edge should be monitored. May affect total data collection time and contribute to the Cloud provider API rate limit. */
  fetchLambdasAtEdge?: Maybe<Scalars['Boolean']['output']>;
  /** Specify if tags should be collected. May affect total data collection time and contribute to the Cloud provider API rate limit. */
  fetchTags?: Maybe<Scalars['Boolean']['output']>;
  /** The cloud service integration identifier. */
  id?: Maybe<Scalars['Int']['output']>;
  /**
   * [DEPRECATED] Multiple polling interval is no longer supported, use only metrics_polling_interval
   * @deprecated [DEPRECATED] Multiple polling interval is no longer supported, use only metrics_polling_interval
   */
  inventoryPollingInterval?: Maybe<Scalars['Int']['output']>;
  /** The parent linked account identifier. */
  linkedAccount?: Maybe<CloudLinkedAccount>;
  /** The data polling interval in seconds. */
  metricsPollingInterval?: Maybe<Scalars['Int']['output']>;
  /** The cloud service integration name. */
  name?: Maybe<Scalars['String']['output']>;
  /** The parent NewRelic account identifier. */
  nrAccountId: Scalars['Int']['output'];
  /** The cloud service used in the integration. */
  service?: Maybe<CloudService>;
  /** Specify a Tag key associated with the resources that you want to monitor. Filter values are case-sensitive. */
  tagKey?: Maybe<Scalars['String']['output']>;
  /** Specify a Tag value associated with the resources that you want to monitor. Filter values are case-sensitive. */
  tagValue?: Maybe<Scalars['String']['output']>;
  /** The object last update date, in epoch (Unix) time */
  updatedAt: Scalars['EpochSeconds']['output'];
};

/** Amazon CloudFront */
export type CloudCloudfrontIntegrationInput = {
  /** Specify if Lambdas@Edge should be monitored. May affect total data collection time and contribute to the Cloud provider API rate limit. */
  fetchLambdasAtEdge?: InputMaybe<Scalars['Boolean']['input']>;
  /** Specify if tags should be collected. May affect total data collection time and contribute to the Cloud provider API rate limit. */
  fetchTags?: InputMaybe<Scalars['Boolean']['input']>;
  /** [DEPRECATED] Multiple polling interval is no longer supported, use only metrics_polling_interval */
  inventoryPollingInterval?: InputMaybe<Scalars['Int']['input']>;
  /** The linked account identifier. */
  linkedAccountId: Scalars['Int']['input'];
  /** The data polling interval in seconds. */
  metricsPollingInterval?: InputMaybe<Scalars['Int']['input']>;
  /** Specify a Tag key associated with the resources that you want to monitor. Filter values are case-sensitive. */
  tagKey?: InputMaybe<Scalars['String']['input']>;
  /** Specify a Tag value associated with the resources that you want to monitor. Filter values are case-sensitive. */
  tagValue?: InputMaybe<Scalars['String']['input']>;
};

/** CloudTrail Integration */
export type CloudCloudtrailIntegration = CloudIntegration & {
  __typename?: 'CloudCloudtrailIntegration';
  /** Specify each AWS region that includes the resources that you want to monitor. */
  awsRegions?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
  /** The object creation date, in epoch (Unix) time */
  createdAt: Scalars['EpochSeconds']['output'];
  /** The cloud service integration identifier. */
  id?: Maybe<Scalars['Int']['output']>;
  /**
   * [DEPRECATED] Multiple polling interval is no longer supported, use only metrics_polling_interval
   * @deprecated [DEPRECATED] Multiple polling interval is no longer supported, use only metrics_polling_interval
   */
  inventoryPollingInterval?: Maybe<Scalars['Int']['output']>;
  /** The parent linked account identifier. */
  linkedAccount?: Maybe<CloudLinkedAccount>;
  /** The data polling interval in seconds. */
  metricsPollingInterval?: Maybe<Scalars['Int']['output']>;
  /** The cloud service integration name. */
  name?: Maybe<Scalars['String']['output']>;
  /** The parent NewRelic account identifier. */
  nrAccountId: Scalars['Int']['output'];
  /** The cloud service used in the integration. */
  service?: Maybe<CloudService>;
  /** The object last update date, in epoch (Unix) time */
  updatedAt: Scalars['EpochSeconds']['output'];
};

/** AWS CloudTrail */
export type CloudCloudtrailIntegrationInput = {
  /** Specify each AWS region that includes the resources that you want to monitor. */
  awsRegions?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  /** [DEPRECATED] Multiple polling interval is no longer supported, use only metrics_polling_interval */
  inventoryPollingInterval?: InputMaybe<Scalars['Int']['input']>;
  /** The linked account identifier. */
  linkedAccountId: Scalars['Int']['input'];
  /** The data polling interval in seconds. */
  metricsPollingInterval?: InputMaybe<Scalars['Int']['input']>;
};

/** Configuration field for a cloud service */
export type CloudConfigField = {
  __typename?: 'CloudConfigField';
  /** The cloud service field default value, remember to cast it properly depending of the value of the field 'type'. */
  default?: Maybe<Scalars['String']['output']>;
  /** Specifies if the field is deprecated. */
  deprecated?: Maybe<Scalars['Boolean']['output']>;
  /** The configuration field description. */
  description?: Maybe<Scalars['String']['output']>;
  /** Specifies if the fetch options should be active or not for the field */
  fetchOptions?: Maybe<Scalars['Boolean']['output']>;
  /** The cloud service field label. */
  label: Scalars['String']['output'];
  /** Specifies if the field has multiple values. */
  multiple?: Maybe<Scalars['Boolean']['output']>;
  /** The configuration field name. */
  name: Scalars['String']['output'];
  /** The cloud service field available options. */
  options?: Maybe<Array<CloudConfigFieldOption>>;
  /** The cloud service field placeholder. */
  placeholder?: Maybe<Scalars['String']['output']>;
  /** Specifies if the field is required. */
  required: Scalars['Boolean']['output'];
  /** The cloud service field type. */
  type: Scalars['String']['output'];
};

/** Configuration field option */
export type CloudConfigFieldOption = {
  __typename?: 'CloudConfigFieldOption';
  /** Field option name. */
  name: Scalars['String']['output'];
  /** Field option value, remember to cast it properly with according to the field 'type' field. */
  value: Scalars['String']['output'];
};

/** Autogenerated return type of ConfigureIntegration */
export type CloudConfigureIntegrationPayload = {
  __typename?: 'CloudConfigureIntegrationPayload';
  /** The list of errors. */
  errors: Array<CloudIntegrationMutationError>;
  /** The created/modified service integrations. */
  integrations: Array<CloudIntegration>;
};

/** A cloud service dashboard template. */
export type CloudDashboardTemplate = {
  __typename?: 'CloudDashboardTemplate';
  /** The object creation date, in epoch (Unix) time */
  createdAt: Scalars['EpochSeconds']['output'];
  /** The dashboard layout position. */
  layout: Scalars['Int']['output'];
  /** The dashboard template name. */
  name: Scalars['String']['output'];
  /** The dashboard template slug. */
  slug: Scalars['String']['output'];
  /** The object last update date, in epoch (Unix) time */
  updatedAt: Scalars['EpochSeconds']['output'];
};

/** Information required to disable a cloud service integration from a linked account. */
export type CloudDisableAccountIntegrationInput = {
  /** The linked account identifier */
  linkedAccountId: Scalars['Int']['input'];
};

/** Autogenerated return type of DisableIntegration */
export type CloudDisableIntegrationPayload = {
  __typename?: 'CloudDisableIntegrationPayload';
  /** The list of disabled cloud service integrations. */
  disabledIntegrations: Array<CloudIntegration>;
  /** The list of errors. */
  errors: Array<CloudIntegrationMutationError>;
};

/** List of providers */
export type CloudDisableIntegrationsInput = {
  /** Aws provider */
  aws?: InputMaybe<CloudAwsDisableIntegrationsInput>;
  /** AwsGovcloud provider */
  awsGovcloud?: InputMaybe<CloudAwsGovcloudDisableIntegrationsInput>;
  /** Azure provider */
  azure?: InputMaybe<CloudAzureDisableIntegrationsInput>;
  /** Gcp provider */
  gcp?: InputMaybe<CloudGcpDisableIntegrationsInput>;
};

/** DynamoDB Integration */
export type CloudDynamodbIntegration = CloudIntegration & {
  __typename?: 'CloudDynamodbIntegration';
  /** Specify each AWS region that includes the resources that you want to monitor. */
  awsRegions?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
  /** The object creation date, in epoch (Unix) time */
  createdAt: Scalars['EpochSeconds']['output'];
  /** Determine if extra inventory data be collected or not. May affect total data collection time and contribute to the Cloud provider API rate limit. */
  fetchExtendedInventory?: Maybe<Scalars['Boolean']['output']>;
  /** Specify if tags should be collected. May affect total data collection time and contribute to the Cloud provider API rate limit. */
  fetchTags?: Maybe<Scalars['Boolean']['output']>;
  /** The cloud service integration identifier. */
  id?: Maybe<Scalars['Int']['output']>;
  /**
   * [DEPRECATED] Multiple polling interval is no longer supported, use only metrics_polling_interval
   * @deprecated [DEPRECATED] Multiple polling interval is no longer supported, use only metrics_polling_interval
   */
  inventoryPollingInterval?: Maybe<Scalars['Int']['output']>;
  /** The parent linked account identifier. */
  linkedAccount?: Maybe<CloudLinkedAccount>;
  /** The data polling interval in seconds. */
  metricsPollingInterval?: Maybe<Scalars['Int']['output']>;
  /** The cloud service integration name. */
  name?: Maybe<Scalars['String']['output']>;
  /** The parent NewRelic account identifier. */
  nrAccountId: Scalars['Int']['output'];
  /** The cloud service used in the integration. */
  service?: Maybe<CloudService>;
  /** Specify a Tag key associated with the resources that you want to monitor. Filter values are case-sensitive. */
  tagKey?: Maybe<Scalars['String']['output']>;
  /** Specify a Tag value associated with the resources that you want to monitor. Filter values are case-sensitive. */
  tagValue?: Maybe<Scalars['String']['output']>;
  /** The object last update date, in epoch (Unix) time */
  updatedAt: Scalars['EpochSeconds']['output'];
};

/** Amazon DynamoDB */
export type CloudDynamodbIntegrationInput = {
  /** Specify each AWS region that includes the resources that you want to monitor. */
  awsRegions?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  /** Determine if extra inventory data be collected or not. May affect total data collection time and contribute to the Cloud provider API rate limit. */
  fetchExtendedInventory?: InputMaybe<Scalars['Boolean']['input']>;
  /** Specify if tags should be collected. May affect total data collection time and contribute to the Cloud provider API rate limit. */
  fetchTags?: InputMaybe<Scalars['Boolean']['input']>;
  /** [DEPRECATED] Multiple polling interval is no longer supported, use only metrics_polling_interval */
  inventoryPollingInterval?: InputMaybe<Scalars['Int']['input']>;
  /** The linked account identifier. */
  linkedAccountId: Scalars['Int']['input'];
  /** The data polling interval in seconds. */
  metricsPollingInterval?: InputMaybe<Scalars['Int']['input']>;
  /** Specify a Tag key associated with the resources that you want to monitor. Filter values are case-sensitive. */
  tagKey?: InputMaybe<Scalars['String']['input']>;
  /** Specify a Tag value associated with the resources that you want to monitor. Filter values are case-sensitive. */
  tagValue?: InputMaybe<Scalars['String']['input']>;
};

/** EBS Integration */
export type CloudEbsIntegration = CloudIntegration & {
  __typename?: 'CloudEbsIntegration';
  /** Specify each AWS region that includes the resources that you want to monitor. */
  awsRegions?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
  /** The object creation date, in epoch (Unix) time */
  createdAt: Scalars['EpochSeconds']['output'];
  /** Determine if extra inventory data be collected or not. May affect total data collection time and contribute to the Cloud provider API rate limit. */
  fetchExtendedInventory?: Maybe<Scalars['Boolean']['output']>;
  /** The cloud service integration identifier. */
  id?: Maybe<Scalars['Int']['output']>;
  /**
   * [DEPRECATED] Multiple polling interval is no longer supported, use only metrics_polling_interval
   * @deprecated [DEPRECATED] Multiple polling interval is no longer supported, use only metrics_polling_interval
   */
  inventoryPollingInterval?: Maybe<Scalars['Int']['output']>;
  /** The parent linked account identifier. */
  linkedAccount?: Maybe<CloudLinkedAccount>;
  /** The data polling interval in seconds. */
  metricsPollingInterval?: Maybe<Scalars['Int']['output']>;
  /** The cloud service integration name. */
  name?: Maybe<Scalars['String']['output']>;
  /** The parent NewRelic account identifier. */
  nrAccountId: Scalars['Int']['output'];
  /** The cloud service used in the integration. */
  service?: Maybe<CloudService>;
  /** Specify a Tag key associated with the resources that you want to monitor. Filter values are case-sensitive. */
  tagKey?: Maybe<Scalars['String']['output']>;
  /** Specify a Tag value associated with the resources that you want to monitor. Filter values are case-sensitive. */
  tagValue?: Maybe<Scalars['String']['output']>;
  /** The object last update date, in epoch (Unix) time */
  updatedAt: Scalars['EpochSeconds']['output'];
};

/** Amazon Elastic Block Store (EBS) */
export type CloudEbsIntegrationInput = {
  /** Specify each AWS region that includes the resources that you want to monitor. */
  awsRegions?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  /** Determine if extra inventory data be collected or not. May affect total data collection time and contribute to the Cloud provider API rate limit. */
  fetchExtendedInventory?: InputMaybe<Scalars['Boolean']['input']>;
  /** [DEPRECATED] Multiple polling interval is no longer supported, use only metrics_polling_interval */
  inventoryPollingInterval?: InputMaybe<Scalars['Int']['input']>;
  /** The linked account identifier. */
  linkedAccountId: Scalars['Int']['input'];
  /** The data polling interval in seconds. */
  metricsPollingInterval?: InputMaybe<Scalars['Int']['input']>;
  /** Specify a Tag key associated with the resources that you want to monitor. Filter values are case-sensitive. */
  tagKey?: InputMaybe<Scalars['String']['input']>;
  /** Specify a Tag value associated with the resources that you want to monitor. Filter values are case-sensitive. */
  tagValue?: InputMaybe<Scalars['String']['input']>;
};

/** EC2 Integration */
export type CloudEc2Integration = CloudIntegration & {
  __typename?: 'CloudEc2Integration';
  /** Specify each AWS region that includes the resources that you want to monitor. */
  awsRegions?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
  /** The object creation date, in epoch (Unix) time */
  createdAt: Scalars['EpochSeconds']['output'];
  /** Specify if the old legacy metadata and tag names have to be kept, it will consume more ingest data size */
  duplicateEc2Tags?: Maybe<Scalars['Boolean']['output']>;
  /** Specify if IP addresses of ec2 instance should be collected */
  fetchIpAddresses?: Maybe<Scalars['Boolean']['output']>;
  /** The cloud service integration identifier. */
  id?: Maybe<Scalars['Int']['output']>;
  /**
   * [DEPRECATED] Multiple polling interval is no longer supported, use only metrics_polling_interval
   * @deprecated [DEPRECATED] Multiple polling interval is no longer supported, use only metrics_polling_interval
   */
  inventoryPollingInterval?: Maybe<Scalars['Int']['output']>;
  /** The parent linked account identifier. */
  linkedAccount?: Maybe<CloudLinkedAccount>;
  /** The data polling interval in seconds. */
  metricsPollingInterval?: Maybe<Scalars['Int']['output']>;
  /** The cloud service integration name. */
  name?: Maybe<Scalars['String']['output']>;
  /** The parent NewRelic account identifier. */
  nrAccountId: Scalars['Int']['output'];
  /** The cloud service used in the integration. */
  service?: Maybe<CloudService>;
  /** Specify a Tag key associated with the resources that you want to monitor. Filter values are case-sensitive. */
  tagKey?: Maybe<Scalars['String']['output']>;
  /** Specify a Tag value associated with the resources that you want to monitor. Filter values are case-sensitive. */
  tagValue?: Maybe<Scalars['String']['output']>;
  /** The object last update date, in epoch (Unix) time */
  updatedAt: Scalars['EpochSeconds']['output'];
};

/** Amazon Elastic Compute Cloud (EC2) */
export type CloudEc2IntegrationInput = {
  /** Specify each AWS region that includes the resources that you want to monitor. */
  awsRegions?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  /** Specify if the old legacy metadata and tag names have to be kept, it will consume more ingest data size */
  duplicateEc2Tags?: InputMaybe<Scalars['Boolean']['input']>;
  /** Specify if IP addresses of ec2 instance should be collected */
  fetchIpAddresses?: InputMaybe<Scalars['Boolean']['input']>;
  /** [DEPRECATED] Multiple polling interval is no longer supported, use only metrics_polling_interval */
  inventoryPollingInterval?: InputMaybe<Scalars['Int']['input']>;
  /** The linked account identifier. */
  linkedAccountId: Scalars['Int']['input'];
  /** The data polling interval in seconds. */
  metricsPollingInterval?: InputMaybe<Scalars['Int']['input']>;
  /** Specify a Tag key associated with the resources that you want to monitor. Filter values are case-sensitive. */
  tagKey?: InputMaybe<Scalars['String']['input']>;
  /** Specify a Tag value associated with the resources that you want to monitor. Filter values are case-sensitive. */
  tagValue?: InputMaybe<Scalars['String']['input']>;
};

/** ECS Integration */
export type CloudEcsIntegration = CloudIntegration & {
  __typename?: 'CloudEcsIntegration';
  /** Specify each AWS region that includes the resources that you want to monitor. */
  awsRegions?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
  /** The object creation date, in epoch (Unix) time */
  createdAt: Scalars['EpochSeconds']['output'];
  /** Specify if tags should be collected. May affect total data collection time and contribute to the Cloud provider API rate limit. */
  fetchTags?: Maybe<Scalars['Boolean']['output']>;
  /** The cloud service integration identifier. */
  id?: Maybe<Scalars['Int']['output']>;
  /**
   * [DEPRECATED] Multiple polling interval is no longer supported, use only metrics_polling_interval
   * @deprecated [DEPRECATED] Multiple polling interval is no longer supported, use only metrics_polling_interval
   */
  inventoryPollingInterval?: Maybe<Scalars['Int']['output']>;
  /** The parent linked account identifier. */
  linkedAccount?: Maybe<CloudLinkedAccount>;
  /** The data polling interval in seconds. */
  metricsPollingInterval?: Maybe<Scalars['Int']['output']>;
  /** The cloud service integration name. */
  name?: Maybe<Scalars['String']['output']>;
  /** The parent NewRelic account identifier. */
  nrAccountId: Scalars['Int']['output'];
  /** The cloud service used in the integration. */
  service?: Maybe<CloudService>;
  /** Specify a Tag key associated with the resources that you want to monitor. Filter values are case-sensitive. */
  tagKey?: Maybe<Scalars['String']['output']>;
  /** Specify a Tag value associated with the resources that you want to monitor. Filter values are case-sensitive. */
  tagValue?: Maybe<Scalars['String']['output']>;
  /** The object last update date, in epoch (Unix) time */
  updatedAt: Scalars['EpochSeconds']['output'];
};

/** Amazon Elastic Container Service (ECS) */
export type CloudEcsIntegrationInput = {
  /** Specify each AWS region that includes the resources that you want to monitor. */
  awsRegions?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  /** Specify if tags should be collected. May affect total data collection time and contribute to the Cloud provider API rate limit. */
  fetchTags?: InputMaybe<Scalars['Boolean']['input']>;
  /** [DEPRECATED] Multiple polling interval is no longer supported, use only metrics_polling_interval */
  inventoryPollingInterval?: InputMaybe<Scalars['Int']['input']>;
  /** The linked account identifier. */
  linkedAccountId: Scalars['Int']['input'];
  /** The data polling interval in seconds. */
  metricsPollingInterval?: InputMaybe<Scalars['Int']['input']>;
  /** Specify a Tag key associated with the resources that you want to monitor. Filter values are case-sensitive. */
  tagKey?: InputMaybe<Scalars['String']['input']>;
  /** Specify a Tag value associated with the resources that you want to monitor. Filter values are case-sensitive. */
  tagValue?: InputMaybe<Scalars['String']['input']>;
};

/** EFS Integration */
export type CloudEfsIntegration = CloudIntegration & {
  __typename?: 'CloudEfsIntegration';
  /** Specify each AWS region that includes the resources that you want to monitor. */
  awsRegions?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
  /** The object creation date, in epoch (Unix) time */
  createdAt: Scalars['EpochSeconds']['output'];
  /** Specify if tags should be collected. May affect total data collection time and contribute to the Cloud provider API rate limit. */
  fetchTags?: Maybe<Scalars['Boolean']['output']>;
  /** The cloud service integration identifier. */
  id?: Maybe<Scalars['Int']['output']>;
  /**
   * [DEPRECATED] Multiple polling interval is no longer supported, use only metrics_polling_interval
   * @deprecated [DEPRECATED] Multiple polling interval is no longer supported, use only metrics_polling_interval
   */
  inventoryPollingInterval?: Maybe<Scalars['Int']['output']>;
  /** The parent linked account identifier. */
  linkedAccount?: Maybe<CloudLinkedAccount>;
  /** The data polling interval in seconds. */
  metricsPollingInterval?: Maybe<Scalars['Int']['output']>;
  /** The cloud service integration name. */
  name?: Maybe<Scalars['String']['output']>;
  /** The parent NewRelic account identifier. */
  nrAccountId: Scalars['Int']['output'];
  /** The cloud service used in the integration. */
  service?: Maybe<CloudService>;
  /** Specify a Tag key associated with the resources that you want to monitor. Filter values are case-sensitive. */
  tagKey?: Maybe<Scalars['String']['output']>;
  /** Specify a Tag value associated with the resources that you want to monitor. Filter values are case-sensitive. */
  tagValue?: Maybe<Scalars['String']['output']>;
  /** The object last update date, in epoch (Unix) time */
  updatedAt: Scalars['EpochSeconds']['output'];
};

/** Amazon Elastic File System (EFS) */
export type CloudEfsIntegrationInput = {
  /** Specify each AWS region that includes the resources that you want to monitor. */
  awsRegions?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  /** Specify if tags should be collected. May affect total data collection time and contribute to the Cloud provider API rate limit. */
  fetchTags?: InputMaybe<Scalars['Boolean']['input']>;
  /** [DEPRECATED] Multiple polling interval is no longer supported, use only metrics_polling_interval */
  inventoryPollingInterval?: InputMaybe<Scalars['Int']['input']>;
  /** The linked account identifier. */
  linkedAccountId: Scalars['Int']['input'];
  /** The data polling interval in seconds. */
  metricsPollingInterval?: InputMaybe<Scalars['Int']['input']>;
  /** Specify a Tag key associated with the resources that you want to monitor. Filter values are case-sensitive. */
  tagKey?: InputMaybe<Scalars['String']['input']>;
  /** Specify a Tag value associated with the resources that you want to monitor. Filter values are case-sensitive. */
  tagValue?: InputMaybe<Scalars['String']['input']>;
};

/** ElastiCache Integration */
export type CloudElasticacheIntegration = CloudIntegration & {
  __typename?: 'CloudElasticacheIntegration';
  /** Specify each AWS region that includes the resources that you want to monitor. */
  awsRegions?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
  /** The object creation date, in epoch (Unix) time */
  createdAt: Scalars['EpochSeconds']['output'];
  /** Specify if tags should be collected. May affect total data collection time and contribute to the Cloud provider API rate limit. */
  fetchTags?: Maybe<Scalars['Boolean']['output']>;
  /** The cloud service integration identifier. */
  id?: Maybe<Scalars['Int']['output']>;
  /**
   * [DEPRECATED] Multiple polling interval is no longer supported, use only metrics_polling_interval
   * @deprecated [DEPRECATED] Multiple polling interval is no longer supported, use only metrics_polling_interval
   */
  inventoryPollingInterval?: Maybe<Scalars['Int']['output']>;
  /** The parent linked account identifier. */
  linkedAccount?: Maybe<CloudLinkedAccount>;
  /** The data polling interval in seconds. */
  metricsPollingInterval?: Maybe<Scalars['Int']['output']>;
  /** The cloud service integration name. */
  name?: Maybe<Scalars['String']['output']>;
  /** The parent NewRelic account identifier. */
  nrAccountId: Scalars['Int']['output'];
  /** The cloud service used in the integration. */
  service?: Maybe<CloudService>;
  /** Specify a Tag key associated with the resources that you want to monitor. Filter values are case-sensitive. */
  tagKey?: Maybe<Scalars['String']['output']>;
  /** Specify a Tag value associated with the resources that you want to monitor. Filter values are case-sensitive. */
  tagValue?: Maybe<Scalars['String']['output']>;
  /** The object last update date, in epoch (Unix) time */
  updatedAt: Scalars['EpochSeconds']['output'];
};

/** Amazon ElastiCache */
export type CloudElasticacheIntegrationInput = {
  /** Specify each AWS region that includes the resources that you want to monitor. */
  awsRegions?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  /** Specify if tags should be collected. May affect total data collection time and contribute to the Cloud provider API rate limit. */
  fetchTags?: InputMaybe<Scalars['Boolean']['input']>;
  /** [DEPRECATED] Multiple polling interval is no longer supported, use only metrics_polling_interval */
  inventoryPollingInterval?: InputMaybe<Scalars['Int']['input']>;
  /** The linked account identifier. */
  linkedAccountId: Scalars['Int']['input'];
  /** The data polling interval in seconds. */
  metricsPollingInterval?: InputMaybe<Scalars['Int']['input']>;
  /** Specify a Tag key associated with the resources that you want to monitor. Filter values are case-sensitive. */
  tagKey?: InputMaybe<Scalars['String']['input']>;
  /** Specify a Tag value associated with the resources that you want to monitor. Filter values are case-sensitive. */
  tagValue?: InputMaybe<Scalars['String']['input']>;
};

/** Elastic Beanstalk Integration */
export type CloudElasticbeanstalkIntegration = CloudIntegration & {
  __typename?: 'CloudElasticbeanstalkIntegration';
  /** Specify each AWS region that includes the resources that you want to monitor. */
  awsRegions?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
  /** The object creation date, in epoch (Unix) time */
  createdAt: Scalars['EpochSeconds']['output'];
  /** Determine if extra inventory data be collected or not. May affect total data collection time and contribute to the Cloud provider API rate limit. */
  fetchExtendedInventory?: Maybe<Scalars['Boolean']['output']>;
  /** Specify if tags should be collected. May affect total data collection time and contribute to the Cloud provider API rate limit. */
  fetchTags?: Maybe<Scalars['Boolean']['output']>;
  /** The cloud service integration identifier. */
  id?: Maybe<Scalars['Int']['output']>;
  /**
   * [DEPRECATED] Multiple polling interval is no longer supported, use only metrics_polling_interval
   * @deprecated [DEPRECATED] Multiple polling interval is no longer supported, use only metrics_polling_interval
   */
  inventoryPollingInterval?: Maybe<Scalars['Int']['output']>;
  /** The parent linked account identifier. */
  linkedAccount?: Maybe<CloudLinkedAccount>;
  /** The data polling interval in seconds. */
  metricsPollingInterval?: Maybe<Scalars['Int']['output']>;
  /** The cloud service integration name. */
  name?: Maybe<Scalars['String']['output']>;
  /** The parent NewRelic account identifier. */
  nrAccountId: Scalars['Int']['output'];
  /** The cloud service used in the integration. */
  service?: Maybe<CloudService>;
  /** Specify a Tag key associated with the resources that you want to monitor. Filter values are case-sensitive. */
  tagKey?: Maybe<Scalars['String']['output']>;
  /** Specify a Tag value associated with the resources that you want to monitor. Filter values are case-sensitive. */
  tagValue?: Maybe<Scalars['String']['output']>;
  /** The object last update date, in epoch (Unix) time */
  updatedAt: Scalars['EpochSeconds']['output'];
};

/** AWS Elastic Beanstalk */
export type CloudElasticbeanstalkIntegrationInput = {
  /** Specify each AWS region that includes the resources that you want to monitor. */
  awsRegions?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  /** Determine if extra inventory data be collected or not. May affect total data collection time and contribute to the Cloud provider API rate limit. */
  fetchExtendedInventory?: InputMaybe<Scalars['Boolean']['input']>;
  /** Specify if tags should be collected. May affect total data collection time and contribute to the Cloud provider API rate limit. */
  fetchTags?: InputMaybe<Scalars['Boolean']['input']>;
  /** [DEPRECATED] Multiple polling interval is no longer supported, use only metrics_polling_interval */
  inventoryPollingInterval?: InputMaybe<Scalars['Int']['input']>;
  /** The linked account identifier. */
  linkedAccountId: Scalars['Int']['input'];
  /** The data polling interval in seconds. */
  metricsPollingInterval?: InputMaybe<Scalars['Int']['input']>;
  /** Specify a Tag key associated with the resources that you want to monitor. Filter values are case-sensitive. */
  tagKey?: InputMaybe<Scalars['String']['input']>;
  /** Specify a Tag value associated with the resources that you want to monitor. Filter values are case-sensitive. */
  tagValue?: InputMaybe<Scalars['String']['input']>;
};

/** Elasticsearch Service Integration */
export type CloudElasticsearchIntegration = CloudIntegration & {
  __typename?: 'CloudElasticsearchIntegration';
  /** Specify each AWS region that includes the resources that you want to monitor. */
  awsRegions?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
  /** The object creation date, in epoch (Unix) time */
  createdAt: Scalars['EpochSeconds']['output'];
  /** Specify if metrics should be collected for nodes. Turning it on will increase the number of API calls made to CloudWatch. */
  fetchNodes?: Maybe<Scalars['Boolean']['output']>;
  /** The cloud service integration identifier. */
  id?: Maybe<Scalars['Int']['output']>;
  /**
   * [DEPRECATED] Multiple polling interval is no longer supported, use only metrics_polling_interval
   * @deprecated [DEPRECATED] Multiple polling interval is no longer supported, use only metrics_polling_interval
   */
  inventoryPollingInterval?: Maybe<Scalars['Int']['output']>;
  /** The parent linked account identifier. */
  linkedAccount?: Maybe<CloudLinkedAccount>;
  /** The data polling interval in seconds. */
  metricsPollingInterval?: Maybe<Scalars['Int']['output']>;
  /** The cloud service integration name. */
  name?: Maybe<Scalars['String']['output']>;
  /** The parent NewRelic account identifier. */
  nrAccountId: Scalars['Int']['output'];
  /** The cloud service used in the integration. */
  service?: Maybe<CloudService>;
  /** Specify a Tag key associated with the resources that you want to monitor. Filter values are case-sensitive. */
  tagKey?: Maybe<Scalars['String']['output']>;
  /** Specify a Tag value associated with the resources that you want to monitor. Filter values are case-sensitive. */
  tagValue?: Maybe<Scalars['String']['output']>;
  /** The object last update date, in epoch (Unix) time */
  updatedAt: Scalars['EpochSeconds']['output'];
};

/** Amazon Elasticsearch Service */
export type CloudElasticsearchIntegrationInput = {
  /** Specify each AWS region that includes the resources that you want to monitor. */
  awsRegions?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  /** Specify if metrics should be collected for nodes. Turning it on will increase the number of API calls made to CloudWatch. */
  fetchNodes?: InputMaybe<Scalars['Boolean']['input']>;
  /** [DEPRECATED] Multiple polling interval is no longer supported, use only metrics_polling_interval */
  inventoryPollingInterval?: InputMaybe<Scalars['Int']['input']>;
  /** The linked account identifier. */
  linkedAccountId: Scalars['Int']['input'];
  /** The data polling interval in seconds. */
  metricsPollingInterval?: InputMaybe<Scalars['Int']['input']>;
  /** Specify a Tag key associated with the resources that you want to monitor. Filter values are case-sensitive. */
  tagKey?: InputMaybe<Scalars['String']['input']>;
  /** Specify a Tag value associated with the resources that you want to monitor. Filter values are case-sensitive. */
  tagValue?: InputMaybe<Scalars['String']['input']>;
};

/** ELB (Classic) Integration */
export type CloudElbIntegration = CloudIntegration & {
  __typename?: 'CloudElbIntegration';
  /** Specify each AWS region that includes the resources that you want to monitor. */
  awsRegions?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
  /** The object creation date, in epoch (Unix) time */
  createdAt: Scalars['EpochSeconds']['output'];
  /** Determine if extra inventory data be collected or not. May affect total data collection time and contribute to the Cloud provider API rate limit. */
  fetchExtendedInventory?: Maybe<Scalars['Boolean']['output']>;
  /** Specify if tags should be collected. May affect total data collection time and contribute to the Cloud provider API rate limit. */
  fetchTags?: Maybe<Scalars['Boolean']['output']>;
  /** The cloud service integration identifier. */
  id?: Maybe<Scalars['Int']['output']>;
  /**
   * [DEPRECATED] Multiple polling interval is no longer supported, use only metrics_polling_interval
   * @deprecated [DEPRECATED] Multiple polling interval is no longer supported, use only metrics_polling_interval
   */
  inventoryPollingInterval?: Maybe<Scalars['Int']['output']>;
  /** The parent linked account identifier. */
  linkedAccount?: Maybe<CloudLinkedAccount>;
  /** The data polling interval in seconds. */
  metricsPollingInterval?: Maybe<Scalars['Int']['output']>;
  /** The cloud service integration name. */
  name?: Maybe<Scalars['String']['output']>;
  /** The parent NewRelic account identifier. */
  nrAccountId: Scalars['Int']['output'];
  /** The cloud service used in the integration. */
  service?: Maybe<CloudService>;
  /** The object last update date, in epoch (Unix) time */
  updatedAt: Scalars['EpochSeconds']['output'];
};

/** Elastic Load Balancing - Classic Load Balancer (ELB) */
export type CloudElbIntegrationInput = {
  /** Specify each AWS region that includes the resources that you want to monitor. */
  awsRegions?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  /** Determine if extra inventory data be collected or not. May affect total data collection time and contribute to the Cloud provider API rate limit. */
  fetchExtendedInventory?: InputMaybe<Scalars['Boolean']['input']>;
  /** Specify if tags should be collected. May affect total data collection time and contribute to the Cloud provider API rate limit. */
  fetchTags?: InputMaybe<Scalars['Boolean']['input']>;
  /** [DEPRECATED] Multiple polling interval is no longer supported, use only metrics_polling_interval */
  inventoryPollingInterval?: InputMaybe<Scalars['Int']['input']>;
  /** The linked account identifier. */
  linkedAccountId: Scalars['Int']['input'];
  /** The data polling interval in seconds. */
  metricsPollingInterval?: InputMaybe<Scalars['Int']['input']>;
};

/** EMR Integration */
export type CloudEmrIntegration = CloudIntegration & {
  __typename?: 'CloudEmrIntegration';
  /** Specify each AWS region that includes the resources that you want to monitor. */
  awsRegions?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
  /** The object creation date, in epoch (Unix) time */
  createdAt: Scalars['EpochSeconds']['output'];
  /** Specify if tags and the extended inventory should be collected. May affect total data collection time and contribute to the Cloud provider API rate limit. */
  fetchTags?: Maybe<Scalars['Boolean']['output']>;
  /** The cloud service integration identifier. */
  id?: Maybe<Scalars['Int']['output']>;
  /**
   * [DEPRECATED] Multiple polling interval is no longer supported, use only metrics_polling_interval
   * @deprecated [DEPRECATED] Multiple polling interval is no longer supported, use only metrics_polling_interval
   */
  inventoryPollingInterval?: Maybe<Scalars['Int']['output']>;
  /** The parent linked account identifier. */
  linkedAccount?: Maybe<CloudLinkedAccount>;
  /** The data polling interval in seconds. */
  metricsPollingInterval?: Maybe<Scalars['Int']['output']>;
  /** The cloud service integration name. */
  name?: Maybe<Scalars['String']['output']>;
  /** The parent NewRelic account identifier. */
  nrAccountId: Scalars['Int']['output'];
  /** The cloud service used in the integration. */
  service?: Maybe<CloudService>;
  /** Specify a Tag key associated with the resources that you want to monitor. Filter values are case-sensitive. */
  tagKey?: Maybe<Scalars['String']['output']>;
  /** Specify a Tag value associated with the resources that you want to monitor. Filter values are case-sensitive. */
  tagValue?: Maybe<Scalars['String']['output']>;
  /** The object last update date, in epoch (Unix) time */
  updatedAt: Scalars['EpochSeconds']['output'];
};

/** Amazon Elastic MapReduce (EMR) */
export type CloudEmrIntegrationInput = {
  /** Specify each AWS region that includes the resources that you want to monitor. */
  awsRegions?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  /** Specify if tags and the extended inventory should be collected. May affect total data collection time and contribute to the Cloud provider API rate limit. */
  fetchTags?: InputMaybe<Scalars['Boolean']['input']>;
  /** [DEPRECATED] Multiple polling interval is no longer supported, use only metrics_polling_interval */
  inventoryPollingInterval?: InputMaybe<Scalars['Int']['input']>;
  /** The linked account identifier. */
  linkedAccountId: Scalars['Int']['input'];
  /** The data polling interval in seconds. */
  metricsPollingInterval?: InputMaybe<Scalars['Int']['input']>;
  /** Specify a Tag key associated with the resources that you want to monitor. Filter values are case-sensitive. */
  tagKey?: InputMaybe<Scalars['String']['input']>;
  /** Specify a Tag value associated with the resources that you want to monitor. Filter values are case-sensitive. */
  tagValue?: InputMaybe<Scalars['String']['input']>;
};

/** Vertex AI Integration */
export type CloudGcpAiplatformIntegration = CloudIntegration & {
  __typename?: 'CloudGcpAiplatformIntegration';
  /** The object creation date, in epoch (Unix) time */
  createdAt: Scalars['EpochSeconds']['output'];
  /** The cloud service integration identifier. */
  id?: Maybe<Scalars['Int']['output']>;
  /**
   * [DEPRECATED] Multiple polling interval is no longer supported, use only metrics_polling_interval
   * @deprecated [DEPRECATED] Multiple polling interval is no longer supported, use only metrics_polling_interval
   */
  inventoryPollingInterval?: Maybe<Scalars['Int']['output']>;
  /** The parent linked account identifier. */
  linkedAccount?: Maybe<CloudLinkedAccount>;
  /** The data polling interval in seconds. */
  metricsPollingInterval?: Maybe<Scalars['Int']['output']>;
  /** The cloud service integration name. */
  name?: Maybe<Scalars['String']['output']>;
  /** The parent NewRelic account identifier. */
  nrAccountId: Scalars['Int']['output'];
  /** The cloud service used in the integration. */
  service?: Maybe<CloudService>;
  /** The object last update date, in epoch (Unix) time */
  updatedAt: Scalars['EpochSeconds']['output'];
};

/** Vertex AI */
export type CloudGcpAiplatformIntegrationInput = {
  /** [DEPRECATED] Multiple polling interval is no longer supported, use only metrics_polling_interval */
  inventoryPollingInterval?: InputMaybe<Scalars['Int']['input']>;
  /** The linked account identifier. */
  linkedAccountId: Scalars['Int']['input'];
  /** The data polling interval in seconds. */
  metricsPollingInterval?: InputMaybe<Scalars['Int']['input']>;
};

/** AlloyDB Integration */
export type CloudGcpAlloydbIntegration = CloudIntegration & {
  __typename?: 'CloudGcpAlloydbIntegration';
  /** The object creation date, in epoch (Unix) time */
  createdAt: Scalars['EpochSeconds']['output'];
  /** The cloud service integration identifier. */
  id?: Maybe<Scalars['Int']['output']>;
  /**
   * [DEPRECATED] Multiple polling interval is no longer supported, use only metrics_polling_interval
   * @deprecated [DEPRECATED] Multiple polling interval is no longer supported, use only metrics_polling_interval
   */
  inventoryPollingInterval?: Maybe<Scalars['Int']['output']>;
  /** The parent linked account identifier. */
  linkedAccount?: Maybe<CloudLinkedAccount>;
  /** The data polling interval in seconds. */
  metricsPollingInterval?: Maybe<Scalars['Int']['output']>;
  /** The cloud service integration name. */
  name?: Maybe<Scalars['String']['output']>;
  /** The parent NewRelic account identifier. */
  nrAccountId: Scalars['Int']['output'];
  /** The cloud service used in the integration. */
  service?: Maybe<CloudService>;
  /** The object last update date, in epoch (Unix) time */
  updatedAt: Scalars['EpochSeconds']['output'];
};

/** AlloyDB */
export type CloudGcpAlloydbIntegrationInput = {
  /** [DEPRECATED] Multiple polling interval is no longer supported, use only metrics_polling_interval */
  inventoryPollingInterval?: InputMaybe<Scalars['Int']['input']>;
  /** The linked account identifier. */
  linkedAccountId: Scalars['Int']['input'];
  /** The data polling interval in seconds. */
  metricsPollingInterval?: InputMaybe<Scalars['Int']['input']>;
};

/** App Engine Integration */
export type CloudGcpAppengineIntegration = CloudIntegration & {
  __typename?: 'CloudGcpAppengineIntegration';
  /** The object creation date, in epoch (Unix) time */
  createdAt: Scalars['EpochSeconds']['output'];
  /** The cloud service integration identifier. */
  id?: Maybe<Scalars['Int']['output']>;
  /**
   * [DEPRECATED] Multiple polling interval is no longer supported, use only metrics_polling_interval
   * @deprecated [DEPRECATED] Multiple polling interval is no longer supported, use only metrics_polling_interval
   */
  inventoryPollingInterval?: Maybe<Scalars['Int']['output']>;
  /** The parent linked account identifier. */
  linkedAccount?: Maybe<CloudLinkedAccount>;
  /** The data polling interval in seconds. */
  metricsPollingInterval?: Maybe<Scalars['Int']['output']>;
  /** The cloud service integration name. */
  name?: Maybe<Scalars['String']['output']>;
  /** The parent NewRelic account identifier. */
  nrAccountId: Scalars['Int']['output'];
  /** The cloud service used in the integration. */
  service?: Maybe<CloudService>;
  /** The object last update date, in epoch (Unix) time */
  updatedAt: Scalars['EpochSeconds']['output'];
};

/** Google App Engine */
export type CloudGcpAppengineIntegrationInput = {
  /** [DEPRECATED] Multiple polling interval is no longer supported, use only metrics_polling_interval */
  inventoryPollingInterval?: InputMaybe<Scalars['Int']['input']>;
  /** The linked account identifier. */
  linkedAccountId: Scalars['Int']['input'];
  /** The data polling interval in seconds. */
  metricsPollingInterval?: InputMaybe<Scalars['Int']['input']>;
};

/** BigQuery Integration */
export type CloudGcpBigqueryIntegration = CloudIntegration & {
  __typename?: 'CloudGcpBigqueryIntegration';
  /** The object creation date, in epoch (Unix) time */
  createdAt: Scalars['EpochSeconds']['output'];
  /** Fetch BigQuery Table metrics, disabled by default */
  fetchTableMetrics?: Maybe<Scalars['Boolean']['output']>;
  /** Specify if labels and the extended inventory should be collected. May affect total data collection time and contribute to the Cloud provider API rate limit. */
  fetchTags?: Maybe<Scalars['Boolean']['output']>;
  /** The cloud service integration identifier. */
  id?: Maybe<Scalars['Int']['output']>;
  /**
   * [DEPRECATED] Multiple polling interval is no longer supported, use only metrics_polling_interval
   * @deprecated [DEPRECATED] Multiple polling interval is no longer supported, use only metrics_polling_interval
   */
  inventoryPollingInterval?: Maybe<Scalars['Int']['output']>;
  /** The parent linked account identifier. */
  linkedAccount?: Maybe<CloudLinkedAccount>;
  /** The data polling interval in seconds. */
  metricsPollingInterval?: Maybe<Scalars['Int']['output']>;
  /** The cloud service integration name. */
  name?: Maybe<Scalars['String']['output']>;
  /** The parent NewRelic account identifier. */
  nrAccountId: Scalars['Int']['output'];
  /** The cloud service used in the integration. */
  service?: Maybe<CloudService>;
  /** The object last update date, in epoch (Unix) time */
  updatedAt: Scalars['EpochSeconds']['output'];
};

/** BigQuery */
export type CloudGcpBigqueryIntegrationInput = {
  /** Fetch BigQuery Table metrics, disabled by default */
  fetchTableMetrics?: InputMaybe<Scalars['Boolean']['input']>;
  /** Specify if labels and the extended inventory should be collected. May affect total data collection time and contribute to the Cloud provider API rate limit. */
  fetchTags?: InputMaybe<Scalars['Boolean']['input']>;
  /** [DEPRECATED] Multiple polling interval is no longer supported, use only metrics_polling_interval */
  inventoryPollingInterval?: InputMaybe<Scalars['Int']['input']>;
  /** The linked account identifier. */
  linkedAccountId: Scalars['Int']['input'];
  /** The data polling interval in seconds. */
  metricsPollingInterval?: InputMaybe<Scalars['Int']['input']>;
};

/** Bigtable Integration */
export type CloudGcpBigtableIntegration = CloudIntegration & {
  __typename?: 'CloudGcpBigtableIntegration';
  /** The object creation date, in epoch (Unix) time */
  createdAt: Scalars['EpochSeconds']['output'];
  /** The cloud service integration identifier. */
  id?: Maybe<Scalars['Int']['output']>;
  /**
   * [DEPRECATED] Multiple polling interval is no longer supported, use only metrics_polling_interval
   * @deprecated [DEPRECATED] Multiple polling interval is no longer supported, use only metrics_polling_interval
   */
  inventoryPollingInterval?: Maybe<Scalars['Int']['output']>;
  /** The parent linked account identifier. */
  linkedAccount?: Maybe<CloudLinkedAccount>;
  /** The data polling interval in seconds. */
  metricsPollingInterval?: Maybe<Scalars['Int']['output']>;
  /** The cloud service integration name. */
  name?: Maybe<Scalars['String']['output']>;
  /** The parent NewRelic account identifier. */
  nrAccountId: Scalars['Int']['output'];
  /** The cloud service used in the integration. */
  service?: Maybe<CloudService>;
  /** The object last update date, in epoch (Unix) time */
  updatedAt: Scalars['EpochSeconds']['output'];
};

/** Bigtable */
export type CloudGcpBigtableIntegrationInput = {
  /** [DEPRECATED] Multiple polling interval is no longer supported, use only metrics_polling_interval */
  inventoryPollingInterval?: InputMaybe<Scalars['Int']['input']>;
  /** The linked account identifier. */
  linkedAccountId: Scalars['Int']['input'];
  /** The data polling interval in seconds. */
  metricsPollingInterval?: InputMaybe<Scalars['Int']['input']>;
};

/** Composer Integration */
export type CloudGcpComposerIntegration = CloudIntegration & {
  __typename?: 'CloudGcpComposerIntegration';
  /** The object creation date, in epoch (Unix) time */
  createdAt: Scalars['EpochSeconds']['output'];
  /** The cloud service integration identifier. */
  id?: Maybe<Scalars['Int']['output']>;
  /**
   * [DEPRECATED] Multiple polling interval is no longer supported, use only metrics_polling_interval
   * @deprecated [DEPRECATED] Multiple polling interval is no longer supported, use only metrics_polling_interval
   */
  inventoryPollingInterval?: Maybe<Scalars['Int']['output']>;
  /** The parent linked account identifier. */
  linkedAccount?: Maybe<CloudLinkedAccount>;
  /** The data polling interval in seconds. */
  metricsPollingInterval?: Maybe<Scalars['Int']['output']>;
  /** The cloud service integration name. */
  name?: Maybe<Scalars['String']['output']>;
  /** The parent NewRelic account identifier. */
  nrAccountId: Scalars['Int']['output'];
  /** The cloud service used in the integration. */
  service?: Maybe<CloudService>;
  /** The object last update date, in epoch (Unix) time */
  updatedAt: Scalars['EpochSeconds']['output'];
};

/** Composer */
export type CloudGcpComposerIntegrationInput = {
  /** [DEPRECATED] Multiple polling interval is no longer supported, use only metrics_polling_interval */
  inventoryPollingInterval?: InputMaybe<Scalars['Int']['input']>;
  /** The linked account identifier. */
  linkedAccountId: Scalars['Int']['input'];
  /** The data polling interval in seconds. */
  metricsPollingInterval?: InputMaybe<Scalars['Int']['input']>;
};

/** Dataflow Integration */
export type CloudGcpDataflowIntegration = CloudIntegration & {
  __typename?: 'CloudGcpDataflowIntegration';
  /** The object creation date, in epoch (Unix) time */
  createdAt: Scalars['EpochSeconds']['output'];
  /** The cloud service integration identifier. */
  id?: Maybe<Scalars['Int']['output']>;
  /**
   * [DEPRECATED] Multiple polling interval is no longer supported, use only metrics_polling_interval
   * @deprecated [DEPRECATED] Multiple polling interval is no longer supported, use only metrics_polling_interval
   */
  inventoryPollingInterval?: Maybe<Scalars['Int']['output']>;
  /** The parent linked account identifier. */
  linkedAccount?: Maybe<CloudLinkedAccount>;
  /** The data polling interval in seconds. */
  metricsPollingInterval?: Maybe<Scalars['Int']['output']>;
  /** The cloud service integration name. */
  name?: Maybe<Scalars['String']['output']>;
  /** The parent NewRelic account identifier. */
  nrAccountId: Scalars['Int']['output'];
  /** The cloud service used in the integration. */
  service?: Maybe<CloudService>;
  /** The object last update date, in epoch (Unix) time */
  updatedAt: Scalars['EpochSeconds']['output'];
};

/** Dataflow */
export type CloudGcpDataflowIntegrationInput = {
  /** [DEPRECATED] Multiple polling interval is no longer supported, use only metrics_polling_interval */
  inventoryPollingInterval?: InputMaybe<Scalars['Int']['input']>;
  /** The linked account identifier. */
  linkedAccountId: Scalars['Int']['input'];
  /** The data polling interval in seconds. */
  metricsPollingInterval?: InputMaybe<Scalars['Int']['input']>;
};

/** Dataproc Integration */
export type CloudGcpDataprocIntegration = CloudIntegration & {
  __typename?: 'CloudGcpDataprocIntegration';
  /** The object creation date, in epoch (Unix) time */
  createdAt: Scalars['EpochSeconds']['output'];
  /** The cloud service integration identifier. */
  id?: Maybe<Scalars['Int']['output']>;
  /**
   * [DEPRECATED] Multiple polling interval is no longer supported, use only metrics_polling_interval
   * @deprecated [DEPRECATED] Multiple polling interval is no longer supported, use only metrics_polling_interval
   */
  inventoryPollingInterval?: Maybe<Scalars['Int']['output']>;
  /** The parent linked account identifier. */
  linkedAccount?: Maybe<CloudLinkedAccount>;
  /** The data polling interval in seconds. */
  metricsPollingInterval?: Maybe<Scalars['Int']['output']>;
  /** The cloud service integration name. */
  name?: Maybe<Scalars['String']['output']>;
  /** The parent NewRelic account identifier. */
  nrAccountId: Scalars['Int']['output'];
  /** The cloud service used in the integration. */
  service?: Maybe<CloudService>;
  /** The object last update date, in epoch (Unix) time */
  updatedAt: Scalars['EpochSeconds']['output'];
};

/** Dataproc */
export type CloudGcpDataprocIntegrationInput = {
  /** [DEPRECATED] Multiple polling interval is no longer supported, use only metrics_polling_interval */
  inventoryPollingInterval?: InputMaybe<Scalars['Int']['input']>;
  /** The linked account identifier. */
  linkedAccountId: Scalars['Int']['input'];
  /** The data polling interval in seconds. */
  metricsPollingInterval?: InputMaybe<Scalars['Int']['input']>;
};

/** Datastore Integration */
export type CloudGcpDatastoreIntegration = CloudIntegration & {
  __typename?: 'CloudGcpDatastoreIntegration';
  /** The object creation date, in epoch (Unix) time */
  createdAt: Scalars['EpochSeconds']['output'];
  /** The cloud service integration identifier. */
  id?: Maybe<Scalars['Int']['output']>;
  /**
   * [DEPRECATED] Multiple polling interval is no longer supported, use only metrics_polling_interval
   * @deprecated [DEPRECATED] Multiple polling interval is no longer supported, use only metrics_polling_interval
   */
  inventoryPollingInterval?: Maybe<Scalars['Int']['output']>;
  /** The parent linked account identifier. */
  linkedAccount?: Maybe<CloudLinkedAccount>;
  /** The data polling interval in seconds. */
  metricsPollingInterval?: Maybe<Scalars['Int']['output']>;
  /** The cloud service integration name. */
  name?: Maybe<Scalars['String']['output']>;
  /** The parent NewRelic account identifier. */
  nrAccountId: Scalars['Int']['output'];
  /** The cloud service used in the integration. */
  service?: Maybe<CloudService>;
  /** The object last update date, in epoch (Unix) time */
  updatedAt: Scalars['EpochSeconds']['output'];
};

/** Datastore */
export type CloudGcpDatastoreIntegrationInput = {
  /** [DEPRECATED] Multiple polling interval is no longer supported, use only metrics_polling_interval */
  inventoryPollingInterval?: InputMaybe<Scalars['Int']['input']>;
  /** The linked account identifier. */
  linkedAccountId: Scalars['Int']['input'];
  /** The data polling interval in seconds. */
  metricsPollingInterval?: InputMaybe<Scalars['Int']['input']>;
};

/** List of integrations */
export type CloudGcpDisableIntegrationsInput = {
  /** Vertex AI integration */
  gcpAiplatform?: InputMaybe<Array<InputMaybe<CloudDisableAccountIntegrationInput>>>;
  /** AlloyDB integration */
  gcpAlloydb?: InputMaybe<Array<InputMaybe<CloudDisableAccountIntegrationInput>>>;
  /** App Engine integration */
  gcpAppengine?: InputMaybe<Array<InputMaybe<CloudDisableAccountIntegrationInput>>>;
  /** BigQuery integration */
  gcpBigquery?: InputMaybe<Array<InputMaybe<CloudDisableAccountIntegrationInput>>>;
  /** Bigtable integration */
  gcpBigtable?: InputMaybe<Array<InputMaybe<CloudDisableAccountIntegrationInput>>>;
  /** Composer integration */
  gcpComposer?: InputMaybe<Array<InputMaybe<CloudDisableAccountIntegrationInput>>>;
  /** Dataflow integration */
  gcpDataflow?: InputMaybe<Array<InputMaybe<CloudDisableAccountIntegrationInput>>>;
  /** Dataproc integration */
  gcpDataproc?: InputMaybe<Array<InputMaybe<CloudDisableAccountIntegrationInput>>>;
  /** Datastore integration */
  gcpDatastore?: InputMaybe<Array<InputMaybe<CloudDisableAccountIntegrationInput>>>;
  /** Firebase Database integration */
  gcpFirebasedatabase?: InputMaybe<Array<InputMaybe<CloudDisableAccountIntegrationInput>>>;
  /** Firebase Hosting integration */
  gcpFirebasehosting?: InputMaybe<Array<InputMaybe<CloudDisableAccountIntegrationInput>>>;
  /** Firebase Storage integration */
  gcpFirebasestorage?: InputMaybe<Array<InputMaybe<CloudDisableAccountIntegrationInput>>>;
  /** Firestore integration */
  gcpFirestore?: InputMaybe<Array<InputMaybe<CloudDisableAccountIntegrationInput>>>;
  /** Cloud Functions integration */
  gcpFunctions?: InputMaybe<Array<InputMaybe<CloudDisableAccountIntegrationInput>>>;
  /** Interconnect integration */
  gcpInterconnect?: InputMaybe<Array<InputMaybe<CloudDisableAccountIntegrationInput>>>;
  /** Kubernetes Engine integration */
  gcpKubernetes?: InputMaybe<Array<InputMaybe<CloudDisableAccountIntegrationInput>>>;
  /** Cloud Load Balancing integration */
  gcpLoadbalancing?: InputMaybe<Array<InputMaybe<CloudDisableAccountIntegrationInput>>>;
  /** Memcache integration */
  gcpMemcache?: InputMaybe<Array<InputMaybe<CloudDisableAccountIntegrationInput>>>;
  /** Cloud Pub/Sub integration */
  gcpPubsub?: InputMaybe<Array<InputMaybe<CloudDisableAccountIntegrationInput>>>;
  /** Redis integration */
  gcpRedis?: InputMaybe<Array<InputMaybe<CloudDisableAccountIntegrationInput>>>;
  /** Router integration */
  gcpRouter?: InputMaybe<Array<InputMaybe<CloudDisableAccountIntegrationInput>>>;
  /** Run integration */
  gcpRun?: InputMaybe<Array<InputMaybe<CloudDisableAccountIntegrationInput>>>;
  /** Cloud Spanner integration */
  gcpSpanner?: InputMaybe<Array<InputMaybe<CloudDisableAccountIntegrationInput>>>;
  /** Cloud SQL integration */
  gcpSql?: InputMaybe<Array<InputMaybe<CloudDisableAccountIntegrationInput>>>;
  /** Cloud Storage integration */
  gcpStorage?: InputMaybe<Array<InputMaybe<CloudDisableAccountIntegrationInput>>>;
  /** Compute Engine integration */
  gcpVms?: InputMaybe<Array<InputMaybe<CloudDisableAccountIntegrationInput>>>;
  /** VPC Access integration */
  gcpVpcaccess?: InputMaybe<Array<InputMaybe<CloudDisableAccountIntegrationInput>>>;
};

/** Firebase Database Integration */
export type CloudGcpFirebasedatabaseIntegration = CloudIntegration & {
  __typename?: 'CloudGcpFirebasedatabaseIntegration';
  /** The object creation date, in epoch (Unix) time */
  createdAt: Scalars['EpochSeconds']['output'];
  /** The cloud service integration identifier. */
  id?: Maybe<Scalars['Int']['output']>;
  /**
   * [DEPRECATED] Multiple polling interval is no longer supported, use only metrics_polling_interval
   * @deprecated [DEPRECATED] Multiple polling interval is no longer supported, use only metrics_polling_interval
   */
  inventoryPollingInterval?: Maybe<Scalars['Int']['output']>;
  /** The parent linked account identifier. */
  linkedAccount?: Maybe<CloudLinkedAccount>;
  /** The data polling interval in seconds. */
  metricsPollingInterval?: Maybe<Scalars['Int']['output']>;
  /** The cloud service integration name. */
  name?: Maybe<Scalars['String']['output']>;
  /** The parent NewRelic account identifier. */
  nrAccountId: Scalars['Int']['output'];
  /** The cloud service used in the integration. */
  service?: Maybe<CloudService>;
  /** The object last update date, in epoch (Unix) time */
  updatedAt: Scalars['EpochSeconds']['output'];
};

/** Firebase Database */
export type CloudGcpFirebasedatabaseIntegrationInput = {
  /** [DEPRECATED] Multiple polling interval is no longer supported, use only metrics_polling_interval */
  inventoryPollingInterval?: InputMaybe<Scalars['Int']['input']>;
  /** The linked account identifier. */
  linkedAccountId: Scalars['Int']['input'];
  /** The data polling interval in seconds. */
  metricsPollingInterval?: InputMaybe<Scalars['Int']['input']>;
};

/** Firebase Hosting Integration */
export type CloudGcpFirebasehostingIntegration = CloudIntegration & {
  __typename?: 'CloudGcpFirebasehostingIntegration';
  /** The object creation date, in epoch (Unix) time */
  createdAt: Scalars['EpochSeconds']['output'];
  /** The cloud service integration identifier. */
  id?: Maybe<Scalars['Int']['output']>;
  /**
   * [DEPRECATED] Multiple polling interval is no longer supported, use only metrics_polling_interval
   * @deprecated [DEPRECATED] Multiple polling interval is no longer supported, use only metrics_polling_interval
   */
  inventoryPollingInterval?: Maybe<Scalars['Int']['output']>;
  /** The parent linked account identifier. */
  linkedAccount?: Maybe<CloudLinkedAccount>;
  /** The data polling interval in seconds. */
  metricsPollingInterval?: Maybe<Scalars['Int']['output']>;
  /** The cloud service integration name. */
  name?: Maybe<Scalars['String']['output']>;
  /** The parent NewRelic account identifier. */
  nrAccountId: Scalars['Int']['output'];
  /** The cloud service used in the integration. */
  service?: Maybe<CloudService>;
  /** The object last update date, in epoch (Unix) time */
  updatedAt: Scalars['EpochSeconds']['output'];
};

/** Firebase Hosting */
export type CloudGcpFirebasehostingIntegrationInput = {
  /** [DEPRECATED] Multiple polling interval is no longer supported, use only metrics_polling_interval */
  inventoryPollingInterval?: InputMaybe<Scalars['Int']['input']>;
  /** The linked account identifier. */
  linkedAccountId: Scalars['Int']['input'];
  /** The data polling interval in seconds. */
  metricsPollingInterval?: InputMaybe<Scalars['Int']['input']>;
};

/** Firebase Storage Integration */
export type CloudGcpFirebasestorageIntegration = CloudIntegration & {
  __typename?: 'CloudGcpFirebasestorageIntegration';
  /** The object creation date, in epoch (Unix) time */
  createdAt: Scalars['EpochSeconds']['output'];
  /** The cloud service integration identifier. */
  id?: Maybe<Scalars['Int']['output']>;
  /**
   * [DEPRECATED] Multiple polling interval is no longer supported, use only metrics_polling_interval
   * @deprecated [DEPRECATED] Multiple polling interval is no longer supported, use only metrics_polling_interval
   */
  inventoryPollingInterval?: Maybe<Scalars['Int']['output']>;
  /** The parent linked account identifier. */
  linkedAccount?: Maybe<CloudLinkedAccount>;
  /** The data polling interval in seconds. */
  metricsPollingInterval?: Maybe<Scalars['Int']['output']>;
  /** The cloud service integration name. */
  name?: Maybe<Scalars['String']['output']>;
  /** The parent NewRelic account identifier. */
  nrAccountId: Scalars['Int']['output'];
  /** The cloud service used in the integration. */
  service?: Maybe<CloudService>;
  /** The object last update date, in epoch (Unix) time */
  updatedAt: Scalars['EpochSeconds']['output'];
};

/** Firebase Storage */
export type CloudGcpFirebasestorageIntegrationInput = {
  /** [DEPRECATED] Multiple polling interval is no longer supported, use only metrics_polling_interval */
  inventoryPollingInterval?: InputMaybe<Scalars['Int']['input']>;
  /** The linked account identifier. */
  linkedAccountId: Scalars['Int']['input'];
  /** The data polling interval in seconds. */
  metricsPollingInterval?: InputMaybe<Scalars['Int']['input']>;
};

/** Firestore Integration */
export type CloudGcpFirestoreIntegration = CloudIntegration & {
  __typename?: 'CloudGcpFirestoreIntegration';
  /** The object creation date, in epoch (Unix) time */
  createdAt: Scalars['EpochSeconds']['output'];
  /** The cloud service integration identifier. */
  id?: Maybe<Scalars['Int']['output']>;
  /**
   * [DEPRECATED] Multiple polling interval is no longer supported, use only metrics_polling_interval
   * @deprecated [DEPRECATED] Multiple polling interval is no longer supported, use only metrics_polling_interval
   */
  inventoryPollingInterval?: Maybe<Scalars['Int']['output']>;
  /** The parent linked account identifier. */
  linkedAccount?: Maybe<CloudLinkedAccount>;
  /** The data polling interval in seconds. */
  metricsPollingInterval?: Maybe<Scalars['Int']['output']>;
  /** The cloud service integration name. */
  name?: Maybe<Scalars['String']['output']>;
  /** The parent NewRelic account identifier. */
  nrAccountId: Scalars['Int']['output'];
  /** The cloud service used in the integration. */
  service?: Maybe<CloudService>;
  /** The object last update date, in epoch (Unix) time */
  updatedAt: Scalars['EpochSeconds']['output'];
};

/** Firestore */
export type CloudGcpFirestoreIntegrationInput = {
  /** [DEPRECATED] Multiple polling interval is no longer supported, use only metrics_polling_interval */
  inventoryPollingInterval?: InputMaybe<Scalars['Int']['input']>;
  /** The linked account identifier. */
  linkedAccountId: Scalars['Int']['input'];
  /** The data polling interval in seconds. */
  metricsPollingInterval?: InputMaybe<Scalars['Int']['input']>;
};

/** Cloud Functions Integration */
export type CloudGcpFunctionsIntegration = CloudIntegration & {
  __typename?: 'CloudGcpFunctionsIntegration';
  /** The object creation date, in epoch (Unix) time */
  createdAt: Scalars['EpochSeconds']['output'];
  /** The cloud service integration identifier. */
  id?: Maybe<Scalars['Int']['output']>;
  /**
   * [DEPRECATED] Multiple polling interval is no longer supported, use only metrics_polling_interval
   * @deprecated [DEPRECATED] Multiple polling interval is no longer supported, use only metrics_polling_interval
   */
  inventoryPollingInterval?: Maybe<Scalars['Int']['output']>;
  /** The parent linked account identifier. */
  linkedAccount?: Maybe<CloudLinkedAccount>;
  /** The data polling interval in seconds. */
  metricsPollingInterval?: Maybe<Scalars['Int']['output']>;
  /** The cloud service integration name. */
  name?: Maybe<Scalars['String']['output']>;
  /** The parent NewRelic account identifier. */
  nrAccountId: Scalars['Int']['output'];
  /** The cloud service used in the integration. */
  service?: Maybe<CloudService>;
  /** The object last update date, in epoch (Unix) time */
  updatedAt: Scalars['EpochSeconds']['output'];
};

/** Google Cloud Functions */
export type CloudGcpFunctionsIntegrationInput = {
  /** [DEPRECATED] Multiple polling interval is no longer supported, use only metrics_polling_interval */
  inventoryPollingInterval?: InputMaybe<Scalars['Int']['input']>;
  /** The linked account identifier. */
  linkedAccountId: Scalars['Int']['input'];
  /** The data polling interval in seconds. */
  metricsPollingInterval?: InputMaybe<Scalars['Int']['input']>;
};

/** List of integrations */
export type CloudGcpIntegrationsInput = {
  /** Vertex AI integration */
  gcpAiplatform?: InputMaybe<Array<InputMaybe<CloudGcpAiplatformIntegrationInput>>>;
  /** AlloyDB integration */
  gcpAlloydb?: InputMaybe<Array<InputMaybe<CloudGcpAlloydbIntegrationInput>>>;
  /** App Engine integration */
  gcpAppengine?: InputMaybe<Array<InputMaybe<CloudGcpAppengineIntegrationInput>>>;
  /** BigQuery integration */
  gcpBigquery?: InputMaybe<Array<InputMaybe<CloudGcpBigqueryIntegrationInput>>>;
  /** Bigtable integration */
  gcpBigtable?: InputMaybe<Array<InputMaybe<CloudGcpBigtableIntegrationInput>>>;
  /** Composer integration */
  gcpComposer?: InputMaybe<Array<InputMaybe<CloudGcpComposerIntegrationInput>>>;
  /** Dataflow integration */
  gcpDataflow?: InputMaybe<Array<InputMaybe<CloudGcpDataflowIntegrationInput>>>;
  /** Dataproc integration */
  gcpDataproc?: InputMaybe<Array<InputMaybe<CloudGcpDataprocIntegrationInput>>>;
  /** Datastore integration */
  gcpDatastore?: InputMaybe<Array<InputMaybe<CloudGcpDatastoreIntegrationInput>>>;
  /** Firebase Database integration */
  gcpFirebasedatabase?: InputMaybe<Array<InputMaybe<CloudGcpFirebasedatabaseIntegrationInput>>>;
  /** Firebase Hosting integration */
  gcpFirebasehosting?: InputMaybe<Array<InputMaybe<CloudGcpFirebasehostingIntegrationInput>>>;
  /** Firebase Storage integration */
  gcpFirebasestorage?: InputMaybe<Array<InputMaybe<CloudGcpFirebasestorageIntegrationInput>>>;
  /** Firestore integration */
  gcpFirestore?: InputMaybe<Array<InputMaybe<CloudGcpFirestoreIntegrationInput>>>;
  /** Cloud Functions integration */
  gcpFunctions?: InputMaybe<Array<InputMaybe<CloudGcpFunctionsIntegrationInput>>>;
  /** Interconnect integration */
  gcpInterconnect?: InputMaybe<Array<InputMaybe<CloudGcpInterconnectIntegrationInput>>>;
  /** Kubernetes Engine integration */
  gcpKubernetes?: InputMaybe<Array<InputMaybe<CloudGcpKubernetesIntegrationInput>>>;
  /** Cloud Load Balancing integration */
  gcpLoadbalancing?: InputMaybe<Array<InputMaybe<CloudGcpLoadbalancingIntegrationInput>>>;
  /** Memcache integration */
  gcpMemcache?: InputMaybe<Array<InputMaybe<CloudGcpMemcacheIntegrationInput>>>;
  /** Cloud Pub/Sub integration */
  gcpPubsub?: InputMaybe<Array<InputMaybe<CloudGcpPubsubIntegrationInput>>>;
  /** Redis integration */
  gcpRedis?: InputMaybe<Array<InputMaybe<CloudGcpRedisIntegrationInput>>>;
  /** Router integration */
  gcpRouter?: InputMaybe<Array<InputMaybe<CloudGcpRouterIntegrationInput>>>;
  /** Run integration */
  gcpRun?: InputMaybe<Array<InputMaybe<CloudGcpRunIntegrationInput>>>;
  /** Cloud Spanner integration */
  gcpSpanner?: InputMaybe<Array<InputMaybe<CloudGcpSpannerIntegrationInput>>>;
  /** Cloud SQL integration */
  gcpSql?: InputMaybe<Array<InputMaybe<CloudGcpSqlIntegrationInput>>>;
  /** Cloud Storage integration */
  gcpStorage?: InputMaybe<Array<InputMaybe<CloudGcpStorageIntegrationInput>>>;
  /** Compute Engine integration */
  gcpVms?: InputMaybe<Array<InputMaybe<CloudGcpVmsIntegrationInput>>>;
  /** VPC Access integration */
  gcpVpcaccess?: InputMaybe<Array<InputMaybe<CloudGcpVpcaccessIntegrationInput>>>;
};

/** Interconnect Integration */
export type CloudGcpInterconnectIntegration = CloudIntegration & {
  __typename?: 'CloudGcpInterconnectIntegration';
  /** The object creation date, in epoch (Unix) time */
  createdAt: Scalars['EpochSeconds']['output'];
  /** The cloud service integration identifier. */
  id?: Maybe<Scalars['Int']['output']>;
  /**
   * [DEPRECATED] Multiple polling interval is no longer supported, use only metrics_polling_interval
   * @deprecated [DEPRECATED] Multiple polling interval is no longer supported, use only metrics_polling_interval
   */
  inventoryPollingInterval?: Maybe<Scalars['Int']['output']>;
  /** The parent linked account identifier. */
  linkedAccount?: Maybe<CloudLinkedAccount>;
  /** The data polling interval in seconds. */
  metricsPollingInterval?: Maybe<Scalars['Int']['output']>;
  /** The cloud service integration name. */
  name?: Maybe<Scalars['String']['output']>;
  /** The parent NewRelic account identifier. */
  nrAccountId: Scalars['Int']['output'];
  /** The cloud service used in the integration. */
  service?: Maybe<CloudService>;
  /** The object last update date, in epoch (Unix) time */
  updatedAt: Scalars['EpochSeconds']['output'];
};

/** Interconnect */
export type CloudGcpInterconnectIntegrationInput = {
  /** [DEPRECATED] Multiple polling interval is no longer supported, use only metrics_polling_interval */
  inventoryPollingInterval?: InputMaybe<Scalars['Int']['input']>;
  /** The linked account identifier. */
  linkedAccountId: Scalars['Int']['input'];
  /** The data polling interval in seconds. */
  metricsPollingInterval?: InputMaybe<Scalars['Int']['input']>;
};

/** Kubernetes Engine Integration */
export type CloudGcpKubernetesIntegration = CloudIntegration & {
  __typename?: 'CloudGcpKubernetesIntegration';
  /** The object creation date, in epoch (Unix) time */
  createdAt: Scalars['EpochSeconds']['output'];
  /** The cloud service integration identifier. */
  id?: Maybe<Scalars['Int']['output']>;
  /**
   * [DEPRECATED] Multiple polling interval is no longer supported, use only metrics_polling_interval
   * @deprecated [DEPRECATED] Multiple polling interval is no longer supported, use only metrics_polling_interval
   */
  inventoryPollingInterval?: Maybe<Scalars['Int']['output']>;
  /** The parent linked account identifier. */
  linkedAccount?: Maybe<CloudLinkedAccount>;
  /** The data polling interval in seconds. */
  metricsPollingInterval?: Maybe<Scalars['Int']['output']>;
  /** The cloud service integration name. */
  name?: Maybe<Scalars['String']['output']>;
  /** The parent NewRelic account identifier. */
  nrAccountId: Scalars['Int']['output'];
  /** The cloud service used in the integration. */
  service?: Maybe<CloudService>;
  /** The object last update date, in epoch (Unix) time */
  updatedAt: Scalars['EpochSeconds']['output'];
};

/** Google Kubernetes Engine */
export type CloudGcpKubernetesIntegrationInput = {
  /** [DEPRECATED] Multiple polling interval is no longer supported, use only metrics_polling_interval */
  inventoryPollingInterval?: InputMaybe<Scalars['Int']['input']>;
  /** The linked account identifier. */
  linkedAccountId: Scalars['Int']['input'];
  /** The data polling interval in seconds. */
  metricsPollingInterval?: InputMaybe<Scalars['Int']['input']>;
};

/** Information required to link a GCP account to a NewRelic account. */
export type CloudGcpLinkAccountInput = {
  /** The linked account name. */
  name: Scalars['String']['input'];
  /** The GCP project identifier. */
  projectId: Scalars['String']['input'];
};

/** Cloud Load Balancing Integration */
export type CloudGcpLoadbalancingIntegration = CloudIntegration & {
  __typename?: 'CloudGcpLoadbalancingIntegration';
  /** The object creation date, in epoch (Unix) time */
  createdAt: Scalars['EpochSeconds']['output'];
  /** The cloud service integration identifier. */
  id?: Maybe<Scalars['Int']['output']>;
  /**
   * [DEPRECATED] Multiple polling interval is no longer supported, use only metrics_polling_interval
   * @deprecated [DEPRECATED] Multiple polling interval is no longer supported, use only metrics_polling_interval
   */
  inventoryPollingInterval?: Maybe<Scalars['Int']['output']>;
  /** The parent linked account identifier. */
  linkedAccount?: Maybe<CloudLinkedAccount>;
  /** The data polling interval in seconds. */
  metricsPollingInterval?: Maybe<Scalars['Int']['output']>;
  /** The cloud service integration name. */
  name?: Maybe<Scalars['String']['output']>;
  /** The parent NewRelic account identifier. */
  nrAccountId: Scalars['Int']['output'];
  /** The cloud service used in the integration. */
  service?: Maybe<CloudService>;
  /** The object last update date, in epoch (Unix) time */
  updatedAt: Scalars['EpochSeconds']['output'];
};

/** Google Cloud Load Balancing */
export type CloudGcpLoadbalancingIntegrationInput = {
  /** [DEPRECATED] Multiple polling interval is no longer supported, use only metrics_polling_interval */
  inventoryPollingInterval?: InputMaybe<Scalars['Int']['input']>;
  /** The linked account identifier. */
  linkedAccountId: Scalars['Int']['input'];
  /** The data polling interval in seconds. */
  metricsPollingInterval?: InputMaybe<Scalars['Int']['input']>;
};

/** Memcache Integration */
export type CloudGcpMemcacheIntegration = CloudIntegration & {
  __typename?: 'CloudGcpMemcacheIntegration';
  /** The object creation date, in epoch (Unix) time */
  createdAt: Scalars['EpochSeconds']['output'];
  /** The cloud service integration identifier. */
  id?: Maybe<Scalars['Int']['output']>;
  /**
   * [DEPRECATED] Multiple polling interval is no longer supported, use only metrics_polling_interval
   * @deprecated [DEPRECATED] Multiple polling interval is no longer supported, use only metrics_polling_interval
   */
  inventoryPollingInterval?: Maybe<Scalars['Int']['output']>;
  /** The parent linked account identifier. */
  linkedAccount?: Maybe<CloudLinkedAccount>;
  /** The data polling interval in seconds. */
  metricsPollingInterval?: Maybe<Scalars['Int']['output']>;
  /** The cloud service integration name. */
  name?: Maybe<Scalars['String']['output']>;
  /** The parent NewRelic account identifier. */
  nrAccountId: Scalars['Int']['output'];
  /** The cloud service used in the integration. */
  service?: Maybe<CloudService>;
  /** The object last update date, in epoch (Unix) time */
  updatedAt: Scalars['EpochSeconds']['output'];
};

/** Memcache */
export type CloudGcpMemcacheIntegrationInput = {
  /** [DEPRECATED] Multiple polling interval is no longer supported, use only metrics_polling_interval */
  inventoryPollingInterval?: InputMaybe<Scalars['Int']['input']>;
  /** The linked account identifier. */
  linkedAccountId: Scalars['Int']['input'];
  /** The data polling interval in seconds. */
  metricsPollingInterval?: InputMaybe<Scalars['Int']['input']>;
};

/** Google Cloud Platform project information */
export type CloudGcpProject = {
  __typename?: 'CloudGcpProject';
  /** The gcp project id. */
  id: Scalars['String']['output'];
  /** The gcp project name. */
  name: Scalars['String']['output'];
  /** Shows if the project is alredy linked. */
  registered: Scalars['Boolean']['output'];
  /** The gcp project state. */
  state: Scalars['String']['output'];
};

/** The Google Cloud Platform cloud provider */
export type CloudGcpProvider = CloudProvider & {
  __typename?: 'CloudGcpProvider';
  /** The object creation date, in epoch (Unix) time */
  createdAt: Scalars['EpochSeconds']['output'];
  /** The cloud provider icon name. */
  icon: Scalars['String']['output'];
  /** The cloud provider identifier in NewRelic. */
  id: Scalars['Int']['output'];
  /** The cloud provider name. */
  name: Scalars['String']['output'];
  /** The list of GCP projects. */
  projects: Array<CloudGcpProject>;
  /** Get details of one cloud provider service. */
  service?: Maybe<CloudService>;
  /** The service account identifier used to link the GCP project to NewRelic. */
  serviceAccountId: Scalars['String']['output'];
  /** Get details of all the cloud provider services available for integration. */
  services: Array<CloudService>;
  /** The cloud provider short name. */
  slug: Scalars['String']['output'];
  /** The object last update date, in epoch (Unix) time */
  updatedAt: Scalars['EpochSeconds']['output'];
};


/** The Google Cloud Platform cloud provider */
export type CloudGcpProviderProjectsArgs = {
  state: Scalars['String']['input'];
};


/** The Google Cloud Platform cloud provider */
export type CloudGcpProviderServiceArgs = {
  slug: Scalars['String']['input'];
};

/** Cloud Pub/Sub Integration */
export type CloudGcpPubsubIntegration = CloudIntegration & {
  __typename?: 'CloudGcpPubsubIntegration';
  /** The object creation date, in epoch (Unix) time */
  createdAt: Scalars['EpochSeconds']['output'];
  /** Specify if labels and the extended inventory should be collected. May affect total data collection time and contribute to the Cloud provider API rate limit. */
  fetchTags?: Maybe<Scalars['Boolean']['output']>;
  /** The cloud service integration identifier. */
  id?: Maybe<Scalars['Int']['output']>;
  /**
   * [DEPRECATED] Multiple polling interval is no longer supported, use only metrics_polling_interval
   * @deprecated [DEPRECATED] Multiple polling interval is no longer supported, use only metrics_polling_interval
   */
  inventoryPollingInterval?: Maybe<Scalars['Int']['output']>;
  /** The parent linked account identifier. */
  linkedAccount?: Maybe<CloudLinkedAccount>;
  /** The data polling interval in seconds. */
  metricsPollingInterval?: Maybe<Scalars['Int']['output']>;
  /** The cloud service integration name. */
  name?: Maybe<Scalars['String']['output']>;
  /** The parent NewRelic account identifier. */
  nrAccountId: Scalars['Int']['output'];
  /** The cloud service used in the integration. */
  service?: Maybe<CloudService>;
  /** The object last update date, in epoch (Unix) time */
  updatedAt: Scalars['EpochSeconds']['output'];
};

/** Cloud Pub/Sub */
export type CloudGcpPubsubIntegrationInput = {
  /** Specify if labels and the extended inventory should be collected. May affect total data collection time and contribute to the Cloud provider API rate limit. */
  fetchTags?: InputMaybe<Scalars['Boolean']['input']>;
  /** [DEPRECATED] Multiple polling interval is no longer supported, use only metrics_polling_interval */
  inventoryPollingInterval?: InputMaybe<Scalars['Int']['input']>;
  /** The linked account identifier. */
  linkedAccountId: Scalars['Int']['input'];
  /** The data polling interval in seconds. */
  metricsPollingInterval?: InputMaybe<Scalars['Int']['input']>;
};

/** Redis Integration */
export type CloudGcpRedisIntegration = CloudIntegration & {
  __typename?: 'CloudGcpRedisIntegration';
  /** The object creation date, in epoch (Unix) time */
  createdAt: Scalars['EpochSeconds']['output'];
  /** The cloud service integration identifier. */
  id?: Maybe<Scalars['Int']['output']>;
  /**
   * [DEPRECATED] Multiple polling interval is no longer supported, use only metrics_polling_interval
   * @deprecated [DEPRECATED] Multiple polling interval is no longer supported, use only metrics_polling_interval
   */
  inventoryPollingInterval?: Maybe<Scalars['Int']['output']>;
  /** The parent linked account identifier. */
  linkedAccount?: Maybe<CloudLinkedAccount>;
  /** The data polling interval in seconds. */
  metricsPollingInterval?: Maybe<Scalars['Int']['output']>;
  /** The cloud service integration name. */
  name?: Maybe<Scalars['String']['output']>;
  /** The parent NewRelic account identifier. */
  nrAccountId: Scalars['Int']['output'];
  /** The cloud service used in the integration. */
  service?: Maybe<CloudService>;
  /** The object last update date, in epoch (Unix) time */
  updatedAt: Scalars['EpochSeconds']['output'];
};

/** Redis */
export type CloudGcpRedisIntegrationInput = {
  /** [DEPRECATED] Multiple polling interval is no longer supported, use only metrics_polling_interval */
  inventoryPollingInterval?: InputMaybe<Scalars['Int']['input']>;
  /** The linked account identifier. */
  linkedAccountId: Scalars['Int']['input'];
  /** The data polling interval in seconds. */
  metricsPollingInterval?: InputMaybe<Scalars['Int']['input']>;
};

/** Router Integration */
export type CloudGcpRouterIntegration = CloudIntegration & {
  __typename?: 'CloudGcpRouterIntegration';
  /** The object creation date, in epoch (Unix) time */
  createdAt: Scalars['EpochSeconds']['output'];
  /** The cloud service integration identifier. */
  id?: Maybe<Scalars['Int']['output']>;
  /**
   * [DEPRECATED] Multiple polling interval is no longer supported, use only metrics_polling_interval
   * @deprecated [DEPRECATED] Multiple polling interval is no longer supported, use only metrics_polling_interval
   */
  inventoryPollingInterval?: Maybe<Scalars['Int']['output']>;
  /** The parent linked account identifier. */
  linkedAccount?: Maybe<CloudLinkedAccount>;
  /** The data polling interval in seconds. */
  metricsPollingInterval?: Maybe<Scalars['Int']['output']>;
  /** The cloud service integration name. */
  name?: Maybe<Scalars['String']['output']>;
  /** The parent NewRelic account identifier. */
  nrAccountId: Scalars['Int']['output'];
  /** The cloud service used in the integration. */
  service?: Maybe<CloudService>;
  /** The object last update date, in epoch (Unix) time */
  updatedAt: Scalars['EpochSeconds']['output'];
};

/** Router */
export type CloudGcpRouterIntegrationInput = {
  /** [DEPRECATED] Multiple polling interval is no longer supported, use only metrics_polling_interval */
  inventoryPollingInterval?: InputMaybe<Scalars['Int']['input']>;
  /** The linked account identifier. */
  linkedAccountId: Scalars['Int']['input'];
  /** The data polling interval in seconds. */
  metricsPollingInterval?: InputMaybe<Scalars['Int']['input']>;
};

/** Run Integration */
export type CloudGcpRunIntegration = CloudIntegration & {
  __typename?: 'CloudGcpRunIntegration';
  /** The object creation date, in epoch (Unix) time */
  createdAt: Scalars['EpochSeconds']['output'];
  /** The cloud service integration identifier. */
  id?: Maybe<Scalars['Int']['output']>;
  /**
   * [DEPRECATED] Multiple polling interval is no longer supported, use only metrics_polling_interval
   * @deprecated [DEPRECATED] Multiple polling interval is no longer supported, use only metrics_polling_interval
   */
  inventoryPollingInterval?: Maybe<Scalars['Int']['output']>;
  /** The parent linked account identifier. */
  linkedAccount?: Maybe<CloudLinkedAccount>;
  /** The data polling interval in seconds. */
  metricsPollingInterval?: Maybe<Scalars['Int']['output']>;
  /** The cloud service integration name. */
  name?: Maybe<Scalars['String']['output']>;
  /** The parent NewRelic account identifier. */
  nrAccountId: Scalars['Int']['output'];
  /** The cloud service used in the integration. */
  service?: Maybe<CloudService>;
  /** The object last update date, in epoch (Unix) time */
  updatedAt: Scalars['EpochSeconds']['output'];
};

/** Run */
export type CloudGcpRunIntegrationInput = {
  /** [DEPRECATED] Multiple polling interval is no longer supported, use only metrics_polling_interval */
  inventoryPollingInterval?: InputMaybe<Scalars['Int']['input']>;
  /** The linked account identifier. */
  linkedAccountId: Scalars['Int']['input'];
  /** The data polling interval in seconds. */
  metricsPollingInterval?: InputMaybe<Scalars['Int']['input']>;
};

/** Autogenerated return type of GcpServiceAccountAuth */
export type CloudGcpServiceAccountAuthPayload = {
  __typename?: 'CloudGcpServiceAccountAuthPayload';
  /** Unique guid associated with the credentials. */
  state: Scalars['String']['output'];
};

/** Cloud Spanner Integration */
export type CloudGcpSpannerIntegration = CloudIntegration & {
  __typename?: 'CloudGcpSpannerIntegration';
  /** The object creation date, in epoch (Unix) time */
  createdAt: Scalars['EpochSeconds']['output'];
  /** Specify if labels and the extended inventory should be collected. May affect total data collection time and contribute to the Cloud provider API rate limit. */
  fetchTags?: Maybe<Scalars['Boolean']['output']>;
  /** The cloud service integration identifier. */
  id?: Maybe<Scalars['Int']['output']>;
  /**
   * [DEPRECATED] Multiple polling interval is no longer supported, use only metrics_polling_interval
   * @deprecated [DEPRECATED] Multiple polling interval is no longer supported, use only metrics_polling_interval
   */
  inventoryPollingInterval?: Maybe<Scalars['Int']['output']>;
  /** The parent linked account identifier. */
  linkedAccount?: Maybe<CloudLinkedAccount>;
  /** The data polling interval in seconds. */
  metricsPollingInterval?: Maybe<Scalars['Int']['output']>;
  /** The cloud service integration name. */
  name?: Maybe<Scalars['String']['output']>;
  /** The parent NewRelic account identifier. */
  nrAccountId: Scalars['Int']['output'];
  /** The cloud service used in the integration. */
  service?: Maybe<CloudService>;
  /** The object last update date, in epoch (Unix) time */
  updatedAt: Scalars['EpochSeconds']['output'];
};

/** Cloud Spanner */
export type CloudGcpSpannerIntegrationInput = {
  /** Specify if labels and the extended inventory should be collected. May affect total data collection time and contribute to the Cloud provider API rate limit. */
  fetchTags?: InputMaybe<Scalars['Boolean']['input']>;
  /** [DEPRECATED] Multiple polling interval is no longer supported, use only metrics_polling_interval */
  inventoryPollingInterval?: InputMaybe<Scalars['Int']['input']>;
  /** The linked account identifier. */
  linkedAccountId: Scalars['Int']['input'];
  /** The data polling interval in seconds. */
  metricsPollingInterval?: InputMaybe<Scalars['Int']['input']>;
};

/** Cloud SQL Integration */
export type CloudGcpSqlIntegration = CloudIntegration & {
  __typename?: 'CloudGcpSqlIntegration';
  /** The object creation date, in epoch (Unix) time */
  createdAt: Scalars['EpochSeconds']['output'];
  /** The cloud service integration identifier. */
  id?: Maybe<Scalars['Int']['output']>;
  /**
   * [DEPRECATED] Multiple polling interval is no longer supported, use only metrics_polling_interval
   * @deprecated [DEPRECATED] Multiple polling interval is no longer supported, use only metrics_polling_interval
   */
  inventoryPollingInterval?: Maybe<Scalars['Int']['output']>;
  /** The parent linked account identifier. */
  linkedAccount?: Maybe<CloudLinkedAccount>;
  /** The data polling interval in seconds. */
  metricsPollingInterval?: Maybe<Scalars['Int']['output']>;
  /** The cloud service integration name. */
  name?: Maybe<Scalars['String']['output']>;
  /** The parent NewRelic account identifier. */
  nrAccountId: Scalars['Int']['output'];
  /** The cloud service used in the integration. */
  service?: Maybe<CloudService>;
  /** The object last update date, in epoch (Unix) time */
  updatedAt: Scalars['EpochSeconds']['output'];
};

/** Google Cloud SQL */
export type CloudGcpSqlIntegrationInput = {
  /** [DEPRECATED] Multiple polling interval is no longer supported, use only metrics_polling_interval */
  inventoryPollingInterval?: InputMaybe<Scalars['Int']['input']>;
  /** The linked account identifier. */
  linkedAccountId: Scalars['Int']['input'];
  /** The data polling interval in seconds. */
  metricsPollingInterval?: InputMaybe<Scalars['Int']['input']>;
};

/** Cloud Storage Integration */
export type CloudGcpStorageIntegration = CloudIntegration & {
  __typename?: 'CloudGcpStorageIntegration';
  /** The object creation date, in epoch (Unix) time */
  createdAt: Scalars['EpochSeconds']['output'];
  /** Specify if labels and the extended inventory should be collected. May affect total data collection time and contribute to the Cloud provider API rate limit. */
  fetchTags?: Maybe<Scalars['Boolean']['output']>;
  /** The cloud service integration identifier. */
  id?: Maybe<Scalars['Int']['output']>;
  /**
   * [DEPRECATED] Multiple polling interval is no longer supported, use only metrics_polling_interval
   * @deprecated [DEPRECATED] Multiple polling interval is no longer supported, use only metrics_polling_interval
   */
  inventoryPollingInterval?: Maybe<Scalars['Int']['output']>;
  /** The parent linked account identifier. */
  linkedAccount?: Maybe<CloudLinkedAccount>;
  /** The data polling interval in seconds. */
  metricsPollingInterval?: Maybe<Scalars['Int']['output']>;
  /** The cloud service integration name. */
  name?: Maybe<Scalars['String']['output']>;
  /** The parent NewRelic account identifier. */
  nrAccountId: Scalars['Int']['output'];
  /** The cloud service used in the integration. */
  service?: Maybe<CloudService>;
  /** The object last update date, in epoch (Unix) time */
  updatedAt: Scalars['EpochSeconds']['output'];
};

/** Google Cloud Storage */
export type CloudGcpStorageIntegrationInput = {
  /** Specify if labels and the extended inventory should be collected. May affect total data collection time and contribute to the Cloud provider API rate limit. */
  fetchTags?: InputMaybe<Scalars['Boolean']['input']>;
  /** [DEPRECATED] Multiple polling interval is no longer supported, use only metrics_polling_interval */
  inventoryPollingInterval?: InputMaybe<Scalars['Int']['input']>;
  /** The linked account identifier. */
  linkedAccountId: Scalars['Int']['input'];
  /** The data polling interval in seconds. */
  metricsPollingInterval?: InputMaybe<Scalars['Int']['input']>;
};

/** Compute Engine Integration */
export type CloudGcpVmsIntegration = CloudIntegration & {
  __typename?: 'CloudGcpVmsIntegration';
  /** The object creation date, in epoch (Unix) time */
  createdAt: Scalars['EpochSeconds']['output'];
  /** The cloud service integration identifier. */
  id?: Maybe<Scalars['Int']['output']>;
  /**
   * [DEPRECATED] Multiple polling interval is no longer supported, use only metrics_polling_interval
   * @deprecated [DEPRECATED] Multiple polling interval is no longer supported, use only metrics_polling_interval
   */
  inventoryPollingInterval?: Maybe<Scalars['Int']['output']>;
  /** The parent linked account identifier. */
  linkedAccount?: Maybe<CloudLinkedAccount>;
  /** The data polling interval in seconds. */
  metricsPollingInterval?: Maybe<Scalars['Int']['output']>;
  /** The cloud service integration name. */
  name?: Maybe<Scalars['String']['output']>;
  /** The parent NewRelic account identifier. */
  nrAccountId: Scalars['Int']['output'];
  /** The cloud service used in the integration. */
  service?: Maybe<CloudService>;
  /** The object last update date, in epoch (Unix) time */
  updatedAt: Scalars['EpochSeconds']['output'];
};

/** Google Compute Engine */
export type CloudGcpVmsIntegrationInput = {
  /** [DEPRECATED] Multiple polling interval is no longer supported, use only metrics_polling_interval */
  inventoryPollingInterval?: InputMaybe<Scalars['Int']['input']>;
  /** The linked account identifier. */
  linkedAccountId: Scalars['Int']['input'];
  /** The data polling interval in seconds. */
  metricsPollingInterval?: InputMaybe<Scalars['Int']['input']>;
};

/** VPC Access Integration */
export type CloudGcpVpcaccessIntegration = CloudIntegration & {
  __typename?: 'CloudGcpVpcaccessIntegration';
  /** The object creation date, in epoch (Unix) time */
  createdAt: Scalars['EpochSeconds']['output'];
  /** The cloud service integration identifier. */
  id?: Maybe<Scalars['Int']['output']>;
  /**
   * [DEPRECATED] Multiple polling interval is no longer supported, use only metrics_polling_interval
   * @deprecated [DEPRECATED] Multiple polling interval is no longer supported, use only metrics_polling_interval
   */
  inventoryPollingInterval?: Maybe<Scalars['Int']['output']>;
  /** The parent linked account identifier. */
  linkedAccount?: Maybe<CloudLinkedAccount>;
  /** The data polling interval in seconds. */
  metricsPollingInterval?: Maybe<Scalars['Int']['output']>;
  /** The cloud service integration name. */
  name?: Maybe<Scalars['String']['output']>;
  /** The parent NewRelic account identifier. */
  nrAccountId: Scalars['Int']['output'];
  /** The cloud service used in the integration. */
  service?: Maybe<CloudService>;
  /** The object last update date, in epoch (Unix) time */
  updatedAt: Scalars['EpochSeconds']['output'];
};

/** VPC Access */
export type CloudGcpVpcaccessIntegrationInput = {
  /** [DEPRECATED] Multiple polling interval is no longer supported, use only metrics_polling_interval */
  inventoryPollingInterval?: InputMaybe<Scalars['Int']['input']>;
  /** The linked account identifier. */
  linkedAccountId: Scalars['Int']['input'];
  /** The data polling interval in seconds. */
  metricsPollingInterval?: InputMaybe<Scalars['Int']['input']>;
};

/** Health Integration */
export type CloudHealthIntegration = CloudIntegration & {
  __typename?: 'CloudHealthIntegration';
  /** The object creation date, in epoch (Unix) time */
  createdAt: Scalars['EpochSeconds']['output'];
  /** The cloud service integration identifier. */
  id?: Maybe<Scalars['Int']['output']>;
  /**
   * [DEPRECATED] Multiple polling interval is no longer supported, use only metrics_polling_interval
   * @deprecated [DEPRECATED] Multiple polling interval is no longer supported, use only metrics_polling_interval
   */
  inventoryPollingInterval?: Maybe<Scalars['Int']['output']>;
  /** The parent linked account identifier. */
  linkedAccount?: Maybe<CloudLinkedAccount>;
  /** The data polling interval in seconds. */
  metricsPollingInterval?: Maybe<Scalars['Int']['output']>;
  /** The cloud service integration name. */
  name?: Maybe<Scalars['String']['output']>;
  /** The parent NewRelic account identifier. */
  nrAccountId: Scalars['Int']['output'];
  /** The cloud service used in the integration. */
  service?: Maybe<CloudService>;
  /** The object last update date, in epoch (Unix) time */
  updatedAt: Scalars['EpochSeconds']['output'];
};

/** AWS Health */
export type CloudHealthIntegrationInput = {
  /** [DEPRECATED] Multiple polling interval is no longer supported, use only metrics_polling_interval */
  inventoryPollingInterval?: InputMaybe<Scalars['Int']['input']>;
  /** The linked account identifier. */
  linkedAccountId: Scalars['Int']['input'];
  /** The data polling interval in seconds. */
  metricsPollingInterval?: InputMaybe<Scalars['Int']['input']>;
};

/** IAM Integration */
export type CloudIamIntegration = CloudIntegration & {
  __typename?: 'CloudIamIntegration';
  /** The object creation date, in epoch (Unix) time */
  createdAt: Scalars['EpochSeconds']['output'];
  /** The cloud service integration identifier. */
  id?: Maybe<Scalars['Int']['output']>;
  /**
   * [DEPRECATED] Multiple polling interval is no longer supported, use only metrics_polling_interval
   * @deprecated [DEPRECATED] Multiple polling interval is no longer supported, use only metrics_polling_interval
   */
  inventoryPollingInterval?: Maybe<Scalars['Int']['output']>;
  /** The parent linked account identifier. */
  linkedAccount?: Maybe<CloudLinkedAccount>;
  /** The data polling interval in seconds. */
  metricsPollingInterval?: Maybe<Scalars['Int']['output']>;
  /** The cloud service integration name. */
  name?: Maybe<Scalars['String']['output']>;
  /** The parent NewRelic account identifier. */
  nrAccountId: Scalars['Int']['output'];
  /** The cloud service used in the integration. */
  service?: Maybe<CloudService>;
  /** Specify a Tag key associated with the resources that you want to monitor. Filter values are case-sensitive. */
  tagKey?: Maybe<Scalars['String']['output']>;
  /** Specify a Tag value associated with the resources that you want to monitor. Filter values are case-sensitive. */
  tagValue?: Maybe<Scalars['String']['output']>;
  /** The object last update date, in epoch (Unix) time */
  updatedAt: Scalars['EpochSeconds']['output'];
};

/** AWS Identity and Access Management (IAM) */
export type CloudIamIntegrationInput = {
  /** [DEPRECATED] Multiple polling interval is no longer supported, use only metrics_polling_interval */
  inventoryPollingInterval?: InputMaybe<Scalars['Int']['input']>;
  /** The linked account identifier. */
  linkedAccountId: Scalars['Int']['input'];
  /** The data polling interval in seconds. */
  metricsPollingInterval?: InputMaybe<Scalars['Int']['input']>;
  /** Specify a Tag key associated with the resources that you want to monitor. Filter values are case-sensitive. */
  tagKey?: InputMaybe<Scalars['String']['input']>;
  /** Specify a Tag value associated with the resources that you want to monitor. Filter values are case-sensitive. */
  tagValue?: InputMaybe<Scalars['String']['input']>;
};

/** The configuration of a cloud service integration for a linked account. */
export type CloudIntegration = {
  /** The object creation date, in epoch (Unix) time */
  createdAt: Scalars['EpochSeconds']['output'];
  /** The cloud service integration identifier. */
  id?: Maybe<Scalars['Int']['output']>;
  /** The parent linked account identifier. */
  linkedAccount?: Maybe<CloudLinkedAccount>;
  /** The cloud service integration name. */
  name?: Maybe<Scalars['String']['output']>;
  /** The parent NewRelic account identifier. */
  nrAccountId: Scalars['Int']['output'];
  /** The cloud service used in the integration. */
  service?: Maybe<CloudService>;
  /** The object last update date, in epoch (Unix) time */
  updatedAt: Scalars['EpochSeconds']['output'];
};

/** Integration Mutation Error */
export type CloudIntegrationMutationError = {
  __typename?: 'CloudIntegrationMutationError';
  /** The passed integration slug. */
  integrationSlug?: Maybe<Scalars['String']['output']>;
  /** The passed linked account identifier. */
  linkedAccountId?: Maybe<Scalars['Int']['output']>;
  /** The error message. */
  message: Scalars['String']['output'];
  /** The passed newrelic account identifier. */
  nrAccountId: Scalars['Int']['output'];
  /** The error status. */
  type: Scalars['String']['output'];
};

/** List of providers */
export type CloudIntegrationsInput = {
  /** Aws provider */
  aws?: InputMaybe<CloudAwsIntegrationsInput>;
  /** AwsGovcloud provider */
  awsGovcloud?: InputMaybe<CloudAwsGovcloudIntegrationsInput>;
  /** Azure provider */
  azure?: InputMaybe<CloudAzureIntegrationsInput>;
  /** Gcp provider */
  gcp?: InputMaybe<CloudGcpIntegrationsInput>;
};

/** IoT Integration */
export type CloudIotIntegration = CloudIntegration & {
  __typename?: 'CloudIotIntegration';
  /** Specify each AWS region that includes the resources that you want to monitor. */
  awsRegions?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
  /** The object creation date, in epoch (Unix) time */
  createdAt: Scalars['EpochSeconds']['output'];
  /** The cloud service integration identifier. */
  id?: Maybe<Scalars['Int']['output']>;
  /**
   * [DEPRECATED] Multiple polling interval is no longer supported, use only metrics_polling_interval
   * @deprecated [DEPRECATED] Multiple polling interval is no longer supported, use only metrics_polling_interval
   */
  inventoryPollingInterval?: Maybe<Scalars['Int']['output']>;
  /** The parent linked account identifier. */
  linkedAccount?: Maybe<CloudLinkedAccount>;
  /** The data polling interval in seconds. */
  metricsPollingInterval?: Maybe<Scalars['Int']['output']>;
  /** The cloud service integration name. */
  name?: Maybe<Scalars['String']['output']>;
  /** The parent NewRelic account identifier. */
  nrAccountId: Scalars['Int']['output'];
  /** The cloud service used in the integration. */
  service?: Maybe<CloudService>;
  /** The object last update date, in epoch (Unix) time */
  updatedAt: Scalars['EpochSeconds']['output'];
};

/** AWS IoT */
export type CloudIotIntegrationInput = {
  /** Specify each AWS region that includes the resources that you want to monitor. */
  awsRegions?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  /** [DEPRECATED] Multiple polling interval is no longer supported, use only metrics_polling_interval */
  inventoryPollingInterval?: InputMaybe<Scalars['Int']['input']>;
  /** The linked account identifier. */
  linkedAccountId: Scalars['Int']['input'];
  /** The data polling interval in seconds. */
  metricsPollingInterval?: InputMaybe<Scalars['Int']['input']>;
};

/** Kinesis Firehose Integration */
export type CloudKinesisFirehoseIntegration = CloudIntegration & {
  __typename?: 'CloudKinesisFirehoseIntegration';
  /** Specify each AWS region that includes the resources that you want to monitor. */
  awsRegions?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
  /** The object creation date, in epoch (Unix) time */
  createdAt: Scalars['EpochSeconds']['output'];
  /** The cloud service integration identifier. */
  id?: Maybe<Scalars['Int']['output']>;
  /**
   * [DEPRECATED] Multiple polling interval is no longer supported, use only metrics_polling_interval
   * @deprecated [DEPRECATED] Multiple polling interval is no longer supported, use only metrics_polling_interval
   */
  inventoryPollingInterval?: Maybe<Scalars['Int']['output']>;
  /** The parent linked account identifier. */
  linkedAccount?: Maybe<CloudLinkedAccount>;
  /** The data polling interval in seconds. */
  metricsPollingInterval?: Maybe<Scalars['Int']['output']>;
  /** The cloud service integration name. */
  name?: Maybe<Scalars['String']['output']>;
  /** The parent NewRelic account identifier. */
  nrAccountId: Scalars['Int']['output'];
  /** The cloud service used in the integration. */
  service?: Maybe<CloudService>;
  /** The object last update date, in epoch (Unix) time */
  updatedAt: Scalars['EpochSeconds']['output'];
};

/** Amazon Kinesis Data Firehose */
export type CloudKinesisFirehoseIntegrationInput = {
  /** Specify each AWS region that includes the resources that you want to monitor. */
  awsRegions?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  /** [DEPRECATED] Multiple polling interval is no longer supported, use only metrics_polling_interval */
  inventoryPollingInterval?: InputMaybe<Scalars['Int']['input']>;
  /** The linked account identifier. */
  linkedAccountId: Scalars['Int']['input'];
  /** The data polling interval in seconds. */
  metricsPollingInterval?: InputMaybe<Scalars['Int']['input']>;
};

/** Kinesis Streams Integration */
export type CloudKinesisIntegration = CloudIntegration & {
  __typename?: 'CloudKinesisIntegration';
  /** Specify each AWS region that includes the resources that you want to monitor. */
  awsRegions?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
  /** The object creation date, in epoch (Unix) time */
  createdAt: Scalars['EpochSeconds']['output'];
  /** Specify if Shards should be monitored. May affect total data collection time and contribute to the Cloud provider API rate limit. */
  fetchShards?: Maybe<Scalars['Boolean']['output']>;
  /** Specify if tags should be collected. May affect total data collection time and contribute to the Cloud provider API rate limit. */
  fetchTags?: Maybe<Scalars['Boolean']['output']>;
  /** The cloud service integration identifier. */
  id?: Maybe<Scalars['Int']['output']>;
  /**
   * [DEPRECATED] Multiple polling interval is no longer supported, use only metrics_polling_interval
   * @deprecated [DEPRECATED] Multiple polling interval is no longer supported, use only metrics_polling_interval
   */
  inventoryPollingInterval?: Maybe<Scalars['Int']['output']>;
  /** The parent linked account identifier. */
  linkedAccount?: Maybe<CloudLinkedAccount>;
  /** The data polling interval in seconds. */
  metricsPollingInterval?: Maybe<Scalars['Int']['output']>;
  /** The cloud service integration name. */
  name?: Maybe<Scalars['String']['output']>;
  /** The parent NewRelic account identifier. */
  nrAccountId: Scalars['Int']['output'];
  /** The cloud service used in the integration. */
  service?: Maybe<CloudService>;
  /** Specify a Tag key associated with the resources that you want to monitor. Filter values are case-sensitive. */
  tagKey?: Maybe<Scalars['String']['output']>;
  /** Specify a Tag value associated with the resources that you want to monitor. Filter values are case-sensitive. */
  tagValue?: Maybe<Scalars['String']['output']>;
  /** The object last update date, in epoch (Unix) time */
  updatedAt: Scalars['EpochSeconds']['output'];
};

/** Amazon Kinesis Data Streams */
export type CloudKinesisIntegrationInput = {
  /** Specify each AWS region that includes the resources that you want to monitor. */
  awsRegions?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  /** Specify if Shards should be monitored. May affect total data collection time and contribute to the Cloud provider API rate limit. */
  fetchShards?: InputMaybe<Scalars['Boolean']['input']>;
  /** Specify if tags should be collected. May affect total data collection time and contribute to the Cloud provider API rate limit. */
  fetchTags?: InputMaybe<Scalars['Boolean']['input']>;
  /** [DEPRECATED] Multiple polling interval is no longer supported, use only metrics_polling_interval */
  inventoryPollingInterval?: InputMaybe<Scalars['Int']['input']>;
  /** The linked account identifier. */
  linkedAccountId: Scalars['Int']['input'];
  /** The data polling interval in seconds. */
  metricsPollingInterval?: InputMaybe<Scalars['Int']['input']>;
  /** Specify a Tag key associated with the resources that you want to monitor. Filter values are case-sensitive. */
  tagKey?: InputMaybe<Scalars['String']['input']>;
  /** Specify a Tag value associated with the resources that you want to monitor. Filter values are case-sensitive. */
  tagValue?: InputMaybe<Scalars['String']['input']>;
};

/** Lambda Integration */
export type CloudLambdaIntegration = CloudIntegration & {
  __typename?: 'CloudLambdaIntegration';
  /** Specify each AWS region that includes the resources that you want to monitor. */
  awsRegions?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
  /** The object creation date, in epoch (Unix) time */
  createdAt: Scalars['EpochSeconds']['output'];
  /** Specify if tags should be collected. May affect total data collection time and contribute to the Cloud provider API rate limit. */
  fetchTags?: Maybe<Scalars['Boolean']['output']>;
  /** The cloud service integration identifier. */
  id?: Maybe<Scalars['Int']['output']>;
  /**
   * [DEPRECATED] Multiple polling interval is no longer supported, use only metrics_polling_interval
   * @deprecated [DEPRECATED] Multiple polling interval is no longer supported, use only metrics_polling_interval
   */
  inventoryPollingInterval?: Maybe<Scalars['Int']['output']>;
  /** The parent linked account identifier. */
  linkedAccount?: Maybe<CloudLinkedAccount>;
  /** The data polling interval in seconds. */
  metricsPollingInterval?: Maybe<Scalars['Int']['output']>;
  /** The cloud service integration name. */
  name?: Maybe<Scalars['String']['output']>;
  /** The parent NewRelic account identifier. */
  nrAccountId: Scalars['Int']['output'];
  /** The cloud service used in the integration. */
  service?: Maybe<CloudService>;
  /** Specify a Tag key associated with the resources that you want to monitor. Filter values are case-sensitive. */
  tagKey?: Maybe<Scalars['String']['output']>;
  /** Specify a Tag value associated with the resources that you want to monitor. Filter values are case-sensitive. */
  tagValue?: Maybe<Scalars['String']['output']>;
  /** The object last update date, in epoch (Unix) time */
  updatedAt: Scalars['EpochSeconds']['output'];
};

/** AWS Lambda */
export type CloudLambdaIntegrationInput = {
  /** Specify each AWS region that includes the resources that you want to monitor. */
  awsRegions?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  /** Specify if tags should be collected. May affect total data collection time and contribute to the Cloud provider API rate limit. */
  fetchTags?: InputMaybe<Scalars['Boolean']['input']>;
  /** [DEPRECATED] Multiple polling interval is no longer supported, use only metrics_polling_interval */
  inventoryPollingInterval?: InputMaybe<Scalars['Int']['input']>;
  /** The linked account identifier. */
  linkedAccountId: Scalars['Int']['input'];
  /** The data polling interval in seconds. */
  metricsPollingInterval?: InputMaybe<Scalars['Int']['input']>;
  /** Specify a Tag key associated with the resources that you want to monitor. Filter values are case-sensitive. */
  tagKey?: InputMaybe<Scalars['String']['input']>;
  /** Specify a Tag value associated with the resources that you want to monitor. Filter values are case-sensitive. */
  tagValue?: InputMaybe<Scalars['String']['input']>;
};

/** Autogenerated return type of LinkAccount */
export type CloudLinkAccountPayload = {
  __typename?: 'CloudLinkAccountPayload';
  /** The list of errors. */
  errors: Array<CloudAccountMutationError>;
  /** The created Linked accounts. */
  linkedAccounts: Array<CloudLinkedAccount>;
};

/** Specific Cloud provider information required to link the Cloud provider account to a NewRelic account. */
export type CloudLinkCloudAccountsInput = {
  /** Aws provider */
  aws?: InputMaybe<Array<CloudAwsLinkAccountInput>>;
  /** AwsGovCloud provider */
  awsGovcloud?: InputMaybe<Array<CloudAwsGovCloudLinkAccountInput>>;
  /** Azure provider */
  azure?: InputMaybe<Array<CloudAzureLinkAccountInput>>;
  /** Gcp provider */
  gcp?: InputMaybe<Array<CloudGcpLinkAccountInput>>;
};

/** A cloud account linked to a NewRelic account. */
export type CloudLinkedAccount = {
  __typename?: 'CloudLinkedAccount';
  /** The credential. This is a Role ARN for AWS, an application ID for Azure and a service account ID or user account email for GCP. */
  authLabel: Scalars['String']['output'];
  /** The object creation date, in epoch (Unix) time */
  createdAt: Scalars['EpochSeconds']['output'];
  /** Indicates whether the account disabled. */
  disabled?: Maybe<Scalars['Boolean']['output']>;
  /** The cloud account identifier. This is the Account ID in AWS, the Subscription ID in Azure and the Project ID in GCP. */
  externalId?: Maybe<Scalars['String']['output']>;
  /** The linked account identifier in NewRelic. */
  id: Scalars['Int']['output'];
  /** Get details of one cloud service integration. */
  integration: CloudIntegration;
  /** Get details of all cloud service integrations. */
  integrations: Array<CloudIntegration>;
  /** Indicate how the metrics will be collected (PUSH/PULL) */
  metricCollectionMode: CloudMetricCollectionMode;
  /** The linked account name in NewRelic. */
  name: Scalars['String']['output'];
  /** The New Relic account identifier. */
  nrAccountId: Scalars['Int']['output'];
  /** The cloud provider. */
  provider: CloudProvider;
  /** The object last update date, in epoch (Unix) time */
  updatedAt: Scalars['EpochSeconds']['output'];
};


/** A cloud account linked to a NewRelic account. */
export type CloudLinkedAccountIntegrationArgs = {
  id: Scalars['Int']['input'];
};


/** A cloud account linked to a NewRelic account. */
export type CloudLinkedAccountIntegrationsArgs = {
  service?: InputMaybe<Scalars['String']['input']>;
};

/** How metrics will be collected. */
export enum CloudMetricCollectionMode {
  /** Metrics will be pulled by NewRelic */
  Pull = 'PULL',
  /** Metrics will be pushed by the provider */
  Push = 'PUSH'
}

/** Autogenerated return type of MigrateAwsGovCloudToAssumeRole */
export type CloudMigrateAwsGovCloudToAssumeRolePayload = {
  __typename?: 'CloudMigrateAwsGovCloudToAssumeRolePayload';
  /** The list of errors. */
  errors: Array<CloudAccountMutationError>;
  /** The updated linked accounts. */
  linkedAccounts: Array<CloudLinkedAccount>;
};

/** A cloud services provider. */
export type CloudProvider = {
  /** The object creation date, in epoch (Unix) time */
  createdAt: Scalars['EpochSeconds']['output'];
  /** The cloud provider icon name. */
  icon: Scalars['String']['output'];
  /** The cloud provider identifier in NewRelic. */
  id: Scalars['Int']['output'];
  /** The cloud provider name. */
  name: Scalars['String']['output'];
  /** Get details of one cloud provider service. */
  service?: Maybe<CloudService>;
  /** Get details of all the cloud provider services available for integration. */
  services: Array<CloudService>;
  /** The cloud provider short name. */
  slug: Scalars['String']['output'];
  /** The object last update date, in epoch (Unix) time */
  updatedAt: Scalars['EpochSeconds']['output'];
};


/** A cloud services provider. */
export type CloudProviderServiceArgs = {
  slug: Scalars['String']['input'];
};

/** RDS Integration */
export type CloudRdsIntegration = CloudIntegration & {
  __typename?: 'CloudRdsIntegration';
  /** Specify each AWS region that includes the resources that you want to monitor. */
  awsRegions?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
  /** The object creation date, in epoch (Unix) time */
  createdAt: Scalars['EpochSeconds']['output'];
  /** Specify if tags should be collected. May affect total data collection time and contribute to the Cloud provider API rate limit. */
  fetchTags?: Maybe<Scalars['Boolean']['output']>;
  /** The cloud service integration identifier. */
  id?: Maybe<Scalars['Int']['output']>;
  /**
   * [DEPRECATED] Multiple polling interval is no longer supported, use only metrics_polling_interval
   * @deprecated [DEPRECATED] Multiple polling interval is no longer supported, use only metrics_polling_interval
   */
  inventoryPollingInterval?: Maybe<Scalars['Int']['output']>;
  /** The parent linked account identifier. */
  linkedAccount?: Maybe<CloudLinkedAccount>;
  /** The data polling interval in seconds. */
  metricsPollingInterval?: Maybe<Scalars['Int']['output']>;
  /** The cloud service integration name. */
  name?: Maybe<Scalars['String']['output']>;
  /** The parent NewRelic account identifier. */
  nrAccountId: Scalars['Int']['output'];
  /** The cloud service used in the integration. */
  service?: Maybe<CloudService>;
  /** Specify a Tag key associated with the resources that you want to monitor. Filter values are case-sensitive. */
  tagKey?: Maybe<Scalars['String']['output']>;
  /** Specify a Tag value associated with the resources that you want to monitor. Filter values are case-sensitive. */
  tagValue?: Maybe<Scalars['String']['output']>;
  /** The object last update date, in epoch (Unix) time */
  updatedAt: Scalars['EpochSeconds']['output'];
};

/** Amazon Relation Database Service (RDS) */
export type CloudRdsIntegrationInput = {
  /** Specify each AWS region that includes the resources that you want to monitor. */
  awsRegions?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  /** Specify if tags should be collected. May affect total data collection time and contribute to the Cloud provider API rate limit. */
  fetchTags?: InputMaybe<Scalars['Boolean']['input']>;
  /** [DEPRECATED] Multiple polling interval is no longer supported, use only metrics_polling_interval */
  inventoryPollingInterval?: InputMaybe<Scalars['Int']['input']>;
  /** The linked account identifier. */
  linkedAccountId: Scalars['Int']['input'];
  /** The data polling interval in seconds. */
  metricsPollingInterval?: InputMaybe<Scalars['Int']['input']>;
  /** Specify a Tag key associated with the resources that you want to monitor. Filter values are case-sensitive. */
  tagKey?: InputMaybe<Scalars['String']['input']>;
  /** Specify a Tag value associated with the resources that you want to monitor. Filter values are case-sensitive. */
  tagValue?: InputMaybe<Scalars['String']['input']>;
};

/** Redshift Integration */
export type CloudRedshiftIntegration = CloudIntegration & {
  __typename?: 'CloudRedshiftIntegration';
  /** Specify each AWS region that includes the resources that you want to monitor. */
  awsRegions?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
  /** The object creation date, in epoch (Unix) time */
  createdAt: Scalars['EpochSeconds']['output'];
  /** The cloud service integration identifier. */
  id?: Maybe<Scalars['Int']['output']>;
  /**
   * [DEPRECATED] Multiple polling interval is no longer supported, use only metrics_polling_interval
   * @deprecated [DEPRECATED] Multiple polling interval is no longer supported, use only metrics_polling_interval
   */
  inventoryPollingInterval?: Maybe<Scalars['Int']['output']>;
  /** The parent linked account identifier. */
  linkedAccount?: Maybe<CloudLinkedAccount>;
  /** The data polling interval in seconds. */
  metricsPollingInterval?: Maybe<Scalars['Int']['output']>;
  /** The cloud service integration name. */
  name?: Maybe<Scalars['String']['output']>;
  /** The parent NewRelic account identifier. */
  nrAccountId: Scalars['Int']['output'];
  /** The cloud service used in the integration. */
  service?: Maybe<CloudService>;
  /** Specify a Tag key associated with the resources that you want to monitor. Filter values are case-sensitive. */
  tagKey?: Maybe<Scalars['String']['output']>;
  /** Specify a Tag value associated with the resources that you want to monitor. Filter values are case-sensitive. */
  tagValue?: Maybe<Scalars['String']['output']>;
  /** The object last update date, in epoch (Unix) time */
  updatedAt: Scalars['EpochSeconds']['output'];
};

/** Amazon Redshift */
export type CloudRedshiftIntegrationInput = {
  /** Specify each AWS region that includes the resources that you want to monitor. */
  awsRegions?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  /** [DEPRECATED] Multiple polling interval is no longer supported, use only metrics_polling_interval */
  inventoryPollingInterval?: InputMaybe<Scalars['Int']['input']>;
  /** The linked account identifier. */
  linkedAccountId: Scalars['Int']['input'];
  /** The data polling interval in seconds. */
  metricsPollingInterval?: InputMaybe<Scalars['Int']['input']>;
  /** Specify a Tag key associated with the resources that you want to monitor. Filter values are case-sensitive. */
  tagKey?: InputMaybe<Scalars['String']['input']>;
  /** Specify a Tag value associated with the resources that you want to monitor. Filter values are case-sensitive. */
  tagValue?: InputMaybe<Scalars['String']['input']>;
};

/** Autogenerated return type of RenameAccount */
export type CloudRenameAccountPayload = {
  __typename?: 'CloudRenameAccountPayload';
  /** The list of errors. */
  errors: Array<CloudAccountMutationError>;
  /** The updated linked accounts. */
  linkedAccounts: Array<CloudLinkedAccount>;
};

/** Information required when operating on a Linked Account. */
export type CloudRenameAccountsInput = {
  /** The linked account identifier. */
  linkedAccountId: Scalars['Int']['input'];
  /** The linked account new name. */
  name: Scalars['String']['input'];
};

/** Route 53 Integration */
export type CloudRoute53Integration = CloudIntegration & {
  __typename?: 'CloudRoute53Integration';
  /** The object creation date, in epoch (Unix) time */
  createdAt: Scalars['EpochSeconds']['output'];
  /** Determine if extra inventory data be collected or not. May affect total data collection time and contribute to the Cloud provider API rate limit. */
  fetchExtendedInventory?: Maybe<Scalars['Boolean']['output']>;
  /** The cloud service integration identifier. */
  id?: Maybe<Scalars['Int']['output']>;
  /**
   * [DEPRECATED] Multiple polling interval is no longer supported, use only metrics_polling_interval
   * @deprecated [DEPRECATED] Multiple polling interval is no longer supported, use only metrics_polling_interval
   */
  inventoryPollingInterval?: Maybe<Scalars['Int']['output']>;
  /** The parent linked account identifier. */
  linkedAccount?: Maybe<CloudLinkedAccount>;
  /** The data polling interval in seconds. */
  metricsPollingInterval?: Maybe<Scalars['Int']['output']>;
  /** The cloud service integration name. */
  name?: Maybe<Scalars['String']['output']>;
  /** The parent NewRelic account identifier. */
  nrAccountId: Scalars['Int']['output'];
  /** The cloud service used in the integration. */
  service?: Maybe<CloudService>;
  /** The object last update date, in epoch (Unix) time */
  updatedAt: Scalars['EpochSeconds']['output'];
};

/** Amazon Route 53 */
export type CloudRoute53IntegrationInput = {
  /** Determine if extra inventory data be collected or not. May affect total data collection time and contribute to the Cloud provider API rate limit. */
  fetchExtendedInventory?: InputMaybe<Scalars['Boolean']['input']>;
  /** [DEPRECATED] Multiple polling interval is no longer supported, use only metrics_polling_interval */
  inventoryPollingInterval?: InputMaybe<Scalars['Int']['input']>;
  /** The linked account identifier. */
  linkedAccountId: Scalars['Int']['input'];
  /** The data polling interval in seconds. */
  metricsPollingInterval?: InputMaybe<Scalars['Int']['input']>;
};

/** S3 Integration */
export type CloudS3Integration = CloudIntegration & {
  __typename?: 'CloudS3Integration';
  /** The object creation date, in epoch (Unix) time */
  createdAt: Scalars['EpochSeconds']['output'];
  /** Determine if extra inventory data be collected or not. May affect total data collection time and contribute to the Cloud provider API rate limit. */
  fetchExtendedInventory?: Maybe<Scalars['Boolean']['output']>;
  /** Specify if tags should be collected. May affect total data collection time and contribute to the Cloud provider API rate limit. */
  fetchTags?: Maybe<Scalars['Boolean']['output']>;
  /** The cloud service integration identifier. */
  id?: Maybe<Scalars['Int']['output']>;
  /**
   * [DEPRECATED] Multiple polling interval is no longer supported, use only metrics_polling_interval
   * @deprecated [DEPRECATED] Multiple polling interval is no longer supported, use only metrics_polling_interval
   */
  inventoryPollingInterval?: Maybe<Scalars['Int']['output']>;
  /** The parent linked account identifier. */
  linkedAccount?: Maybe<CloudLinkedAccount>;
  /** The data polling interval in seconds. */
  metricsPollingInterval?: Maybe<Scalars['Int']['output']>;
  /** The cloud service integration name. */
  name?: Maybe<Scalars['String']['output']>;
  /** The parent NewRelic account identifier. */
  nrAccountId: Scalars['Int']['output'];
  /** The cloud service used in the integration. */
  service?: Maybe<CloudService>;
  /** Specify a Tag key associated with the resources that you want to monitor. Filter values are case-sensitive. */
  tagKey?: Maybe<Scalars['String']['output']>;
  /** Specify a Tag value associated with the resources that you want to monitor. Filter values are case-sensitive. */
  tagValue?: Maybe<Scalars['String']['output']>;
  /** The object last update date, in epoch (Unix) time */
  updatedAt: Scalars['EpochSeconds']['output'];
};

/** Amazon Simple Storage Service (S3) */
export type CloudS3IntegrationInput = {
  /** Determine if extra inventory data be collected or not. May affect total data collection time and contribute to the Cloud provider API rate limit. */
  fetchExtendedInventory?: InputMaybe<Scalars['Boolean']['input']>;
  /** Specify if tags should be collected. May affect total data collection time and contribute to the Cloud provider API rate limit. */
  fetchTags?: InputMaybe<Scalars['Boolean']['input']>;
  /** [DEPRECATED] Multiple polling interval is no longer supported, use only metrics_polling_interval */
  inventoryPollingInterval?: InputMaybe<Scalars['Int']['input']>;
  /** The linked account identifier. */
  linkedAccountId: Scalars['Int']['input'];
  /** The data polling interval in seconds. */
  metricsPollingInterval?: InputMaybe<Scalars['Int']['input']>;
  /** Specify a Tag key associated with the resources that you want to monitor. Filter values are case-sensitive. */
  tagKey?: InputMaybe<Scalars['String']['input']>;
  /** Specify a Tag value associated with the resources that you want to monitor. Filter values are case-sensitive. */
  tagValue?: InputMaybe<Scalars['String']['input']>;
};

/** A Cloud Provider service available for monitoring. */
export type CloudService = {
  __typename?: 'CloudService';
  /** Template with the configuration fields for the cloud service */
  configFields: Array<CloudConfigField>;
  /** The object creation date, in epoch (Unix) time */
  createdAt: Scalars['EpochSeconds']['output'];
  /** The cloud service dashboard templates. */
  dashboards: Array<CloudDashboardTemplate>;
  /** The cloud service icon name. */
  icon: Scalars['String']['output'];
  /** The cloud service identifier in NewRelic. */
  id: Scalars['Int']['output'];
  /** Shows if the cloud service is enabled for integrating. */
  isEnabled: Scalars['Boolean']['output'];
  /** The cloud service name. */
  name: Scalars['String']['output'];
  /** The cloud provider. */
  provider: CloudProvider;
  /** The cloud service unique short name. */
  slug: Scalars['String']['output'];
  /** The object last update date, in epoch (Unix) time */
  updatedAt: Scalars['EpochSeconds']['output'];
};

/** SES Integration */
export type CloudSesIntegration = CloudIntegration & {
  __typename?: 'CloudSesIntegration';
  /** Specify each AWS region that includes the resources that you want to monitor. */
  awsRegions?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
  /** The object creation date, in epoch (Unix) time */
  createdAt: Scalars['EpochSeconds']['output'];
  /** The cloud service integration identifier. */
  id?: Maybe<Scalars['Int']['output']>;
  /**
   * [DEPRECATED] Multiple polling interval is no longer supported, use only metrics_polling_interval
   * @deprecated [DEPRECATED] Multiple polling interval is no longer supported, use only metrics_polling_interval
   */
  inventoryPollingInterval?: Maybe<Scalars['Int']['output']>;
  /** The parent linked account identifier. */
  linkedAccount?: Maybe<CloudLinkedAccount>;
  /** The data polling interval in seconds. */
  metricsPollingInterval?: Maybe<Scalars['Int']['output']>;
  /** The cloud service integration name. */
  name?: Maybe<Scalars['String']['output']>;
  /** The parent NewRelic account identifier. */
  nrAccountId: Scalars['Int']['output'];
  /** The cloud service used in the integration. */
  service?: Maybe<CloudService>;
  /** The object last update date, in epoch (Unix) time */
  updatedAt: Scalars['EpochSeconds']['output'];
};

/** Amazon Simple Email Service (SES) */
export type CloudSesIntegrationInput = {
  /** Specify each AWS region that includes the resources that you want to monitor. */
  awsRegions?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  /** [DEPRECATED] Multiple polling interval is no longer supported, use only metrics_polling_interval */
  inventoryPollingInterval?: InputMaybe<Scalars['Int']['input']>;
  /** The linked account identifier. */
  linkedAccountId: Scalars['Int']['input'];
  /** The data polling interval in seconds. */
  metricsPollingInterval?: InputMaybe<Scalars['Int']['input']>;
};

/** SNS Integration */
export type CloudSnsIntegration = CloudIntegration & {
  __typename?: 'CloudSnsIntegration';
  /** Specify each AWS region that includes the resources that you want to monitor. */
  awsRegions?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
  /** The object creation date, in epoch (Unix) time */
  createdAt: Scalars['EpochSeconds']['output'];
  /** Determine if extra inventory data be collected or not. May affect total data collection time and contribute to the Cloud provider API rate limit. */
  fetchExtendedInventory?: Maybe<Scalars['Boolean']['output']>;
  /** The cloud service integration identifier. */
  id?: Maybe<Scalars['Int']['output']>;
  /**
   * [DEPRECATED] Multiple polling interval is no longer supported, use only metrics_polling_interval
   * @deprecated [DEPRECATED] Multiple polling interval is no longer supported, use only metrics_polling_interval
   */
  inventoryPollingInterval?: Maybe<Scalars['Int']['output']>;
  /** The parent linked account identifier. */
  linkedAccount?: Maybe<CloudLinkedAccount>;
  /** The data polling interval in seconds. */
  metricsPollingInterval?: Maybe<Scalars['Int']['output']>;
  /** The cloud service integration name. */
  name?: Maybe<Scalars['String']['output']>;
  /** The parent NewRelic account identifier. */
  nrAccountId: Scalars['Int']['output'];
  /** The cloud service used in the integration. */
  service?: Maybe<CloudService>;
  /** The object last update date, in epoch (Unix) time */
  updatedAt: Scalars['EpochSeconds']['output'];
};

/** Amazon Simple Notification Service (SNS) */
export type CloudSnsIntegrationInput = {
  /** Specify each AWS region that includes the resources that you want to monitor. */
  awsRegions?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  /** Determine if extra inventory data be collected or not. May affect total data collection time and contribute to the Cloud provider API rate limit. */
  fetchExtendedInventory?: InputMaybe<Scalars['Boolean']['input']>;
  /** [DEPRECATED] Multiple polling interval is no longer supported, use only metrics_polling_interval */
  inventoryPollingInterval?: InputMaybe<Scalars['Int']['input']>;
  /** The linked account identifier. */
  linkedAccountId: Scalars['Int']['input'];
  /** The data polling interval in seconds. */
  metricsPollingInterval?: InputMaybe<Scalars['Int']['input']>;
};

/** SQS Integration */
export type CloudSqsIntegration = CloudIntegration & {
  __typename?: 'CloudSqsIntegration';
  /** Specify each AWS region that includes the resources that you want to monitor. */
  awsRegions?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
  /** The object creation date, in epoch (Unix) time */
  createdAt: Scalars['EpochSeconds']['output'];
  /** Determine if extra inventory data be collected or not. May affect total data collection time and contribute to the Cloud provider API rate limit. */
  fetchExtendedInventory?: Maybe<Scalars['Boolean']['output']>;
  /** Specify if tags should be collected. May affect total data collection time and contribute to the Cloud provider API rate limit. */
  fetchTags?: Maybe<Scalars['Boolean']['output']>;
  /** The cloud service integration identifier. */
  id?: Maybe<Scalars['Int']['output']>;
  /**
   * [DEPRECATED] Multiple polling interval is no longer supported, use only metrics_polling_interval
   * @deprecated [DEPRECATED] Multiple polling interval is no longer supported, use only metrics_polling_interval
   */
  inventoryPollingInterval?: Maybe<Scalars['Int']['output']>;
  /** The parent linked account identifier. */
  linkedAccount?: Maybe<CloudLinkedAccount>;
  /** The data polling interval in seconds. */
  metricsPollingInterval?: Maybe<Scalars['Int']['output']>;
  /** The cloud service integration name. */
  name?: Maybe<Scalars['String']['output']>;
  /** The parent NewRelic account identifier. */
  nrAccountId: Scalars['Int']['output'];
  /** Specify each name or prefix for the Queues that you want to monitor. Filter values are case-sensitive. */
  queuePrefixes?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
  /** The cloud service used in the integration. */
  service?: Maybe<CloudService>;
  /** Specify a Tag key associated with the resources that you want to monitor. Filter values are case-sensitive. */
  tagKey?: Maybe<Scalars['String']['output']>;
  /** Specify a Tag value associated with the resources that you want to monitor. Filter values are case-sensitive. */
  tagValue?: Maybe<Scalars['String']['output']>;
  /** The object last update date, in epoch (Unix) time */
  updatedAt: Scalars['EpochSeconds']['output'];
};

/** Amazon Simple Queue Service (SQS) */
export type CloudSqsIntegrationInput = {
  /** Specify each AWS region that includes the resources that you want to monitor. */
  awsRegions?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  /** Determine if extra inventory data be collected or not. May affect total data collection time and contribute to the Cloud provider API rate limit. */
  fetchExtendedInventory?: InputMaybe<Scalars['Boolean']['input']>;
  /** Specify if tags should be collected. May affect total data collection time and contribute to the Cloud provider API rate limit. */
  fetchTags?: InputMaybe<Scalars['Boolean']['input']>;
  /** [DEPRECATED] Multiple polling interval is no longer supported, use only metrics_polling_interval */
  inventoryPollingInterval?: InputMaybe<Scalars['Int']['input']>;
  /** The linked account identifier. */
  linkedAccountId: Scalars['Int']['input'];
  /** The data polling interval in seconds. */
  metricsPollingInterval?: InputMaybe<Scalars['Int']['input']>;
  /** Specify each name or prefix for the Queues that you want to monitor. Filter values are case-sensitive. */
  queuePrefixes?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  /** Specify a Tag key associated with the resources that you want to monitor. Filter values are case-sensitive. */
  tagKey?: InputMaybe<Scalars['String']['input']>;
  /** Specify a Tag value associated with the resources that you want to monitor. Filter values are case-sensitive. */
  tagValue?: InputMaybe<Scalars['String']['input']>;
};

/** Trusted Advisor Integration */
export type CloudTrustedadvisorIntegration = CloudIntegration & {
  __typename?: 'CloudTrustedadvisorIntegration';
  /** The object creation date, in epoch (Unix) time */
  createdAt: Scalars['EpochSeconds']['output'];
  /** The cloud service integration identifier. */
  id?: Maybe<Scalars['Int']['output']>;
  /**
   * [DEPRECATED] Multiple polling interval is no longer supported, use only metrics_polling_interval
   * @deprecated [DEPRECATED] Multiple polling interval is no longer supported, use only metrics_polling_interval
   */
  inventoryPollingInterval?: Maybe<Scalars['Int']['output']>;
  /** The parent linked account identifier. */
  linkedAccount?: Maybe<CloudLinkedAccount>;
  /** The data polling interval in seconds. */
  metricsPollingInterval?: Maybe<Scalars['Int']['output']>;
  /** The cloud service integration name. */
  name?: Maybe<Scalars['String']['output']>;
  /** The parent NewRelic account identifier. */
  nrAccountId: Scalars['Int']['output'];
  /** The cloud service used in the integration. */
  service?: Maybe<CloudService>;
  /** The object last update date, in epoch (Unix) time */
  updatedAt: Scalars['EpochSeconds']['output'];
};

/** Trusted Advisor */
export type CloudTrustedadvisorIntegrationInput = {
  /** [DEPRECATED] Multiple polling interval is no longer supported, use only metrics_polling_interval */
  inventoryPollingInterval?: InputMaybe<Scalars['Int']['input']>;
  /** The linked account identifier. */
  linkedAccountId: Scalars['Int']['input'];
  /** The data polling interval in seconds. */
  metricsPollingInterval?: InputMaybe<Scalars['Int']['input']>;
};

/** Autogenerated return type of UnlinkAccount */
export type CloudUnlinkAccountPayload = {
  __typename?: 'CloudUnlinkAccountPayload';
  /** The list of errors. */
  errors: Array<CloudAccountMutationError>;
  /** The unlinked accounts. */
  unlinkedAccounts: Array<CloudLinkedAccount>;
};

/** Information required to unlink (remove) a linked account. */
export type CloudUnlinkAccountsInput = {
  /** The linked account identifier. */
  linkedAccountId: Scalars['Int']['input'];
};

/** VPC Integration */
export type CloudVpcIntegration = CloudIntegration & {
  __typename?: 'CloudVpcIntegration';
  /** Specify each AWS region that includes the resources that you want to monitor. */
  awsRegions?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
  /** The object creation date, in epoch (Unix) time */
  createdAt: Scalars['EpochSeconds']['output'];
  /** Specify if NAT gateway should be monitored. May affect total data collection time and contribute to the Cloud provider API rate limit. */
  fetchNatGateway?: Maybe<Scalars['Boolean']['output']>;
  /** Specify if VPN should be monitored. May affect total data collection time and contribute to the Cloud provider API rate limit. */
  fetchVpn?: Maybe<Scalars['Boolean']['output']>;
  /** The cloud service integration identifier. */
  id?: Maybe<Scalars['Int']['output']>;
  /**
   * [DEPRECATED] Multiple polling interval is no longer supported, use only metrics_polling_interval
   * @deprecated [DEPRECATED] Multiple polling interval is no longer supported, use only metrics_polling_interval
   */
  inventoryPollingInterval?: Maybe<Scalars['Int']['output']>;
  /** The parent linked account identifier. */
  linkedAccount?: Maybe<CloudLinkedAccount>;
  /** The data polling interval in seconds. */
  metricsPollingInterval?: Maybe<Scalars['Int']['output']>;
  /** The cloud service integration name. */
  name?: Maybe<Scalars['String']['output']>;
  /** The parent NewRelic account identifier. */
  nrAccountId: Scalars['Int']['output'];
  /** The cloud service used in the integration. */
  service?: Maybe<CloudService>;
  /** Specify a Tag key associated with the resources that you want to monitor. Filter values are case-sensitive. */
  tagKey?: Maybe<Scalars['String']['output']>;
  /** Specify a Tag value associated with the resources that you want to monitor. Filter values are case-sensitive. */
  tagValue?: Maybe<Scalars['String']['output']>;
  /** The object last update date, in epoch (Unix) time */
  updatedAt: Scalars['EpochSeconds']['output'];
};

/** Amazon Virtual Private Cloud (VPC) */
export type CloudVpcIntegrationInput = {
  /** Specify each AWS region that includes the resources that you want to monitor. */
  awsRegions?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  /** Specify if NAT gateway should be monitored. May affect total data collection time and contribute to the Cloud provider API rate limit. */
  fetchNatGateway?: InputMaybe<Scalars['Boolean']['input']>;
  /** Specify if VPN should be monitored. May affect total data collection time and contribute to the Cloud provider API rate limit. */
  fetchVpn?: InputMaybe<Scalars['Boolean']['input']>;
  /** [DEPRECATED] Multiple polling interval is no longer supported, use only metrics_polling_interval */
  inventoryPollingInterval?: InputMaybe<Scalars['Int']['input']>;
  /** The linked account identifier. */
  linkedAccountId: Scalars['Int']['input'];
  /** The data polling interval in seconds. */
  metricsPollingInterval?: InputMaybe<Scalars['Int']['input']>;
  /** Specify a Tag key associated with the resources that you want to monitor. Filter values are case-sensitive. */
  tagKey?: InputMaybe<Scalars['String']['input']>;
  /** Specify a Tag value associated with the resources that you want to monitor. Filter values are case-sensitive. */
  tagValue?: InputMaybe<Scalars['String']['input']>;
};

export type CollaborationActorStitchedFields = {
  __typename?: 'CollaborationActorStitchedFields';
  /**
   * Get BotResponses by ids
   * @deprecated This field is experimental and subject to breaking changes.
   */
  botResponsesByIds?: Maybe<Array<Maybe<CollaborationBotResponse>>>;
  /**
   * Get codeMarks by ids
   * @deprecated This field is experimental and subject to breaking changes.
   */
  codeMarksByIds?: Maybe<Array<Maybe<CollaborationCodeMark>>>;
  /**
   * Find a single comment by ID
   * @deprecated This field is experimental and subject to breaking changes.
   */
  commentById?: Maybe<CollaborationComment>;
  /**
   * Find multiple comments by comment IDs
   * @deprecated This field is experimental and subject to breaking changes.
   */
  commentsByIds?: Maybe<Array<Maybe<CollaborationComment>>>;
  /**
   * Find multiple comments by a single thread ID
   * @deprecated This field is experimental and subject to breaking changes.
   */
  commentsByThreadId?: Maybe<CollaborationCommentConnection>;
  /**
   * Find multiple comments by multiple thread IDs
   * @deprecated This field is experimental and subject to breaking changes.
   */
  commentsByThreadIds?: Maybe<Array<Maybe<CollaborationCommentConnection>>>;
  /**
   * Retrive a context by ID
   * @deprecated This field is experimental and subject to breaking changes.
   */
  contextById?: Maybe<CollaborationContext>;
  /**
   * Retrieve multiple contexts by multiple entity GUIDs
   * @deprecated This field is experimental and subject to breaking changes.
   */
  contextsByEntityGuid?: Maybe<CollaborationLinkedContexts>;
  /**
   * Retrieve multiple contexts by multiple IDs
   * @deprecated This field is experimental and subject to breaking changes.
   */
  contextsByIds?: Maybe<Array<Maybe<CollaborationContext>>>;
  /**
   * Get email by address
   * @deprecated This field is experimental and subject to breaking changes.
   */
  emailByAddress?: Maybe<CollaborationEmail>;
  /**
   * Get an email by the email ID
   * @deprecated This field is experimental and subject to breaking changes.
   */
  emailById?: Maybe<CollaborationEmail>;
  /**
   * Get multiple emails with a list of email IDs
   * @deprecated This field is experimental and subject to breaking changes.
   */
  emailsByIds?: Maybe<Array<Maybe<CollaborationEmail>>>;
  /**
   * Get external service connection by ID
   * @deprecated This field is experimental and subject to breaking changes.
   */
  externalServiceConnectionById?: Maybe<CollaborationExternalServiceConnection>;
  /**
   * Get file by id
   * @deprecated This field is experimental and subject to breaking changes.
   */
  fileById?: Maybe<CollaborationFile>;
  /**
   * Find multiple Grok messages by ids
   * @deprecated This field is experimental and subject to breaking changes.
   */
  grokMessagesByIds?: Maybe<Array<Maybe<CollaborationGrokMessage>>>;
  /**
   * Look a single mention by ID
   * @deprecated This field is experimental and subject to breaking changes.
   */
  mentionById?: Maybe<CollaborationMention>;
  /**
   * Look up multiple mentions by ID
   * @deprecated This field is experimental and subject to breaking changes.
   */
  mentionsByIds?: Maybe<Array<Maybe<CollaborationMention>>>;
  /**
   * Get a single subscriber by ID
   * @deprecated This field is experimental and subject to breaking changes.
   */
  subscriberById?: Maybe<CollaborationSubscriber>;
  /**
   * Get the subscribers for a given thread
   * @deprecated This field is experimental and subject to breaking changes.
   */
  subscribersByThreadId?: Maybe<CollaborationSubscriberConnection>;
  /**
   * Get all subscriptions for a given user
   * @deprecated This field is experimental and subject to breaking changes.
   */
  subscribersByUserId?: Maybe<CollaborationSubscriberConnection>;
  /**
   * Get my subscriptions
   * @deprecated This field is experimental and subject to breaking changes.
   */
  subscriptions?: Maybe<CollaborationSubscriberConnection>;
  /**
   * Get my unread subscriptions for a given context
   * @deprecated This field is experimental and subject to breaking changes.
   */
  subscriptionsUnread?: Maybe<CollaborationSubscriptionsWithUnread>;
  /**
   * Fetch a thread by ID
   * @deprecated This field is experimental and subject to breaking changes.
   */
  threadById?: Maybe<CollaborationThread>;
  /**
   * Get all threads for your organization
   * @deprecated This field is experimental and subject to breaking changes.
   */
  threadsAll?: Maybe<CollaborationThreadConnection>;
  /**
   * Get threads for a given context
   * @deprecated This field is experimental and subject to breaking changes.
   */
  threadsByContextId?: Maybe<CollaborationThreadConnection>;
  /**
   * Get threads for multiple contexts
   * @deprecated This field is experimental and subject to breaking changes.
   */
  threadsByContextIds?: Maybe<Array<Maybe<CollaborationThreadConnection>>>;
  /**
   * Get multiple threads from a list of IDs
   * @deprecated This field is experimental and subject to breaking changes.
   */
  threadsByIds?: Maybe<Array<Maybe<CollaborationThread>>>;
  /**
   * Fetch threads count per status by context id
   * @deprecated This field is experimental and subject to breaking changes.
   */
  threadsCountByContextId?: Maybe<CollaborationThreadsCount>;
  /**
   * Returns a URL and connection ID for socket connections
   * @deprecated This field is experimental and subject to breaking changes.
   */
  webSocketConnectUrl?: Maybe<CollaborationSocketConnection>;
};


export type CollaborationActorStitchedFieldsBotResponsesByIdsArgs = {
  ids: Array<InputMaybe<Scalars['ID']['input']>>;
};


export type CollaborationActorStitchedFieldsCodeMarksByIdsArgs = {
  ids: Array<InputMaybe<Scalars['ID']['input']>>;
};


export type CollaborationActorStitchedFieldsCommentByIdArgs = {
  id: Scalars['ID']['input'];
};


export type CollaborationActorStitchedFieldsCommentsByIdsArgs = {
  ids: Array<InputMaybe<Scalars['ID']['input']>>;
};


export type CollaborationActorStitchedFieldsCommentsByThreadIdArgs = {
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  nextCursor?: InputMaybe<Scalars['String']['input']>;
  prevCursor?: InputMaybe<Scalars['String']['input']>;
  threadId: Scalars['ID']['input'];
};


export type CollaborationActorStitchedFieldsCommentsByThreadIdsArgs = {
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  threadIds: Array<InputMaybe<Scalars['ID']['input']>>;
};


export type CollaborationActorStitchedFieldsContextByIdArgs = {
  id?: InputMaybe<Scalars['ID']['input']>;
};


export type CollaborationActorStitchedFieldsContextsByEntityGuidArgs = {
  entityGuid?: InputMaybe<Scalars['EntityGuid']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  nextCursor?: InputMaybe<Scalars['String']['input']>;
};


export type CollaborationActorStitchedFieldsContextsByIdsArgs = {
  ids?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;
};


export type CollaborationActorStitchedFieldsEmailByAddressArgs = {
  emailAddress: Scalars['String']['input'];
};


export type CollaborationActorStitchedFieldsEmailByIdArgs = {
  id: Scalars['ID']['input'];
};


export type CollaborationActorStitchedFieldsEmailsByIdsArgs = {
  ids: Array<InputMaybe<Scalars['ID']['input']>>;
};


export type CollaborationActorStitchedFieldsExternalServiceConnectionByIdArgs = {
  id?: InputMaybe<Scalars['ID']['input']>;
};


export type CollaborationActorStitchedFieldsFileByIdArgs = {
  id: Scalars['ID']['input'];
  thumbnail?: InputMaybe<Scalars['Boolean']['input']>;
};


export type CollaborationActorStitchedFieldsGrokMessagesByIdsArgs = {
  ids: Array<InputMaybe<Scalars['ID']['input']>>;
};


export type CollaborationActorStitchedFieldsMentionByIdArgs = {
  id?: InputMaybe<Scalars['ID']['input']>;
};


export type CollaborationActorStitchedFieldsMentionsByIdsArgs = {
  ids?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;
};


export type CollaborationActorStitchedFieldsSubscriberByIdArgs = {
  id: Scalars['ID']['input'];
};


export type CollaborationActorStitchedFieldsSubscribersByThreadIdArgs = {
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  nextCursor?: InputMaybe<Scalars['String']['input']>;
  prevCursor?: InputMaybe<Scalars['String']['input']>;
  threadId: Scalars['ID']['input'];
};


export type CollaborationActorStitchedFieldsSubscribersByUserIdArgs = {
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  nextCursor?: InputMaybe<Scalars['String']['input']>;
  prevCursor?: InputMaybe<Scalars['String']['input']>;
  subscriberId: Scalars['ID']['input'];
};


export type CollaborationActorStitchedFieldsSubscriptionsArgs = {
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  nextCursor?: InputMaybe<Scalars['String']['input']>;
  prevCursor?: InputMaybe<Scalars['String']['input']>;
};


export type CollaborationActorStitchedFieldsSubscriptionsUnreadArgs = {
  contextId?: InputMaybe<Scalars['ID']['input']>;
};


export type CollaborationActorStitchedFieldsThreadByIdArgs = {
  id?: InputMaybe<Scalars['ID']['input']>;
};


export type CollaborationActorStitchedFieldsThreadsAllArgs = {
  filter?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  nextCursor?: InputMaybe<Scalars['String']['input']>;
  prevCursor?: InputMaybe<Scalars['String']['input']>;
};


export type CollaborationActorStitchedFieldsThreadsByContextIdArgs = {
  contextId?: InputMaybe<Scalars['ID']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  nextCursor?: InputMaybe<Scalars['String']['input']>;
  prevCursor?: InputMaybe<Scalars['String']['input']>;
  visibility?: InputMaybe<Scalars['String']['input']>;
};


export type CollaborationActorStitchedFieldsThreadsByContextIdsArgs = {
  contextIds?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  visibility?: InputMaybe<Scalars['String']['input']>;
};


export type CollaborationActorStitchedFieldsThreadsByIdsArgs = {
  ids?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;
};


export type CollaborationActorStitchedFieldsThreadsCountByContextIdArgs = {
  contextId?: InputMaybe<Scalars['ID']['input']>;
};

/** Assistant configuration options */
export type CollaborationAssistantConfigInput = {
  /** Name of the configuration */
  name: Scalars['String']['input'];
  /** Configuration value */
  value: Scalars['String']['input'];
};

/** Files uploaded by user */
export type CollaborationBotResponse = {
  __typename?: 'CollaborationBotResponse';
  /**
   * Account ID
   * @deprecated This field is experimental and subject to breaking changes.
   */
  accountId?: Maybe<Scalars['Int']['output']>;
  /**
   * Time the thread was created
   * @deprecated This field is experimental and subject to breaking changes.
   */
  createdAt: Scalars['EpochMilliseconds']['output'];
  /**
   * Indicates whether or not a comment is deactivated
   * @deprecated This field is experimental and subject to breaking changes.
   */
  deactivated?: Maybe<Scalars['Boolean']['output']>;
  /**
   * Bot Response ID
   * @deprecated This field is experimental and subject to breaking changes.
   */
  id: Scalars['ID']['output'];
  /**
   * Time the thread was modified
   * @deprecated This field is experimental and subject to breaking changes.
   */
  modifiedAt: Scalars['EpochMilliseconds']['output'];
  /**
   * Organization ID
   * @deprecated This field is experimental and subject to breaking changes.
   */
  organizationId?: Maybe<Scalars['ID']['output']>;
  /**
   * JSON payload for the bot response in string format
   * @deprecated This field is experimental and subject to breaking changes.
   */
  payload?: Maybe<Scalars['String']['output']>;
};

/** Feedback on bot reponse */
export type CollaborationBotResponseFeedback = {
  __typename?: 'CollaborationBotResponseFeedback';
  /**
   * rating
   * @deprecated This field is experimental and subject to breaking changes.
   */
  rating?: Maybe<Scalars['Int']['output']>;
  /**
   * Bot Response ID
   * @deprecated This field is experimental and subject to breaking changes.
   */
  responseId?: Maybe<Scalars['ID']['output']>;
};

/** Code mark created in CodeStream */
export type CollaborationCodeMark = {
  __typename?: 'CollaborationCodeMark';
  /**
   * Account ID
   * @deprecated This field is experimental and subject to breaking changes.
   */
  accountId?: Maybe<Scalars['Int']['output']>;
  /**
   * The actual code
   * @deprecated This field is experimental and subject to breaking changes.
   */
  code?: Maybe<Scalars['String']['output']>;
  /**
   * Time the code mark was created
   * @deprecated This field is experimental and subject to breaking changes.
   */
  createdAt?: Maybe<Scalars['EpochMilliseconds']['output']>;
  /**
   * Creator ID
   * @deprecated This field is experimental and subject to breaking changes.
   */
  creatorId?: Maybe<Scalars['ID']['output']>;
  /**
   * Code mark status
   * @deprecated This field is experimental and subject to breaking changes.
   */
  deactivated?: Maybe<Scalars['Boolean']['output']>;
  /**
   * File to which this code block applies
   * @deprecated This field is experimental and subject to breaking changes.
   */
  file?: Maybe<Scalars['String']['output']>;
  /**
   * Codemark ID
   * @deprecated This field is experimental and subject to breaking changes.
   */
  id: Scalars['ID']['output'];
  /**
   * Time the code mark was modified
   * @deprecated This field is experimental and subject to breaking changes.
   */
  modifiedAt?: Maybe<Scalars['EpochMilliseconds']['output']>;
  /**
   * Organization ID
   * @deprecated This field is experimental and subject to breaking changes.
   */
  organizationId?: Maybe<Scalars['ID']['output']>;
  /**
   * The permalink used to jump to this code mark in codestream
   * @deprecated This field is experimental and subject to breaking changes.
   */
  permalink?: Maybe<Scalars['String']['output']>;
  /**
   * Path to the repo to which this code block applies
   * @deprecated This field is experimental and subject to breaking changes.
   */
  repo?: Maybe<Scalars['String']['output']>;
  /**
   * The git commit sha the code was at when the code block was captured
   * @deprecated This field is experimental and subject to breaking changes.
   */
  sha?: Maybe<Scalars['String']['output']>;
};

/** Comment tied to a thread */
export type CollaborationComment = {
  __typename?: 'CollaborationComment';
  /**
   * Account that owns the comment
   * @deprecated This field is experimental and subject to breaking changes.
   */
  accountId: Scalars['Int']['output'];
  /**
   * Special attributes of the comment
   * @deprecated This field is experimental and subject to breaking changes.
   */
  attributes?: Maybe<Scalars['String']['output']>;
  /**
   * The message of the comment
   * @deprecated This field is experimental and subject to breaking changes.
   */
  body: Scalars['String']['output'];
  /**
   * ID of the context where the comment's thread lives
   * @deprecated This field is experimental and subject to breaking changes.
   */
  contextId: Scalars['ID']['output'];
  /**
   * Context Meta Data
   * @deprecated This field is experimental and subject to breaking changes.
   */
  contextMetadata?: Maybe<Scalars['CollaborationRawContextMetadata']['output']>;
  /**
   * Comment creation time
   * @deprecated This field is experimental and subject to breaking changes.
   */
  createdAt: Scalars['EpochMilliseconds']['output'];
  /**
   * Comment creator details
   * @deprecated This field is experimental and subject to breaking changes.
   */
  creator?: Maybe<CollaborationCommentCreator>;
  /**
   * ID of the creator of the comment
   * @deprecated This field is experimental and subject to breaking changes.
   */
  creatorId: Scalars['ID']['output'];
  /**
   * Indicates whether or not a comment is deactivated
   * @deprecated This field is experimental and subject to breaking changes.
   */
  deactivated?: Maybe<Scalars['Boolean']['output']>;
  /**
   * Indicates whether or not a comment was edited
   * @deprecated This field is experimental and subject to breaking changes.
   */
  edited?: Maybe<Scalars['Boolean']['output']>;
  /**
   * External appliation type which comment is originated from
   * @deprecated This field is experimental and subject to breaking changes.
   */
  externalApplicationType?: Maybe<Scalars['String']['output']>;
  /**
   * External creator if comment is from external application
   * @deprecated This field is experimental and subject to breaking changes.
   */
  externalCreator?: Maybe<CollaborationExternalCommentCreator>;
  /**
   * External creator id if comment is from external application
   * @deprecated This field is experimental and subject to breaking changes.
   */
  externalCreatorId?: Maybe<Scalars['ID']['output']>;
  /**
   * Comment ID
   * @deprecated This field is experimental and subject to breaking changes.
   */
  id: Scalars['ID']['output'];
  /**
   * Mentions associated with a comment
   * @deprecated This field is experimental and subject to breaking changes.
   */
  mentions?: Maybe<Array<Maybe<CollaborationMention>>>;
  /**
   * Comment modified time
   * @deprecated This field is experimental and subject to breaking changes.
   */
  modifiedAt: Scalars['EpochMilliseconds']['output'];
  /**
   * Organization that owns the comment
   * @deprecated This field is experimental and subject to breaking changes.
   */
  organizationId: Scalars['ID']['output'];
  /**
   * Reference URL of the comment
   * @deprecated This field is experimental and subject to breaking changes.
   */
  referenceUrl?: Maybe<Scalars['String']['output']>;
  /**
   * Indicates the comment is a reply to some other comment
   * @deprecated This field is experimental and subject to breaking changes.
   */
  replyTo?: Maybe<Scalars['ID']['output']>;
  /**
   * List of sync statuses to external applications
   * @deprecated This field is experimental and subject to breaking changes.
   */
  syncStatuses?: Maybe<Array<Maybe<CollaborationCommentSyncStatus>>>;
  /**
   * Denotes system message and type of comment
   * @deprecated This field is experimental and subject to breaking changes.
   */
  systemMessageType?: Maybe<Scalars['String']['output']>;
  /**
   * ID of the thread where the comment lives
   * @deprecated This field is experimental and subject to breaking changes.
   */
  threadId: Scalars['ID']['output'];
  /**
   * Timer picker start time
   * @deprecated This field is experimental and subject to breaking changes.
   */
  timePickerFrom?: Maybe<Scalars['EpochMilliseconds']['output']>;
  /**
   * Timer picker end time
   * @deprecated This field is experimental and subject to breaking changes.
   */
  timePickerTo?: Maybe<Scalars['EpochMilliseconds']['output']>;
};

/** Cursor pagination object */
export type CollaborationCommentConnection = {
  __typename?: 'CollaborationCommentConnection';
  /**
   * Array of results
   * @deprecated This field is experimental and subject to breaking changes.
   */
  entities?: Maybe<Array<Maybe<CollaborationComment>>>;
  /**
   * has next page
   * @deprecated This field is experimental and subject to breaking changes.
   */
  hasNextPage?: Maybe<Scalars['Boolean']['output']>;
  /**
   * has previous page
   * @deprecated This field is experimental and subject to breaking changes.
   */
  hasPreviousPage?: Maybe<Scalars['Boolean']['output']>;
  /**
   * Next cursor to paginate by
   * @deprecated This field is experimental and subject to breaking changes.
   */
  nextCursor?: Maybe<Scalars['String']['output']>;
  /**
   * Previous cursor to paginate by
   * @deprecated This field is experimental and subject to breaking changes.
   */
  prevCursor?: Maybe<Scalars['String']['output']>;
  /**
   * Total amount paginatable
   * @deprecated This field is experimental and subject to breaking changes.
   */
  totalCount?: Maybe<Scalars['Int']['output']>;
};

/** Creator of the comment */
export type CollaborationCommentCreator = {
  __typename?: 'CollaborationCommentCreator';
  /**
   * Email of the comment creator
   * @deprecated This field is experimental and subject to breaking changes.
   */
  email?: Maybe<Scalars['String']['output']>;
  /**
   * Name of the comment creator
   * @deprecated This field is experimental and subject to breaking changes.
   */
  name?: Maybe<Scalars['String']['output']>;
  /**
   * ID of the comment creator
   * @deprecated This field is experimental and subject to breaking changes.
   */
  userId: Scalars['ID']['output'];
};

/** Comment sync status to external application */
export type CollaborationCommentSyncStatus = {
  __typename?: 'CollaborationCommentSyncStatus';
  /**
   * External application type
   * @deprecated This field is experimental and subject to breaking changes.
   */
  appType?: Maybe<Scalars['String']['output']>;
  /**
   * Error as cause for not ok
   * @deprecated This field is experimental and subject to breaking changes.
   */
  error?: Maybe<Scalars['String']['output']>;
  /**
   * Sync success or not, undefined indicates pending
   * @deprecated This field is experimental and subject to breaking changes.
   */
  ok?: Maybe<Scalars['Boolean']['output']>;
};

/** Context represents a page or construct where threads can be created and conversations can happen */
export type CollaborationContext = {
  __typename?: 'CollaborationContext';
  /**
   * Account ID
   * @deprecated This field is experimental and subject to breaking changes.
   */
  accountId?: Maybe<Scalars['Int']['output']>;
  /**
   * Metadata added to context
   * @deprecated This field is experimental and subject to breaking changes.
   */
  contextMetadata?: Maybe<Scalars['CollaborationRawContextMetadata']['output']>;
  /**
   * Time the context was created
   * @deprecated This field is experimental and subject to breaking changes.
   */
  createdAt: Scalars['EpochMilliseconds']['output'];
  /**
   * Creator ID
   * @deprecated This field is experimental and subject to breaking changes.
   */
  creatorId: Scalars['ID']['output'];
  /**
   * Indicates whether or not the context has been deactivated
   * @deprecated This field is experimental and subject to breaking changes.
   */
  deactivated?: Maybe<Scalars['Boolean']['output']>;
  /**
   * URL state entity GUID associated with the context
   * @deprecated This field is experimental and subject to breaking changes.
   */
  entityGuid?: Maybe<Scalars['EntityGuid']['output']>;
  /**
   * Context ID
   * @deprecated This field is experimental and subject to breaking changes.
   */
  id: Scalars['ID']['output'];
  /**
   * Creator ID of the latest comment on the latest thread
   * @deprecated This field is experimental and subject to breaking changes.
   */
  latestThreadCommentCreatorId?: Maybe<Scalars['ID']['output']>;
  /**
   * Comment ID of the latest comment on the latest thread
   * @deprecated This field is experimental and subject to breaking changes.
   */
  latestThreadCommentId?: Maybe<Scalars['ID']['output']>;
  /**
   * Time of the latest comment on the latest thread
   * @deprecated This field is experimental and subject to breaking changes.
   */
  latestThreadCommentTime?: Maybe<Scalars['EpochMilliseconds']['output']>;
  /**
   * ID of the thread with latest activity
   * @deprecated This field is experimental and subject to breaking changes.
   */
  latestThreadId?: Maybe<Scalars['ID']['output']>;
  /**
   * Time the context was modified
   * @deprecated This field is experimental and subject to breaking changes.
   */
  modifiedAt: Scalars['EpochMilliseconds']['output'];
  /**
   * Organization ID
   * @deprecated This field is experimental and subject to breaking changes.
   */
  organizationId: Scalars['ID']['output'];
  /**
   * URL that represents the context
   * @deprecated This field is experimental and subject to breaking changes.
   */
  referenceUrl?: Maybe<Scalars['String']['output']>;
  /**
   * Get a thread associated with this context
   * @deprecated This field is experimental and subject to breaking changes.
   */
  thread?: Maybe<CollaborationThread>;
  /**
   * Number of threads about this context
   * @deprecated This field is experimental and subject to breaking changes.
   */
  threadCount: Scalars['Int']['output'];
  /**
   * Threads for a given context
   * @deprecated This field is experimental and subject to breaking changes.
   */
  threads?: Maybe<CollaborationThreadConnection>;
};


/** Context represents a page or construct where threads can be created and conversations can happen */
export type CollaborationContextThreadArgs = {
  id?: InputMaybe<Scalars['ID']['input']>;
};


/** Context represents a page or construct where threads can be created and conversations can happen */
export type CollaborationContextThreadsArgs = {
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

/** Email object to store any mentioned email addresses */
export type CollaborationEmail = {
  __typename?: 'CollaborationEmail';
  /**
   * Time the email was created
   * @deprecated This field is experimental and subject to breaking changes.
   */
  createdAt: Scalars['EpochMilliseconds']['output'];
  /**
   * Creator ID
   * @deprecated This field is experimental and subject to breaking changes.
   */
  creatorId: Scalars['ID']['output'];
  /**
   * Email address that was mentioned
   * @deprecated This field is experimental and subject to breaking changes.
   */
  emailAddress: Scalars['String']['output'];
  /**
   * Email ID
   * @deprecated This field is experimental and subject to breaking changes.
   */
  id: Scalars['ID']['output'];
  /**
   * Time the addresse was modified
   * @deprecated This field is experimental and subject to breaking changes.
   */
  modifiedAt: Scalars['EpochMilliseconds']['output'];
  /**
   * Organization ID
   * @deprecated This field is experimental and subject to breaking changes.
   */
  organizationId?: Maybe<Scalars['ID']['output']>;
  /**
   * Time the user registered this email
   * @deprecated This field is experimental and subject to breaking changes.
   */
  registeredAt?: Maybe<Scalars['EpochMilliseconds']['output']>;
  /**
   * Status of the email address
   * @deprecated This field is experimental and subject to breaking changes.
   */
  status: Scalars['String']['output'];
  /**
   * If someone eventually registers with this email address, their user ID is stored here
   * @deprecated This field is experimental and subject to breaking changes.
   */
  userId?: Maybe<Scalars['ID']['output']>;
};

/** Valid collaboration application integrations */
export enum CollaborationExternalApplicationType {
  /**
   * Codestream integration
   * @deprecated This field is experimental and subject to breaking changes.
   */
  Codestream = 'CODESTREAM',
  /**
   * Email integration
   * @deprecated This field is experimental and subject to breaking changes.
   */
  Email = 'EMAIL',
  /**
   * Slack integration
   * @deprecated This field is experimental and subject to breaking changes.
   */
  Slack = 'SLACK',
  /**
   * Teams integration
   * @deprecated This field is experimental and subject to breaking changes.
   */
  Teams = 'TEAMS'
}

/** Creator of the comment from a 3rd party */
export type CollaborationExternalCommentCreator = {
  __typename?: 'CollaborationExternalCommentCreator';
  /**
   * External comment creator created time
   * @deprecated This field is experimental and subject to breaking changes.
   */
  createdAt?: Maybe<Scalars['EpochMilliseconds']['output']>;
  /**
   * Email address registered in external application
   * @deprecated This field is experimental and subject to breaking changes.
   */
  emailAddress?: Maybe<Scalars['String']['output']>;
  /**
   * Unique ID of external comment creator
   * @deprecated This field is experimental and subject to breaking changes.
   */
  id: Scalars['ID']['output'];
  /**
   * External comment creator modified time
   * @deprecated This field is experimental and subject to breaking changes.
   */
  modifiedAt?: Maybe<Scalars['EpochMilliseconds']['output']>;
  /**
   * New Relic user ID if existing
   * @deprecated This field is experimental and subject to breaking changes.
   */
  userId?: Maybe<Scalars['Int']['output']>;
  /**
   * User display name from external application
   * @deprecated This field is experimental and subject to breaking changes.
   */
  userName?: Maybe<Scalars['String']['output']>;
};

/** External Service represents a link between a New Relic thread and a thread on an external service */
export type CollaborationExternalServiceConnection = {
  __typename?: 'CollaborationExternalServiceConnection';
  /**
   * Account ID
   * @deprecated This field is experimental and subject to breaking changes.
   */
  accountId?: Maybe<Scalars['Int']['output']>;
  /**
   * 3rd party channel ID
   * @deprecated This field is experimental and subject to breaking changes.
   */
  channelId?: Maybe<Scalars['ID']['output']>;
  /**
   * Time the external service connection was created
   * @deprecated This field is experimental and subject to breaking changes.
   */
  createdAt: Scalars['EpochMilliseconds']['output'];
  /**
   * Creator ID
   * @deprecated This field is experimental and subject to breaking changes.
   */
  creatorId: Scalars['ID']['output'];
  /**
   * Indicates whether or not the external service connection has been deactivated
   * @deprecated This field is experimental and subject to breaking changes.
   */
  deactivated?: Maybe<Scalars['Boolean']['output']>;
  /**
   * External Service Connection ID
   * @deprecated This field is experimental and subject to breaking changes.
   */
  id: Scalars['ID']['output'];
  /**
   * Organization ID
   * @deprecated This field is experimental and subject to breaking changes.
   */
  organizationId: Scalars['ID']['output'];
  /**
   * Session ID provided by the notifications gateway when creating the first external message
   * @deprecated This field is experimental and subject to breaking changes.
   */
  sessionId: Scalars['ID']['output'];
  /**
   * Thread ID where messages from the external service will be created
   * @deprecated This field is experimental and subject to breaking changes.
   */
  threadId: Scalars['ID']['output'];
  /**
   * Connection type. One of ['SLACK', 'TEAMS', 'EMAIL']
   * @deprecated This field is experimental and subject to breaking changes.
   */
  type: Scalars['String']['output'];
};

/** Cursor pagination object */
export type CollaborationExternalServiceConnectionGroup = {
  __typename?: 'CollaborationExternalServiceConnectionGroup';
  /**
   * Array of results
   * @deprecated This field is experimental and subject to breaking changes.
   */
  entities?: Maybe<Array<Maybe<CollaborationExternalServiceConnection>>>;
  /**
   * has next page
   * @deprecated This field is experimental and subject to breaking changes.
   */
  hasNextPage?: Maybe<Scalars['Boolean']['output']>;
  /**
   * has previous page
   * @deprecated This field is experimental and subject to breaking changes.
   */
  hasPreviousPage?: Maybe<Scalars['Boolean']['output']>;
  /**
   * Next cursor to paginate by
   * @deprecated This field is experimental and subject to breaking changes.
   */
  nextCursor?: Maybe<Scalars['String']['output']>;
  /**
   * Previous cursor to paginate by
   * @deprecated This field is experimental and subject to breaking changes.
   */
  prevCursor?: Maybe<Scalars['String']['output']>;
  /**
   * Total amount paginatable
   * @deprecated This field is experimental and subject to breaking changes.
   */
  totalCount?: Maybe<Scalars['Int']['output']>;
};

/** Files uploaded by user */
export type CollaborationFile = {
  __typename?: 'CollaborationFile';
  /**
   * Account ID
   * @deprecated This field is experimental and subject to breaking changes.
   */
  accountId?: Maybe<Scalars['Int']['output']>;
  /**
   * Time the thread was created
   * @deprecated This field is experimental and subject to breaking changes.
   */
  createdAt: Scalars['EpochMilliseconds']['output'];
  /**
   * Creator ID
   * @deprecated This field is experimental and subject to breaking changes.
   */
  creatorId?: Maybe<Scalars['ID']['output']>;
  /**
   * File status
   * @deprecated This field is experimental and subject to breaking changes.
   */
  deactivated?: Maybe<Scalars['Boolean']['output']>;
  /**
   * The type of external application
   * @deprecated This field is experimental and subject to breaking changes.
   */
  externalApplicationType?: Maybe<Scalars['String']['output']>;
  /**
   * The user id of the external user
   * @deprecated This field is experimental and subject to breaking changes.
   */
  externalCreatorId?: Maybe<Scalars['String']['output']>;
  /**
   * Name of file
   * @deprecated This field is experimental and subject to breaking changes.
   */
  fileName?: Maybe<Scalars['String']['output']>;
  /**
   * File Path
   * @deprecated This field is experimental and subject to breaking changes.
   */
  filePath?: Maybe<Scalars['String']['output']>;
  /**
   * Does image have thumbnail version
   * @deprecated This field is experimental and subject to breaking changes.
   */
  hasThumbnail?: Maybe<Scalars['Boolean']['output']>;
  /**
   * Thread ID
   * @deprecated This field is experimental and subject to breaking changes.
   */
  id: Scalars['ID']['output'];
  /**
   * Is image NR screenshot
   * @deprecated This field is experimental and subject to breaking changes.
   */
  isScreenshot?: Maybe<Scalars['Boolean']['output']>;
  /**
   * Time the thread was modified
   * @deprecated This field is experimental and subject to breaking changes.
   */
  modifiedAt: Scalars['EpochMilliseconds']['output'];
  /**
   * Organization ID
   * @deprecated This field is experimental and subject to breaking changes.
   */
  organizationId?: Maybe<Scalars['ID']['output']>;
  /**
   * Upload Url
   * @deprecated This field is experimental and subject to breaking changes.
   */
  uploadUrl?: Maybe<Scalars['String']['output']>;
};

/** Messages generated from Grok */
export type CollaborationGrokMessage = {
  __typename?: 'CollaborationGrokMessage';
  /**
   * Account ID
   * @deprecated This field is experimental and subject to breaking changes.
   */
  accountId?: Maybe<Scalars['Int']['output']>;
  /**
   * The card included with Groks response
   * @deprecated This field is experimental and subject to breaking changes.
   */
  card?: Maybe<Scalars['String']['output']>;
  /**
   * The message content
   * @deprecated This field is experimental and subject to breaking changes.
   */
  content?: Maybe<Scalars['String']['output']>;
  /**
   * Indicates whether or not the message is deactivated
   * @deprecated This field is experimental and subject to breaking changes.
   */
  context?: Maybe<Scalars['CollaborationRawContextMetadata']['output']>;
  /**
   * Time the message was created
   * @deprecated This field is experimental and subject to breaking changes.
   */
  createdAt: Scalars['EpochMilliseconds']['output'];
  /**
   * Creator ID
   * @deprecated This field is experimental and subject to breaking changes.
   */
  creatorId?: Maybe<Scalars['ID']['output']>;
  /**
   * Message ID
   * @deprecated This field is experimental and subject to breaking changes.
   */
  id: Scalars['ID']['output'];
  /**
   * Time the message was modified
   * @deprecated This field is experimental and subject to breaking changes.
   */
  modifiedAt: Scalars['EpochMilliseconds']['output'];
  /**
   * Role of the message creator
   * @deprecated This field is experimental and subject to breaking changes.
   */
  role?: Maybe<Scalars['String']['output']>;
  /**
   * Thread ID
   * @deprecated This field is experimental and subject to breaking changes.
   */
  threadId?: Maybe<Scalars['ID']['output']>;
};

/** Contains contexts and cursor information */
export type CollaborationLinkedContexts = {
  __typename?: 'CollaborationLinkedContexts';
  /**
   * Array of contexts
   * @deprecated This field is experimental and subject to breaking changes.
   */
  entities?: Maybe<Array<Maybe<CollaborationContext>>>;
  /**
   * Cursor to fetch next page
   * @deprecated This field is experimental and subject to breaking changes.
   */
  nextCursor?: Maybe<Scalars['String']['output']>;
};

/** A mention represents a mentionable item like a user, file, graph, etc */
export type CollaborationMention = {
  __typename?: 'CollaborationMention';
  /**
   * The comment that mentioned this item
   * @deprecated This field is experimental and subject to breaking changes.
   */
  commentId: Scalars['ID']['output'];
  /**
   * The time the mention was created
   * @deprecated This field is experimental and subject to breaking changes.
   */
  createdAt: Scalars['EpochMilliseconds']['output'];
  /**
   * Creator ID
   * @deprecated This field is experimental and subject to breaking changes.
   */
  creatorId: Scalars['ID']['output'];
  /**
   * Indicates whether or not the mention has been deactivated
   * @deprecated This field is experimental and subject to breaking changes.
   */
  deactivated: Scalars['Boolean']['output'];
  /**
   * Email object if mentionable thing is an email
   * @deprecated This field is experimental and subject to breaking changes.
   */
  email?: Maybe<CollaborationEmail>;
  /**
   * The type of external application associated with this mention (e.g.: SLACK)
   * @deprecated This field is experimental and subject to breaking changes.
   */
  externalApplicationType?: Maybe<CollaborationExternalApplicationType>;
  /**
   * The user id of the user mentioning this item
   * @deprecated This field is experimental and subject to breaking changes.
   */
  externalCreatorId?: Maybe<Scalars['ID']['output']>;
  /**
   * Mention ID
   * @deprecated This field is experimental and subject to breaking changes.
   */
  id: Scalars['ID']['output'];
  /**
   * ID of thing being mentioned
   * @deprecated This field is experimental and subject to breaking changes.
   */
  mentionableItemId: Scalars['ID']['output'];
  /**
   * The time the mention was last modified
   * @deprecated This field is experimental and subject to breaking changes.
   */
  modifiedAt?: Maybe<Scalars['EpochMilliseconds']['output']>;
  /**
   * The type of item being mentioned
   * @deprecated This field is experimental and subject to breaking changes.
   */
  type: Scalars['String']['output'];
};

/** Message shared to external application */
export type CollaborationMessageSent = {
  __typename?: 'CollaborationMessageSent';
  /**
   * Message ID
   * @deprecated This field is experimental and subject to breaking changes.
   */
  id: Scalars['ID']['output'];
  /**
   * Message creation time
   * @deprecated This field is experimental and subject to breaking changes.
   */
  sentAt: Scalars['EpochMilliseconds']['output'];
  /**
   * List of sync statuses to external applications
   * @deprecated This field is experimental and subject to breaking changes.
   */
  syncStatuses?: Maybe<Array<Maybe<CollaborationCommentSyncStatus>>>;
};

/** Websocket subscriber connection data */
export type CollaborationSocketConnection = {
  __typename?: 'CollaborationSocketConnection';
  /**
   * New Relic Connection ID
   * @deprecated This field is experimental and subject to breaking changes.
   */
  nrConnectionId?: Maybe<Scalars['String']['output']>;
  /**
   * The URL that the client should connect to
   * @deprecated This field is experimental and subject to breaking changes.
   */
  url?: Maybe<Scalars['SecureValue']['output']>;
};

/** Defines if the threads is OPEN, CLOSED or ARCHIVED */
export enum CollaborationStatus {
  /**
   * Archived thread wont't show in multi-thread
   * @deprecated This field is experimental and subject to breaking changes.
   */
  Archived = 'ARCHIVED',
  /**
   * Closed thread
   * @deprecated This field is experimental and subject to breaking changes.
   */
  Closed = 'CLOSED',
  /**
   * Open thread
   * @deprecated This field is experimental and subject to breaking changes.
   */
  Open = 'OPEN'
}

/** A subscriber represents a user subscribed to a thread */
export type CollaborationSubscriber = {
  __typename?: 'CollaborationSubscriber';
  /**
   * Account ID
   * @deprecated This field is experimental and subject to breaking changes.
   */
  accountId: Scalars['Int']['output'];
  /**
   * Indicates whether or not the subscription is active
   * @deprecated This field is experimental and subject to breaking changes.
   */
  activelySubscribed?: Maybe<Scalars['Boolean']['output']>;
  /**
   * Number of comments this subscriber has read in this thread
   * @deprecated This field is experimental and subject to breaking changes.
   */
  commentsReadCount?: Maybe<Scalars['Int']['output']>;
  /**
   * Context ID
   * @deprecated This field is experimental and subject to breaking changes.
   */
  contextId: Scalars['ID']['output'];
  /**
   * Time subscription was created
   * @deprecated This field is experimental and subject to breaking changes.
   */
  createdAt?: Maybe<Scalars['EpochMilliseconds']['output']>;
  /**
   * The type of external application associated with this subscription (e.g.: SLACK)
   * @deprecated This field is experimental and subject to breaking changes.
   */
  externalApplicationType?: Maybe<Scalars['String']['output']>;
  /**
   * The non NR user id associated to this subscription
   * @deprecated This field is experimental and subject to breaking changes.
   */
  externalCreatorId?: Maybe<Scalars['ID']['output']>;
  /**
   * Subscriber ID
   * @deprecated This field is experimental and subject to breaking changes.
   */
  id: Scalars['ID']['output'];
  /**
   * ID of the last comment read
   * @deprecated This field is experimental and subject to breaking changes.
   */
  lastCommentReadId?: Maybe<Scalars['ID']['output']>;
  /**
   * Number of mentions in this thread
   * @deprecated This field is experimental and subject to breaking changes.
   */
  mentionCount?: Maybe<Scalars['Int']['output']>;
  /**
   * Number of mentions the user has read
   * @deprecated This field is experimental and subject to breaking changes.
   */
  mentionsReadCount?: Maybe<Scalars['Int']['output']>;
  /**
   * Time subscription was modified
   * @deprecated This field is experimental and subject to breaking changes.
   */
  modifiedAt?: Maybe<Scalars['EpochMilliseconds']['output']>;
  /**
   * Organization ID
   * @deprecated This field is experimental and subject to breaking changes.
   */
  organizationId: Scalars['ID']['output'];
  /**
   * Get the thread that this subscriber is for
   * @deprecated This field is experimental and subject to breaking changes.
   */
  thread?: Maybe<CollaborationThread>;
  /**
   * Thread ID
   * @deprecated This field is experimental and subject to breaking changes.
   */
  threadId: Scalars['ID']['output'];
  /**
   * Number of comments deleted before the user read them
   * @deprecated This field is experimental and subject to breaking changes.
   */
  unreadCommentDeletedCount?: Maybe<Scalars['Int']['output']>;
  /**
   * User ID
   * @deprecated This field is experimental and subject to breaking changes.
   */
  userId: Scalars['ID']['output'];
};

/** Cursor pagination object */
export type CollaborationSubscriberConnection = {
  __typename?: 'CollaborationSubscriberConnection';
  /**
   * Array of results
   * @deprecated This field is experimental and subject to breaking changes.
   */
  entities?: Maybe<Array<Maybe<CollaborationSubscriber>>>;
  /**
   * has next page
   * @deprecated This field is experimental and subject to breaking changes.
   */
  hasNextPage?: Maybe<Scalars['Boolean']['output']>;
  /**
   * has previous page
   * @deprecated This field is experimental and subject to breaking changes.
   */
  hasPreviousPage?: Maybe<Scalars['Boolean']['output']>;
  /**
   * Next cursor to paginate by
   * @deprecated This field is experimental and subject to breaking changes.
   */
  nextCursor?: Maybe<Scalars['String']['output']>;
  /**
   * Previous cursor to paginate by
   * @deprecated This field is experimental and subject to breaking changes.
   */
  prevCursor?: Maybe<Scalars['String']['output']>;
  /**
   * Total amount paginatable
   * @deprecated This field is experimental and subject to breaking changes.
   */
  totalCount?: Maybe<Scalars['Int']['output']>;
};

/** Only subscriptions with unread messages */
export type CollaborationSubscriptionsWithUnread = {
  __typename?: 'CollaborationSubscriptionsWithUnread';
  /**
   * A list of subscriptions
   * @deprecated This field is experimental and subject to breaking changes.
   */
  subscriptions?: Maybe<Scalars['String']['output']>;
  /**
   * The number of unread comments for this user
   * @deprecated This field is experimental and subject to breaking changes.
   */
  unreadCommentCount?: Maybe<Scalars['Int']['output']>;
  /**
   * The number of unread threads for this user
   * @deprecated This field is experimental and subject to breaking changes.
   */
  unreadThreadCount?: Maybe<Scalars['Int']['output']>;
};

/** Thread tied to a context */
export type CollaborationThread = {
  __typename?: 'CollaborationThread';
  /**
   * Account ID
   * @deprecated This field is experimental and subject to breaking changes.
   */
  accountId?: Maybe<Scalars['Int']['output']>;
  /**
   * Query for a single comment within a thread
   * @deprecated This field is experimental and subject to breaking changes.
   */
  comment?: Maybe<CollaborationComment>;
  /**
   * Number of comments in the thread
   * @deprecated This field is experimental and subject to breaking changes.
   */
  commentCount: Scalars['Int']['output'];
  /**
   * Query for multiple comments on a thread
   * @deprecated This field is experimental and subject to breaking changes.
   */
  comments?: Maybe<CollaborationCommentConnection>;
  /**
   * Context ID
   * @deprecated This field is experimental and subject to breaking changes.
   */
  contextId?: Maybe<Scalars['ID']['output']>;
  /**
   * Metadata added to thread
   * @deprecated This field is experimental and subject to breaking changes.
   */
  contextMetadata?: Maybe<Scalars['CollaborationRawContextMetadata']['output']>;
  /**
   * Time the thread was created
   * @deprecated This field is experimental and subject to breaking changes.
   */
  createdAt: Scalars['EpochMilliseconds']['output'];
  /**
   * Creator ID
   * @deprecated This field is experimental and subject to breaking changes.
   */
  creatorId?: Maybe<Scalars['ID']['output']>;
  /**
   * Indicates whether or not the thread was deactivated
   * @deprecated This field is experimental and subject to breaking changes.
   */
  deactivated?: Maybe<Scalars['Boolean']['output']>;
  /**
   * The count of deleted comments
   * @deprecated This field is experimental and subject to breaking changes.
   */
  deletedCommentCount: Scalars['Int']['output'];
  /**
   * Indicate that thread is linked to a external application type
   * @deprecated This field is experimental and subject to breaking changes.
   */
  externalApplicationType?: Maybe<Scalars['String']['output']>;
  /**
   * External Service Connections for a thread
   * @deprecated This field is experimental and subject to breaking changes.
   */
  externalServiceConnections?: Maybe<CollaborationExternalServiceConnectionGroup>;
  /**
   * The ID of the first comment in the thread
   * @deprecated This field is experimental and subject to breaking changes.
   */
  firstCommentId?: Maybe<Scalars['ID']['output']>;
  /**
   * Thread ID
   * @deprecated This field is experimental and subject to breaking changes.
   */
  id: Scalars['ID']['output'];
  /**
   * The latest comment's creator ID
   * @deprecated This field is experimental and subject to breaking changes.
   */
  latestCommentCreatorId?: Maybe<Scalars['ID']['output']>;
  /**
   * The latest comment ID
   * @deprecated This field is experimental and subject to breaking changes.
   */
  latestCommentId?: Maybe<Scalars['ID']['output']>;
  /**
   * The time the latest comment was posted
   * @deprecated This field is experimental and subject to breaking changes.
   */
  latestCommentTime?: Maybe<Scalars['EpochMilliseconds']['output']>;
  /**
   * Time the thread was modified
   * @deprecated This field is experimental and subject to breaking changes.
   */
  modifiedAt: Scalars['EpochMilliseconds']['output'];
  /**
   * Organization ID
   * @deprecated This field is experimental and subject to breaking changes.
   */
  organizationId?: Maybe<Scalars['ID']['output']>;
  /**
   * Reference URL
   * @deprecated This field is experimental and subject to breaking changes.
   */
  referenceUrl?: Maybe<Scalars['String']['output']>;
  /**
   * Defines if the threads is OPEN, CLOSED or ARCHIVED
   * @deprecated This field is experimental and subject to breaking changes.
   */
  status?: Maybe<Scalars['String']['output']>;
  /**
   * Get a specific subscriber
   * @deprecated This field is experimental and subject to breaking changes.
   */
  subscriber?: Maybe<CollaborationSubscriber>;
  /**
   * Get the subscribers for this thread
   * @deprecated This field is experimental and subject to breaking changes.
   */
  subscribers?: Maybe<CollaborationSubscriberConnection>;
};


/** Thread tied to a context */
export type CollaborationThreadCommentArgs = {
  id: Scalars['ID']['input'];
};


/** Thread tied to a context */
export type CollaborationThreadCommentsArgs = {
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** Thread tied to a context */
export type CollaborationThreadExternalServiceConnectionsArgs = {
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** Thread tied to a context */
export type CollaborationThreadSubscriberArgs = {
  id?: InputMaybe<Scalars['ID']['input']>;
};


/** Thread tied to a context */
export type CollaborationThreadSubscribersArgs = {
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

/** Cursor pagination object */
export type CollaborationThreadConnection = {
  __typename?: 'CollaborationThreadConnection';
  /**
   * Array of results
   * @deprecated This field is experimental and subject to breaking changes.
   */
  entities?: Maybe<Array<Maybe<CollaborationThread>>>;
  /**
   * has next page
   * @deprecated This field is experimental and subject to breaking changes.
   */
  hasNextPage?: Maybe<Scalars['Boolean']['output']>;
  /**
   * has previous page
   * @deprecated This field is experimental and subject to breaking changes.
   */
  hasPreviousPage?: Maybe<Scalars['Boolean']['output']>;
  /**
   * Next cursor to paginate by
   * @deprecated This field is experimental and subject to breaking changes.
   */
  nextCursor?: Maybe<Scalars['String']['output']>;
  /**
   * Previous cursor to paginate by
   * @deprecated This field is experimental and subject to breaking changes.
   */
  prevCursor?: Maybe<Scalars['String']['output']>;
  /**
   * Total amount paginatable
   * @deprecated This field is experimental and subject to breaking changes.
   */
  totalCount?: Maybe<Scalars['Int']['output']>;
};

/** Threads count per status */
export type CollaborationThreadsCount = {
  __typename?: 'CollaborationThreadsCount';
  /**
   * Threads count in closed status
   * @deprecated This field is experimental and subject to breaking changes.
   */
  closed?: Maybe<Scalars['Int']['output']>;
  /**
   * Threads count in open status
   * @deprecated This field is experimental and subject to breaking changes.
   */
  open?: Maybe<Scalars['Int']['output']>;
};

/** A group of entities defined by entity search queries and specific GUIDs */
export type CollectionEntity = {
  collection?: Maybe<EntityCollection>;
  guid?: Maybe<Scalars['EntityGuid']['output']>;
};


/** A group of entities defined by entity search queries and specific GUIDs */
export type CollectionEntityCollectionArgs = {
  name: Scalars['String']['input'];
};

export type CommerceAccountStitchedFields = {
  __typename?: 'CommerceAccountStitchedFields';
  /** Returns current pool balance for APoF accounts */
  annualPool?: Maybe<CommerceAnnualPool>;
  /** Returns billing info for the account including contact and address info */
  billingInfo?: Maybe<CommerceBillingInfo>;
  /** Returns current dunning status metadata */
  dunningMetadata?: Maybe<CommerceDunningMetadata>;
  /** Returns currently purchasable offers, with parameters for filtering */
  eligibleOffers?: Maybe<Array<Maybe<CommerceOffer>>>;
  /** Returns all invoices */
  invoices?: Maybe<Array<Maybe<CommerceInvoice>>>;
  /** Returns auth- and request-related values needed to render payment information update IFrames */
  paymentFormEmbedInfo?: Maybe<CommercePaymentFormEmbedInfo>;
  /** Returns default CREDIT CARD pay method information (does not apply for other pay method types) */
  paymentInfo?: Maybe<CommercePaymentInfo>;
  /** Returns default payment method type */
  paymentType?: Maybe<CommercePaymentType>;
  /** Returns subscriptions with presently active products for an account */
  subscriptions?: Maybe<Array<Maybe<CommerceBillingSubscription>>>;
  /** Return list of valid addresses given an address */
  validatedAddresses?: Maybe<CommerceValidatedAddressesResult>;
};


export type CommerceAccountStitchedFieldsPaymentFormEmbedInfoArgs = {
  location: CommerceLocation;
};


export type CommerceAccountStitchedFieldsValidatedAddressesArgs = {
  address: CommerceAddressInput;
};

/** Basic address fields */
export type CommerceAddress = {
  __typename?: 'CommerceAddress';
  /** Building number and street name, in mixed case. e.g 188 Spear Street */
  address1?: Maybe<Scalars['String']['output']>;
  /** Returns additional info for address, in mixed case. e.g St 1000 */
  address2?: Maybe<Scalars['String']['output']>;
  /** Returns city, in mixed case. e.g San Francisco */
  city?: Maybe<Scalars['String']['output']>;
  /** Returns abbreviated country code, e.g US */
  country?: Maybe<Scalars['String']['output']>;
  /** Returns an extended postal code if applicable, e.g 94105-0000 */
  postalCode?: Maybe<Scalars['String']['output']>;
  /**
   * Returns the abbreviated state, e.g CA.
   * For the US region, this is any valid state. For non-US regions, this can be a region such as a province.
   */
  state?: Maybe<Scalars['String']['output']>;
};

/** Maps errors to a specific input field and provides a reason */
export type CommerceAddressError = {
  __typename?: 'CommerceAddressError';
  /** Refers to the address field with an error */
  field?: Maybe<CommerceAddressField>;
  /** Reason for the error on the address field */
  message?: Maybe<Scalars['String']['output']>;
};

/** Contains address errors */
export type CommerceAddressErrors = {
  __typename?: 'CommerceAddressErrors';
  /** List of address errors */
  errors?: Maybe<Array<Maybe<CommerceAddressError>>>;
};

/** Refers to an address field */
export enum CommerceAddressField {
  /** Refers to a generic error on the address that could not be attributed to a specific field */
  Address = 'ADDRESS',
  /** Refers to address1 */
  Address1 = 'ADDRESS1',
  /** Refers to address2 */
  Address2 = 'ADDRESS2',
  /** Refers to city, province, etc. */
  City = 'CITY',
  /** Refers to country */
  Country = 'COUNTRY',
  /** Refers to postal code */
  PostalCode = 'POSTAL_CODE',
  /** Refers to state or region */
  State = 'STATE'
}

/** Basic address fields input. Fields can be extended, hyphenated, or shortened versions of the value. The API will attempt to validate any inputs. */
export type CommerceAddressInput = {
  /** Building number and street name. e.g 188 Spear Street */
  address1?: InputMaybe<Scalars['String']['input']>;
  /** Additional address info, such as suite, apt, unit number. e.g Suite 1000 */
  address2?: InputMaybe<Scalars['String']['input']>;
  /** e.g San Francisco */
  city?: InputMaybe<Scalars['String']['input']>;
  /** e.g United States, or US */
  country?: InputMaybe<Scalars['String']['input']>;
  /** Any valid postal code which may also be an extended postal code. e.g 94105, or 94105-0000 */
  postalCode?: InputMaybe<Scalars['String']['input']>;
  /** For the US region, this is any valid state. For non-US regions, this can be a region such as a province. */
  state?: InputMaybe<Scalars['String']['input']>;
};

/** Contains validated addresses */
export type CommerceAddresses = {
  __typename?: 'CommerceAddresses';
  /** List of validated addresses */
  addresses?: Maybe<Array<Maybe<CommerceAddress>>>;
};

/** Information about annual pool balance */
export type CommerceAnnualPool = {
  __typename?: 'CommerceAnnualPool';
  /** The remaining balance from the total */
  balance?: Maybe<Scalars['String']['output']>;
  /** The start date of the subscription */
  contractStartDate?: Maybe<Scalars['Date']['output']>;
  /** The remaining prepaid balance */
  prepaidBalance?: Maybe<Scalars['String']['output']>;
  /** The total prepaid amount */
  prepaidTotal?: Maybe<Scalars['String']['output']>;
  /** The total annual commitment amount */
  total?: Maybe<Scalars['String']['output']>;
};

/** The base offer pricing information included in all other pricing types */
export type CommerceBaseOfferPricing = {
  /** How the product is priced */
  pricingModel?: Maybe<CommercePricingModel>;
  /** The pricing name */
  pricingName?: Maybe<Scalars['String']['output']>;
  /** How the product is billed */
  pricingType?: Maybe<CommercePricingType>;
};

/** The base pricing information included in all other pricing types */
export type CommerceBasePricing = {
  /** When the pricing ends within the subscription - for most configurations, this aligns with the subscription end date. In ISO8601 format: YYYY-MM-DD */
  endDate?: Maybe<Scalars['Date']['output']>;
  /** How the product is priced */
  pricingModel?: Maybe<CommercePricingModel>;
  /** The pricing name */
  pricingName?: Maybe<Scalars['String']['output']>;
  /** How the product is billed */
  pricingType?: Maybe<CommercePricingType>;
  /** When the pricing starts within the subscription - for most configurations, this aligns with the subscription start date. In ISO8601 format: YYYY-MM-DD */
  startDate?: Maybe<Scalars['Date']['output']>;
};

/** How often the customer should be billed */
export enum CommerceBillingCycle {
  /** Annual billing frequency */
  Annual = 'ANNUAL',
  /** Monthly billing frequency */
  Monthly = 'MONTHLY'
}

/** Customer billing info */
export type CommerceBillingInfo = {
  __typename?: 'CommerceBillingInfo';
  /** Billing address for the customer */
  billToAddress?: Maybe<CommerceAddress>;
  /** Billing contact info for the customer */
  billToContact?: Maybe<CommerceContactInfo>;
  /** Tax info for customers */
  taxInfo?: Maybe<CommerceTaxInfo>;
};

/** Customer billing info */
export type CommerceBillingInfoInput = {
  /** Billing address for the customer */
  billToAddress?: InputMaybe<CommerceAddressInput>;
  /** Billing contact info for the customer */
  billToContact?: InputMaybe<CommerceContactInfoInput>;
  /** Tax info for customers */
  taxInfo?: InputMaybe<CommerceTaxInfoInput>;
};

/** The subscription for a customer. Only currently active subscriptions will be returned. */
export type CommerceBillingSubscription = {
  __typename?: 'CommerceBillingSubscription';
  /** List of subscription products and commitment data */
  commitments?: Maybe<Array<Maybe<CommerceCommitment>>>;
  /** The end date of the subscription in ISO8601 format: YYYY-MM-DD */
  endDate?: Maybe<Scalars['Date']['output']>;
  /** Subscription ID */
  id?: Maybe<Scalars['ID']['output']>;
  /** The start date of the subscription in ISO8601 format: YYYY-MM-DD */
  startDate?: Maybe<Scalars['Date']['output']>;
  /** The status of the subscription */
  status?: Maybe<CommerceSubscriptionStatus>;
  /** Term of the subscriptions - either monthly or termed */
  term?: Maybe<CommerceSubscriptionTerm>;
  /** The type of the subscription's term, either termed or evergreen (un-termed) */
  termType?: Maybe<CommerceSubscriptionTermType>;
  /** Category of the subscription. Will categorize self-serve configurations. All other plan configurations will be designated as OTHER */
  type?: Maybe<CommerceSubscriptionType>;
};

/** A pre or post purchased offer's buying program */
export enum CommerceBuyingProgram {
  /** Annual pool of funds plan */
  Apof = 'APOF',
  /** Legacy subscriptions for individual products (non-consumption based) */
  Legacy = 'LEGACY',
  /** Pay as you go plan */
  Payg = 'PAYG',
  /** Savings plan */
  Savings = 'SAVINGS',
  /** Site license plan */
  SiteLicense = 'SITE_LICENSE',
  /** Volume plan */
  Volume = 'VOLUME'
}

/** Indicates that the attempt to cancel a subscription succeeded. */
export type CommerceCancelConfirmation = {
  __typename?: 'CommerceCancelConfirmation';
  /** Confirmation id. */
  id: Scalars['String']['output'];
};

/** Indicates that the attempt to cancel a subscription failed. */
export type CommerceCancelFailure = {
  __typename?: 'CommerceCancelFailure';
  /** The reasons for the failure. */
  reasons?: Maybe<Array<Maybe<CommerceValidationFailure>>>;
};

/** Indicates whether the attempt to cancel a subscription resulted in success or failure. */
export type CommerceCancelResult = CommerceCancelConfirmation | CommerceCancelFailure;

/** Credit card types */
export enum CommerceCardTypes {
  /** For American Express credit cards */
  Americanexpress = 'AMERICANEXPRESS',
  /** For Discover credit cards */
  Discover = 'DISCOVER',
  /** For MasterCard credit cards */
  Mastercard = 'MASTERCARD',
  /** For Visa credit cards */
  Visa = 'VISA'
}

/** Category for for a pre or post purchase offer */
export enum CommerceCategory {
  /** Add-on */
  Addon = 'ADDON',
  /** Plan (e.g. PAYG) */
  Plan = 'PLAN',
  /** Promotional offer */
  Promo = 'PROMO',
  /** Trial */
  Trial = 'TRIAL'
}

/** Sales channel associated with the offer */
export enum CommerceChannel {
  /** Sales led */
  SalesLed = 'SALES_LED',
  /** Self serve */
  SelfServe = 'SELF_SERVE'
}

/** A subscription's product and commitment data */
export type CommerceCommitment = {
  __typename?: 'CommerceCommitment';
  /** The pricing costs associated with the product, specific to this commitment. i.e pricing can be different than the list price of the product */
  chargedPrices?: Maybe<Array<Maybe<CommercePricing>>>;
  /** A commitment ID */
  id?: Maybe<Scalars['ID']['output']>;
  /** The product name relating to the commitment */
  productName?: Maybe<Scalars['String']['output']>;
  /** Represents status of the commitment as it relates to change updates */
  status?: Maybe<CommerceCommitmentStatus>;
};

/** Status of commitment */
export enum CommerceCommitmentStatus {
  /** All commitment charges are current */
  Current = 'CURRENT',
  /** Some commitment charge is pending removal */
  PendingCancel = 'PENDING_CANCEL',
  /** Some commitment charge is pending change */
  PendingChange = 'PENDING_CHANGE',
  /** Some commitment charge is pending start */
  PendingStart = 'PENDING_START'
}

/** Customer billing contact info */
export type CommerceContactInfo = {
  __typename?: 'CommerceContactInfo';
  /** Billing contact CC emails */
  ccEmails?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
  /** Billing company name */
  companyName?: Maybe<Scalars['String']['output']>;
  /** Billing contact email */
  email?: Maybe<Scalars['String']['output']>;
  /** Billing contact first name */
  firstName?: Maybe<Scalars['String']['output']>;
  /** Billing contact last name */
  lastName?: Maybe<Scalars['String']['output']>;
};

/** Customer billing contact info */
export type CommerceContactInfoInput = {
  /** Billing contact CC emails */
  ccEmails?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  /** Billing company name */
  companyName?: InputMaybe<Scalars['String']['input']>;
  /** Billing contact email */
  email?: InputMaybe<Scalars['String']['input']>;
  /** Billing contact first name */
  firstName?: InputMaybe<Scalars['String']['input']>;
  /** Billing contact last name */
  lastName?: InputMaybe<Scalars['String']['input']>;
};

/** Discount pricing information */
export type CommerceDiscountOfferPricing = CommerceBaseOfferPricing & {
  __typename?: 'CommerceDiscountOfferPricing';
  /** The discount price, will be a positive value */
  discount?: Maybe<Scalars['Float']['output']>;
  /** How the product is priced */
  pricingModel?: Maybe<CommercePricingModel>;
  /** The pricing name */
  pricingName?: Maybe<Scalars['String']['output']>;
  /** How the product is billed */
  pricingType?: Maybe<CommercePricingType>;
};

/** Discount pricing information */
export type CommerceDiscountPricing = CommerceBaseOfferPricing & CommerceBasePricing & {
  __typename?: 'CommerceDiscountPricing';
  /** The discount price, will be a positive value */
  discount?: Maybe<Scalars['Float']['output']>;
  /** When the pricing ends within the subscription - for base plan configurations, this aligns with the subscription end date. In ISO8601 format: YYYY-MM-DD */
  endDate?: Maybe<Scalars['Date']['output']>;
  /** How the product is priced */
  pricingModel?: Maybe<CommercePricingModel>;
  /** The pricing name */
  pricingName?: Maybe<Scalars['String']['output']>;
  /** How the product is billed */
  pricingType?: Maybe<CommercePricingType>;
  /** When the pricing starts within the subscription - for base plan configurations, this aligns with the subscription start date. In ISO8601 format: YYYY-MM-DD */
  startDate?: Maybe<Scalars['Date']['output']>;
};

/** Metadata related to an account's dunning status */
export type CommerceDunningMetadata = {
  __typename?: 'CommerceDunningMetadata';
  /** Manually set custom date for when a dunning account will become suspended, instead of the default 15 days after invoice. */
  extendedGraceDate?: Maybe<Scalars['Date']['output']>;
  /** When an already suspended account's subscriptions will be cancelled and open invoices written off. */
  writeOffDate?: Maybe<Scalars['Date']['output']>;
};

/** Free pricing information - this will apply to free products */
export type CommerceFreeOfferPricing = CommerceBaseOfferPricing & {
  __typename?: 'CommerceFreeOfferPricing';
  /** How the product is priced */
  pricingModel?: Maybe<CommercePricingModel>;
  /** The pricing name */
  pricingName?: Maybe<Scalars['String']['output']>;
  /** How the product is billed */
  pricingType?: Maybe<CommercePricingType>;
  /** Unit of measurement for what's being priced */
  uom?: Maybe<Scalars['String']['output']>;
};

/** Free pricing information - this will apply to free products */
export type CommerceFreePricing = CommerceBaseOfferPricing & CommerceBasePricing & {
  __typename?: 'CommerceFreePricing';
  /** When the pricing ends within the subscription - for base plan configurations, this aligns with the subscription end date. In ISO8601 format: YYYY-MM-DD */
  endDate?: Maybe<Scalars['Date']['output']>;
  /** How the product is priced */
  pricingModel?: Maybe<CommercePricingModel>;
  /** The pricing name */
  pricingName?: Maybe<Scalars['String']['output']>;
  /** How the product is billed */
  pricingType?: Maybe<CommercePricingType>;
  /** When the pricing starts within the subscription - for base plan configurations, this aligns with the subscription start date. In ISO8601 format: YYYY-MM-DD */
  startDate?: Maybe<Scalars['Date']['output']>;
  /** Unit of measurement for what's being priced */
  uom?: Maybe<Scalars['String']['output']>;
};

/** Indicates there is no valid offer for the provided id. */
export type CommerceInvalidOffer = {
  __typename?: 'CommerceInvalidOffer';
  /** A human readable message. */
  message: Scalars['String']['output'];
};

/** Indicates the client provided an invalid offer id. */
export type CommerceInvalidOption = {
  __typename?: 'CommerceInvalidOption';
  /** A human readable message. */
  message: Scalars['String']['output'];
};

/** An invoice */
export type CommerceInvoice = {
  __typename?: 'CommerceInvoice';
  /** The total amount of money required to fully pay said invoice */
  amount?: Maybe<Scalars['Float']['output']>;
  /** The remaining amount not yet paid */
  balance?: Maybe<Scalars['Float']['output']>;
  /** The date the invoice was issued yyyy-MM-dd */
  date?: Maybe<Scalars['Date']['output']>;
  /** Download link for the invoice PDF. Clicking the link will initiate a download in the browser. */
  downloadLink?: Maybe<Scalars['String']['output']>;
  /** A Zuora reference ID */
  id?: Maybe<Scalars['ID']['output']>;
  /** A Zuora reference number */
  number?: Maybe<Scalars['String']['output']>;
  /** Either PAID, UNPAID or PAST_DUE */
  status?: Maybe<CommerceInvoiceStatus>;
};

/** The payment and overdue status of an invoice */
export enum CommerceInvoiceStatus {
  /** The invoice has been paid in full */
  Paid = 'PAID',
  /** The invoice has not been paid in full and is past due */
  PastDue = 'PAST_DUE',
  /** The invoice has not been paid in full but is not yet past due */
  Unpaid = 'UNPAID'
}

/** A single key-value pair detailing one of the causes of a validation failure. */
export type CommerceKeyValueValidationFailureDetails = {
  __typename?: 'CommerceKeyValueValidationFailureDetails';
  /** A key identifying the cause of the validation failure. */
  key: Scalars['String']['output'];
  /** A human-readable string detailing the cause of the validation failure. */
  value?: Maybe<Scalars['String']['output']>;
};

/** A location within the New Relic UI */
export enum CommerceLocation {
  /** Credit card details - dark theme */
  CcDetailsDarkTheme = 'CC_DETAILS_DARK_THEME',
  /** Credit card details - light theme */
  CcDetailsLightTheme = 'CC_DETAILS_LIGHT_THEME',
  /** Credit card details - dark theme - dev environment only (will not work in production) */
  DevCcDetailsDarkTheme = 'DEV_CC_DETAILS_DARK_THEME',
  /** Credit card details - light theme - dev environment only (will not work in production) */
  DevCcDetailsLightTheme = 'DEV_CC_DETAILS_LIGHT_THEME'
}

/** String key value pair used for arbitrary data, similar to a map */
export type CommerceMetadataMap = {
  __typename?: 'CommerceMetadataMap';
  /** Key of map */
  key: Scalars['String']['output'];
  /** Value of map */
  value?: Maybe<Scalars['String']['output']>;
};

export type CommerceNotificationsAccountStitchedFields = {
  __typename?: 'CommerceNotificationsAccountStitchedFields';
  /** A list of zero or more banners to display. */
  banners?: Maybe<Array<Maybe<CommerceNotificationsBanner>>>;
  /** A list of zero or more applicable CTAs for the account. */
  ctas?: Maybe<Array<Maybe<CommerceNotificationsCta>>>;
  /** The full screen paywall to display, if any. */
  paywall?: Maybe<CommerceNotificationsPaywall>;
};

/** A notification implemented as a banner. */
export type CommerceNotificationsBanner = {
  __typename?: 'CommerceNotificationsBanner';
  /** The primary identifier for a given banner. */
  id: Scalars['String']['output'];
};

/** A notification implemented as a CTA ("call to action"). */
export type CommerceNotificationsCta = {
  __typename?: 'CommerceNotificationsCta';
  /** The primary identifier for a given CTA. */
  id: Scalars['String']['output'];
};

/** Details about the mute. */
export type CommerceNotificationsMute = {
  __typename?: 'CommerceNotificationsMute';
  /** Expire time in UTC. */
  expires: Scalars['DateTime']['output'];
};

/** The result of request to mute a notification. */
export type CommerceNotificationsMuteNotificationResult = CommerceNotificationsMuted | CommerceNotificationsNotMuted;

/** We muted the notification. */
export type CommerceNotificationsMuted = {
  __typename?: 'CommerceNotificationsMuted';
  /** A description of the successful mute request. */
  mute: CommerceNotificationsMute;
};

/** We did not mute the notification. */
export type CommerceNotificationsNotMuted = {
  __typename?: 'CommerceNotificationsNotMuted';
  /** A message indicating the reason why we didn't accept the request. */
  reason: Scalars['String']['output'];
};

/** There are a handful of notification types supported. */
export enum CommerceNotificationsNotificationType {
  /** A top-of-screen notification. */
  Banner = 'BANNER',
  /** A "call to action", e.g. a prompt, button, or sales-related information to display. */
  Cta = 'CTA',
  /** A full-page notification. */
  Paywall = 'PAYWALL'
}

/** A notification implemented as a full screen takeover. */
export type CommerceNotificationsPaywall = {
  __typename?: 'CommerceNotificationsPaywall';
  /** The primary identifier for a given paywall. */
  id: Scalars['String']['output'];
  /** Indicates how a paywall should behave. */
  type: CommerceNotificationsPaywallType;
};

/** Indicates how a given paywall should behave. */
export enum CommerceNotificationsPaywallType {
  /** Can be dismissed by the user (i.e a warning). */
  Dismissible = 'DISMISSIBLE',
  /** Can NOT be dismissed by the user (i.e a full lockout). */
  NonDismissible = 'NON_DISMISSIBLE'
}

/** A pre-purchased offer that will be presented to the customer for sale. An offer typically a bundle of products */
export type CommerceOffer = {
  __typename?: 'CommerceOffer';
  /** Buying program for offer */
  buyingProgram: CommerceBuyingProgram;
  /** List of sales channels */
  channels: Array<Maybe<CommerceChannel>>;
  /** Internal identifier of individual offer */
  id: Scalars['String']['output'];
  /** Arbitrary map of metadata associated with offer */
  metadata: Array<Maybe<CommerceMetadataMap>>;
  /** Human readable name of individual offer */
  name: Scalars['String']['output'];
  /** Products included in offer */
  pricedProducts: Array<Maybe<CommercePricedProduct>>;
  /** Offer product level */
  productLevel?: Maybe<CommerceProductLevel>;
  /** Type of offer */
  type: CommerceOfferType;
};

/** Pricing types that come with offers */
export type CommerceOfferPricing = CommerceDiscountOfferPricing | CommerceFreeOfferPricing | CommerceStandardOfferPricing | CommerceTieredOfferPricing;

/** Type of offer */
export type CommerceOfferType = {
  __typename?: 'CommerceOfferType';
  /** Category for for a pre or post purchase offer */
  category?: Maybe<CommerceCategory>;
  /** Offer type identifier */
  id: Scalars['String']['output'];
  /** Name of type */
  name?: Maybe<Scalars['String']['output']>;
};

/** Additional extra options to adjust the available offer */
export type CommerceOptionsInput = {
  /** Additional days of data retention to include when purchasing certain offers (e.g. Data Plus); will be rounded to the nearest multiple of 30 */
  additionalDaysRetention?: InputMaybe<Scalars['Int']['input']>;
  /** How often the customer should be billed */
  billingCycle?: InputMaybe<CommerceBillingCycle>;
  /** User selected custom amount of extra pool limit */
  extraPool?: InputMaybe<Scalars['Int']['input']>;
  /** Commitment term length in years */
  termLength?: InputMaybe<Scalars['Int']['input']>;
  /** Amount in dollars to be replenished when pool of funds is depleted */
  topUpAmount?: InputMaybe<Scalars['Int']['input']>;
};

/** A token, a signature, and various pieces of request metadata needed to render a Zuora IFrame */
export type CommercePaymentFormEmbedInfo = {
  __typename?: 'CommercePaymentFormEmbedInfo';
  /** The New Relic account's corresponding ID within the billing/payment system */
  accountKey?: Maybe<Scalars['String']['output']>;
  /** An RSA key */
  key?: Maybe<Scalars['String']['output']>;
  /** The page id of the IFrame to be rendered */
  pageId?: Maybe<Scalars['String']['output']>;
  /** An RSA signature */
  signature?: Maybe<Scalars['String']['output']>;
  /** The tenant ID (external) */
  tenantId?: Maybe<Scalars['String']['output']>;
  /** An RSA token for rendering a payment info IFrame */
  token?: Maybe<Scalars['SecureValue']['output']>;
  /** The IFrame source's URI (where it's hosted) */
  uri?: Maybe<Scalars['String']['output']>;
};

/** Credit card payment information */
export type CommercePaymentInfo = {
  __typename?: 'CommercePaymentInfo';
  /** Full name of the credit card owner */
  cardHolderName?: Maybe<Scalars['String']['output']>;
  /** Credit card type */
  cardType?: Maybe<CommerceCardTypes>;
  /** Last 4 digits of the credit card */
  ccNumberLastFour?: Maybe<Scalars['String']['output']>;
  /** 1 or 2 digit expiration month of the credit card e.g '1', '10' */
  expirationMonth?: Maybe<Scalars['String']['output']>;
  /** 4 digit expiration year of the credit card e.g '2022' */
  expirationYear?: Maybe<Scalars['String']['output']>;
};

/** Type of payment method. The default is CREDIT_CARD for new accounts, regardless of if there is a payment on file. */
export enum CommercePaymentType {
  /** For automated clearing house (ACH) payment type */
  Ach = 'ACH',
  /** For credit card payment type */
  CreditCard = 'CREDIT_CARD',
  /** for debit card payment type */
  DebitCard = 'DEBIT_CARD',
  /** For all other payment types */
  Other = 'OTHER',
  /** For paypal payment type */
  Paypal = 'PAYPAL'
}

/** An individual product that may be included as part of a pre or post purchased offer */
export type CommercePricedProduct = {
  __typename?: 'CommercePricedProduct';
  /** Arbitrary map of metadata associated with product */
  metadata: Array<Maybe<CommerceMetadataMap>>;
  /** Human readable name of individual priced product */
  name: Scalars['String']['output'];
  /** Pricing info for product */
  prices: Array<Maybe<CommerceOfferPricing>>;
  /** Product line associated with product */
  productLine: CommerceProductLine;
  /** Specific region for product */
  region?: Maybe<CommerceRegion>;
};

/** Pricing types that come with commitments */
export type CommercePricing = CommerceDiscountPricing | CommerceFreePricing | CommerceStandardPricing | CommerceTieredPricing;

/** How a product charge is priced */
export enum CommercePricingModel {
  /** Discount - charges that are discounts */
  Discount = 'DISCOUNT',
  /** Flat fee - charges that have a flat price, regardless of the quantity purchased */
  FlatFee = 'FLAT_FEE',
  /** Per unit - charges that are priced per unit of product purchased */
  PerUnit = 'PER_UNIT',
  /** Tiered - charges that are priced based on tiered pricing */
  Tiered = 'TIERED',
  /** Volume - charges that are priced based on volume of products purchased */
  Volume = 'VOLUME'
}

/** Pricing tier information */
export type CommercePricingTier = {
  __typename?: 'CommercePricingTier';
  /** The ending quantity at which this tier configuration takes effect. A null value indicates that this tier configuration will take effect up to any quantity purchased within this tier */
  endUnit?: Maybe<Scalars['Float']['output']>;
  /** Price applied in this tier, depending on the price format */
  price?: Maybe<Scalars['Float']['output']>;
  /** Price format for this tier */
  priceFormat?: Maybe<Scalars['String']['output']>;
  /** The starting quantity at which this tier configuration takes effect */
  startUnit?: Maybe<Scalars['Float']['output']>;
  /** Indicates the tier level - starts at 1 for the tier with the lowest startUnit */
  tier?: Maybe<Scalars['Int']['output']>;
};

/** How a product charge is billed */
export enum CommercePricingType {
  /** One-time pricing - charges with this pricing will only be charged once */
  OneTime = 'ONE_TIME',
  /** Recurring pricing - charges with this pricing will be charged every bill cycle */
  Recurring = 'RECURRING',
  /** Usage pricing - applies to most products */
  Usage = 'USAGE'
}

/** Level of product */
export enum CommerceProductLevel {
  /** Enterprise level of product */
  Enterprise = 'ENTERPRISE',
  /** Free level of product */
  Free = 'FREE',
  /** Pro level of product */
  Pro = 'PRO',
  /** Standard level of product */
  Standard = 'STANDARD'
}

/** Product line for specific product that is part of pre or post-purchase Offer */
export enum CommerceProductLine {
  /** Alerts & Intelligence */
  Ai = 'AI',
  /** APM */
  Apm = 'APM',
  /** Browser monitoring */
  Browser = 'BROWSER',
  /** Compute */
  Compute = 'COMPUTE',
  /** Data consumption */
  Data = 'DATA',
  /** Finance */
  Finance = 'FINANCE',
  /** Infrastructure */
  Infrastructure = 'INFRASTRUCTURE',
  /** Insights */
  Insights = 'INSIGHTS',
  /** Logs */
  Logs = 'LOGS',
  /** Metrics */
  Metrics = 'METRICS',
  /** Mobile */
  Mobile = 'MOBILE',
  /** Other */
  Other = 'OTHER',
  /** Scanned events */
  ScannedEvents = 'SCANNED_EVENTS',
  /** Serverless */
  Serverless = 'SERVERLESS',
  /** Synthetics */
  Synthetics = 'SYNTHETICS',
  /** Traces */
  Traces = 'TRACES',
  /** Provisioned users */
  Users = 'USERS'
}

/** Indicates that the attempt to purchase an offer succeeded. */
export type CommercePurchaseConfirmation = {
  __typename?: 'CommercePurchaseConfirmation';
  /** Confirmation id. */
  id: Scalars['String']['output'];
};

/** Indicates that the attempt to purchase an offer failed. */
export type CommercePurchaseFailure = {
  __typename?: 'CommercePurchaseFailure';
  /** The reasons for the failure. */
  reasons?: Maybe<Array<Maybe<CommercePurchaseFailureReason>>>;
};

/** A set of possible reasons the attempt to purchase failed. */
export type CommercePurchaseFailureReason = CommerceInvalidOffer | CommerceInvalidOption | CommerceValidationFailure;

/** Indicates whether the attempt to purchase an offer resulted in success or failure. */
export type CommercePurchaseResult = CommercePurchaseConfirmation | CommercePurchaseFailure;

/** Region associated with product */
export enum CommerceRegion {
  /** European Union countries */
  Eu = 'EU',
  /** United States */
  Us = 'US'
}

/** Standard pricing information - this will apply to most products */
export type CommerceStandardOfferPricing = CommerceBaseOfferPricing & {
  __typename?: 'CommerceStandardOfferPricing';
  /** The price of a unit */
  price?: Maybe<Scalars['Float']['output']>;
  /** How the product is priced */
  pricingModel?: Maybe<CommercePricingModel>;
  /** The pricing name */
  pricingName?: Maybe<Scalars['String']['output']>;
  /** How the product is billed */
  pricingType?: Maybe<CommercePricingType>;
  /** Unit of measurement for what's being priced */
  uom?: Maybe<Scalars['String']['output']>;
};

/** Standard pricing information - this will apply to most products */
export type CommerceStandardPricing = CommerceBaseOfferPricing & CommerceBasePricing & {
  __typename?: 'CommerceStandardPricing';
  /** Next charge date (for post-paid subscriptions only) */
  chargedThroughDate?: Maybe<Scalars['Date']['output']>;
  /** When the pricing ends within the subscription - for base plan configurations, this aligns with the subscription end date. In ISO8601 format: YYYY-MM-DD */
  endDate?: Maybe<Scalars['Date']['output']>;
  /** The price of a unit */
  price?: Maybe<Scalars['Float']['output']>;
  /** How the product is priced */
  pricingModel?: Maybe<CommercePricingModel>;
  /** The pricing name */
  pricingName?: Maybe<Scalars['String']['output']>;
  /** How the product is billed */
  pricingType?: Maybe<CommercePricingType>;
  /** The number of units purchased, relevant for non-consumption based products (e.g. APM, Browser, etc.) */
  quantity?: Maybe<Scalars['Float']['output']>;
  /** When the pricing starts within the subscription - for base plan configurations, this aligns with the subscription start date. In ISO8601 format: YYYY-MM-DD */
  startDate?: Maybe<Scalars['Date']['output']>;
  /** Unit of measurement for what's being priced */
  uom?: Maybe<Scalars['String']['output']>;
};

/** State of a subscription */
export enum CommerceSubscriptionStatus {
  /** Indicates an active subscription */
  Active = 'ACTIVE',
  /** Indicates a cancelled subscription. These subscriptions will only be returned if the subscription cancel date is in the future */
  Cancelled = 'CANCELLED'
}

/** Term of a subscription */
export enum CommerceSubscriptionTerm {
  /** Indicates a subscription with a 1-year term */
  Annual = 'ANNUAL',
  /** An ongoing subscription, with no end date */
  Monthly = 'MONTHLY',
  /** Indicates a subscription which is not monthly (ongoing with no end date) or annual (1-year term) */
  Other = 'OTHER',
  /** A limited subscription */
  Termed = 'TERMED'
}

/** The type of term associated with a subscription */
export enum CommerceSubscriptionTermType {
  /** Indicates an un-termed subscription */
  Evergreen = 'EVERGREEN',
  /** Indicates a termed subscription */
  Termed = 'TERMED'
}

/** Type of a subscription for identification purposes */
export enum CommerceSubscriptionType {
  /** Denotes the subscription as being an enterprise tier, annual subscription */
  EnterpriseApof = 'ENTERPRISE_APOF',
  /** Denotes the subscription as being an enterprise tier, monthly subscription */
  EnterprisePayg = 'ENTERPRISE_PAYG',
  /** Denotes the subscription as being an enterprise tier, savings subscription */
  EnterpriseSavings = 'ENTERPRISE_SAVINGS',
  /** Denotes the subscription as being an enterprise tier, volume subscription */
  EnterpriseVolume = 'ENTERPRISE_VOLUME',
  /** Denotes the subscription as being a free tier, monthly subscription */
  FreePayg = 'FREE_PAYG',
  /** Denotes the subscription as being a subscription with post-paid products */
  Legacy = 'LEGACY',
  /** Denotes the subscription as being anything other than the self-serve configurations */
  Other = 'OTHER',
  /** Denotes the subscription as being a pro tier, annual subscription */
  ProApof = 'PRO_APOF',
  /** Denotes the subscription as being a pro tier, monthly subscription */
  ProPayg = 'PRO_PAYG',
  /** Denotes the subscription as being a pro tier, savings subscription */
  ProSavings = 'PRO_SAVINGS',
  /** Denotes the subscription as being a pro tier, volume subscription */
  ProVolume = 'PRO_VOLUME',
  /** Denotes the subscription as being a standard tier, monthly subscription */
  StandardPayg = 'STANDARD_PAYG'
}

/** Customer tax info */
export type CommerceTaxInfo = {
  __typename?: 'CommerceTaxInfo';
  /** VAT Id for customers, usually EU customers */
  vatId?: Maybe<Scalars['String']['output']>;
  /** VAT status for customers, usually EU customers */
  vatStatus?: Maybe<CommerceVatStatus>;
};

/** Customer tax info */
export type CommerceTaxInfoInput = {
  /** VAT Id for customers, usually EU customers */
  vatId?: InputMaybe<Scalars['String']['input']>;
  /** VAT status for customers, usually EU customers */
  vatStatus?: InputMaybe<CommerceVatStatus>;
};

/** Tiered pricing information */
export type CommerceTieredOfferPricing = CommerceBaseOfferPricing & {
  __typename?: 'CommerceTieredOfferPricing';
  /** How the product is priced */
  pricingModel?: Maybe<CommercePricingModel>;
  /** The pricing name */
  pricingName?: Maybe<Scalars['String']['output']>;
  /** How the product is billed */
  pricingType?: Maybe<CommercePricingType>;
  /** List of tiers associated with this pricing type */
  tiers?: Maybe<Array<Maybe<CommercePricingTier>>>;
  /** Unit of measurement for what's being priced */
  uom?: Maybe<Scalars['String']['output']>;
};

/** Tiered pricing information */
export type CommerceTieredPricing = CommerceBaseOfferPricing & CommerceBasePricing & {
  __typename?: 'CommerceTieredPricing';
  /** When the pricing ends within the subscription - for most configurations, this aligns with the subscription end date. In ISO8601 format: YYYY-MM-DD */
  endDate?: Maybe<Scalars['Date']['output']>;
  /** How the product is priced */
  pricingModel?: Maybe<CommercePricingModel>;
  /** The pricing name */
  pricingName?: Maybe<Scalars['String']['output']>;
  /** How the product is billed */
  pricingType?: Maybe<CommercePricingType>;
  /** When the pricing starts within the subscription - for most configurations, this aligns with the subscription start date. In ISO8601 format: YYYY-MM-DD */
  startDate?: Maybe<Scalars['Date']['output']>;
  /** List of tiers associated with this pricing type */
  tiers?: Maybe<Array<Maybe<CommercePricingTier>>>;
  /** Unit of measurement for what's being priced */
  uom?: Maybe<Scalars['String']['output']>;
};

/** Will either return addresses or addressable errors */
export type CommerceValidatedAddressesResult = CommerceAddressErrors | CommerceAddresses;

/** Indicates that one or more validation checks failed (e.g. payment info expired). */
export type CommerceValidationFailure = {
  __typename?: 'CommerceValidationFailure';
  /** An error code indicating the particular validation failure which occurred. */
  code: Scalars['String']['output'];
  /** An optional list of key-value pairs which provide additional details about the cause of the validation failure. */
  details?: Maybe<Array<Maybe<CommerceKeyValueValidationFailureDetails>>>;
  /** A human-readable message detailing the cause of the validation failure. */
  message: Scalars['String']['output'];
};

/** VAT Status options */
export enum CommerceVatStatus {
  /** Business VAT status */
  Business = 'BUSINESS',
  /** Business with no VAT ID status */
  BusinessNoVatId = 'BUSINESS_NO_VAT_ID',
  /** Government or non-profit VAT status */
  GovtOrNonProfit = 'GOVT_OR_NON_PROFIT',
  /** Personal VAT status */
  Personal = 'PERSONAL'
}

export type Consumption = {
  __typename?: 'Consumption';
  /** The list of accounts that have ingest for a given organization id and specific duration. */
  accounts?: Maybe<ProductRatingV2IngestAccountsResultV2>;
  /** The `Consumption` object provides consumption data about a user. */
  customerId?: Maybe<Scalars['ID']['output']>;
  /** The list of organizations that have ingest for a given customer id and specific duration. */
  organizations?: Maybe<ProductRatingV2IngestOrganizationsResult>;
  /** This field provides access to UserConsumption data. */
  userConsumption?: Maybe<UserConsumptionConsumptionStitchedFields>;
};


export type ConsumptionAccountsArgs = {
  cursor?: InputMaybe<Scalars['String']['input']>;
  filter: ProductRatingV2AccountFilterInput;
};


export type ConsumptionOrganizationsArgs = {
  cursor?: InputMaybe<Scalars['String']['input']>;
  filter: ProductRatingV2OrganizationFilterInput;
};

/** The Account content being shared */
export type ContentSharingAccountContent = {
  /** Account IDs of the content being shared */
  accountIds: Array<Scalars['Int']['input']>;
  /** Content title */
  title?: InputMaybe<Scalars['String']['input']>;
  /** The url associated with the account ID */
  url: Scalars['String']['input'];
};

/** The content being shared */
export type ContentSharingContentInput = {
  /** The Account content being shared */
  accountContent?: InputMaybe<ContentSharingAccountContent>;
  /** The Enitity content being shared */
  entityContent?: InputMaybe<ContentSharingEntityContent>;
};

/** The emailRecipient */
export type ContentSharingEmailRecipient = {
  /** The email address of the recipient */
  emailAddress: Scalars['String']['input'];
};

/** The Enitity content being shared */
export type ContentSharingEntityContent = {
  /** Entity GUIDs associated with the content being shared */
  guids: Array<Scalars['EntityGuid']['input']>;
  /** Content title */
  title?: InputMaybe<Scalars['String']['input']>;
  /** The url associated with the Entity Guid */
  url: Scalars['String']['input'];
};

/** The recipients of the content being shared */
export type ContentSharingRecipientInput = {
  /** The emailRecipient */
  emailRecipient?: InputMaybe<ContentSharingEmailRecipient>;
};

/** Response of the share */
export type ContentSharingShareContentResponse = {
  __typename?: 'ContentSharingShareContentResponse';
  /** Response message for the mutation */
  message?: Maybe<Scalars['String']['output']>;
};

export type CorrelationAccountStitchedFields = {
  __typename?: 'CorrelationAccountStitchedFields';
  /**
   * Find the intersections of incident attributes.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  incidentIntersections?: Maybe<CorrelationIntersectionResult>;
  /**
   * Fetch a search operation.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  incidentSearchOperation?: Maybe<CorrelationApplicableIncidentSearch>;
  /**
   * Find the similar attributes of two incidents.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  incidentSimilarity?: Maybe<CorrelationSimilarAttributeResult>;
  /**
   * Fetch merged child issue entries for a parent issue.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  mergeEntriesByIssue?: Maybe<CorrelationMergeEntries>;
  /**
   * Fetch relevant merge feedback for an issue.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  mergeFeedback?: Maybe<Array<CorrelationMergeFeedback>>;
  /**
   * Fetch relevant merge feedback for a rule
   * @deprecated This field is experimental and subject to breaking changes.
   */
  mergeFeedbackByRule?: Maybe<Array<CorrelationMergeFeedback>>;
  /**
   * Fetch a rule by ID.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  rule?: Maybe<CorrelationRule>;
  /**
   * Returns a paginated list of rules.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  rules?: Maybe<CorrelationRuleListing>;
  /**
   * Number of rules relevant to this account.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  rulesCount?: Maybe<Scalars['Int']['output']>;
  /**
   * Fetch a simulation.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  simulation?: Maybe<CorrelationSimulation>;
  /**
   * Fetch a suggested rule.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  suggestion?: Maybe<CorrelationSuggestion>;
  /**
   * Returns a paginated list of suggested rules.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  suggestions?: Maybe<CorrelationSuggestionListing>;
};


export type CorrelationAccountStitchedFieldsIncidentIntersectionsArgs = {
  incidentIds: Array<Scalars['ID']['input']>;
};


export type CorrelationAccountStitchedFieldsIncidentSearchOperationArgs = {
  searchId: Scalars['ID']['input'];
};


export type CorrelationAccountStitchedFieldsIncidentSimilarityArgs = {
  incidentIds: Array<Scalars['ID']['input']>;
  similarityAlgorithm: CorrelationSimilarityAlgorithm;
  similarityDistance: Scalars['Float']['input'];
};


export type CorrelationAccountStitchedFieldsMergeEntriesByIssueArgs = {
  issueId: Scalars['ID']['input'];
};


export type CorrelationAccountStitchedFieldsMergeFeedbackArgs = {
  issueId: Scalars['ID']['input'];
};


export type CorrelationAccountStitchedFieldsMergeFeedbackByRuleArgs = {
  ruleId: Scalars['ID']['input'];
};


export type CorrelationAccountStitchedFieldsRuleArgs = {
  ruleId: Scalars['ID']['input'];
};


export type CorrelationAccountStitchedFieldsRulesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  pageSize?: InputMaybe<Scalars['Int']['input']>;
  ruleStates?: InputMaybe<Array<CorrelationRuleState>>;
  ruleTypes?: InputMaybe<Array<CorrelationRuleType>>;
  sortMethod?: InputMaybe<CorrelationRuleSortMethod>;
};


export type CorrelationAccountStitchedFieldsSimulationArgs = {
  simulationId: Scalars['ID']['input'];
};


export type CorrelationAccountStitchedFieldsSuggestionArgs = {
  suggestionId: Scalars['ID']['input'];
};


export type CorrelationAccountStitchedFieldsSuggestionsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  pageSize?: InputMaybe<Scalars['Int']['input']>;
  sortMethod?: InputMaybe<CorrelationSuggestionSortMethod>;
  suggestionStates?: InputMaybe<Array<CorrelationSuggestionState>>;
};

/** Input type for All expression */
export type CorrelationAllInput = {
  /** Children expressions. */
  children: Array<CorrelationRuleExpressionInput>;
};

/** Input type for And expression */
export type CorrelationAndInput = {
  /** Left child expression. */
  left: CorrelationRuleExpressionInput;
  /** Right child expression. */
  right: CorrelationRuleExpressionInput;
};

/** A key-value entry of rule annotations. Rule annotations are to provide additional rule information beyond the essential rule fields. */
export type CorrelationAnnotationEntry = {
  __typename?: 'CorrelationAnnotationEntry';
  /**
   * Key of an entry of rule annotations. Exact key matching required to identify as the same key.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  key: Scalars['String']['output'];
  /**
   * Value of an entry of rule annotations.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  value: Scalars['String']['output'];
};

/** A key-value entry of rule annotations. Rule annotations are to provide additional rule information beyond the essential rule fields. */
export type CorrelationAnnotationInput = {
  /** Key of an entry of rule annotations. Exact key matching required to identify as the same key. */
  key: Scalars['String']['input'];
  /** Value of an entry of rule annotations. */
  value: Scalars['String']['input'];
};

/** A search for a subset of incidents that may be relevant for a given rule expression */
export type CorrelationApplicableIncidentSearch = {
  __typename?: 'CorrelationApplicableIncidentSearch';
  /**
   * Time search operation completed
   * @deprecated This field is experimental and subject to breaking changes.
   */
  completedAt?: Maybe<Scalars['EpochMilliseconds']['output']>;
  /**
   * Time search operation was created
   * @deprecated This field is experimental and subject to breaking changes.
   */
  createdAt: Scalars['EpochMilliseconds']['output'];
  /**
   * Error message if search operation failed
   * @deprecated This field is experimental and subject to breaking changes.
   */
  errorMessage?: Maybe<Scalars['String']['output']>;
  /**
   * ID of search operation
   * @deprecated This field is experimental and subject to breaking changes.
   */
  id: Scalars['ID']['output'];
  /**
   * Number of incidents scanned by the search operation
   * @deprecated This field is experimental and subject to breaking changes.
   */
  incidentsScanned: Scalars['Int']['output'];
  /**
   * Listing of incident selectors and potential applicable incidents
   * @deprecated This field is experimental and subject to breaking changes.
   */
  results: Array<CorrelationSelectorExamples>;
  /**
   * Time search operation was last updated
   * @deprecated This field is experimental and subject to breaking changes.
   */
  updatedAt: Scalars['EpochMilliseconds']['output'];
};

/** Event attribute name and value. */
export type CorrelationAttributeData = {
  __typename?: 'CorrelationAttributeData';
  /**
   * Name of the attribute.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  name: Scalars['String']['output'];
  /**
   * Value of the attribute.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  value: Scalars['String']['output'];
};

/** Input type for AttributeExists expression */
export type CorrelationAttributeExistsInput = {
  /** Incident selector to be used in comparison. */
  incident: CorrelationIncidentObjectInput;
};

/** Represents the key of an attribute */
export type CorrelationAttributeKey = {
  __typename?: 'CorrelationAttributeKey';
  /**
   * The string uniquely identifying this attribute
   * @deprecated This field is experimental and subject to breaking changes.
   */
  name: Scalars['String']['output'];
  /**
   * The number of distinct values this key has been associated with
   * @deprecated This field is experimental and subject to breaking changes.
   */
  numValues: Scalars['Int']['output'];
  /**
   * The number of objects in which this key is present
   * @deprecated This field is experimental and subject to breaking changes.
   */
  occurrences: Scalars['Int']['output'];
  /**
   * The 10 most frequent values this key has been associated with
   * @deprecated This field is experimental and subject to breaking changes.
   */
  topValues: Array<CorrelationAttributeValue>;
};

/** Represents a value of an attribute */
export type CorrelationAttributeValue = {
  __typename?: 'CorrelationAttributeValue';
  /**
   * The value that an AttributeKey has been associated with
   * @deprecated This field is experimental and subject to breaking changes.
   */
  name: Scalars['String']['output'];
  /**
   * The number of times this value has been associated with the AttributeKey
   * @deprecated This field is experimental and subject to breaking changes.
   */
  occurrences: Scalars['Int']['output'];
};

/** Input type for CategoricalClustering expression */
export type CorrelationCategoricalClusteringInput = {
  /** Threshold for comparison. */
  threshold: Scalars['Float']['input'];
};

/** A common attribute defined in rule. */
export type CorrelationCommonAttribute = {
  __typename?: 'CorrelationCommonAttribute';
  /**
   * First attribute.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  firstAttr: CorrelationAttributeData;
  /**
   * Operator.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  operator: Scalars['String']['output'];
  /**
   * Second attribute.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  secondAttr: CorrelationAttributeData;
};

/** Basic data of an entity. */
export type CorrelationEntityData = {
  __typename?: 'CorrelationEntityData';
  /**
   * ID of vertex.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  vertexId?: Maybe<Scalars['String']['output']>;
  /**
   * Name of vertex.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  vertexName?: Maybe<Scalars['String']['output']>;
  /**
   * Type of vertex.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  vertexType?: Maybe<Scalars['String']['output']>;
};

/** Topology correlation reason by entity information. */
export type CorrelationEntityReason = {
  __typename?: 'CorrelationEntityReason';
  /**
   * First entity reason.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  firstEntity: CorrelationEntityData;
  /**
   * operator.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  operator: Scalars['String']['output'];
  /**
   * Second entity reason.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  secondEntity: CorrelationEntityData;
};

/** A rule filter for event data filtering. */
export type CorrelationFilter = {
  __typename?: 'CorrelationFilter';
  /**
   * Name of filter.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  name: Scalars['String']['output'];
  /**
   * Operator of filter.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  operator: Scalars['String']['output'];
  /**
   * Value of filter.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  value: Array<Scalars['String']['output']>;
};

/** A pair of rule filters for first and second incident respectively. */
export type CorrelationFilterPair = {
  __typename?: 'CorrelationFilterPair';
  /**
   * First filter.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  firstFilter?: Maybe<CorrelationFilter>;
  /**
   * Second filter.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  secondFilter?: Maybe<CorrelationFilter>;
};

/** Input type for FixedContains expression */
export type CorrelationFixedContainsInput = {
  /** Incident selector to be used in comparison. */
  container: CorrelationIncidentObjectInput;
  /** Value to be used in comparison. */
  value: Scalars['String']['input'];
};

/** Input type for FixedCosineDistance expression */
export type CorrelationFixedCosineDistanceInput = {
  /** Incident selector to be used in comparison. */
  incident: CorrelationIncidentObjectInput;
  /** Maximum distance threshold. */
  maxDistance: Scalars['Float']['input'];
  /** Value to be used in comparison. */
  value: Scalars['String']['input'];
};

/** Input type for FixedEndsWith expression */
export type CorrelationFixedEndsWithInput = {
  /** Incident selector to be used in comparison. */
  incident: CorrelationIncidentObjectInput;
  /** Value to be used in comparison. */
  value: Scalars['String']['input'];
};

/** Input type for FixedEqual expression */
export type CorrelationFixedEqualInput = {
  /** Incident selector to be used in comparison. */
  incident: CorrelationIncidentObjectInput;
  /** Value to be used in comparison. */
  value: Scalars['String']['input'];
};

/** Input type for FixedFuzzyScore expression */
export type CorrelationFixedFuzzyScoreInput = {
  /** Incident selector to be used in comparison. */
  incident: CorrelationIncidentObjectInput;
  /** Minimum distance threshold. */
  minDistance: Scalars['Int']['input'];
  /** Value to be used in comparison. */
  value: Scalars['String']['input'];
};

/** Input type for FixedFuzzyWuzzyAdaptiveRatio expression */
export type CorrelationFixedFuzzyWuzzyAdaptiveRatioInput = {
  /** Incident selector to be used in comparison. */
  incident: CorrelationIncidentObjectInput;
  /** Minimum similarity threshold. */
  minSimilarity: Scalars['Float']['input'];
  /** Value to be used in comparison. */
  value: Scalars['String']['input'];
};

/** Input type for FixedFuzzyWuzzyPartialRatio expression */
export type CorrelationFixedFuzzyWuzzyPartialRatioInput = {
  /** Incident selector to be used in comparison. */
  incident: CorrelationIncidentObjectInput;
  /** Minimum similarity threshold. */
  minSimilarity: Scalars['Float']['input'];
  /** Value to be used in comparison. */
  value: Scalars['String']['input'];
};

/** Input type for FixedFuzzyWuzzyRatio expression */
export type CorrelationFixedFuzzyWuzzyRatioInput = {
  /** Incident selector to be used in comparison. */
  incident: CorrelationIncidentObjectInput;
  /** Minimum similarity threshold. */
  minSimilarity: Scalars['Float']['input'];
  /** Value to be used in comparison. */
  value: Scalars['String']['input'];
};

/** Input type for FixedFuzzyWuzzyTokenSetRatio expression */
export type CorrelationFixedFuzzyWuzzyTokenSetRatioInput = {
  /** Incident selector to be used in comparison. */
  incident: CorrelationIncidentObjectInput;
  /** Minimum similarity threshold. */
  minSimilarity: Scalars['Float']['input'];
  /** Value to be used in comparison. */
  value: Scalars['String']['input'];
};

/** Input type for FixedGreaterThan expression */
export type CorrelationFixedGreaterThanInput = {
  /** Value to be used in comparison. */
  compared: Scalars['Float']['input'];
  /** Incident selector to be used in comparison. */
  incident: CorrelationIncidentObjectInput;
};

/** Input type for FixedGreaterThanOrEqual expression */
export type CorrelationFixedGreaterThanOrEqualInput = {
  /** Value to be used in comparison. */
  compared: Scalars['Float']['input'];
  /** Incident selector to be used in comparison. */
  incident: CorrelationIncidentObjectInput;
};

/** Input type for FixedHammingDistance expression */
export type CorrelationFixedHammingDistanceInput = {
  /** Incident selector to be used in comparison. */
  incident: CorrelationIncidentObjectInput;
  /** Maximum distance threshold. */
  maxDistance: Scalars['Int']['input'];
  /** Value to be used in comparison. */
  value: Scalars['String']['input'];
};

/** Input type for FixedJaccardDistance expression */
export type CorrelationFixedJaccardDistanceInput = {
  /** Incident selector to be used in comparison. */
  incident: CorrelationIncidentObjectInput;
  /** Maximum distance threshold. */
  maxDistance: Scalars['Float']['input'];
  /** Value to be used in comparison. */
  value: Scalars['String']['input'];
};

/** Input type for FixedJaroWinkler expression */
export type CorrelationFixedJaroWinklerInput = {
  /** Incident selector to be used in comparison. */
  incident: CorrelationIncidentObjectInput;
  /** Minimum distance threshold. */
  minDistance: Scalars['Float']['input'];
  /** Value to be used in comparison. */
  value: Scalars['String']['input'];
};

/** Input type for FixedLessThan expression */
export type CorrelationFixedLessThanInput = {
  /** Value to be used in comparison. */
  compared: Scalars['Float']['input'];
  /** Incident selector to be used in comparison. */
  incident: CorrelationIncidentObjectInput;
};

/** Input type for FixedLessThanOrEqual expression */
export type CorrelationFixedLessThanOrEqualInput = {
  /** Value to be used in comparison. */
  compared: Scalars['Float']['input'];
  /** Incident selector to be used in comparison. */
  incident: CorrelationIncidentObjectInput;
};

/** Input type for FixedLevenshtein expression */
export type CorrelationFixedLevenshteinInput = {
  /** Incident selector to be used in comparison. */
  incident: CorrelationIncidentObjectInput;
  /** Maximum distance threshold. */
  maxDistance: Scalars['Int']['input'];
  /** Value to be used in comparison. */
  value: Scalars['String']['input'];
};

/** Input type for FixedLongestCommonSubsequenceDistance expression */
export type CorrelationFixedLongestCommonSubsequenceDistanceInput = {
  /** Incident selector to be used in comparison. */
  incident: CorrelationIncidentObjectInput;
  /** Maximum distance threshold. */
  maxDistance: Scalars['Float']['input'];
  /** Value to be used in comparison. */
  value: Scalars['String']['input'];
};

/** Input type for FixedNumericalEqual expression */
export type CorrelationFixedNumericalEqualInput = {
  /** Value to be used in comparison. */
  compared: Scalars['Float']['input'];
  /** Incident selector to be used in comparison. */
  incident: CorrelationIncidentObjectInput;
};

/** Input type for FixedRegularExpression expression */
export type CorrelationFixedRegularExpressionInput = {
  /** Incident selector to be used in comparison. */
  incident: CorrelationIncidentObjectInput;
  /** Value to be used in comparison. */
  value: Scalars['String']['input'];
};

/** Input type for FixedSoundEx expression */
export type CorrelationFixedSoundExInput = {
  /** Incident selector to be used in comparison. */
  incident: CorrelationIncidentObjectInput;
  /** Minimum distance threshold. */
  minDistance: Scalars['Int']['input'];
  /** Value to be used in comparison. */
  value: Scalars['String']['input'];
};

/** Input type for FixedStartsWith expression */
export type CorrelationFixedStartsWithInput = {
  /** Incident selector to be used in comparison. */
  incident: CorrelationIncidentObjectInput;
  /** Value to be used in comparison. */
  value: Scalars['String']['input'];
};

/** Represents an attribute of an incident. */
export type CorrelationIncidentObjectInput = {
  /** Attribute to process of selected incident. */
  attribute: Scalars['String']['input'];
  /** Incident to select. */
  select: CorrelationIncidentSelect;
};

/** Select incident for comparison. */
export enum CorrelationIncidentSelect {
  /**
   * Select first incident in comparison.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  FirstIncident = 'FIRST_INCIDENT',
  /**
   * Select second incident in comparison.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  SecondIncident = 'SECOND_INCIDENT'
}

/** Passive Integrations for a given account */
export type CorrelationIngestAccountStitchedFields = {
  __typename?: 'CorrelationIngestAccountStitchedFields';
  /** A single passive integration fetched by origin name */
  passiveIntegration?: Maybe<CorrelationIngestPassiveIntegration>;
  /** All passive integrations currently known */
  passiveIntegrations?: Maybe<Array<Maybe<CorrelationIngestPassiveIntegration>>>;
};


/** Passive Integrations for a given account */
export type CorrelationIngestAccountStitchedFieldsPassiveIntegrationArgs = {
  origin: Scalars['String']['input'];
};

/**
 * A passive integration, corresponding to an endpoint on the internet that
 * can have metrics, events, alerts, etc. submitted to it
 */
export type CorrelationIngestPassiveIntegration = {
  __typename?: 'CorrelationIngestPassiveIntegration';
  /** Authentication information for a passive integration */
  auth?: Maybe<CorrelationIngestPassiveIntegrationAuth>;
  /** The 'origin' (i.e. expected source, like pagerduty, or rest) of an event */
  origin?: Maybe<Scalars['String']['output']>;
  /**
   * The URL to the passive collection endpoint on the internet.
   *
   * url may match auth.value if the passive collection endpoint is authenticated
   * by URL. The URL scheme may not be https -- e.g. if authType is "email", url
   * may contain a mailto: URL instead. If ever the endpoint is not addressable
   * by URL, url will be empty.
   */
  url?: Maybe<Scalars['String']['output']>;
};

/** Authentication information for a PassiveIntegration */
export type CorrelationIngestPassiveIntegrationAuth = {
  __typename?: 'CorrelationIngestPassiveIntegrationAuth';
  /** The authentication method for the passive collection endpoint */
  type?: Maybe<CorrelationIngestPassiveIntegrationAuthTypeEnum>;
  /**
   * The authentication value; i.e. what should be provided for the passive collector to accept an event.
   *
   * If type is "url", value will match the url attribute.
   * If type is "header", value will correspond to the full string
   *     that should be put into an `Authorization` header when the event is submitted
   *     to passive collectors. The url attribute will show a URL that can be used to
   *     submit alerts ("incidents") to.
   * If type is "email", value will be an e-mail address that can be used to
   *     send the event to passive collectors. More information on e-mail collection
   *     can be found at https://docs.signifai.io/docs/email-collector .
   */
  value?: Maybe<Scalars['String']['output']>;
};

/**
 * Types of authentication a passive integration can have.
 *
 * See documentation for PassiveIntegrationAuth.value for more details.
 */
export enum CorrelationIngestPassiveIntegrationAuthTypeEnum {
  /** Email authentication (messages to the e-mail are considered authenticated) */
  Email = 'EMAIL',
  /** Header "Bearer" JWT token-based authentication */
  Header = 'HEADER',
  /** URL-based authentication (the URL itself is the authentication) */
  Url = 'URL'
}

/** Entry for an attribute that has common values across objects */
export type CorrelationIntersectionAttribute = {
  __typename?: 'CorrelationIntersectionAttribute';
  /**
   * The key of the attribute that is shared
   * @deprecated This field is experimental and subject to breaking changes.
   */
  key: CorrelationAttributeKey;
  /**
   * The set of values that this attribute shares across objects
   * @deprecated This field is experimental and subject to breaking changes.
   */
  values: Array<CorrelationAttributeValue>;
};

/** Description of shared information between objects */
export type CorrelationIntersectionResult = {
  __typename?: 'CorrelationIntersectionResult';
  /**
   * Listing of attributes in the intersection of the provided objects
   * @deprecated This field is experimental and subject to breaking changes.
   */
  attributes: Array<CorrelationIntersectionAttribute>;
  /**
   * Total number of incidents present in the inspected time period
   * @deprecated This field is experimental and subject to breaking changes.
   */
  totalIncidents: Scalars['Int']['output'];
};

/** Priority of issue. */
export enum CorrelationIssuePriority {
  /**
   * Issue priority of critical
   * @deprecated This field is experimental and subject to breaking changes.
   */
  Critical = 'CRITICAL',
  /**
   * Issue priority of high
   * @deprecated This field is experimental and subject to breaking changes.
   */
  High = 'HIGH',
  /**
   * Issue priority of low
   * @deprecated This field is experimental and subject to breaking changes.
   */
  Low = 'LOW',
  /**
   * Issue priority of medium
   * @deprecated This field is experimental and subject to breaking changes.
   */
  Medium = 'MEDIUM'
}

/** Merge entries associated with a parent issue. */
export type CorrelationMergeEntries = {
  __typename?: 'CorrelationMergeEntries';
  /**
   * A list of merge entries formed from child issues.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  mergeEntries: Array<CorrelationMergeEntry>;
  /**
   * ID of parent issue.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  parentIssueId: Scalars['ID']['output'];
};

/** Merge entry formed from a child issue. */
export type CorrelationMergeEntry = {
  __typename?: 'CorrelationMergeEntry';
  /**
   * ID of child issue.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  childIssueId: Scalars['ID']['output'];
  /**
   * Merge feedbacks for child issues.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  mergeFeedbacks: Array<CorrelationMergeFeedback>;
  /**
   * Rule metadata regarding merge for child issues.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  ruleMetadata: Array<CorrelationRuleMergeMetadata>;
};

/** Represents a piece of user feedback for a merge. */
export type CorrelationMergeFeedback = {
  __typename?: 'CorrelationMergeFeedback';
  /**
   * ID of child issue.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  childIssueId: Scalars['ID']['output'];
  /**
   * Opinion of the current user on this merge.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  opinion: CorrelationOpinion;
  /**
   * ID of parent issue.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  parentIssueId: Scalars['ID']['output'];
  /**
   * ID of correlation rule.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  ruleId: Scalars['ID']['output'];
  /**
   * ID of user.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  userId: Scalars['ID']['output'];
};

/** Input type for Not expression */
export type CorrelationNotInput = {
  /** Child expression. */
  child: CorrelationRuleExpressionInput;
};

/** Input type for One expression */
export type CorrelationOneInput = {
  /** Children expressions. */
  children: Array<CorrelationRuleExpressionInput>;
};

/** Result of an operation. */
export type CorrelationOperationResult = {
  __typename?: 'CorrelationOperationResult';
  /**
   * Status of the operation.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  result: CorrelationResultType;
};

/** Types of opinions users can leave as feedback. */
export enum CorrelationOpinion {
  /**
   * A dislike opinion
   * @deprecated This field is experimental and subject to breaking changes.
   */
  Dislike = 'DISLIKE',
  /**
   * A like opinion
   * @deprecated This field is experimental and subject to breaking changes.
   */
  Like = 'LIKE'
}

/** Represents a number of opinions. */
export type CorrelationOpinionEntry = {
  __typename?: 'CorrelationOpinionEntry';
  /**
   * Number of this type of opinion.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  count: Scalars['Int']['output'];
  /**
   * Type of opinion.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  opinion: CorrelationOpinion;
};

/** Input type for Or expression */
export type CorrelationOrInput = {
  /** Left child expression. */
  left: CorrelationRuleExpressionInput;
  /** Right child expression. */
  right: CorrelationRuleExpressionInput;
};

/** Configuration for overriding properties of issues created by merges. */
export type CorrelationOverrideConfiguration = {
  __typename?: 'CorrelationOverrideConfiguration';
  /**
   * Description merged issues should take.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  description?: Maybe<Scalars['String']['output']>;
  /**
   * Priority merged issues should take.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  priority?: Maybe<CorrelationIssuePriority>;
  /**
   * Title merged issues should take.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  title?: Maybe<Scalars['String']['output']>;
};

/** Configuration for overriding properties of issues created by merges. */
export type CorrelationOverrideConfigurationInput = {
  /** Description merged issues should take. */
  description?: InputMaybe<Scalars['String']['input']>;
  /** Priority merged issues should take. */
  priority?: InputMaybe<CorrelationIssuePriority>;
  /** Title merged issues should take. */
  title?: InputMaybe<Scalars['String']['input']>;
};

/** Input type for RelativeCommonPrefix expression */
export type CorrelationRelativeCommonPrefixInput = {
  /** Value to be used in comparison. */
  value: Scalars['String']['input'];
};

/** Input type for RelativeContains expression */
export type CorrelationRelativeContainsInput = {
  /** Incident selector to be used in comparison. */
  contained: CorrelationIncidentObjectInput;
  /** Incident selector to be used in comparison. */
  container: CorrelationIncidentObjectInput;
};

/** Input type for RelativeCosineDistance expression */
export type CorrelationRelativeCosineDistanceInput = {
  /** Left operand of comparison. */
  left: CorrelationIncidentObjectInput;
  /** Maximum distance threshold. */
  maxDistance: Scalars['Float']['input'];
  /** Right operand of comparison. */
  right: CorrelationIncidentObjectInput;
};

/** Input type for RelativeEndsWith expression */
export type CorrelationRelativeEndsWithInput = {
  /** Incident selector to be used in comparison. */
  contained: CorrelationIncidentObjectInput;
  /** Incident selector to be used in comparison. */
  container: CorrelationIncidentObjectInput;
};

/** Input type for RelativeEqual expression */
export type CorrelationRelativeEqualInput = {
  /** Left operand of comparison. */
  left: CorrelationIncidentObjectInput;
  /** Right operand of comparison. */
  right: CorrelationIncidentObjectInput;
};

/** Input type for RelativeFuzzyScore expression */
export type CorrelationRelativeFuzzyScoreInput = {
  /** Left operand of comparison. */
  left: CorrelationIncidentObjectInput;
  /** Minimum distance threshold. */
  minDistance: Scalars['Int']['input'];
  /** Right operand of comparison. */
  right: CorrelationIncidentObjectInput;
};

/** Input type for RelativeFuzzyWuzzyAdaptiveRatio expression */
export type CorrelationRelativeFuzzyWuzzyAdaptiveRatioInput = {
  /** Left operand of comparison. */
  left: CorrelationIncidentObjectInput;
  /** Minimum similarity threshold. */
  minSimilarity: Scalars['Float']['input'];
  /** Right operand of comparison. */
  right: CorrelationIncidentObjectInput;
};

/** Input type for RelativeFuzzyWuzzyPartialRatio expression */
export type CorrelationRelativeFuzzyWuzzyPartialRatioInput = {
  /** Left operand of comparison. */
  left: CorrelationIncidentObjectInput;
  /** Minimum similarity threshold. */
  minSimilarity: Scalars['Float']['input'];
  /** Right operand of comparison. */
  right: CorrelationIncidentObjectInput;
};

/** Input type for RelativeFuzzyWuzzyRatio expression */
export type CorrelationRelativeFuzzyWuzzyRatioInput = {
  /** Left operand of comparison. */
  left: CorrelationIncidentObjectInput;
  /** Minimum similarity threshold. */
  minSimilarity: Scalars['Float']['input'];
  /** Right operand of comparison. */
  right: CorrelationIncidentObjectInput;
};

/** Input type for RelativeFuzzyWuzzyTokenSetRatio expression */
export type CorrelationRelativeFuzzyWuzzyTokenSetRatioInput = {
  /** Left operand of comparison. */
  left: CorrelationIncidentObjectInput;
  /** Minimum similarity threshold. */
  minSimilarity: Scalars['Float']['input'];
  /** Right operand of comparison. */
  right: CorrelationIncidentObjectInput;
};

/** Input type for RelativeGreaterThan expression */
export type CorrelationRelativeGreaterThanInput = {
  /** Left operand of comparison. */
  left: CorrelationIncidentObjectInput;
  /** Right operand of comparison. */
  right: CorrelationIncidentObjectInput;
};

/** Input type for RelativeGreaterThanOrEqual expression */
export type CorrelationRelativeGreaterThanOrEqualInput = {
  /** Left operand of comparison. */
  left: CorrelationIncidentObjectInput;
  /** Right operand of comparison. */
  right: CorrelationIncidentObjectInput;
};

/** Input type for RelativeHammingDistance expression */
export type CorrelationRelativeHammingDistanceInput = {
  /** Left operand of comparison. */
  left: CorrelationIncidentObjectInput;
  /** Maximum distance threshold. */
  maxDistance: Scalars['Int']['input'];
  /** Right operand of comparison. */
  right: CorrelationIncidentObjectInput;
};

/** Input type for RelativeJaccardDistance expression */
export type CorrelationRelativeJaccardDistanceInput = {
  /** Left operand of comparison. */
  left: CorrelationIncidentObjectInput;
  /** Maximum distance threshold. */
  maxDistance: Scalars['Float']['input'];
  /** Right operand of comparison. */
  right: CorrelationIncidentObjectInput;
};

/** Input type for RelativeJaroWinkler expression */
export type CorrelationRelativeJaroWinklerInput = {
  /** Left operand of comparison. */
  left: CorrelationIncidentObjectInput;
  /** Minimum distance threshold. */
  minDistance: Scalars['Float']['input'];
  /** Right operand of comparison. */
  right: CorrelationIncidentObjectInput;
};

/** Input type for RelativeLessThan expression */
export type CorrelationRelativeLessThanInput = {
  /** Left operand of comparison. */
  left: CorrelationIncidentObjectInput;
  /** Right operand of comparison. */
  right: CorrelationIncidentObjectInput;
};

/** Input type for RelativeLessThanOrEqual expression */
export type CorrelationRelativeLessThanOrEqualInput = {
  /** Left operand of comparison. */
  left: CorrelationIncidentObjectInput;
  /** Right operand of comparison. */
  right: CorrelationIncidentObjectInput;
};

/** Input type for RelativeLevenshtein expression */
export type CorrelationRelativeLevenshteinInput = {
  /** Left operand of comparison. */
  left: CorrelationIncidentObjectInput;
  /** Maximum distance threshold. */
  maxDistance: Scalars['Int']['input'];
  /** Right operand of comparison. */
  right: CorrelationIncidentObjectInput;
};

/** Input type for RelativeLongestCommonSubsequenceDistance expression */
export type CorrelationRelativeLongestCommonSubsequenceDistanceInput = {
  /** Left operand of comparison. */
  left: CorrelationIncidentObjectInput;
  /** Maximum distance threshold. */
  maxDistance: Scalars['Float']['input'];
  /** Right operand of comparison. */
  right: CorrelationIncidentObjectInput;
};

/** Input type for RelativeNumericalEqual expression */
export type CorrelationRelativeNumericalEqualInput = {
  /** Left operand of comparison. */
  left: CorrelationIncidentObjectInput;
  /** Right operand of comparison. */
  right: CorrelationIncidentObjectInput;
};

/** Input type for RelativeRegularExpression expression */
export type CorrelationRelativeRegularExpressionInput = {
  /** Left operand of comparison. */
  left: CorrelationIncidentObjectInput;
  /** Right operand of comparison. */
  right: CorrelationIncidentObjectInput;
  /** Value to be used in comparison. */
  value: Scalars['String']['input'];
};

/** Input type for RelativeSoundEx expression */
export type CorrelationRelativeSoundExInput = {
  /** Left operand of comparison. */
  left: CorrelationIncidentObjectInput;
  /** Minimum distance threshold. */
  minDistance: Scalars['Int']['input'];
  /** Right operand of comparison. */
  right: CorrelationIncidentObjectInput;
};

/** Input type for RelativeStartsWith expression */
export type CorrelationRelativeStartsWithInput = {
  /** Incident selector to be used in comparison. */
  contained: CorrelationIncidentObjectInput;
  /** Incident selector to be used in comparison. */
  container: CorrelationIncidentObjectInput;
};

/** Input type for RelativeTopologicallyCommonAncestor expression */
export type CorrelationRelativeTopologicallyCommonAncestorInput = {
  /** Ancestor vertex ID. */
  ancestor?: InputMaybe<Scalars['String']['input']>;
  /** Graph Id. */
  graphId?: InputMaybe<Scalars['ID']['input']>;
  /** Maximum number of hops. */
  maxHops?: InputMaybe<Scalars['Int']['input']>;
  /** Required vertex attributes. */
  requiredAttributes: Array<Scalars['String']['input']>;
  /** Required vertex classes. */
  requiredClasses: Array<CorrelationVertexClass>;
};

/** Input type for RelativeTopologicallyConnected expression */
export type CorrelationRelativeTopologicallyConnectedInput = {
  /** Graph Id. */
  graphId?: InputMaybe<Scalars['ID']['input']>;
  /** Maximum number of hops. */
  maxHops?: InputMaybe<Scalars['Int']['input']>;
  /** IDs of required vertices. */
  required?: InputMaybe<Array<Scalars['String']['input']>>;
  /** Required vertex attributes. */
  requiredAttributes: Array<Scalars['String']['input']>;
  /** Required vertex classes. */
  requiredClasses: Array<CorrelationVertexClass>;
  /** IDs of vertices passing through. */
  through?: InputMaybe<Array<Scalars['String']['input']>>;
};

/** Input type for RelativeTopologicallyDependent expression */
export type CorrelationRelativeTopologicallyDependentInput = {
  /** From vertex ID. */
  from: Array<Scalars['ID']['input']>;
  /** Graph Id. */
  graphId?: InputMaybe<Scalars['ID']['input']>;
  /** Maximum number of hops. */
  maxHops?: InputMaybe<Scalars['Int']['input']>;
  /** Required vertex attributes. */
  requiredAttributes: Array<Scalars['String']['input']>;
  /** Required vertex classes. */
  requiredClasses: Array<CorrelationVertexClass>;
  /** To vertex ID. */
  to: Array<Scalars['ID']['input']>;
};

/** Status of an operation. */
export enum CorrelationResultType {
  /**
   * Failed operation
   * @deprecated This field is experimental and subject to breaking changes.
   */
  Failure = 'FAILURE',
  /**
   * Successful operation
   * @deprecated This field is experimental and subject to breaking changes.
   */
  Success = 'SUCCESS'
}

/** A correlation rule used to compare incidents and subsequently merge issues. */
export type CorrelationRule = {
  __typename?: 'CorrelationRule';
  /**
   * Internal data associated with this rule.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  annotations: Array<CorrelationAnnotationEntry>;
  /**
   * Length of the window in which incidents are compared.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  correlationWindowLength?: Maybe<Scalars['Milliseconds']['output']>;
  /**
   * Time rule was created.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  createdAt: Scalars['EpochMilliseconds']['output'];
  /**
   * Creator of rule.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  creator?: Maybe<UserReference>;
  /**
   * Description of rule.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  description?: Maybe<Scalars['String']['output']>;
  /**
   * ID of rule.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  id: Scalars['ID']['output'];
  /**
   * External data associated with this rule.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  metadata: CorrelationRuleMetadata;
  /**
   * Number of correlations within a window required to merge issues.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  minCorrelationThreshold: Scalars['Int']['output'];
  /**
   * Name of rule.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  name: Scalars['String']['output'];
  /**
   * Configuration to allow rule to override issue properties.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  overrideConfiguration?: Maybe<CorrelationOverrideConfiguration>;
  /**
   * Expression to use to compare incidents.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  ruleExpression: Scalars['CorrelationRuleExpression']['output'];
  /**
   * Type of rule.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  ruleType: CorrelationRuleType;
  /**
   * Creation source of rule.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  source: CorrelationRuleSource;
  /**
   * Current state of rule.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  state: CorrelationRuleState;
  /**
   * Time rule was last updated.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  updatedAt: Scalars['EpochMilliseconds']['output'];
};

/** Blueprint for rule creation. */
export type CorrelationRuleBlueprint = {
  /** Length of the window in which incidents are compared. */
  correlationWindowLength?: InputMaybe<Scalars['Milliseconds']['input']>;
  /** Creator of rule. */
  creator?: InputMaybe<Scalars['String']['input']>;
  /** Description of rule. */
  description?: InputMaybe<Scalars['String']['input']>;
  /** Number of correlations within a window required to merge issues. */
  minCorrelationThreshold?: InputMaybe<Scalars['Int']['input']>;
  /** Name of rule. */
  name: Scalars['String']['input'];
  /** Configuration to allow rule to override issue properties. */
  overrideConfiguration?: InputMaybe<CorrelationOverrideConfigurationInput>;
  /** Expression to use to compare incidents. */
  ruleExpression: CorrelationRuleExpressionInput;
  /** Type of rule. */
  ruleType: CorrelationRuleType;
  /** Creation source of rule. */
  source: CorrelationRuleSource;
};

/** Rule expression input */
export type CorrelationRuleExpressionInput = {
  /** Input type for All expression */
  all?: InputMaybe<CorrelationAllInput>;
  /** Input type for And expression */
  and?: InputMaybe<CorrelationAndInput>;
  /** Input type for AttributeExists expression */
  attributeExists?: InputMaybe<CorrelationAttributeExistsInput>;
  /** Input type for CategoricalClustering expression */
  categoricalClustering?: InputMaybe<CorrelationCategoricalClusteringInput>;
  /** Input type for FixedContains expression */
  fixedContains?: InputMaybe<CorrelationFixedContainsInput>;
  /** Input type for FixedCosineDistance expression */
  fixedCosineDistance?: InputMaybe<CorrelationFixedCosineDistanceInput>;
  /** Input type for FixedEndsWith expression */
  fixedEndsWith?: InputMaybe<CorrelationFixedEndsWithInput>;
  /** Input type for FixedEqual expression */
  fixedEqual?: InputMaybe<CorrelationFixedEqualInput>;
  /** Input type for FixedFuzzyScore expression */
  fixedFuzzyScore?: InputMaybe<CorrelationFixedFuzzyScoreInput>;
  /** Input type for FixedFuzzyWuzzyAdaptiveRatio expression */
  fixedFuzzyWuzzyAdaptiveRatio?: InputMaybe<CorrelationFixedFuzzyWuzzyAdaptiveRatioInput>;
  /** Input type for FixedFuzzyWuzzyPartialRatio expression */
  fixedFuzzyWuzzyPartialRatio?: InputMaybe<CorrelationFixedFuzzyWuzzyPartialRatioInput>;
  /** Input type for FixedFuzzyWuzzyRatio expression */
  fixedFuzzyWuzzyRatio?: InputMaybe<CorrelationFixedFuzzyWuzzyRatioInput>;
  /** Input type for FixedFuzzyWuzzyTokenSetRatio expression */
  fixedFuzzyWuzzyTokenSetRatio?: InputMaybe<CorrelationFixedFuzzyWuzzyTokenSetRatioInput>;
  /** Input type for FixedGreaterThan expression */
  fixedGreaterThan?: InputMaybe<CorrelationFixedGreaterThanInput>;
  /** Input type for FixedGreaterThanOrEqual expression */
  fixedGreaterThanOrEqual?: InputMaybe<CorrelationFixedGreaterThanOrEqualInput>;
  /** Input type for FixedHammingDistance expression */
  fixedHammingDistance?: InputMaybe<CorrelationFixedHammingDistanceInput>;
  /** Input type for FixedJaccardDistance expression */
  fixedJaccardDistance?: InputMaybe<CorrelationFixedJaccardDistanceInput>;
  /** Input type for FixedJaroWinkler expression */
  fixedJaroWinkler?: InputMaybe<CorrelationFixedJaroWinklerInput>;
  /** Input type for FixedLessThan expression */
  fixedLessThan?: InputMaybe<CorrelationFixedLessThanInput>;
  /** Input type for FixedLessThanOrEqual expression */
  fixedLessThanOrEqual?: InputMaybe<CorrelationFixedLessThanOrEqualInput>;
  /** Input type for FixedLevenshtein expression */
  fixedLevenshtein?: InputMaybe<CorrelationFixedLevenshteinInput>;
  /** Input type for FixedLongestCommonSubsequenceDistance expression */
  fixedLongestCommonSubsequenceDistance?: InputMaybe<CorrelationFixedLongestCommonSubsequenceDistanceInput>;
  /** Input type for FixedNumericalEqual expression */
  fixedNumericalEqual?: InputMaybe<CorrelationFixedNumericalEqualInput>;
  /** Input type for FixedRegularExpression expression */
  fixedRegularExpression?: InputMaybe<CorrelationFixedRegularExpressionInput>;
  /** Input type for FixedSoundEx expression */
  fixedSoundEx?: InputMaybe<CorrelationFixedSoundExInput>;
  /** Input type for FixedStartsWith expression */
  fixedStartsWith?: InputMaybe<CorrelationFixedStartsWithInput>;
  /** Input type for Not expression */
  not?: InputMaybe<CorrelationNotInput>;
  /** Input type for One expression */
  one?: InputMaybe<CorrelationOneInput>;
  /** Input type for Or expression */
  or?: InputMaybe<CorrelationOrInput>;
  /** Input type for RelativeCommonPrefix expression */
  relativeCommonPrefix?: InputMaybe<CorrelationRelativeCommonPrefixInput>;
  /** Input type for RelativeContains expression */
  relativeContains?: InputMaybe<CorrelationRelativeContainsInput>;
  /** Input type for RelativeCosineDistance expression */
  relativeCosineDistance?: InputMaybe<CorrelationRelativeCosineDistanceInput>;
  /** Input type for RelativeEndsWith expression */
  relativeEndsWith?: InputMaybe<CorrelationRelativeEndsWithInput>;
  /** Input type for RelativeEqual expression */
  relativeEqual?: InputMaybe<CorrelationRelativeEqualInput>;
  /** Input type for RelativeFuzzyScore expression */
  relativeFuzzyScore?: InputMaybe<CorrelationRelativeFuzzyScoreInput>;
  /** Input type for RelativeFuzzyWuzzyAdaptiveRatio expression */
  relativeFuzzyWuzzyAdaptiveRatio?: InputMaybe<CorrelationRelativeFuzzyWuzzyAdaptiveRatioInput>;
  /** Input type for RelativeFuzzyWuzzyPartialRatio expression */
  relativeFuzzyWuzzyPartialRatio?: InputMaybe<CorrelationRelativeFuzzyWuzzyPartialRatioInput>;
  /** Input type for RelativeFuzzyWuzzyRatio expression */
  relativeFuzzyWuzzyRatio?: InputMaybe<CorrelationRelativeFuzzyWuzzyRatioInput>;
  /** Input type for RelativeFuzzyWuzzyTokenSetRatio expression */
  relativeFuzzyWuzzyTokenSetRatio?: InputMaybe<CorrelationRelativeFuzzyWuzzyTokenSetRatioInput>;
  /** Input type for RelativeGreaterThan expression */
  relativeGreaterThan?: InputMaybe<CorrelationRelativeGreaterThanInput>;
  /** Input type for RelativeGreaterThanOrEqual expression */
  relativeGreaterThanOrEqual?: InputMaybe<CorrelationRelativeGreaterThanOrEqualInput>;
  /** Input type for RelativeHammingDistance expression */
  relativeHammingDistance?: InputMaybe<CorrelationRelativeHammingDistanceInput>;
  /** Input type for RelativeJaccardDistance expression */
  relativeJaccardDistance?: InputMaybe<CorrelationRelativeJaccardDistanceInput>;
  /** Input type for RelativeJaroWinkler expression */
  relativeJaroWinkler?: InputMaybe<CorrelationRelativeJaroWinklerInput>;
  /** Input type for RelativeLessThan expression */
  relativeLessThan?: InputMaybe<CorrelationRelativeLessThanInput>;
  /** Input type for RelativeLessThanOrEqual expression */
  relativeLessThanOrEqual?: InputMaybe<CorrelationRelativeLessThanOrEqualInput>;
  /** Input type for RelativeLevenshtein expression */
  relativeLevenshtein?: InputMaybe<CorrelationRelativeLevenshteinInput>;
  /** Input type for RelativeLongestCommonSubsequenceDistance expression */
  relativeLongestCommonSubsequenceDistance?: InputMaybe<CorrelationRelativeLongestCommonSubsequenceDistanceInput>;
  /** Input type for RelativeNumericalEqual expression */
  relativeNumericalEqual?: InputMaybe<CorrelationRelativeNumericalEqualInput>;
  /** Input type for RelativeRegularExpression expression */
  relativeRegularExpression?: InputMaybe<CorrelationRelativeRegularExpressionInput>;
  /** Input type for RelativeSoundEx expression */
  relativeSoundEx?: InputMaybe<CorrelationRelativeSoundExInput>;
  /** Input type for RelativeStartsWith expression */
  relativeStartsWith?: InputMaybe<CorrelationRelativeStartsWithInput>;
  /** Input type for RelativeTopologicallyCommonAncestor expression */
  relativeTopologicallyCommonAncestor?: InputMaybe<CorrelationRelativeTopologicallyCommonAncestorInput>;
  /** Input type for RelativeTopologicallyConnected expression */
  relativeTopologicallyConnected?: InputMaybe<CorrelationRelativeTopologicallyConnectedInput>;
  /** Input type for RelativeTopologicallyDependent expression */
  relativeTopologicallyDependent?: InputMaybe<CorrelationRelativeTopologicallyDependentInput>;
  /** Input type for WholeCosineDistance expression */
  wholeCosineDistance?: InputMaybe<CorrelationWholeCosineDistanceInput>;
  /** Input type for WholeJaccardSimilarity expression */
  wholeJaccardSimilarity?: InputMaybe<CorrelationWholeJaccardSimilarityInput>;
};

/** Windowed view of an account's rules. */
export type CorrelationRuleListing = {
  __typename?: 'CorrelationRuleListing';
  /**
   * Number of rules in this window.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  count: Scalars['Int']['output'];
  /**
   * Cursor used to fetch next page.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  nextCursor?: Maybe<Scalars['String']['output']>;
  /**
   * Cursor used to fetch previous page.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  prevCursor?: Maybe<Scalars['String']['output']>;
  /**
   * List of rules in this window.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  rules: Array<CorrelationRule>;
};

/** Rule metadata for a merge. */
export type CorrelationRuleMergeMetadata = {
  __typename?: 'CorrelationRuleMergeMetadata';
  /**
   * Common attributes in rule.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  commonAttributes: Array<CorrelationCommonAttribute>;
  /**
   * Entity reason for topology correlation.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  entityReason?: Maybe<CorrelationEntityReason>;
  /**
   * Filters defined in rule.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  filters: Array<CorrelationFilterPair>;
  /**
   * ID of correlation rule.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  ruleId: Scalars['ID']['output'];
  /**
   * Name of rule.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  ruleName: Scalars['String']['output'];
};

/** Metadata about a rule. */
export type CorrelationRuleMetadata = {
  __typename?: 'CorrelationRuleMetadata';
  /**
   * Summary of user opinions for merges by this rule
   * @deprecated This field is experimental and subject to breaking changes.
   */
  mergeOpinionCount: Array<CorrelationOpinionEntry>;
};

/** Sorting method for rules. */
export enum CorrelationRuleSortMethod {
  /**
   * Sort rules by id
   * @deprecated This field is experimental and subject to breaking changes.
   */
  Id = 'ID',
  /**
   * Sort rules by latest_created
   * @deprecated This field is experimental and subject to breaking changes.
   */
  LatestCreated = 'LATEST_CREATED',
  /**
   * Sort rules by state_last_modified
   * @deprecated This field is experimental and subject to breaking changes.
   */
  StateLastModified = 'STATE_LAST_MODIFIED'
}

/** Possible creation sources for rules. */
export enum CorrelationRuleSource {
  /**
   * Created by ADMIN
   * @deprecated This field is experimental and subject to breaking changes.
   */
  Admin = 'ADMIN',
  /**
   * Created by GENERATED
   * @deprecated This field is experimental and subject to breaking changes.
   */
  Generated = 'GENERATED',
  /**
   * Created by SYSTEM
   * @deprecated This field is experimental and subject to breaking changes.
   */
  System = 'SYSTEM',
  /**
   * Created by USER
   * @deprecated This field is experimental and subject to breaking changes.
   */
  User = 'USER'
}

/** State of rule. */
export enum CorrelationRuleState {
  /**
   * Rule state is disabled
   * @deprecated This field is experimental and subject to breaking changes.
   */
  Disabled = 'DISABLED',
  /**
   * Rule state is enabled
   * @deprecated This field is experimental and subject to breaking changes.
   */
  Enabled = 'ENABLED'
}

/** Type of rule */
export enum CorrelationRuleType {
  /**
   * Rule type is explicit
   * @deprecated This field is experimental and subject to breaking changes.
   */
  Explicit = 'EXPLICIT',
  /**
   * Rule type is global
   * @deprecated This field is experimental and subject to breaking changes.
   */
  Global = 'GLOBAL',
  /**
   * Rule type is implicit
   * @deprecated This field is experimental and subject to breaking changes.
   */
  Implicit = 'IMPLICIT'
}

/** Blueprint for a search operation */
export type CorrelationSearchBlueprint = {
  /** Expression to use to compare incidents. */
  expression: CorrelationRuleExpressionInput;
  /** Maximum number of incidents to query for each available incident selector */
  limit?: InputMaybe<Scalars['Int']['input']>;
  /** Duration to consider resources for. */
  retentionWindowLength?: InputMaybe<Scalars['Milliseconds']['input']>;
};

/** Number of incidents applicable for a selector */
export type CorrelationSelectorApplicability = {
  __typename?: 'CorrelationSelectorApplicability';
  /**
   * Applicable number of incidents
   * @deprecated This field is experimental and subject to breaking changes.
   */
  count: Scalars['Int']['output'];
  /**
   * Incident selector
   * @deprecated This field is experimental and subject to breaking changes.
   */
  select: CorrelationIncidentSelect;
};

/** Example subset of incidents applicable for a selector */
export type CorrelationSelectorExamples = {
  __typename?: 'CorrelationSelectorExamples';
  /**
   * IDs of incidents that can be applied to this selector
   * @deprecated This field is experimental and subject to breaking changes.
   */
  incidents: Array<Scalars['ID']['output']>;
  /**
   * Incident selector
   * @deprecated This field is experimental and subject to breaking changes.
   */
  select: CorrelationIncidentSelect;
};

/** Description of list of similar attributes result of given algorithm and distance */
export type CorrelationSimilarAttributeResult = {
  __typename?: 'CorrelationSimilarAttributeResult';
  /**
   * The list of objects that has similar values of given algorithm and distance
   * @deprecated This field is experimental and subject to breaking changes.
   */
  similarAttributes: Array<CorrelationSimilarAttributes>;
};

/** Description of list of similar attributes of given algorithm and distance */
export type CorrelationSimilarAttributes = {
  __typename?: 'CorrelationSimilarAttributes';
  /**
   * The key of the attribute that has similar values
   * @deprecated This field is experimental and subject to breaking changes.
   */
  attributeKey: Scalars['String']['output'];
  /**
   * The value pairs of the attribute that are similar
   * @deprecated This field is experimental and subject to breaking changes.
   */
  attributeValue: Array<CorrelationSimilarPair>;
};

/** Description of list of similar pairs of given algorithm and distance */
export type CorrelationSimilarPair = {
  __typename?: 'CorrelationSimilarPair';
  /**
   * The distance of similar attributes of given algorithm
   * @deprecated This field is experimental and subject to breaking changes.
   */
  distance: Scalars['Float']['output'];
  /**
   * The values of the attribute that are similar
   * @deprecated This field is experimental and subject to breaking changes.
   */
  valuePair: Array<Scalars['String']['output']>;
};

/** Similarity algorithm for querying similar values. */
export enum CorrelationSimilarityAlgorithm {
  /**
   * Similarity algorithm cosine
   * @deprecated This field is experimental and subject to breaking changes.
   */
  Cosine = 'COSINE',
  /**
   * Similarity algorithm fuzzywuzzy_adaptive_ratio
   * @deprecated This field is experimental and subject to breaking changes.
   */
  FuzzywuzzyAdaptiveRatio = 'FUZZYWUZZY_ADAPTIVE_RATIO',
  /**
   * Similarity algorithm fuzzywuzzy_partial_ratio
   * @deprecated This field is experimental and subject to breaking changes.
   */
  FuzzywuzzyPartialRatio = 'FUZZYWUZZY_PARTIAL_RATIO',
  /**
   * Similarity algorithm fuzzywuzzy_ratio
   * @deprecated This field is experimental and subject to breaking changes.
   */
  FuzzywuzzyRatio = 'FUZZYWUZZY_RATIO',
  /**
   * Similarity algorithm fuzzywuzzy_token_set_ratio
   * @deprecated This field is experimental and subject to breaking changes.
   */
  FuzzywuzzyTokenSetRatio = 'FUZZYWUZZY_TOKEN_SET_RATIO',
  /**
   * Similarity algorithm fuzzy_score
   * @deprecated This field is experimental and subject to breaking changes.
   */
  FuzzyScore = 'FUZZY_SCORE',
  /**
   * Similarity algorithm hamming
   * @deprecated This field is experimental and subject to breaking changes.
   */
  Hamming = 'HAMMING',
  /**
   * Similarity algorithm jaccard
   * @deprecated This field is experimental and subject to breaking changes.
   */
  Jaccard = 'JACCARD',
  /**
   * Similarity algorithm jaro_winkler
   * @deprecated This field is experimental and subject to breaking changes.
   */
  JaroWinkler = 'JARO_WINKLER',
  /**
   * Similarity algorithm levenshtein
   * @deprecated This field is experimental and subject to breaking changes.
   */
  Levenshtein = 'LEVENSHTEIN',
  /**
   * Similarity algorithm longest_common_subsequence
   * @deprecated This field is experimental and subject to breaking changes.
   */
  LongestCommonSubsequence = 'LONGEST_COMMON_SUBSEQUENCE'
}

/** Simulation of a rule expression for a certain period of time. */
export type CorrelationSimulation = {
  __typename?: 'CorrelationSimulation';
  /**
   * Example potential incident correlations.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  candidateIncidents: Array<Array<Scalars['ID']['output']>>;
  /**
   * Time simulation completed.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  completedAt?: Maybe<Scalars['EpochMilliseconds']['output']>;
  /**
   * Time simulation was created.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  createdAt: Scalars['EpochMilliseconds']['output'];
  /**
   * Error message if simulation failed.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  errorMessage?: Maybe<Scalars['String']['output']>;
  /**
   * ID of simulation.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  id: Scalars['ID']['output'];
  /**
   * Applicability of ingested incidents to the expression.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  incidentsApplicable: Array<CorrelationSelectorApplicability>;
  /**
   * Number of incidents correlated by simulation.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  incidentsCorrelated: Scalars['Int']['output'];
  /**
   * Number of incidents ingested by simulation.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  incidentsIngested: Scalars['Int']['output'];
  /**
   * Number of applicable incidents processed by simulation.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  incidentsProcessed: Scalars['Int']['output'];
  /**
   * Percentage of current progress of simulation.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  progress: Scalars['Float']['output'];
  /**
   * Time simulation was last updated.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  updatedAt: Scalars['EpochMilliseconds']['output'];
};

/** Blueprint for simulation creation. */
export type CorrelationSimulationBlueprint = {
  /** Length of the window in which incidents are compared. */
  correlationWindowLength?: InputMaybe<Scalars['Milliseconds']['input']>;
  /** Expression to use to compare incidents. */
  expression: CorrelationRuleExpressionInput;
  /** Number of correlated incidents within window required to merge issues. */
  minCorrelationThreshold?: InputMaybe<Scalars['Int']['input']>;
  /** Duration to consider resources for. */
  retentionWindowLength?: InputMaybe<Scalars['Milliseconds']['input']>;
};

/** A suggested correlation rule. */
export type CorrelationSuggestion = {
  __typename?: 'CorrelationSuggestion';
  /**
   * Length of the window in which incidents are compared.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  correlationWindowLength?: Maybe<Scalars['Milliseconds']['output']>;
  /**
   * Time suggestion was created.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  createdAt: Scalars['EpochMilliseconds']['output'];
  /**
   * Description of suggestion.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  description?: Maybe<Scalars['String']['output']>;
  /**
   * External hash of suggestion.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  hash: Scalars['String']['output'];
  /**
   * ID of suggestion.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  id: Scalars['ID']['output'];
  /**
   * Number of correlations within a window required to merge issues.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  minCorrelationThreshold: Scalars['Int']['output'];
  /**
   * Name of suggestion.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  name: Scalars['String']['output'];
  /**
   * Configuration to allow rule to override issue properties.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  overrideConfiguration?: Maybe<CorrelationOverrideConfiguration>;
  /**
   * Expression to use to compare incidents.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  ruleExpression: Scalars['CorrelationRuleExpression']['output'];
  /**
   * Acceptance state of suggestion.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  state: CorrelationSuggestionState;
  /**
   * Service/user that created this suggestion.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  suggester: Scalars['String']['output'];
  /**
   * External support for suggestion.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  support?: Maybe<Scalars['String']['output']>;
};

/** Blueprint for suggestion creation. */
export type CorrelationSuggestionBlueprint = {
  /** Length of the window in which incidents are compared. */
  correlationWindowLength?: InputMaybe<Scalars['Milliseconds']['input']>;
  /** Description of suggestion. */
  description?: InputMaybe<Scalars['String']['input']>;
  /** Hash of suggestion. */
  hash: Scalars['String']['input'];
  /** Number of correlations within a window required to merge issues. */
  minCorrelationThreshold?: InputMaybe<Scalars['Int']['input']>;
  /** Name of suggestion. */
  name: Scalars['String']['input'];
  /** Configuration to allow rule to override issue properties. */
  overrideConfiguration?: InputMaybe<CorrelationOverrideConfigurationInput>;
  /** Expression to use to compare incidents. */
  ruleExpression: CorrelationRuleExpressionInput;
  /** Service/user that created this suggestion. */
  suggester: Scalars['String']['input'];
  /** Support for suggestion. */
  support?: InputMaybe<Scalars['String']['input']>;
};

/** Windowed view of an account's suggestions. */
export type CorrelationSuggestionListing = {
  __typename?: 'CorrelationSuggestionListing';
  /**
   * Number of suggestions in this window.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  count: Scalars['Int']['output'];
  /**
   * Cursor used to fetch next page.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  nextCursor?: Maybe<Scalars['String']['output']>;
  /**
   * Cursor used to fetch previous page.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  prevCursor?: Maybe<Scalars['String']['output']>;
  /**
   * List of suggestions in this window.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  suggestions: Array<CorrelationSuggestion>;
};

/** Sorting method for suggestions. */
export enum CorrelationSuggestionSortMethod {
  /**
   * Sort rules by age
   * @deprecated This field is experimental and subject to breaking changes.
   */
  Age = 'AGE',
  /**
   * Sort rules by id
   * @deprecated This field is experimental and subject to breaking changes.
   */
  Id = 'ID'
}

/** State of suggestion */
export enum CorrelationSuggestionState {
  /**
   * Suggestion is accepted
   * @deprecated This field is experimental and subject to breaking changes.
   */
  Accepted = 'ACCEPTED',
  /**
   * Suggestion is declined
   * @deprecated This field is experimental and subject to breaking changes.
   */
  Declined = 'DECLINED',
  /**
   * Suggestion is postponed
   * @deprecated This field is experimental and subject to breaking changes.
   */
  Postponed = 'POSTPONED',
  /**
   * Suggestion is undecided
   * @deprecated This field is experimental and subject to breaking changes.
   */
  Undecided = 'UNDECIDED'
}

/** Class of vertex. */
export enum CorrelationVertexClass {
  /**
   * Vertex class is application
   * @deprecated This field is experimental and subject to breaking changes.
   */
  Application = 'APPLICATION',
  /**
   * Vertex class is browserapplication
   * @deprecated This field is experimental and subject to breaking changes.
   */
  Browserapplication = 'BROWSERAPPLICATION',
  /**
   * Vertex class is cloudservice
   * @deprecated This field is experimental and subject to breaking changes.
   */
  Cloudservice = 'CLOUDSERVICE',
  /**
   * Vertex class is cluster
   * @deprecated This field is experimental and subject to breaking changes.
   */
  Cluster = 'CLUSTER',
  /**
   * Vertex class is datastore
   * @deprecated This field is experimental and subject to breaking changes.
   */
  Datastore = 'DATASTORE',
  /**
   * Vertex class is host
   * @deprecated This field is experimental and subject to breaking changes.
   */
  Host = 'HOST',
  /**
   * Vertex class is monitor
   * @deprecated This field is experimental and subject to breaking changes.
   */
  Monitor = 'MONITOR',
  /**
   * Vertex class is team
   * @deprecated This field is experimental and subject to breaking changes.
   */
  Team = 'TEAM'
}

/** Input type for WholeCosineDistance expression */
export type CorrelationWholeCosineDistanceInput = {
  /** Maximum distance threshold. */
  maxDistance: Scalars['Float']['input'];
};

/** Input type for WholeJaccardSimilarity expression */
export type CorrelationWholeJaccardSimilarityInput = {
  /** Threshold for comparison. */
  threshold: Scalars['Float']['input'];
};

export type CourierNotificationPreferencesActorStitchedFields = {
  __typename?: 'CourierNotificationPreferencesActorStitchedFields';
  /**
   * Get notification preferences for a user
   * @deprecated This field is experimental and subject to breaking changes.
   */
  notificationPreferences?: Maybe<Array<Maybe<CourierNotificationPreferencesNotificationPreference>>>;
};

/** User notification preference */
export type CourierNotificationPreferencesNotificationPreference = {
  __typename?: 'CourierNotificationPreferencesNotificationPreference';
  /**
   * Indicates whether the user is opted in for this subscription
   * @deprecated This field is experimental and subject to breaking changes.
   */
  isOptedIn: Scalars['Boolean']['output'];
  /**
   * Unique identifier for the subscription topic
   * @deprecated This field is experimental and subject to breaking changes.
   */
  topicId: Scalars['String']['output'];
  /**
   * Name of the subscription topic
   * @deprecated This field is experimental and subject to breaking changes.
   */
  topicName: Scalars['String']['output'];
};

/** Represents the subscription status of a user */
export enum CourierNotificationPreferencesSubscriptionStatus {
  /**
   * The user has opted in to receive notifications
   * @deprecated This field is experimental and subject to breaking changes.
   */
  OptedIn = 'OPTED_IN',
  /**
   * The user has opted out and will not receive notifications
   * @deprecated This field is experimental and subject to breaking changes.
   */
  OptedOut = 'OPTED_OUT'
}

/** Input for a subscription topic */
export type CourierNotificationPreferencesTopic = {
  /** New subscription status */
  status: CourierNotificationPreferencesSubscriptionStatus;
  /** Unique identifier for the subscription topic */
  topicId: Scalars['String']['input'];
};

/** Input for updated notification preference */
export type CourierNotificationPreferencesUpdatedNotificationPreference = {
  /** Details of the subscription topic to update */
  topic: CourierNotificationPreferencesTopic;
};

/** Response to an updated subscription request */
export type CourierNotificationPreferencesUpdatedNotificationPreferenceResponse = {
  __typename?: 'CourierNotificationPreferencesUpdatedNotificationPreferenceResponse';
  /**
   * Message describing the updated subscription status
   * @deprecated This field is experimental and subject to breaking changes.
   */
  message: Scalars['String']['output'];
  /**
   * Unique identifier for the subscription topic
   * @deprecated This field is experimental and subject to breaking changes.
   */
  topicId: Scalars['String']['output'];
};

/** Data that spans _all_ of the `currentUser`'s `authorizedAccounts`. */
export type CrossAccount = {
  __typename?: 'CrossAccount';
  /**
   * Fetches a single capability, looking across all of the `currentUser`'s `authorizedAccounts`
   * @deprecated `currentUser.crossAccount.capability` queries are deprecated. The `actor.capabilities` queries should be used as a replacement. GLOBAL, ACTOR, or ORGANIZATION scope types should be used when replacing capability checks that historically used `currentUser.crossAccount.capability` queries.
   */
  capability?: Maybe<CrossAccountCapability>;
  /** Fetches a single entitlement, looking across all of the `currentUser`'s `authorizedAccounts` */
  entitlement?: Maybe<CrossAccountEntitlement>;
  /**
   * For each in-region `authorizedAccount` for the request's `currentUser`,
   * evaluate a single Feature Flag with the `context`:
   * * User: The request's `currentUser`
   * * Account: The authorized account
   * * NR Admin: The request's NR Admin state
   *
   * After evaluating the Feature Flag for each account, the field will
   * return `true` if any of the evaluations are true. If the user does
   * not have any in-region `authorizedAccounts`, this field will always
   * return `false`.
   */
  featureFlag?: Maybe<CrossAccountFeatureFlag>;
};


/** Data that spans _all_ of the `currentUser`'s `authorizedAccounts`. */
export type CrossAccountCapabilityArgs = {
  name: Scalars['String']['input'];
};


/** Data that spans _all_ of the `currentUser`'s `authorizedAccounts`. */
export type CrossAccountEntitlementArgs = {
  name: Scalars['String']['input'];
};


/** Data that spans _all_ of the `currentUser`'s `authorizedAccounts`. */
export type CrossAccountFeatureFlagArgs = {
  name: Scalars['String']['input'];
};

/** The result of evaluating a capability across all of the `currentUser`'s `authorizedAccounts`. */
export type CrossAccountCapability = {
  __typename?: 'CrossAccountCapability';
  /** The name of the capability. */
  name?: Maybe<Scalars['String']['output']>;
  /** The boolean value indicating if any of the `authorizedAccounts` have this capability. */
  value?: Maybe<Scalars['Boolean']['output']>;
};

/** The result of evaluating an entitlement across all of the `currentUser`'s `authorizedAccounts`. */
export type CrossAccountEntitlement = {
  __typename?: 'CrossAccountEntitlement';
  /** The name of the entitlement. */
  name?: Maybe<Scalars['String']['output']>;
  /** The boolean value indicating if any of the `authorizedAccounts` have this entitlement. */
  value?: Maybe<Scalars['Boolean']['output']>;
};

/** The result of evaluating a Feature Flag across all of the `currentUser`'s `authorizedAccounts` */
export type CrossAccountFeatureFlag = {
  __typename?: 'CrossAccountFeatureFlag';
  name?: Maybe<Scalars['String']['output']>;
  value?: Maybe<Scalars['Boolean']['output']>;
};

/**
 * A data structure that contains the results of the multi account NRDB query along
 * with other capabilities that enhance those results.
 *
 * Direct query results are available through `results`, `totalResult` and
 * `otherResult`. The query you made is accessible through `nrql`, along with
 * `metadata` about the query itself.
 */
export type CrossAccountNrdbResultContainer = {
  __typename?: 'CrossAccountNrdbResultContainer';
  /** In a `COMPARE WITH` query, the `currentResults` contain the results for the current comparison time window. */
  currentResults?: Maybe<Array<Maybe<Scalars['NrdbResult']['output']>>>;
  /**
   * Retrieve a list of event type definitions, providing descriptions
   * of the event types returned by this query, as well as details
   * of their attributes.
   */
  eventDefinitions?: Maybe<Array<Maybe<EventDefinition>>>;
  /** Metadata about the query and result. */
  metadata?: Maybe<NrdbMetadata>;
  /** The [NRQL](https://docs.newrelic.com/docs/insights/nrql-new-relic-query-language/nrql-resources/nrql-syntax-components-functions) query that was executed to yield these results. */
  nrql?: Maybe<Scalars['Nrql']['output']>;
  /**
   * In a `FACET` query, the `otherResult` contains the aggregates representing the events _not_
   * contained in an individual `results` facet.
   */
  otherResult?: Maybe<Scalars['NrdbResult']['output']>;
  /** In a `COMPARE WITH` query, the `previousResults` contain the results for the previous comparison time window. */
  previousResults?: Maybe<Array<Maybe<Scalars['NrdbResult']['output']>>>;
  /** Metadata about the execution of an asynchronous NRQL query. */
  queryProgress?: Maybe<NrdbQueryProgress>;
  /** The raw query results exactly as they are returned from NRDB. NerdGraph provides no additional transformation. */
  rawResponse?: Maybe<Scalars['NrdbRawResults']['output']>;
  /** The query results. This is a flat list of objects who's structure matches the query submitted. */
  results?: Maybe<Array<Maybe<Scalars['NrdbResult']['output']>>>;
  /**
   * In a `FACET` query, the `totalResult` contains the aggregates representing _all_ the events,
   * whether or not they are contained in an individual `results` facet.
   */
  totalResult?: Maybe<Scalars['NrdbResult']['output']>;
};

/** The `CustomerAdministration` object contains fields for managing the configuration that defines the business relationships between New Relic, partners, and customers. */
export type CustomerAdministration = {
  __typename?: 'CustomerAdministration';
  /** Accessible account shares */
  accountShares?: Maybe<OrganizationAccountShareCollection>;
  /** accounts */
  accounts?: Maybe<OrganizationAccountCollection>;
  /** Authentication domains */
  authenticationDomains?: Maybe<OrganizationAuthenticationDomainCollection>;
  /** The `consumption` field is the entry point into a customer's consumption data that is scoped to the ID of the customer. */
  consumption?: Maybe<Consumption>;
  /** Accessible contracts */
  contracts?: Maybe<OrganizationCustomerContractWrapper>;
  /** list of grants */
  grants?: Maybe<MultiTenantAuthorizationGrantCollection>;
  /** Named sets of New Relic users within an authentication domain */
  groups?: Maybe<MultiTenantIdentityGroupCollection>;
  /** This provides access to fields you can use to check the status of asynchronous jobs related to customer administration. */
  jobs?: Maybe<CustomerAdministrationJobs>;
  /** Accessible organizations */
  organizations?: Maybe<OrganizationCustomerOrganizationWrapper>;
  /** list of permissions */
  permissions?: Maybe<MultiTenantAuthorizationPermissionCollection>;
  /** This field provides access to ProductConsumption data. */
  productConsumption?: Maybe<ProductConsumptionCustomerAdministrationStitchedFields>;
  /** list of roles */
  roles?: Maybe<MultiTenantAuthorizationRoleCollection>;
  /** The authenticated `User` who made this request. */
  user?: Maybe<User>;
  /** A collection of New Relic users */
  users?: Maybe<MultiTenantIdentityUserCollection>;
};


/** The `CustomerAdministration` object contains fields for managing the configuration that defines the business relationships between New Relic, partners, and customers. */
export type CustomerAdministrationAccountSharesArgs = {
  cursor?: InputMaybe<Scalars['String']['input']>;
  filter: OrganizationAccountShareFilterInput;
  sort?: InputMaybe<Array<OrganizationAccountShareSortInput>>;
};


/** The `CustomerAdministration` object contains fields for managing the configuration that defines the business relationships between New Relic, partners, and customers. */
export type CustomerAdministrationAccountsArgs = {
  cursor?: InputMaybe<Scalars['String']['input']>;
  filter: OrganizationAccountFilterInput;
  sort?: InputMaybe<Array<OrganizationAccountSortInput>>;
};


/** The `CustomerAdministration` object contains fields for managing the configuration that defines the business relationships between New Relic, partners, and customers. */
export type CustomerAdministrationAuthenticationDomainsArgs = {
  cursor?: InputMaybe<Scalars['String']['input']>;
  filter: OrganizationAuthenticationDomainFilterInput;
  sort?: InputMaybe<Array<OrganizationAuthenticationDomainSortInput>>;
};


/** The `CustomerAdministration` object contains fields for managing the configuration that defines the business relationships between New Relic, partners, and customers. */
export type CustomerAdministrationConsumptionArgs = {
  customerId: Scalars['ID']['input'];
};


/** The `CustomerAdministration` object contains fields for managing the configuration that defines the business relationships between New Relic, partners, and customers. */
export type CustomerAdministrationContractsArgs = {
  cursor?: InputMaybe<Scalars['String']['input']>;
  filter?: InputMaybe<OrganizationCustomerContractFilterInput>;
};


/** The `CustomerAdministration` object contains fields for managing the configuration that defines the business relationships between New Relic, partners, and customers. */
export type CustomerAdministrationGrantsArgs = {
  cursor?: InputMaybe<Scalars['String']['input']>;
  filter: MultiTenantAuthorizationGrantFilterInputExpression;
  sort?: InputMaybe<Array<MultiTenantAuthorizationGrantSortInput>>;
};


/** The `CustomerAdministration` object contains fields for managing the configuration that defines the business relationships between New Relic, partners, and customers. */
export type CustomerAdministrationGroupsArgs = {
  cursor?: InputMaybe<Scalars['String']['input']>;
  filter: MultiTenantIdentityGroupFilterInput;
  sort?: InputMaybe<Array<MultiTenantIdentityGroupSortInput>>;
};


/** The `CustomerAdministration` object contains fields for managing the configuration that defines the business relationships between New Relic, partners, and customers. */
export type CustomerAdministrationOrganizationsArgs = {
  cursor?: InputMaybe<Scalars['String']['input']>;
  filter?: InputMaybe<OrganizationCustomerOrganizationFilterInput>;
};


/** The `CustomerAdministration` object contains fields for managing the configuration that defines the business relationships between New Relic, partners, and customers. */
export type CustomerAdministrationPermissionsArgs = {
  cursor?: InputMaybe<Scalars['String']['input']>;
  filter?: InputMaybe<MultiTenantAuthorizationPermissionFilter>;
};


/** The `CustomerAdministration` object contains fields for managing the configuration that defines the business relationships between New Relic, partners, and customers. */
export type CustomerAdministrationRolesArgs = {
  cursor?: InputMaybe<Scalars['String']['input']>;
  filter: MultiTenantAuthorizationRoleFilterInputExpression;
  sort?: InputMaybe<Array<MultiTenantAuthorizationRoleSortInput>>;
};


/** The `CustomerAdministration` object contains fields for managing the configuration that defines the business relationships between New Relic, partners, and customers. */
export type CustomerAdministrationUsersArgs = {
  cursor?: InputMaybe<Scalars['String']['input']>;
  filter: MultiTenantIdentityUserFilterInput;
  sort?: InputMaybe<Array<MultiTenantIdentityUserSortInput>>;
};

export type CustomerAdministrationJobs = {
  __typename?: 'CustomerAdministrationJobs';
  /** Organization Create job results */
  organizationCreateAsyncResults?: Maybe<OrganizationOrganizationCreateAsyncResultCollection>;
};


export type CustomerAdministrationJobsOrganizationCreateAsyncResultsArgs = {
  cursor?: InputMaybe<Scalars['String']['input']>;
  filter: OrganizationOrganizationCreateAsyncResultFilterInput;
};

/** Type defined so its fields will be merged directly into NerdGraph's Actor type. */
export type DashboardActorStitchedFields = {
  __typename?: 'DashboardActorStitchedFields';
  /** Fetch the list of live URLs created by the API user. */
  liveUrls?: Maybe<DashboardLiveUrlResult>;
};


/** Type defined so its fields will be merged directly into NerdGraph's Actor type. */
export type DashboardActorStitchedFieldsLiveUrlsArgs = {
  filter?: InputMaybe<DashboardLiveUrlsFilterInput>;
};

/** Expected errors that can be returned by addWidgetsToPage operation. */
export type DashboardAddWidgetsToPageError = {
  __typename?: 'DashboardAddWidgetsToPageError';
  /** Error description. */
  description?: Maybe<Scalars['String']['output']>;
  /** Error type. */
  type: DashboardAddWidgetsToPageErrorType;
};

/** Expected error types that can be returned by addWidgetsToPage operation. */
export enum DashboardAddWidgetsToPageErrorType {
  /** User is not allowed to execute the operation. */
  ForbiddenOperation = 'FORBIDDEN_OPERATION',
  /** Invalid input error. */
  InvalidInput = 'INVALID_INPUT',
  /** Page not found in the system. */
  PageNotFound = 'PAGE_NOT_FOUND'
}

/** Result of addWidgetsToPage operation. */
export type DashboardAddWidgetsToPageResult = {
  __typename?: 'DashboardAddWidgetsToPageResult';
  /** Expected errors while processing request. No errors means successful request. */
  errors?: Maybe<Array<Maybe<DashboardAddWidgetsToPageError>>>;
};

/** Alert severity. */
export enum DashboardAlertSeverity {
  /** CRITICAL. */
  Critical = 'CRITICAL',
  /** NOT_ALERTING. */
  NotAlerting = 'NOT_ALERTING',
  /** WARNING. */
  Warning = 'WARNING'
}

/** Configuration for visualization type 'viz.area' */
export type DashboardAreaWidgetConfiguration = {
  __typename?: 'DashboardAreaWidgetConfiguration';
  /** NRQL queries. */
  nrqlQueries?: Maybe<Array<Maybe<DashboardWidgetNrqlQuery>>>;
};

/** Configuration for visualization type 'viz.area' */
export type DashboardAreaWidgetConfigurationInput = {
  /** NRQL queries. */
  nrqlQueries?: InputMaybe<Array<DashboardWidgetNrqlQueryInput>>;
};

/** Configuration for visualization type 'viz.bar' */
export type DashboardBarWidgetConfiguration = {
  __typename?: 'DashboardBarWidgetConfiguration';
  /** NRQL queries. */
  nrqlQueries?: Maybe<Array<Maybe<DashboardWidgetNrqlQuery>>>;
};

/** Configuration for visualization type 'viz.bar'. Learn more about [bar](https://docs.newrelic.com/docs/apis/nerdgraph/examples/create-widgets-dashboards-api/#bar) widget. */
export type DashboardBarWidgetConfigurationInput = {
  /** NRQL queries. */
  nrqlQueries?: InputMaybe<Array<DashboardWidgetNrqlQueryInput>>;
};

/** Configuration for visualization type 'viz.billboard' */
export type DashboardBillboardWidgetConfiguration = {
  __typename?: 'DashboardBillboardWidgetConfiguration';
  /** NRQL queries. */
  nrqlQueries?: Maybe<Array<Maybe<DashboardWidgetNrqlQuery>>>;
  /** Array of thresholds to categorize the results of the query in different groups. */
  thresholds?: Maybe<Array<Maybe<DashboardBillboardWidgetThreshold>>>;
};

/** Configuration for visualization type 'viz.billboard'. Learn more about [billboard](https://docs.newrelic.com/docs/apis/nerdgraph/examples/create-widgets-dashboards-api/#billboard) widget. */
export type DashboardBillboardWidgetConfigurationInput = {
  /** NRQL queries. */
  nrqlQueries?: InputMaybe<Array<DashboardWidgetNrqlQueryInput>>;
  /** Array of thresholds to categorize the results of the query in different groups. */
  thresholds?: InputMaybe<Array<DashboardBillboardWidgetThresholdInput>>;
};

/** Billboard widget threshold. */
export type DashboardBillboardWidgetThreshold = {
  __typename?: 'DashboardBillboardWidgetThreshold';
  /** Alert severity. */
  alertSeverity?: Maybe<DashboardAlertSeverity>;
  /** Alert value. */
  value?: Maybe<Scalars['Float']['output']>;
};

/** Billboard widget threshold input. */
export type DashboardBillboardWidgetThresholdInput = {
  /** Severity of the alert. */
  alertSeverity?: InputMaybe<DashboardAlertSeverity>;
  /** Value of the alert. */
  value?: InputMaybe<Scalars['Float']['input']>;
};

/** Expected errors that can be returned by create operation. */
export type DashboardCreateError = {
  __typename?: 'DashboardCreateError';
  /** Error description. */
  description?: Maybe<Scalars['String']['output']>;
  /** Error type. */
  type: DashboardCreateErrorType;
};

/** Expected error types that can be returned by create operation. */
export enum DashboardCreateErrorType {
  /** Invalid input error. */
  InvalidInput = 'INVALID_INPUT'
}

/** Result of create operation. */
export type DashboardCreateResult = {
  __typename?: 'DashboardCreateResult';
  /** Dashboard creation result. */
  entityResult?: Maybe<DashboardEntityResult>;
  /** Expected errors while processing request. */
  errors?: Maybe<Array<Maybe<DashboardCreateError>>>;
};

/** Expected error types that can be returned by delete operation. */
export type DashboardDeleteError = {
  __typename?: 'DashboardDeleteError';
  /** Error description. */
  description?: Maybe<Scalars['String']['output']>;
  /** Error type. */
  type: DashboardDeleteErrorType;
};

/** Expected error types that can be returned by delete operation. */
export enum DashboardDeleteErrorType {
  /** Dashboard not found in the system. */
  DashboardNotFound = 'DASHBOARD_NOT_FOUND',
  /** User is not allowed to execute the operation. */
  ForbiddenOperation = 'FORBIDDEN_OPERATION'
}

/** Result of delete operation. */
export type DashboardDeleteResult = {
  __typename?: 'DashboardDeleteResult';
  /** Expected errors while processing request. */
  errors?: Maybe<Array<Maybe<DashboardDeleteError>>>;
  /** The status of the attempted delete. */
  status?: Maybe<DashboardDeleteResultStatus>;
};

/** Result status of delete operation. */
export enum DashboardDeleteResultStatus {
  /** FAILURE. */
  Failure = 'FAILURE',
  /** SUCCESS. */
  Success = 'SUCCESS'
}

/** A Dashboard entity. */
export type DashboardEntity = AlertableEntity & Entity & {
  __typename?: 'DashboardEntity';
  account?: Maybe<AccountOutline>;
  /** The New Relic account ID associated with this entity. */
  accountId?: Maybe<Scalars['Int']['output']>;
  /** The current alerting severity of the entity. */
  alertSeverity?: Maybe<EntityAlertSeverity>;
  /**
   * The alert status of the entity.
   * @deprecated Please use `alertSeverity` and `reporting`
   */
  alertStatus?: Maybe<EntityAlertStatus>;
  /** Violations on the entity that were open during the specified time window. This will return up to 500 violations - if there are more in the time window selected, you must narrow the time window or look at fewer entities. */
  alertViolations?: Maybe<Array<Maybe<EntityAlertViolation>>>;
  /** The date and time the dashboard was created */
  createdAt?: Maybe<Scalars['DateTime']['output']>;
  /** The parent entity `guid` of the dashboard. */
  dashboardParentGuid?: Maybe<Scalars['EntityGuid']['output']>;
  /** Retrieve the deployment event(s). Ordered by timestamp DESC. */
  deploymentSearch?: Maybe<ChangeTrackingDeploymentSearchResult>;
  /** Dashboard description. */
  description?: Maybe<Scalars['String']['output']>;
  /** The entity's domain */
  domain?: Maybe<Scalars['String']['output']>;
  /** A value representing the combination of the entity's domain and type. */
  entityType?: Maybe<EntityType>;
  /** The date of last time the entity has updated any of its fields. */
  firstIndexedAt?: Maybe<Scalars['EpochMilliseconds']['output']>;
  /** The list of golden metrics for a specific entity */
  goldenMetrics?: Maybe<EntityGoldenContextScopedGoldenMetrics>;
  /**
   * For the golden signal on this entity, show correlated signals from related entities.
   * Well inspect the golden signals for all related entities and return a sorted list.
   * You can also filter the results.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  goldenSignalCorrelations?: Maybe<GoldenSignalCorrelationResult>;
  /**
   * The deviation from normal of golden signal(s) for the given entity.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  goldenSignalDeviations?: Maybe<Array<Maybe<GoldenSignalSignalDeviation>>>;
  /**
   * The stored golden signal(s) for the given entity.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  goldenSignalValues?: Maybe<GoldenSignalValues>;
  /**
   * The stored golden signal(s) for the given entity. To be removed, use goldenSignalValues instead.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  goldenSignalValuesV2?: Maybe<GoldenSignalValues>;
  /** The list of golden tags for a specific entityType. */
  goldenTags?: Maybe<EntityGoldenContextScopedGoldenTags>;
  /** A unique entity identifier. */
  guid?: Maybe<Scalars['EntityGuid']['output']>;
  /** The time the entity was indexed. */
  indexedAt?: Maybe<Scalars['EpochMilliseconds']['output']>;
  /** The last time the entity's reporting status changed. */
  lastReportingChangeAt?: Maybe<Scalars['EpochMilliseconds']['output']>;
  /** The name of this entity. */
  name?: Maybe<Scalars['String']['output']>;
  nerdStorage?: Maybe<NerdStorageEntityScope>;
  nerdStoreCollection?: Maybe<Array<Maybe<NerdStoreCollectionMember>>>;
  nerdStoreDocument?: Maybe<Scalars['NerdStoreDocument']['output']>;
  /**
   * Make an `Entity` scoped query to NRDB with a NRQL string.
   *
   * A relevant `WHERE` clause will be added to your query to scope data to the entity in question.
   *
   * See the [NRQL Docs](https://docs.newrelic.com/docs/insights/nrql-new-relic-query-language/nrql-resources/nrql-syntax-components-functions) for more information about generating a query string.
   */
  nrdbQuery?: Maybe<NrdbResultContainer>;
  /**
   * Poll for the results of a previously-executed asychronous NRDB query.
   *
   * The `queryId` is available in the `queryProgress` data returned by the original asynchronous query.
   *
   * See [this page](https://docs.newrelic.com/docs/apis/nerdgraph/examples/async-queries-nrql-tutorial) for additional asynchronous query documentation.
   * @deprecated This field is experimental! It may change at any time.
   *
   */
  nrdbQueryProgress?: Maybe<NrdbResultContainer>;
  /** The owner information of the dashboard. */
  owner?: Maybe<DashboardEntityOwnerInfo>;
  /** A nested block of all pages belonging to the dashboard. */
  pages?: Maybe<Array<Maybe<DashboardPage>>>;
  /** The url to the entity. */
  permalink?: Maybe<Scalars['String']['output']>;
  /** The permissions of the dashboard. */
  permissions?: Maybe<DashboardEntityPermissions>;
  /** Recent violations on the entity. */
  recentAlertViolations?: Maybe<Array<Maybe<EntityAlertViolation>>>;
  /** The recommended service levels for the entity. */
  recommendedServiceLevel?: Maybe<ServiceLevelRecommendation>;
  /** Related dashboards results */
  relatedDashboards: RelatedDashboardsRelatedDashboardResult;
  /** Related entities result with optional filtering. */
  relatedEntities?: Maybe<EntityRelationshipRelatedEntitiesResult>;
  /** Relationship traversal results with optional filtering. WARNING: this query is still experimental, and subject to breaking changes. */
  relationshipTraversal?: Maybe<EntityRelationshipTraversalResult>;
  /**
   * A list of the entities' relationships.
   *
   * For more information, visit [our docs](https://docs.newrelic.com/docs/apis/graphql-api/tutorials/graphql-relationships-api-tutorial).
   * @deprecated This field is deprecated! Please use `relatedEntities`.
   */
  relationships?: Maybe<Array<Maybe<EntityRelationship>>>;
  /** The reporting status of the entity. If New Relic is successfully collecting data from your application, this will be true. */
  reporting?: Maybe<Scalars['Boolean']['output']>;
  /** The service level defined for the entity. */
  serviceLevel?: Maybe<ServiceLevelDefinition>;
  /** The list of summary metrics. */
  summaryMetrics?: Maybe<Array<Maybe<EntitySummaryMetric>>>;
  /**
   * The tags applied to the entity.
   *
   * For details on tags, as well as query and mutation examples, visit [our docs](https://docs.newrelic.com/docs/apis/graphql-api/tutorials/graphql-tagging-api-tutorial).
   */
  tags?: Maybe<Array<Maybe<EntityTag>>>;
  /** The tags applied to the entity with their metadata. */
  tagsWithMetadata?: Maybe<Array<Maybe<EntityTagWithMetadata>>>;
  /** Look up Distributed Tracing summary data for the selected `EntityGuid` */
  tracingSummary?: Maybe<DistributedTracingEntityTracingSummary>;
  /** The entity's type */
  type?: Maybe<Scalars['String']['output']>;
  /** List of templates availables for this entity. */
  uiTemplates?: Maybe<Array<EntityDashboardTemplatesUi>>;
  /** The date and time the dashboard was updated */
  updatedAt?: Maybe<Scalars['DateTime']['output']>;
  /** Dashboard-local variable definitions. */
  variables?: Maybe<Array<Maybe<DashboardVariable>>>;
};


/** A Dashboard entity. */
export type DashboardEntityAlertViolationsArgs = {
  endTime: Scalars['EpochMilliseconds']['input'];
  startTime: Scalars['EpochMilliseconds']['input'];
};


/** A Dashboard entity. */
export type DashboardEntityDeploymentSearchArgs = {
  filter?: InputMaybe<ChangeTrackingSearchFilter>;
};


/** A Dashboard entity. */
export type DashboardEntityGoldenMetricsArgs = {
  context?: InputMaybe<EntityGoldenContextInput>;
  timeWindow?: InputMaybe<EntityGoldenNrqlTimeWindowInput>;
};


/** A Dashboard entity. */
export type DashboardEntityGoldenSignalCorrelationsArgs = {
  filter?: InputMaybe<GoldenSignalCorrelationsEntityFilter>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  timeWindow?: InputMaybe<TimeWindowInput>;
};


/** A Dashboard entity. */
export type DashboardEntityGoldenSignalDeviationsArgs = {
  comparisonTimeWindow?: InputMaybe<TimeWindowInput>;
  evaluationTimeWindow?: InputMaybe<TimeWindowInput>;
};


/** A Dashboard entity. */
export type DashboardEntityGoldenSignalValuesArgs = {
  timeWindow?: InputMaybe<TimeWindowInput>;
};


/** A Dashboard entity. */
export type DashboardEntityGoldenSignalValuesV2Args = {
  timeWindow?: InputMaybe<TimeWindowInput>;
};


/** A Dashboard entity. */
export type DashboardEntityGoldenTagsArgs = {
  context?: InputMaybe<EntityGoldenContextInput>;
};


/** A Dashboard entity. */
export type DashboardEntityNerdStoreCollectionArgs = {
  collection: Scalars['String']['input'];
  scopeByActor?: InputMaybe<Scalars['Boolean']['input']>;
};


/** A Dashboard entity. */
export type DashboardEntityNerdStoreDocumentArgs = {
  collection: Scalars['String']['input'];
  documentId: Scalars['String']['input'];
  scopeByActor?: InputMaybe<Scalars['Boolean']['input']>;
};


/** A Dashboard entity. */
export type DashboardEntityNrdbQueryArgs = {
  async?: InputMaybe<Scalars['Boolean']['input']>;
  nrql: Scalars['Nrql']['input'];
  options?: InputMaybe<NrqlQueryOptions>;
  timeout?: InputMaybe<Scalars['Seconds']['input']>;
};


/** A Dashboard entity. */
export type DashboardEntityNrdbQueryProgressArgs = {
  queryId: Scalars['ID']['input'];
};


/** A Dashboard entity. */
export type DashboardEntityRecentAlertViolationsArgs = {
  count?: InputMaybe<Scalars['Int']['input']>;
};


/** A Dashboard entity. */
export type DashboardEntityRelatedEntitiesArgs = {
  cursor?: InputMaybe<Scalars['String']['input']>;
  filter?: InputMaybe<EntityRelationshipEdgeFilter>;
  limit?: InputMaybe<Scalars['Int']['input']>;
};


/** A Dashboard entity. */
export type DashboardEntityRelationshipTraversalArgs = {
  cursor?: InputMaybe<Scalars['String']['input']>;
  hopFilters?: InputMaybe<EntityRelationshipTraversalHopFilters>;
  hops?: InputMaybe<Scalars['Int']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
};


/** A Dashboard entity. */
export type DashboardEntityRelationshipsArgs = {
  endTime?: InputMaybe<Scalars['EpochMilliseconds']['input']>;
  filter?: InputMaybe<EntityRelationshipFilter>;
};


/** A Dashboard entity. */
export type DashboardEntitySummaryMetricsArgs = {
  timeWindow?: InputMaybe<TimeWindowInput>;
};


/** A Dashboard entity. */
export type DashboardEntityTracingSummaryArgs = {
  timeWindow?: InputMaybe<TimeWindowInput>;
};

/** A Dashboard entity outline. */
export type DashboardEntityOutline = AlertableEntityOutline & EntityOutline & {
  __typename?: 'DashboardEntityOutline';
  account?: Maybe<AccountOutline>;
  /** The New Relic account ID associated with this entity. */
  accountId?: Maybe<Scalars['Int']['output']>;
  /** The current alerting severity of the entity. */
  alertSeverity?: Maybe<EntityAlertSeverity>;
  /**
   * The alert status of the entity.
   * @deprecated Please use `alertSeverity` and `reporting`
   */
  alertStatus?: Maybe<EntityAlertStatus>;
  /** The date and time the dashboard was created */
  createdAt?: Maybe<Scalars['DateTime']['output']>;
  /** The parent entity `guid` of the dashboard. */
  dashboardParentGuid?: Maybe<Scalars['EntityGuid']['output']>;
  /** The entity's domain */
  domain?: Maybe<Scalars['String']['output']>;
  /** A value representing the combination of the entity's domain and type. */
  entityType?: Maybe<EntityType>;
  /** The date of last time the entity has updated any of its fields. */
  firstIndexedAt?: Maybe<Scalars['EpochMilliseconds']['output']>;
  /** The list of golden metrics for a specific entity */
  goldenMetrics?: Maybe<EntityGoldenContextScopedGoldenMetrics>;
  /**
   * For the golden signal on this entity, show correlated signals from related entities.
   * Well inspect the golden signals for all related entities and return a sorted list.
   * You can also filter the results.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  goldenSignalCorrelations?: Maybe<GoldenSignalCorrelationResult>;
  /**
   * The deviation from normal of golden signal(s) for the given entity.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  goldenSignalDeviations?: Maybe<Array<Maybe<GoldenSignalSignalDeviation>>>;
  /**
   * The stored golden signal(s) for the given entity.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  goldenSignalValues?: Maybe<GoldenSignalValues>;
  /**
   * The stored golden signal(s) for the given entity. To be removed, use goldenSignalValues instead.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  goldenSignalValuesV2?: Maybe<GoldenSignalValues>;
  /** The list of golden tags for a specific entityType. */
  goldenTags?: Maybe<EntityGoldenContextScopedGoldenTags>;
  /** A unique entity identifier. */
  guid?: Maybe<Scalars['EntityGuid']['output']>;
  /** The time the entity was indexed. */
  indexedAt?: Maybe<Scalars['EpochMilliseconds']['output']>;
  /** The last time the entity's reporting status changed. */
  lastReportingChangeAt?: Maybe<Scalars['EpochMilliseconds']['output']>;
  /** The name of this entity. */
  name?: Maybe<Scalars['String']['output']>;
  /** The owner information of the dashboard. */
  owner?: Maybe<DashboardEntityOwnerInfo>;
  /** The url to the entity. */
  permalink?: Maybe<Scalars['String']['output']>;
  /** The permissions of the dashboard. */
  permissions?: Maybe<DashboardEntityPermissions>;
  /** The recommended service levels for the entity. */
  recommendedServiceLevel?: Maybe<ServiceLevelRecommendation>;
  /** Related dashboards results */
  relatedDashboards: RelatedDashboardsRelatedDashboardResult;
  /** The reporting status of the entity. If New Relic is successfully collecting data from your application, this will be true. */
  reporting?: Maybe<Scalars['Boolean']['output']>;
  /** The service level defined for the entity. */
  serviceLevel?: Maybe<ServiceLevelDefinition>;
  /** The list of summary metrics. */
  summaryMetrics?: Maybe<Array<Maybe<EntitySummaryMetric>>>;
  /**
   * The tags applied to the entity.
   *
   * For details on tags, as well as query and mutation examples, visit [our docs](https://docs.newrelic.com/docs/apis/graphql-api/tutorials/graphql-tagging-api-tutorial).
   */
  tags?: Maybe<Array<Maybe<EntityTag>>>;
  /** The entity's type */
  type?: Maybe<Scalars['String']['output']>;
  /** List of templates availables for this entity. */
  uiTemplates?: Maybe<Array<EntityDashboardTemplatesUi>>;
  /** The date and time the dashboard was updated */
  updatedAt?: Maybe<Scalars['DateTime']['output']>;
};


/** A Dashboard entity outline. */
export type DashboardEntityOutlineGoldenMetricsArgs = {
  context?: InputMaybe<EntityGoldenContextInput>;
  timeWindow?: InputMaybe<EntityGoldenNrqlTimeWindowInput>;
};


/** A Dashboard entity outline. */
export type DashboardEntityOutlineGoldenSignalCorrelationsArgs = {
  filter?: InputMaybe<GoldenSignalCorrelationsEntityFilter>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  timeWindow?: InputMaybe<TimeWindowInput>;
};


/** A Dashboard entity outline. */
export type DashboardEntityOutlineGoldenSignalDeviationsArgs = {
  comparisonTimeWindow?: InputMaybe<TimeWindowInput>;
  evaluationTimeWindow?: InputMaybe<TimeWindowInput>;
};


/** A Dashboard entity outline. */
export type DashboardEntityOutlineGoldenSignalValuesArgs = {
  timeWindow?: InputMaybe<TimeWindowInput>;
};


/** A Dashboard entity outline. */
export type DashboardEntityOutlineGoldenSignalValuesV2Args = {
  timeWindow?: InputMaybe<TimeWindowInput>;
};


/** A Dashboard entity outline. */
export type DashboardEntityOutlineGoldenTagsArgs = {
  context?: InputMaybe<EntityGoldenContextInput>;
};


/** A Dashboard entity outline. */
export type DashboardEntityOutlineSummaryMetricsArgs = {
  timeWindow?: InputMaybe<TimeWindowInput>;
};

/** Dashboard owner */
export type DashboardEntityOwnerInfo = {
  __typename?: 'DashboardEntityOwnerInfo';
  /** The email of the dashboard owner */
  email?: Maybe<Scalars['String']['output']>;
  /** The user ID of the dashboard owner */
  userId?: Maybe<Scalars['Int']['output']>;
};

/** Permisions that represent visibility & editability */
export enum DashboardEntityPermissions {
  /** Private */
  Private = 'PRIVATE',
  /** Public read only */
  PublicReadOnly = 'PUBLIC_READ_ONLY',
  /** Public read & write */
  PublicReadWrite = 'PUBLIC_READ_WRITE'
}

/** Public schema - `DashboardEntity` result representation for mutations. It's a subset of the `DashboardEntity` that inherits from the Entity type, but a complete different type. */
export type DashboardEntityResult = {
  __typename?: 'DashboardEntityResult';
  /** The New Relic account where the dashboard is created. */
  accountId?: Maybe<Scalars['Int']['output']>;
  /** Dashboard creation timestamp. */
  createdAt?: Maybe<Scalars['DateTime']['output']>;
  /** Brief text describing the dashboard. */
  description?: Maybe<Scalars['String']['output']>;
  /** Unique entity identifier. */
  guid?: Maybe<Scalars['EntityGuid']['output']>;
  /** The name of the dashboard. */
  name?: Maybe<Scalars['String']['output']>;
  /** Information of the user that owns the dashboard. */
  owner?: Maybe<DashboardOwnerInfo>;
  /** A nested block of all pages belonging to the dashboard. */
  pages?: Maybe<Array<Maybe<DashboardPage>>>;
  /** Dashboard permissions configuration. */
  permissions?: Maybe<DashboardPermissions>;
  /** Dashboard update timestamp. */
  updatedAt?: Maybe<Scalars['DateTime']['output']>;
  /** Dashboard-local variable definitions. */
  variables?: Maybe<Array<Maybe<DashboardVariable>>>;
};

/** Dashboard input. */
export type DashboardInput = {
  /** Brief text describing the dashboard. */
  description?: InputMaybe<Scalars['String']['input']>;
  /** The name of the dashboard. */
  name: Scalars['String']['input'];
  /** A nested block of all pages belonging to the dashboard. */
  pages: Array<DashboardPageInput>;
  /** Permissions to set level of visibility & editing. */
  permissions: DashboardPermissions;
  /** Dashboard-local variable definitions. */
  variables?: InputMaybe<Array<DashboardVariableInput>>;
};

/** Configuration for visualization type 'viz.line' */
export type DashboardLineWidgetConfiguration = {
  __typename?: 'DashboardLineWidgetConfiguration';
  /** NRQL queries. */
  nrqlQueries?: Maybe<Array<Maybe<DashboardWidgetNrqlQuery>>>;
};

/** Configuration for visualization type 'viz.line'. Learn more about [line](https://docs.newrelic.com/docs/apis/nerdgraph/examples/create-widgets-dashboards-api/#line) widget. */
export type DashboardLineWidgetConfigurationInput = {
  /** NRQL queries. */
  nrqlQueries?: InputMaybe<Array<DashboardWidgetNrqlQueryInput>>;
};

/** Live URL. */
export type DashboardLiveUrl = {
  __typename?: 'DashboardLiveUrl';
  /** Creation date. */
  createdAt?: Maybe<Scalars['EpochMilliseconds']['output']>;
  /** Title that describes the source entity that is accessible through the public live URL. */
  title?: Maybe<Scalars['String']['output']>;
  /** Live URL type. */
  type?: Maybe<DashboardLiveUrlType>;
  /** Public URL. */
  url: Scalars['String']['output'];
  /** The unique identifier of the public live URL. */
  uuid: Scalars['ID']['output'];
};

/** Live URL error. */
export type DashboardLiveUrlError = {
  __typename?: 'DashboardLiveUrlError';
  /** Description of the error. */
  description?: Maybe<Scalars['String']['output']>;
  /** Type of error. */
  type?: Maybe<DashboardLiveUrlErrorType>;
};

/** Live URL error type. */
export enum DashboardLiveUrlErrorType {
  /** General operation failure. */
  OperationFailure = 'OPERATION_FAILURE',
  /** Unauthorized error. */
  Unauthorized = 'UNAUTHORIZED',
  /** Not supported error. */
  Unsupported = 'UNSUPPORTED',
  /** URL not found in the system. */
  UrlNotFound = 'URL_NOT_FOUND'
}

/** Live URL result. */
export type DashboardLiveUrlResult = {
  __typename?: 'DashboardLiveUrlResult';
  /** The list of errors, if any. */
  errors?: Maybe<Array<Maybe<DashboardLiveUrlError>>>;
  /** Live URL. */
  liveUrls?: Maybe<Array<Maybe<DashboardLiveUrl>>>;
};

/** Live URL type. */
export enum DashboardLiveUrlType {
  /** Dashboard. */
  Dashboard = 'DASHBOARD',
  /** Widget. */
  Widget = 'WIDGET'
}

/** Live URLs input. */
export type DashboardLiveUrlsFilterInput = {
  /** Live URL type. */
  type?: InputMaybe<DashboardLiveUrlType>;
  /** The unique identifier of a public live URL. */
  uuid?: InputMaybe<Scalars['ID']['input']>;
};

/** Configuration for visualization type 'viz.markdown' */
export type DashboardMarkdownWidgetConfiguration = {
  __typename?: 'DashboardMarkdownWidgetConfiguration';
  /** Markdown content of the widget. */
  text: Scalars['String']['output'];
};

/** Configuration for visualization type 'viz.markdown'. Learn more about [markdown](https://docs.newrelic.com/docs/apis/nerdgraph/examples/create-widgets-dashboards-api/#markdown) widget. */
export type DashboardMarkdownWidgetConfigurationInput = {
  /** Markdown content of the widget. */
  text: Scalars['String']['input'];
};

/** Information on the owner of a dashboard or page. */
export type DashboardOwnerInfo = {
  __typename?: 'DashboardOwnerInfo';
  /** New Relic user email. */
  email?: Maybe<Scalars['String']['output']>;
  /** New Relic user ID. */
  userId?: Maybe<Scalars['Int']['output']>;
};

/** Page in a dashboard entity. */
export type DashboardPage = {
  __typename?: 'DashboardPage';
  /** Page creation timestamp. */
  createdAt?: Maybe<Scalars['DateTime']['output']>;
  /** Brief text describing the page. */
  description?: Maybe<Scalars['String']['output']>;
  /** Unique entity identifier. */
  guid?: Maybe<Scalars['EntityGuid']['output']>;
  /** The name of the page. */
  name?: Maybe<Scalars['String']['output']>;
  /** Information of the user that owns the page. */
  owner?: Maybe<DashboardOwnerInfo>;
  /** Page update timestamp. */
  updatedAt?: Maybe<Scalars['DateTime']['output']>;
  /** A nested block of all widgets belonging to the page. */
  widgets?: Maybe<Array<Maybe<DashboardWidget>>>;
};

/** Page input. */
export type DashboardPageInput = {
  /** Brief text describing the page. */
  description?: InputMaybe<Scalars['String']['input']>;
  /** Unique entity identifier of the Page to be updated. When null, it means a new Page will be created. */
  guid?: InputMaybe<Scalars['EntityGuid']['input']>;
  /** The name of the page. */
  name: Scalars['String']['input'];
  /** A nested block of all widgets belonging to the page. */
  widgets: Array<DashboardWidgetInput>;
};

/** Permissions that represent visibility & editing. */
export enum DashboardPermissions {
  /** Only you can see the dashboard. Everything but the metadata is hidden. */
  Private = 'PRIVATE',
  /** All users are able to see the dashboard, but only you have full rights to work with the dashboard. Other users can access the dashboard but are not able to edit or delete it, although they can duplicate it. */
  PublicReadOnly = 'PUBLIC_READ_ONLY',
  /** All users have full rights to the dashboard. */
  PublicReadWrite = 'PUBLIC_READ_WRITE'
}

/** Configuration for visualization type 'viz.pie' */
export type DashboardPieWidgetConfiguration = {
  __typename?: 'DashboardPieWidgetConfiguration';
  /** NRQL queries. */
  nrqlQueries?: Maybe<Array<Maybe<DashboardWidgetNrqlQuery>>>;
};

/** Configuration for visualization type 'viz.pie'.  Learn more about [pie](https://docs.newrelic.com/docs/apis/nerdgraph/examples/create-widgets-dashboards-api/#pie) widget. */
export type DashboardPieWidgetConfigurationInput = {
  /** NRQL queries. */
  nrqlQueries?: InputMaybe<Array<DashboardWidgetNrqlQueryInput>>;
};

/** Result of revokeLiveUrl operation. */
export type DashboardRevokeLiveDashboardUrlResult = {
  __typename?: 'DashboardRevokeLiveDashboardUrlResult';
  /** The unique identifier of the public live dashboard URL if revoked successfully, null otherwise. */
  id?: Maybe<Scalars['ID']['output']>;
};

/** Revoke live URL result. */
export type DashboardRevokeLiveUrlResult = {
  __typename?: 'DashboardRevokeLiveUrlResult';
  /** The list of errors, if any. */
  errors?: Maybe<Array<Maybe<DashboardLiveUrlError>>>;
  /** The unique identifier of the public live URL if revoked successfully, null otherwise. */
  uuid?: Maybe<Scalars['ID']['output']>;
};

/** Parameters that affect the data and the rendering of the dashboards returned by the snapshot url mutation. */
export type DashboardSnapshotUrlInput = {
  /** Period of time from which the data to be displayed on the dashboard will be obtained. */
  timeWindow?: InputMaybe<DashboardSnapshotUrlTimeWindowInput>;
};

/** Period of time from which the data to be displayed on the dashboard will be obtained. */
export type DashboardSnapshotUrlTimeWindowInput = {
  /** The starting time of the time window. If specified, an endTime or a duration must also be specified. */
  beginTime?: InputMaybe<Scalars['EpochMilliseconds']['input']>;
  /** The duration of the time window. */
  duration?: InputMaybe<Scalars['Milliseconds']['input']>;
  /** The end time of the time window. If specified, a beginTime or a duration must also be specified. */
  endTime?: InputMaybe<Scalars['EpochMilliseconds']['input']>;
};

/** Configuration for visualization type 'viz.table' */
export type DashboardTableWidgetConfiguration = {
  __typename?: 'DashboardTableWidgetConfiguration';
  /** NRQL queries. */
  nrqlQueries?: Maybe<Array<Maybe<DashboardWidgetNrqlQuery>>>;
};

/** Configuration for visualization type 'viz.table'.  Learn more about [table](https://docs.newrelic.com/docs/apis/nerdgraph/examples/create-widgets-dashboards-api/#table) widget. */
export type DashboardTableWidgetConfigurationInput = {
  /** NRQL queries. */
  nrqlQueries?: InputMaybe<Array<DashboardWidgetNrqlQueryInput>>;
};

/** Expected error types that can be returned by undelete operation. */
export type DashboardUndeleteError = {
  __typename?: 'DashboardUndeleteError';
  /** Error description. */
  description?: Maybe<Scalars['String']['output']>;
  /** Error type. */
  type: DashboardUndeleteErrorType;
};

/** Expected error types that can be returned by undelete operation. */
export enum DashboardUndeleteErrorType {
  /** Dashboard not found in the system. */
  DashboardNotFound = 'DASHBOARD_NOT_FOUND',
  /** User is not allowed to execute the operation. */
  ForbiddenOperation = 'FORBIDDEN_OPERATION'
}

/** Result of undelete operation. */
export type DashboardUndeleteResult = {
  __typename?: 'DashboardUndeleteResult';
  /** Expected errors while processing request. No errors means successful request. */
  errors?: Maybe<Array<Maybe<DashboardUndeleteError>>>;
};

/** Expected errors that can be returned by update operation. */
export type DashboardUpdateError = {
  __typename?: 'DashboardUpdateError';
  /** Error description. */
  description?: Maybe<Scalars['String']['output']>;
  /** Error type. */
  type: DashboardUpdateErrorType;
};

/** Expected error types that can be returned by update operation. */
export enum DashboardUpdateErrorType {
  /** User is not allowed to execute the operation. */
  ForbiddenOperation = 'FORBIDDEN_OPERATION',
  /** Invalid input error. */
  InvalidInput = 'INVALID_INPUT'
}

/** Expected errors that can be returned by updatePage operation. */
export type DashboardUpdatePageError = {
  __typename?: 'DashboardUpdatePageError';
  /** Error description. */
  description?: Maybe<Scalars['String']['output']>;
  /** Error type. */
  type: DashboardUpdatePageErrorType;
};

/** Expected error types that can be returned by updatePage operation. */
export enum DashboardUpdatePageErrorType {
  /** User is not allowed to execute the operation. */
  ForbiddenOperation = 'FORBIDDEN_OPERATION',
  /** Invalid input error. */
  InvalidInput = 'INVALID_INPUT',
  /** Page not found in the system. */
  PageNotFound = 'PAGE_NOT_FOUND'
}

/** Page input used when updating an individual page. */
export type DashboardUpdatePageInput = {
  /** Page description. */
  description?: InputMaybe<Scalars['String']['input']>;
  /** Page name. */
  name: Scalars['String']['input'];
  /** Page widgets. */
  widgets: Array<DashboardWidgetInput>;
};

/** Result of updatePage operation. */
export type DashboardUpdatePageResult = {
  __typename?: 'DashboardUpdatePageResult';
  /** Expected errors while processing request. No errors means successful request. */
  errors?: Maybe<Array<Maybe<DashboardUpdatePageError>>>;
};

/** Result of update operation. */
export type DashboardUpdateResult = {
  __typename?: 'DashboardUpdateResult';
  /** Dashboard update result. */
  entityResult?: Maybe<DashboardEntityResult>;
  /** Expected errors while processing request. */
  errors?: Maybe<Array<Maybe<DashboardUpdateError>>>;
};

/** Input type used when updating widgets. */
export type DashboardUpdateWidgetInput = {
  /** Typed widgets are area, bar, billboard, line, markdown, pie, and table. Check our [docs](https://docs.newrelic.com/docs/apis/nerdgraph/examples/create-widgets-dashboards-api/#widget-typed) for more info. */
  configuration?: InputMaybe<DashboardWidgetConfigurationInput>;
  /** ID of the widget to be updated. */
  id: Scalars['ID']['input'];
  /** The widget's position and size in the dashboard. */
  layout?: InputMaybe<DashboardWidgetLayoutInput>;
  /** Entities related to the widget. Currently only supports one Dashboard entity guid, but may allow other cases in the future. */
  linkedEntityGuids?: InputMaybe<Array<Scalars['EntityGuid']['input']>>;
  /** Untyped widgets are all other widgets, such as bullet, histogram, inventory, etc. Check our [docs](https://docs.newrelic.com/docs/apis/nerdgraph/examples/create-widgets-dashboards-api/#widget-untyped) for more info. */
  rawConfiguration?: InputMaybe<Scalars['DashboardWidgetRawConfiguration']['input']>;
  /** A title for the widget. */
  title?: InputMaybe<Scalars['String']['input']>;
  /** Specifies how this widget will be visualized. If null, the WidgetConfigurationInput will be used to determine the visualization. */
  visualization?: InputMaybe<DashboardWidgetVisualizationInput>;
};

/** Expected errors that can be returned by updateWidgetsInPage operation. */
export type DashboardUpdateWidgetsInPageError = {
  __typename?: 'DashboardUpdateWidgetsInPageError';
  /** Error description. */
  description?: Maybe<Scalars['String']['output']>;
  /** Error type. */
  type: DashboardUpdateWidgetsInPageErrorType;
};

/** Expected error types that can be returned by updateWidgetsInPage operation. */
export enum DashboardUpdateWidgetsInPageErrorType {
  /** User is not allowed to execute the operation. */
  ForbiddenOperation = 'FORBIDDEN_OPERATION',
  /** Invalid input error. */
  InvalidInput = 'INVALID_INPUT',
  /** Page not found in the system. */
  PageNotFound = 'PAGE_NOT_FOUND',
  /** Widget not found in the system. */
  WidgetNotFound = 'WIDGET_NOT_FOUND'
}

/** Result of updateWidgetsInPage operation. */
export type DashboardUpdateWidgetsInPageResult = {
  __typename?: 'DashboardUpdateWidgetsInPageResult';
  /** Expected errors while processing request. No errors means successful request. */
  errors?: Maybe<Array<Maybe<DashboardUpdateWidgetsInPageError>>>;
};

/** Definition of a variable that is local to this dashboard. Variables are placeholders for dynamic values in widget NRQLs. */
export type DashboardVariable = {
  __typename?: 'DashboardVariable';
  /**
   * [DEPRECATED] Default value for this variable. The actual value to be used will depend on the type.
   * @deprecated This field will always be null. Use defaultValues instead.
   */
  defaultValue?: Maybe<DashboardVariableDefaultValue>;
  /** Default values for this variable. The actual value to be used will depend on the type. */
  defaultValues?: Maybe<Array<Maybe<DashboardVariableDefaultItem>>>;
  /** Indicates whether this variable supports multiple selection or not. Only applies to variables of type NRQL or ENUM. */
  isMultiSelection?: Maybe<Scalars['Boolean']['output']>;
  /** List of possible values for variables of type ENUM. */
  items?: Maybe<Array<Maybe<DashboardVariableEnumItem>>>;
  /** Variable identifier. */
  name?: Maybe<Scalars['String']['output']>;
  /** Configuration for variables of type NRQL. */
  nrqlQuery?: Maybe<DashboardVariableNrqlQuery>;
  /** Options applied to the variable. */
  options?: Maybe<DashboardVariableOptions>;
  /** Indicates the strategy to apply when replacing a variable in a NRQL query. */
  replacementStrategy?: Maybe<DashboardVariableReplacementStrategy>;
  /** Human-friendly display string for this variable. */
  title?: Maybe<Scalars['String']['output']>;
  /** Specifies the data type of the variable and where its possible values may come from. */
  type?: Maybe<DashboardVariableType>;
};

/** Represents a possible default value item. */
export type DashboardVariableDefaultItem = {
  __typename?: 'DashboardVariableDefaultItem';
  /** The value of this default item. */
  value?: Maybe<DashboardVariableDefaultValue>;
};

/** Represents a possible default value item. */
export type DashboardVariableDefaultItemInput = {
  /** The value of this default item. */
  value: DashboardVariableDefaultValueInput;
};

/** Specifies a default value for variables. */
export type DashboardVariableDefaultValue = {
  __typename?: 'DashboardVariableDefaultValue';
  /** Default string value. */
  string?: Maybe<Scalars['String']['output']>;
};

/** Specifies a default value for variables. */
export type DashboardVariableDefaultValueInput = {
  /** Default string value. */
  string?: InputMaybe<Scalars['String']['input']>;
};

/** Represents a possible value for a variable of type ENUM. */
export type DashboardVariableEnumItem = {
  __typename?: 'DashboardVariableEnumItem';
  /** A human-friendly display string for this value. */
  title?: Maybe<Scalars['String']['output']>;
  /** A possible variable value. */
  value?: Maybe<Scalars['String']['output']>;
};

/** Input type that represents a possible value for a variable of type ENUM. */
export type DashboardVariableEnumItemInput = {
  /** A human-friendly display string for this value. */
  title?: InputMaybe<Scalars['String']['input']>;
  /** A possible variable value */
  value: Scalars['String']['input'];
};

/** Definition of a variable that is local to this dashboard. Variables are placeholders for dynamic values in widget NRQLs. */
export type DashboardVariableInput = {
  /** [DEPRECATED] Default value for this variable. The actual value to be used will depend on the type. */
  defaultValue?: InputMaybe<DashboardVariableDefaultValueInput>;
  /** Default values for this variable. The actual value to be used will depend on the type. */
  defaultValues?: InputMaybe<Array<DashboardVariableDefaultItemInput>>;
  /** Indicates whether this variable supports multiple selection or not. Only applies to variables of type NRQL or ENUM. */
  isMultiSelection?: InputMaybe<Scalars['Boolean']['input']>;
  /** List of possible values for variables of type ENUM */
  items?: InputMaybe<Array<InputMaybe<DashboardVariableEnumItemInput>>>;
  /** Variable identifier. */
  name: Scalars['String']['input'];
  /** Configuration for variables of type NRQL. */
  nrqlQuery?: InputMaybe<DashboardVariableNrqlQueryInput>;
  /** Options applied to the variable */
  options?: InputMaybe<DashboardVariableOptionsInput>;
  /** Indicates the strategy to apply when replacing a variable in a NRQL query. */
  replacementStrategy?: InputMaybe<DashboardVariableReplacementStrategy>;
  /** Human-friendly display string for this variable. */
  title?: InputMaybe<Scalars['String']['input']>;
  /** Specifies the data type of the variable and where its possible values may come from. */
  type: DashboardVariableType;
};

/** Configuration for variables of type NRQL. */
export type DashboardVariableNrqlQuery = {
  __typename?: 'DashboardVariableNrqlQuery';
  /** New Relic account ID(s) to issue the query against. */
  accountIds?: Maybe<Array<Maybe<Scalars['Int']['output']>>>;
  /** NRQL formatted query. */
  query: Scalars['Nrql']['output'];
};

/** Configuration for variables of type NRQL. */
export type DashboardVariableNrqlQueryInput = {
  /** New Relic account ID(s) to issue the query against. */
  accountIds: Array<Scalars['Int']['input']>;
  /** NRQL formatted query. */
  query: Scalars['Nrql']['input'];
};

/** Options applied to the variable. */
export type DashboardVariableOptions = {
  __typename?: 'DashboardVariableOptions';
  /** Only applies to variables of type NRQL. With this turned on, the time range for the NRQL query will override the time picker on dashboards and other pages. Turn this off to use the time picker as normal. */
  ignoreTimeRange?: Maybe<Scalars['Boolean']['output']>;
};

/** Options applied to the variable */
export type DashboardVariableOptionsInput = {
  /** Only applies to variables of type NRQL. With this turned on, the time range for the NRQL query will override the time picker on dashboards and other pages. Turn this off to use the time picker as normal. */
  ignoreTimeRange?: InputMaybe<Scalars['Boolean']['input']>;
};

/** Possible strategies when replacing variables in a NRQL query. */
export enum DashboardVariableReplacementStrategy {
  /** Replace the variable based on its automatically-inferred type. */
  Default = 'DEFAULT',
  /** Replace the variable value as an identifier. */
  Identifier = 'IDENTIFIER',
  /** Replace the variable value as a number. */
  Number = 'NUMBER',
  /** Replace the variable value as a string. */
  String = 'STRING'
}

/** Indicates where a variable's possible values may come from. */
export enum DashboardVariableType {
  /** Value comes from an enumerated list of possible values. */
  Enum = 'ENUM',
  /** Value comes from the results of a NRQL query. */
  Nrql = 'NRQL',
  /** Dashboard user can supply an arbitrary string value to variable. */
  String = 'STRING'
}

/** Widgets in a Dashboard Page. */
export type DashboardWidget = {
  __typename?: 'DashboardWidget';
  /** Typed widgets are area, bar, billboard, line, markdown, pie, and table. */
  configuration?: Maybe<DashboardWidgetConfiguration>;
  /** ID of the widget. */
  id: Scalars['ID']['output'];
  /** The widget's position and size in the dashboard. */
  layout?: Maybe<DashboardWidgetLayout>;
  /** Entities related to the widget. Currently only supports one Dashboard entity guid, but may allow other cases in the future. */
  linkedEntities?: Maybe<Array<Maybe<EntityOutline>>>;
  /** Untyped widgets are all other widgets, such as bullet, histogram, inventory, etc. */
  rawConfiguration: Scalars['DashboardWidgetRawConfiguration']['output'];
  /** A title for the widget. */
  title?: Maybe<Scalars['String']['output']>;
  /** Specifies how this widget will be visualized. */
  visualization: DashboardWidgetVisualization;
};

/** Typed configuration for known visualizations. Only one (at most) will be populated for a given widget. */
export type DashboardWidgetConfiguration = {
  __typename?: 'DashboardWidgetConfiguration';
  /** Configuration for visualization type 'viz.area' */
  area?: Maybe<DashboardAreaWidgetConfiguration>;
  /** Configuration for visualization type 'viz.bar' */
  bar?: Maybe<DashboardBarWidgetConfiguration>;
  /** Configuration for visualization type 'viz.billboard' */
  billboard?: Maybe<DashboardBillboardWidgetConfiguration>;
  /** Configuration for visualization type 'viz.line' */
  line?: Maybe<DashboardLineWidgetConfiguration>;
  /** Configuration for visualization type 'viz.markdown' */
  markdown?: Maybe<DashboardMarkdownWidgetConfiguration>;
  /** Configuration for visualization type 'viz.pie' */
  pie?: Maybe<DashboardPieWidgetConfiguration>;
  /** Configuration for visualization type 'viz.table' */
  table?: Maybe<DashboardTableWidgetConfiguration>;
};

/** Typed configuration for known visualizations. At most one may be populated. */
export type DashboardWidgetConfigurationInput = {
  /** Configuration for visualization type 'viz.area' */
  area?: InputMaybe<DashboardAreaWidgetConfigurationInput>;
  /** Configuration for visualization type 'viz.bar' */
  bar?: InputMaybe<DashboardBarWidgetConfigurationInput>;
  /** Configuration for visualization type 'viz.billboard' */
  billboard?: InputMaybe<DashboardBillboardWidgetConfigurationInput>;
  /** Configuration for visualization type 'viz.line' */
  line?: InputMaybe<DashboardLineWidgetConfigurationInput>;
  /** Configuration for visualization type 'viz.markdown' */
  markdown?: InputMaybe<DashboardMarkdownWidgetConfigurationInput>;
  /** Configuration for visualization type 'viz.pie' */
  pie?: InputMaybe<DashboardPieWidgetConfigurationInput>;
  /** Configuration for visualization type 'viz.table' */
  table?: InputMaybe<DashboardTableWidgetConfigurationInput>;
};

/** Widget input. */
export type DashboardWidgetInput = {
  /** Typed widgets are area, bar, billboard, line, markdown, pie, and table. Check our [docs](https://docs.newrelic.com/docs/apis/nerdgraph/examples/create-widgets-dashboards-api/#widget-typed) for more info. */
  configuration?: InputMaybe<DashboardWidgetConfigurationInput>;
  /** ID of the widget. If null, a new widget will be created and added to a dashboard. */
  id?: InputMaybe<Scalars['ID']['input']>;
  /** The widget's position and size in the dashboard. */
  layout?: InputMaybe<DashboardWidgetLayoutInput>;
  /** Entities related to the widget. Currently only supports one Dashboard entity guid, but may allow other cases in the future. */
  linkedEntityGuids?: InputMaybe<Array<Scalars['EntityGuid']['input']>>;
  /** Untyped widgets are all other widgets, such as bullet, histogram, inventory, etc. Check our [docs](https://docs.newrelic.com/docs/apis/nerdgraph/examples/create-widgets-dashboards-api/#widget-untyped) for more info. */
  rawConfiguration?: InputMaybe<Scalars['DashboardWidgetRawConfiguration']['input']>;
  /** A title for the widget. */
  title?: InputMaybe<Scalars['String']['input']>;
  /** Specifies how this widget will be visualized. If null, the WidgetConfigurationInput will be used to determine the visualization. */
  visualization?: InputMaybe<DashboardWidgetVisualizationInput>;
};

/** Widget layout. */
export type DashboardWidgetLayout = {
  __typename?: 'DashboardWidgetLayout';
  /** Column position of widget from top left, starting at 1. */
  column?: Maybe<Scalars['Int']['output']>;
  /** Height of the widget. Valid values are 1 to 12 inclusive. Defaults to 3. */
  height?: Maybe<Scalars['Int']['output']>;
  /** Row position of widget from top left, starting at 1. */
  row?: Maybe<Scalars['Int']['output']>;
  /** Width of the widget. Valid values are 1 to 12 inclusive. Defaults to 4. */
  width?: Maybe<Scalars['Int']['output']>;
};

/** Widget layout input. */
export type DashboardWidgetLayoutInput = {
  /** Column position of widget from top left, starting at 1. */
  column?: InputMaybe<Scalars['Int']['input']>;
  /** Height of the widget. Valid values are 1 to 12 inclusive. Defaults to 3. */
  height?: InputMaybe<Scalars['Int']['input']>;
  /** Row position of widget from top left, starting at 1. */
  row?: InputMaybe<Scalars['Int']['input']>;
  /** Width of the widget. Valid values are 1 to 12 inclusive. Defaults to 4. */
  width?: InputMaybe<Scalars['Int']['input']>;
};

/** Single NRQL query for a widget. */
export type DashboardWidgetNrqlQuery = {
  __typename?: 'DashboardWidgetNrqlQuery';
  /** New Relic account ID to issue the query against. */
  accountId: Scalars['Int']['output'];
  /** NRQL formatted query. */
  query: Scalars['Nrql']['output'];
};

/** NRQL query used by a widget. */
export type DashboardWidgetNrqlQueryInput = {
  /** New Relic account ID to issue the query against. */
  accountId: Scalars['Int']['input'];
  /** NRQL formatted query. */
  query: Scalars['Nrql']['input'];
};

/** Visualization configuration. */
export type DashboardWidgetVisualization = {
  __typename?: 'DashboardWidgetVisualization';
  /** This field can either have a known type like `viz.area` or `<nerdpack-id>.<visualization-id>` in the case of custom visualizations. */
  id?: Maybe<Scalars['String']['output']>;
};

/** Visualization configuration. */
export type DashboardWidgetVisualizationInput = {
  /** This field can either have a known type like `viz.area` or `<nerdpack-id>.<visualization-id>` in the case of [custom visualizations](https://developer.newrelic.com/explore-docs/custom-viz/build-visualization/). Check out [docs](https://docs.newrelic.com/docs/apis/nerdgraph/examples/create-widgets-dashboards-api/#widget-schema) for more info. */
  id?: InputMaybe<Scalars['String']['input']>;
};

/** Attribute object that contains data about the attribute */
export type DataDictionaryAttribute = {
  __typename?: 'DataDictionaryAttribute';
  /** Description of what this attribute represents, how it's measured, etc */
  definition: Scalars['String']['output'];
  /** URL of this attribute on the New Relic docs site */
  docsUrl?: Maybe<Scalars['String']['output']>;
  /** List of events using this attribute */
  events: Array<Scalars['String']['output']>;
  /** The official name of this attribute */
  name: Scalars['String']['output'];
  /** Unit this attribute is measuring (if applicable) */
  units?: Maybe<DataDictionaryUnit>;
};


/** Attribute object that contains data about the attribute */
export type DataDictionaryAttributeDefinitionArgs = {
  format?: InputMaybe<DataDictionaryTextFormat>;
};

/** The source generating the event data */
export type DataDictionaryDataSource = {
  __typename?: 'DataDictionaryDataSource';
  /** Name of the source */
  name: Scalars['String']['output'];
};

/** Event data definitions, where they come from, and information about the attributes they contain */
export type DataDictionaryDocsStitchedFields = {
  __typename?: 'DataDictionaryDocsStitchedFields';
  /** List of events */
  events?: Maybe<Array<DataDictionaryEvent>>;
};


/** Event data definitions, where they come from, and information about the attributes they contain */
export type DataDictionaryDocsStitchedFieldsEventsArgs = {
  names?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
};

/** Event object that contains data about the event and its attributes */
export type DataDictionaryEvent = {
  __typename?: 'DataDictionaryEvent';
  /** List of attributes in this event */
  attributes: Array<DataDictionaryAttribute>;
  /** List of places where this event comes from */
  dataSources: Array<DataDictionaryDataSource>;
  /** A description of the event */
  definition?: Maybe<Scalars['String']['output']>;
  /** The official name of this event */
  name: Scalars['String']['output'];
};


/** Event object that contains data about the event and its attributes */
export type DataDictionaryEventDefinitionArgs = {
  format?: InputMaybe<DataDictionaryTextFormat>;
};

/** Enumerated list of text output */
export enum DataDictionaryTextFormat {
  /** Text as HTML output */
  Html = 'HTML',
  /** Text as markdown output */
  Markdown = 'MARKDOWN',
  /** Text as plain output, stripped of markup */
  Plain = 'PLAIN'
}

/** The unit of measurement */
export type DataDictionaryUnit = {
  __typename?: 'DataDictionaryUnit';
  /** Name and abbreviation (if applicable) of the unit */
  label: Scalars['String']['output'];
};

/** Input object to add and change a feature setting toggle for an account */
export type DataManagementAccountFeatureSettingInput = {
  /** Enabled state for the feature setting */
  enabled?: InputMaybe<Scalars['Boolean']['input']>;
  /** Feature setting lookup */
  featureSetting?: InputMaybe<DataManagementFeatureSettingLookup>;
  /** When locked is true, children inherit parent's enabled state */
  locked?: InputMaybe<Scalars['Boolean']['input']>;
};

/** Account Limit */
export type DataManagementAccountLimit = {
  __typename?: 'DataManagementAccountLimit';
  /** Category for the limit */
  category?: Maybe<DataManagementCategory>;
  /** Description of the uses for this limit */
  description?: Maybe<Scalars['String']['output']>;
  /** Link to documentation for this limit */
  documentationLink?: Maybe<Scalars['String']['output']>;
  /** What happens when the limit is reached? */
  limitReachedBehaviorDescription?: Maybe<Scalars['String']['output']>;
  /** Unique name for the limit */
  name?: Maybe<Scalars['String']['output']>;
  /** Time between limit resets */
  timeInterval?: Maybe<Scalars['Nrql']['output']>;
  /** Type of limit for aggregation and reporting */
  type?: Maybe<DataManagementType>;
  /** Unit for the limit value */
  unit?: Maybe<DataManagementUnit>;
  /** Value for the limit */
  value?: Maybe<Scalars['Int']['output']>;
};

export type DataManagementAccountStitchedFields = {
  __typename?: 'DataManagementAccountStitchedFields';
  /** List all customizable event namespaces */
  customizableRetention?: Maybe<DataManagementCustomizableRetention>;
  /** Get the event retention policies for an account */
  eventRetentionPolicies?: Maybe<Array<Maybe<DataManagementRenderedRetention>>>;
  /** Get the event retention rule for a namespace on an account, if it exists */
  eventRetentionRule?: Maybe<DataManagementRule>;
  /** List all the event retention rules for an account */
  eventRetentionRules?: Maybe<Array<Maybe<DataManagementRule>>>;
  /** Query for all feature settings */
  featureSettings?: Maybe<Array<Maybe<DataManagementFeatureSetting>>>;
  /** Query for all limits */
  limits?: Maybe<Array<Maybe<DataManagementAccountLimit>>>;
  /** List of accounts with retention rules over contract maximum */
  noncompliantAccounts?: Maybe<Array<Maybe<DataManagementNoncompliantAccount>>>;
  /** Audit of retention values per namespace for an account */
  retentionAudit?: Maybe<Array<Maybe<DataManagementRetentionValues>>>;
  /** List of all namespaces */
  retentions?: Maybe<Array<Maybe<DataManagementRetention>>>;
};


export type DataManagementAccountStitchedFieldsEventRetentionRuleArgs = {
  namespace: Scalars['String']['input'];
};


export type DataManagementAccountStitchedFieldsNoncompliantAccountsArgs = {
  checkRules?: InputMaybe<Scalars['Boolean']['input']>;
};

/** Applied rules */
export type DataManagementAppliedRules = {
  __typename?: 'DataManagementAppliedRules';
  /** The account id for namespace rule */
  accountId?: Maybe<Scalars['Int']['output']>;
  /** Length of time data will be retained (in days) */
  retentionInDays?: Maybe<Scalars['Int']['output']>;
};

/** Result for bulk retention copy to an account */
export type DataManagementBulkCopyResult = {
  __typename?: 'DataManagementBulkCopyResult';
  /** The failure destination accounts */
  failure?: Maybe<Array<Maybe<Scalars['Int']['output']>>>;
  /** The successful destination accounts */
  success?: Maybe<Array<Maybe<Scalars['Int']['output']>>>;
};

/** Category of a limit */
export enum DataManagementCategory {
  /** Limits on Alerting */
  Alerting = 'ALERTING',
  /** Limits on Ingest */
  Ingest = 'INGEST',
  /** Limits on Query */
  Query = 'QUERY'
}

/** Wrapper object for customizable retention namespaces */
export type DataManagementCustomizableRetention = {
  __typename?: 'DataManagementCustomizableRetention';
  /** List of customizable event namespaces */
  eventNamespaces?: Maybe<Array<Maybe<DataManagementEventNamespaces>>>;
};

/** Event namespace */
export type DataManagementEventNamespaces = {
  __typename?: 'DataManagementEventNamespaces';
  /** The upper limit for the retention value */
  maxRetentionInDays?: Maybe<Scalars['Int']['output']>;
  /** The lower limit for the retention value */
  minRetentionInDays?: Maybe<Scalars['Int']['output']>;
  /** The name of a namespace */
  namespace?: Maybe<Scalars['String']['output']>;
};

/** Feature Setting */
export type DataManagementFeatureSetting = {
  __typename?: 'DataManagementFeatureSetting';
  /** Enabled state for the feature setting */
  enabled?: Maybe<Scalars['Boolean']['output']>;
  /** Key to identify the feature setting */
  key?: Maybe<Scalars['String']['output']>;
  /** Locked state for the feature setting */
  locked?: Maybe<Scalars['Boolean']['output']>;
  /** Unique name for the feature setting */
  name?: Maybe<Scalars['String']['output']>;
};

/** Input object to lookup a feature setting */
export type DataManagementFeatureSettingLookup = {
  /** Key of the feature setting */
  key?: InputMaybe<Scalars['String']['input']>;
};

/** Namespace level retention */
export type DataManagementNamespaceLevelRetention = {
  __typename?: 'DataManagementNamespaceLevelRetention';
  /** Length of time data will be retained (in days) */
  retentionInDays?: Maybe<Scalars['Int']['output']>;
};

/** Accounts with retention rules over contract maximum */
export type DataManagementNoncompliantAccount = {
  __typename?: 'DataManagementNoncompliantAccount';
  /** The account id out of compliance */
  accountId?: Maybe<Scalars['Int']['output']>;
  /** The name of the namespace most over contract maximum */
  namespace?: Maybe<Scalars['String']['output']>;
  /** The current value of the retention over contract maximum */
  retentionInDays?: Maybe<Scalars['Int']['output']>;
  /** The maximum value from the contract */
  subscriptionInDays?: Maybe<Scalars['Int']['output']>;
};

/** An account's current retention values for a namespace */
export type DataManagementRenderedRetention = {
  __typename?: 'DataManagementRenderedRetention';
  /** The account id for the event retention */
  accountId?: Maybe<Scalars['Int']['output']>;
  /** The namespace for the event retention */
  namespace?: Maybe<Scalars['String']['output']>;
  /** Base retention value for an event namespace */
  namespaceLevelRetention?: Maybe<DataManagementNamespaceLevelRetention>;
  /** The UNIX timestamp when the retention was last updated */
  updatedAt?: Maybe<Scalars['EpochSeconds']['output']>;
};

/** Wrapper object for retention namespaces */
export type DataManagementRetention = {
  __typename?: 'DataManagementRetention';
  /** Is this field customizable? */
  customizable?: Maybe<Scalars['Boolean']['output']>;
  /** The name as displayed in the UI */
  displayName?: Maybe<Scalars['String']['output']>;
  /** The upper limit for the retention value */
  maxRetentionInDays?: Maybe<Scalars['Int']['output']>;
  /** The lower limit for the retention value */
  minRetentionInDays?: Maybe<Scalars['Int']['output']>;
  /** The name of a namespace */
  namespace?: Maybe<Scalars['String']['output']>;
  /** The source of the namespace */
  source?: Maybe<Scalars['String']['output']>;
};

/** Wrapper object for namespace retention values */
export type DataManagementRetentionValues = {
  __typename?: 'DataManagementRetentionValues';
  /** List of rules applied to a namespace */
  appliedRules?: Maybe<Array<Maybe<DataManagementAppliedRules>>>;
  /** The name of a namespace */
  namespace?: Maybe<Scalars['String']['output']>;
  /** The retention value from the subscription (in days) */
  subscriptionRetentionInDays?: Maybe<Scalars['Int']['output']>;
};

/** A rule for setting a data retention value for a particular event namespace on an account */
export type DataManagementRule = {
  __typename?: 'DataManagementRule';
  /** The UNIX timestamp when the event retention rule went into effect */
  createdAt?: Maybe<Scalars['EpochSeconds']['output']>;
  /** The New Relic ID of the user who created the event retention rule */
  createdById?: Maybe<Scalars['Int']['output']>;
  /** The UNIX timestamp when the event retention rule was deleted */
  deletedAt?: Maybe<Scalars['EpochSeconds']['output']>;
  /** The New Relic ID of the user who deleted the event retention rule */
  deletedById?: Maybe<Scalars['Int']['output']>;
  /** The event retention rule's unique identifier */
  id?: Maybe<Scalars['ID']['output']>;
  /** The namespace the event retention rule applies to */
  namespace?: Maybe<Scalars['String']['output']>;
  /** Length of time data will be retained (in days) */
  retentionInDays?: Maybe<Scalars['Int']['output']>;
};

/** Input rule type for bulk rule creation */
export type DataManagementRuleInput = {
  /** The namespace the event retention rule applies to */
  namespace?: InputMaybe<Scalars['String']['input']>;
  /** Length of time for event data retention (in days) */
  retentionInDays?: InputMaybe<Scalars['Int']['input']>;
};

/** Type of a limit */
export enum DataManagementType {
  /** Report usage as a gauge type */
  Gauge = 'GAUGE',
  /** Aggregate and report usage as a rate type */
  Rate = 'RATE'
}

/** Unit for a limit value */
export enum DataManagementUnit {
  /** Value is in bytes */
  Bytes = 'BYTES',
  /** Value is a count */
  Count = 'COUNT',
  /** Value is in gigabytes */
  Gigabytes = 'GIGABYTES'
}

export type DataSourceGapsActorStitchedFields = {
  __typename?: 'DataSourceGapsActorStitchedFields';
  /**
   * Retrieve data source gaps that match the provided query.
   *
   * If no query is provided, data source gaps from all authorized accounts will be included.
   */
  gaps?: Maybe<DataSourceGapsGapsResult>;
};


export type DataSourceGapsActorStitchedFieldsGapsArgs = {
  cursor?: InputMaybe<Scalars['String']['input']>;
  query?: InputMaybe<DataSourceGapsGapsQuery>;
};

/** A single data source gap associated with an account. The data source gap may also include a specific entity, but not always. */
export type DataSourceGapsGap = {
  __typename?: 'DataSourceGapsGap';
  /** The account associated with the data source gap. */
  account?: Maybe<AccountReference>;
  /** The time when the data source gap was first detected. */
  detectedAt: Scalars['EpochMilliseconds']['output'];
  /** The entity associated with the data source gap. */
  entity?: Maybe<EntityOutline>;
  /** The type of the data source gap. */
  gapType: DataSourceGapsGapType;
};

/** A descriptor of the data source needing instrumentation. */
export type DataSourceGapsGapType = {
  __typename?: 'DataSourceGapsGapType';
  /** The unique identifier of the data source associated with this gap type. This can be used with the `actor.nr1Catalog.dataSource` field. */
  dataSourceId?: Maybe<Scalars['ID']['output']>;
  /** The human-readable name of this data source gap type. */
  displayName?: Maybe<Scalars['String']['output']>;
  /** The unique identifier of this data source gap type. */
  id: DataSourceGapsGapTypeIdentifier;
};

/** The different types of data source gaps detectable by New Relic. */
export enum DataSourceGapsGapTypeIdentifier {
  /** Apache */
  Apache = 'APACHE',
  /** APM agent logs */
  ApmAgentLogs = 'APM_AGENT_LOGS',
  /** Cassandra */
  Cassandra = 'CASSANDRA',
  /** Consul */
  Consul = 'CONSUL',
  /** Couchbase */
  Couchbase = 'COUCHBASE',
  /** Elasticsearch */
  Elasticsearch = 'ELASTICSEARCH',
  /** Go */
  Go = 'GO',
  /** HAProxy */
  Haproxy = 'HAPROXY',
  /** Infrastructure agent logs */
  InfraLogs = 'INFRA_LOGS',
  /** Java */
  Java = 'JAVA',
  /** JMX */
  Jmx = 'JMX',
  /** Memcached */
  Memcached = 'MEMCACHED',
  /** .NET */
  MicrosoftNet = 'MICROSOFT_NET',
  /** Microsoft SQL Server */
  MicrosoftSqlServer = 'MICROSOFT_SQL_SERVER',
  /** MongoDB */
  Mongodb = 'MONGODB',
  /** MySQL */
  Mysql = 'MYSQL',
  /** Nagios */
  Nagios = 'NAGIOS',
  /** NGINX */
  Nginx = 'NGINX',
  /** Node.js */
  NodeJs = 'NODE_JS',
  /** PHP */
  Php = 'PHP',
  /** Pixie */
  Pixie = 'PIXIE',
  /** PostgreSQL */
  Postgresql = 'POSTGRESQL',
  /** Python */
  Python = 'PYTHON',
  /** RabbitMQ */
  Rabbitmq = 'RABBITMQ',
  /** Redis */
  Redis = 'REDIS',
  /** Ruby */
  Ruby = 'RUBY',
  /** Varnish */
  Varnish = 'VARNISH'
}

/** Query parameters used to filter data source gaps. */
export type DataSourceGapsGapsQuery = {
  /** A list of account IDs used to filter data source gaps. */
  accountIds?: InputMaybe<Array<Scalars['Int']['input']>>;
  /** A list of entity GUIDs used to filter data source gaps. */
  entityGuids?: InputMaybe<Array<Scalars['EntityGuid']['input']>>;
  /** A list of gap type identifiers used to filter data source gaps. */
  gapTypeIds?: InputMaybe<Array<DataSourceGapsGapTypeIdentifier>>;
};

/**
 * A data structure that contains the detailed response of a query for data source gaps.
 *
 * The direct query result is available through `results`.
 */
export type DataSourceGapsGapsResult = {
  __typename?: 'DataSourceGapsGapsResult';
  /** The cursor used to fetch the next set of paginated results. */
  nextCursor?: Maybe<Scalars['String']['output']>;
  /** The list of data source gaps that match the provided query. */
  results?: Maybe<Array<DataSourceGapsGap>>;
  /** The total number of data source gaps that match the provided query, regardless of pagination. */
  totalCount?: Maybe<Scalars['Int']['output']>;
};

/** Represents a date time window input. */
export type DateTimeWindowInput = {
  /** The end date and time expressed as an ISO8601 formatted string */
  endTime: Scalars['DateTime']['input'];
  /** The start date and time expressed as an ISO8601 formatted string */
  startTime: Scalars['DateTime']['input'];
};

/** Returns error group posts */
export type DiscussionAccountStitchedFields = {
  __typename?: 'DiscussionAccountStitchedFields';
  /**
   * Retrieve an error group post by ID
   * @deprecated This field is experimental and subject to breaking changes.
   */
  errorGroupPost?: Maybe<DiscussionErrorGroupPost>;
  /**
   * Retrieve a set of posts attached to an error group
   * @deprecated This field is experimental and subject to breaking changes.
   */
  errorGroupPosts?: Maybe<Array<Maybe<DiscussionErrorGroupPost>>>;
};


/** Returns error group posts */
export type DiscussionAccountStitchedFieldsErrorGroupPostArgs = {
  postId: Scalars['String']['input'];
};


/** Returns error group posts */
export type DiscussionAccountStitchedFieldsErrorGroupPostsArgs = {
  errorGroupGuid: Scalars['EntityGuid']['input'];
};

/** Attributes required to create a new post */
export type DiscussionCreateErrorGroupPostInput = {
  /** Participants mentioned in the Post */
  mentionedParticipants?: InputMaybe<DiscussionErrorGroupPostParticipantsInput>;
  /** The ID of the post that is a parent of ths post */
  parentPostId?: InputMaybe<Scalars['String']['input']>;
  /** Text of the post */
  text: Scalars['String']['input'];
};

/** A post participant representing an external, non-New-Relic user. */
export type DiscussionErrorGroupExternalParticipant = DiscussionErrorGroupPostParticipant & {
  __typename?: 'DiscussionErrorGroupExternalParticipant';
  /**
   * user email
   * @deprecated This field is experimental and subject to breaking changes.
   */
  email: Scalars['String']['output'];
  /**
   * User full name
   * @deprecated This field is experimental and subject to breaking changes.
   */
  fullName: Scalars['String']['output'];
  /**
   * User username
   * @deprecated This field is experimental and subject to breaking changes.
   */
  username: Scalars['String']['output'];
};

/** A post participant representing a New Relic user. */
export type DiscussionErrorGroupNewRelicParticipant = DiscussionErrorGroupPostParticipant & {
  __typename?: 'DiscussionErrorGroupNewRelicParticipant';
  /**
   * user email
   * @deprecated This field is experimental and subject to breaking changes.
   */
  email: Scalars['String']['output'];
  /**
   * User details
   * @deprecated This field is experimental and subject to breaking changes.
   */
  userInfo?: Maybe<UserReference>;
};

/** A post in a discussion. */
export type DiscussionErrorGroupPost = {
  __typename?: 'DiscussionErrorGroupPost';
  /**
   * ID of the New Relic account that owns the object being commented on
   * @deprecated This field is experimental and subject to breaking changes.
   */
  accountId: Scalars['Int']['output'];
  /**
   * Code blocks associated to the post
   * @deprecated This field is experimental and subject to breaking changes.
   */
  codeBlocks: Array<Maybe<DiscussionErrorGroupPostCodeBlock>>;
  /**
   * time the post was created
   * @deprecated This field is experimental and subject to breaking changes.
   */
  createdAt: Scalars['EpochMilliseconds']['output'];
  /**
   * creator of the post
   * @deprecated This field is experimental and subject to breaking changes.
   */
  creator: DiscussionErrorGroupPostParticipant;
  /**
   * whether the post has been deleted
   * @deprecated This field is experimental and subject to breaking changes.
   */
  deactivated: Scalars['Boolean']['output'];
  /**
   * Guid of the error group being commented on
   * @deprecated This field is experimental and subject to breaking changes.
   */
  errorGroupGuid: Scalars['EntityGuid']['output'];
  /**
   * Files attached to the post
   * @deprecated This field is experimental and subject to breaking changes.
   */
  files: Array<Maybe<DiscussionErrorGroupPostFileAttachment>>;
  /**
   * identifies every user mentioned in the comment
   * @deprecated This field is experimental and subject to breaking changes.
   */
  mentionedParticipants: Array<Maybe<DiscussionErrorGroupPostParticipant>>;
  /**
   * time the post was last modified
   * @deprecated This field is experimental and subject to breaking changes.
   */
  modifiedAt: Scalars['EpochMilliseconds']['output'];
  /**
   * if this comment is a reply to another comment, the ID of the post
   * @deprecated This field is experimental and subject to breaking changes.
   */
  parentPostId?: Maybe<Scalars['String']['output']>;
  /**
   * ID of the post
   * @deprecated This field is experimental and subject to breaking changes.
   */
  postId: Scalars['String']['output'];
  /**
   * User reactions to the post
   * @deprecated This field is experimental and subject to breaking changes.
   */
  reactions: Array<Maybe<DiscussionErrorGroupPostReaction>>;
  /**
   * sequence number of the post, in creation order
   * @deprecated This field is experimental and subject to breaking changes.
   */
  seqNum: Scalars['Int']['output'];
  /**
   * text of the comment
   * @deprecated This field is experimental and subject to breaking changes.
   */
  text: Scalars['String']['output'];
  /**
   * A version number, indicating the version of the post, starts at 1 and increments with every modification to the model
   * @deprecated This field is experimental and subject to breaking changes.
   */
  version: Scalars['Int']['output'];
};

/** Represents a code block */
export type DiscussionErrorGroupPostCodeBlock = {
  __typename?: 'DiscussionErrorGroupPostCodeBlock';
  /**
   * the actual code of the code block, as captured at the time code block was referenced
   * @deprecated This field is experimental and subject to breaking changes.
   */
  code: Scalars['String']['output'];
  /**
   * the path to the source file (relative to the repo path) from which the code block came
   * @deprecated This field is experimental and subject to breaking changes.
   */
  file: Scalars['String']['output'];
  /**
   * a URL which references the code block
   * @deprecated This field is experimental and subject to breaking changes.
   */
  permalink: Scalars['String']['output'];
  /**
   * the remote of the repo the code block is associated with
   * @deprecated This field is experimental and subject to breaking changes.
   */
  repo: Scalars['String']['output'];
  /**
   * the commit hash representing the code when the code block was captured
   * @deprecated This field is experimental and subject to breaking changes.
   */
  sha: Scalars['String']['output'];
};

/** A post participant representing an external, non-New-Relic user. */
export type DiscussionErrorGroupPostExternalParticipantInput = {
  /** user email */
  email: Scalars['String']['input'];
  /** user full name. Field is deprecated and will be ignored. */
  fullName?: InputMaybe<Scalars['String']['input']>;
  /** user username */
  username?: InputMaybe<Scalars['String']['input']>;
};

/** Represents a file attachment to a post */
export type DiscussionErrorGroupPostFileAttachment = {
  __typename?: 'DiscussionErrorGroupPostFileAttachment';
  /**
   * File MIME type
   * @deprecated This field is experimental and subject to breaking changes.
   */
  mimetype: Scalars['String']['output'];
  /**
   * File name
   * @deprecated This field is experimental and subject to breaking changes.
   */
  name: Scalars['String']['output'];
  /**
   * File size, in bytes
   * @deprecated This field is experimental and subject to breaking changes.
   */
  size: Scalars['String']['output'];
  /**
   * URL of the file
   * @deprecated This field is experimental and subject to breaking changes.
   */
  url: Scalars['String']['output'];
};

/** Input describing a New Relic user as a post participant */
export type DiscussionErrorGroupPostNewRelicUserParticipantInput = {
  /** New Relic user id */
  userId: Scalars['Int']['input'];
};

/** Represents a participant on a post, either New Relic user or not */
export type DiscussionErrorGroupPostParticipant = {
  /**
   * user email
   * @deprecated This field is experimental and subject to breaking changes.
   */
  email: Scalars['String']['output'];
};

/** Participants in a post */
export type DiscussionErrorGroupPostParticipantsInput = {
  /** Non New Relic users participating in a post */
  externalUsers?: InputMaybe<Array<InputMaybe<DiscussionErrorGroupPostExternalParticipantInput>>>;
  /** New Relic users participating in a post */
  newRelicUsers?: InputMaybe<Array<InputMaybe<DiscussionErrorGroupPostNewRelicUserParticipantInput>>>;
};

/** Represents users reacting to a post */
export type DiscussionErrorGroupPostReaction = {
  __typename?: 'DiscussionErrorGroupPostReaction';
  /**
   * The name of the reaction. Corresponds to the ID of an emoji in the emoji-mart NPM module.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  reaction: Scalars['String']['output'];
  /**
   * Users who had this reaction to the post
   * @deprecated This field is experimental and subject to breaking changes.
   */
  users: Array<Maybe<DiscussionErrorGroupPostParticipant>>;
};

/** Attributes required to update a post */
export type DiscussionUpdateErrorGroupPostInput = {
  /** post updated mentioned participants */
  mentionedParticipants?: InputMaybe<DiscussionErrorGroupPostParticipantsInput>;
  /** post updated text */
  text?: InputMaybe<Scalars['String']['input']>;
};

export type DistributedTracingActorStitchedFields = {
  __typename?: 'DistributedTracingActorStitchedFields';
  /** Look up the details of a trace based upon the traceId and optional start time. */
  trace?: Maybe<DistributedTracingTrace>;
};


export type DistributedTracingActorStitchedFieldsTraceArgs = {
  timestamp?: InputMaybe<Scalars['EpochMilliseconds']['input']>;
  traceId: Scalars['String']['input'];
};

/** Details tracing summary data for the provided `EntityGuid` that occurred during the provided `startTime` and `endTime` */
export type DistributedTracingEntityTracingSummary = {
  __typename?: 'DistributedTracingEntityTracingSummary';
  /** The number of traces where this entity produced an error */
  errorTraceCount?: Maybe<Scalars['Int']['output']>;
  /** The percentage of error traces produced by this entity compared to all error traces in the system */
  percentOfAllErrorTraces?: Maybe<Scalars['Float']['output']>;
};

/** The primary building block of a distributed trace.  An individual unit of work. */
export type DistributedTracingSpan = {
  __typename?: 'DistributedTracingSpan';
  /** All attributes for this span. This field is a map of string keys to attributes values. */
  attributes?: Maybe<Scalars['DistributedTracingSpanAttributes']['output']>;
  /** When the span represents a call to another entity, clientType indicates the type of the entity that was called. */
  clientType?: Maybe<DistributedTracingSpanClientType>;
  /** The duration of this span in milliseconds. */
  durationMs?: Maybe<Scalars['Milliseconds']['output']>;
  /** Unique identifier for the entity that created this span. This value has a corresponding entry in the entities field of the trace. */
  entityGuid?: Maybe<Scalars['String']['output']>;
  /** Unique identifier for this span. */
  id: Scalars['String']['output'];
  /** The name of this span. */
  name?: Maybe<Scalars['String']['output']>;
  /** The identifier of the caller of this span (null if this is the root span). */
  parentId?: Maybe<Scalars['String']['output']>;
  /** The position of a span with respect to the boundaries between processes in the trace. */
  processBoundary: DistributedTracingSpanProcessBoundary;
  /** Anomalies detected for this span, compared to similar spans that occurred over the previous hours before this span occurred. */
  spanAnomalies?: Maybe<Array<Maybe<DistributedTracingSpanAnomaly>>>;
  /** Epoch milliseconds timestamp represents this span's start time. */
  timestamp: Scalars['EpochMilliseconds']['output'];
  /** Unique identifier shared by all spans within a single trace. */
  traceId: Scalars['String']['output'];
};

/** An anomaly detected with respect to an attribute of a span. */
export type DistributedTracingSpanAnomaly = {
  __typename?: 'DistributedTracingSpanAnomaly';
  /** The value of the span attribute which was detected as being anomalous. */
  anomalousValue: Scalars['Float']['output'];
  /** The attribute of the span which was detected as being anomalous. */
  anomalyType: DistributedTracingSpanAnomalyType;
  /** The average value for the attribute on similar spans. */
  averageMeasure: Scalars['Float']['output'];
};

/** The type of Span Anomaly being reported (currently only Duration is supported). */
export enum DistributedTracingSpanAnomalyType {
  /** An anomaly type related to the duration of the span. */
  Duration = 'DURATION'
}

/** Represents whether a span is a call to a datastore or an external service. */
export enum DistributedTracingSpanClientType {
  /** A span that represents a call to a datastore. */
  Datastore = 'DATASTORE',
  /** A span that represents a call to an external service. */
  External = 'EXTERNAL'
}

/** A relationship between a parent and child span. */
export type DistributedTracingSpanConnection = {
  __typename?: 'DistributedTracingSpanConnection';
  /** The span identifier of the child for this connection. */
  child: Scalars['String']['output'];
  /** The span identifier of the parent for this connection. */
  parent: Scalars['String']['output'];
};

/** The position of a span with respect to the boundaries between processes in the trace. */
export enum DistributedTracingSpanProcessBoundary {
  /** The first span in a process. */
  Entry = 'ENTRY',
  /** A span that is the parent of an ENTRY span, or has an attribute name prefixed with either `db.` or `http.`, such as `db.statement` or `http.url`. If a span is both the first span in its process and has a `db.` or `http.`, its processBoundary value will be ENTRY. */
  Exit = 'EXIT',
  /** A span that is neither an ENTRY nor EXIT span. In-process spans are operations within each process, like internal method calls and functions. */
  InProcess = 'IN_PROCESS'
}

/** A collection of spans with context describing those spans.  The trace represents the complete processing of a request. */
export type DistributedTracingTrace = {
  __typename?: 'DistributedTracingTrace';
  /** The duration in milliseconds for the back-end part of this trace (not from a client such as a Browser application) */
  backendDurationMs?: Maybe<Scalars['Milliseconds']['output']>;
  /** The total duration of this trace in milliseconds. */
  durationMs?: Maybe<Scalars['Milliseconds']['output']>;
  /** All entities that are part of this trace. */
  entities: Array<EntityOutline>;
  /** The number of entities that are part of this trace. */
  entityCount: Scalars['Int']['output'];
  /** Unique identifier for this trace. */
  id: Scalars['String']['output'];
  /** Parent/child IDs that represent all of the span relationships within this trace. */
  spanConnections: Array<Maybe<DistributedTracingSpanConnection>>;
  /** Spans associated with this trace. The maximum number of spans returned is limited to 10_000. This could be less than the actual number of spans sent for the trace. */
  spans: Array<DistributedTracingSpan>;
  /** Epoch milliseconds timestamp represents this trace's start time. */
  timestamp: Scalars['EpochMilliseconds']['output'];
};

export type DocumentationFields = {
  __typename?: 'DocumentationFields';
  /**
   * View a list of all features for a chosen Agent
   * @deprecated This field is deprecated and does not return results.
   */
  agentFeatures?: Maybe<Array<Maybe<AgentFeatures>>>;
  /** View a list of all releases for a chosen Agent */
  agentReleases?: Maybe<Array<Maybe<AgentRelease>>>;
  /** This field provides access to DataDictionary data. */
  dataDictionary?: Maybe<DataDictionaryDocsStitchedFields>;
  /** A list of all the Time Zones from the IANA tz database */
  timeZones?: Maybe<Array<Maybe<TimeZoneInfo>>>;
  /** This field provides access to WhatsNew data. */
  whatsNew?: Maybe<WhatsNewDocsStitchedFields>;
};


export type DocumentationFieldsAgentFeaturesArgs = {
  agentName: AgentFeaturesFilter;
};


export type DocumentationFieldsAgentReleasesArgs = {
  agentName: AgentReleasesFilter;
};

/** Domain Operations an Admin can complete on the domain */
export enum DomainManagementAllowedDomainOperations {
  /**
   * Admin can delete the domain
   * @deprecated This field is experimental and subject to breaking changes.
   */
  Delete = 'DELETE',
  /**
   * Admin can start the reverify process for the domain
   * @deprecated This field is experimental and subject to breaking changes.
   */
  Reverify = 'REVERIFY',
  /**
   * Admin can save changes to the domain
   * @deprecated This field is experimental and subject to breaking changes.
   */
  Update = 'UPDATE'
}

/** Returned after creating a domain or retrying a domain verification */
export type DomainManagementCreateDomainResponse = {
  __typename?: 'DomainManagementCreateDomainResponse';
  /**
   * The id for the domain
   * @deprecated This field is experimental and subject to breaking changes.
   */
  domainId: Scalars['String']['output'];
  /**
   * A DNS Entry to be placed on the provided domain, to verify ownership
   * @deprecated This field is experimental and subject to breaking changes.
   */
  verificationTxtRecord?: Maybe<Scalars['SecureValue']['output']>;
};

/** Domain record and associated user creation settings */
export type DomainManagementDomain = {
  __typename?: 'DomainManagementDomain';
  /**
   * Operations that can be accessed through the UI for this domain
   * @deprecated This field is experimental and subject to breaking changes.
   */
  allowedDomainOperations: Array<DomainManagementAllowedDomainOperations>;
  /**
   * When the Domain was created
   * @deprecated This field is experimental and subject to breaking changes.
   */
  dateCreated?: Maybe<Scalars['DateTime']['output']>;
  /**
   * When the Domain Capture Configuration was last updated
   * @deprecated This field is experimental and subject to breaking changes.
   */
  dateUpdated?: Maybe<Scalars['DateTime']['output']>;
  /**
   * The domain Id
   * @deprecated This field is experimental and subject to breaking changes.
   */
  domainId?: Maybe<Scalars['String']['output']>;
  /**
   * Portion of email address after the @, used for associating new users with your organization
   * @deprecated This field is experimental and subject to breaking changes.
   */
  domainName?: Maybe<Scalars['String']['output']>;
  /**
   * Defines a potential users option to join the organization during the signup experience when domain capture is off
   * @deprecated This field is experimental and subject to breaking changes.
   */
  joinOrganizationPreference?: Maybe<DomainManagementJoinOrganizationPreference>;
  /**
   * Message displayed to potential users during signup, who's email address belongs to the configured domain
   * @deprecated This field is experimental and subject to breaking changes.
   */
  message?: Maybe<Scalars['String']['output']>;
  /**
   * Collection of settings to configure new users that join your organization via domain capture
   * @deprecated This field is experimental and subject to breaking changes.
   */
  newUserConfiguration?: Maybe<DomainManagementNewUserConfiguration>;
  /**
   * Domain verification method
   * @deprecated This field is experimental and subject to breaking changes.
   */
  verificationMethod?: Maybe<DomainManagementVerificationMethod>;
  /**
   * Domain verification status
   * @deprecated This field is experimental and subject to breaking changes.
   */
  verificationStatus?: Maybe<DomainManagementVerificationStatusType>;
};

/** Returned after deleting a domain */
export type DomainManagementDomainDeleteResponse = {
  __typename?: 'DomainManagementDomainDeleteResponse';
  /**
   * status
   * @deprecated This field is experimental and subject to breaking changes.
   */
  status?: Maybe<Scalars['String']['output']>;
};

/** Used to filter domains */
export type DomainManagementDomainFilterInput = {
  /** The domain ids to return results for */
  domainIds?: InputMaybe<Array<Scalars['String']['input']>>;
};

/** Defines a new users option to join the organization during the signup experience when domain capture is off */
export enum DomainManagementJoinOrganizationPreference {
  /**
   * User may join the Organization
   * @deprecated This field is experimental and subject to breaking changes.
   */
  Join = 'JOIN',
  /**
   * User may not join the Organization
   * @deprecated This field is experimental and subject to breaking changes.
   */
  None = 'NONE',
  /**
   * User may request to join the Organization
   * @deprecated This field is experimental and subject to breaking changes.
   */
  Request = 'REQUEST'
}

/** All information pertaining to the users interacting with domain capture */
export type DomainManagementNewUserConfiguration = {
  __typename?: 'DomainManagementNewUserConfiguration';
  /**
   * Authentication Domain ID new users will be added to
   * @deprecated This field is experimental and subject to breaking changes.
   */
  authenticationDomainId?: Maybe<Scalars['String']['output']>;
  /**
   * Indicates new users can join your organization
   * @deprecated This field is experimental and subject to breaking changes.
   */
  canJoin?: Maybe<Scalars['Boolean']['output']>;
  /**
   * Indicates new users can request to join your organization
   * @deprecated This field is experimental and subject to breaking changes.
   */
  canRequest?: Maybe<Scalars['Boolean']['output']>;
  /**
   * Indicates new users can access the default New Relic signup flow
   * @deprecated This field is experimental and subject to breaking changes.
   */
  canSignup?: Maybe<Scalars['Boolean']['output']>;
  /**
   * Array of IDs for Groups new users will be added to
   * @deprecated This field is experimental and subject to breaking changes.
   */
  groupIds: Array<Scalars['String']['output']>;
  /**
   * Initial type new users will be assigned
   * @deprecated This field is experimental and subject to breaking changes.
   */
  userType?: Maybe<DomainManagementUserType>;
};

/** Collection of settings to configure new users that join your organization via domain capture */
export type DomainManagementNewUserConfigurationInput = {
  /** Authentication Domain ID the User will be added to */
  authenticationDomainId: Scalars['String']['input'];
  /** Array of IDs for Groups the User will be added to */
  groupIds: Array<Scalars['String']['input']>;
  /** UserType the new user will be assigned */
  userType: DomainManagementUserType;
};

export type DomainManagementOrganizationStitchedFields = {
  __typename?: 'DomainManagementOrganizationStitchedFields';
  /**
   * Returns your organization's domains
   * @deprecated This field is experimental and subject to breaking changes.
   */
  domains?: Maybe<Array<DomainManagementDomain>>;
};


export type DomainManagementOrganizationStitchedFieldsDomainsArgs = {
  filter?: InputMaybe<DomainManagementDomainFilterInput>;
};

/** Returned after updating a capture configuration */
export type DomainManagementUpdateCaptureConfigurationResponse = {
  __typename?: 'DomainManagementUpdateCaptureConfigurationResponse';
  /**
   * status
   * @deprecated This field is experimental and subject to breaking changes.
   */
  status?: Maybe<Scalars['String']['output']>;
};

/** Available user types */
export enum DomainManagementUserType {
  /**
   * basic user
   * @deprecated This field is experimental and subject to breaking changes.
   */
  Basic = 'BASIC',
  /**
   * core user
   * @deprecated This field is experimental and subject to breaking changes.
   */
  Core = 'CORE',
  /**
   * full platform user
   * @deprecated This field is experimental and subject to breaking changes.
   */
  FullPlatform = 'FULL_PLATFORM'
}

/** Domain Verification Methods */
export enum DomainManagementVerificationMethod {
  /**
   * Domain ownership has been validated by a DNS TXT Record
   * @deprecated This field is experimental and subject to breaking changes.
   */
  DnsTxtRecord = 'DNS_TXT_RECORD',
  /**
   * Domain ownership has been manually verified
   * @deprecated This field is experimental and subject to breaking changes.
   */
  Manual = 'MANUAL'
}

/** Domain Verification Statuses */
export enum DomainManagementVerificationStatusType {
  /**
   * Domain was not verified within the allotted time
   * @deprecated This field is experimental and subject to breaking changes.
   */
  Expired = 'EXPIRED',
  /**
   * Domain has been created, but ownership has not yet been verified
   * @deprecated This field is experimental and subject to breaking changes.
   */
  Pending = 'PENDING',
  /**
   * Domain ownership verification status has been transferred to another Organization
   * @deprecated This field is experimental and subject to breaking changes.
   */
  Transferred = 'TRANSFERRED',
  /**
   * Domain ownership has been verified
   * @deprecated This field is experimental and subject to breaking changes.
   */
  Verified = 'VERIFIED'
}

/** Details about an entity type */
export type DomainType = {
  __typename?: 'DomainType';
  /**
   * The domain of the entity.
   *
   * The domain must be a value matching /[A-Z][A-Z0-9_]{2,14}/.
   */
  domain: Scalars['String']['output'];
  /**
   * The type of the entity.
   *
   * The type must be a value matching /[A-Z][A-Z0-9_]{2,49}/.
   *
   * Some examples are APPLICATION, HOST or CONTAINER.
   */
  type: Scalars['String']['output'];
};

/** Input for getting details about an entity type */
export type DomainTypeInput = {
  /**
   * The domain of the entity.
   *
   * The domain must be a value matching /[A-Z][A-Z0-9_]{2,14}/.
   */
  domain: Scalars['String']['input'];
  /**
   * The type of the entity.
   *
   * The type must be a value matching /[A-Z][A-Z0-9_]{2,49}/.
   *
   * Some examples are APPLICATION, HOST or CONTAINER.
   */
  type: Scalars['String']['input'];
};

export type EdgeAccountStitchedFields = {
  __typename?: 'EdgeAccountStitchedFields';
  /** Provides access to Tracing data. */
  tracing?: Maybe<EdgeTracing>;
};

/** All the details necessary to configure an agent to connect to an endoint. */
export type EdgeAgentEndpointDetail = EdgeEndpointDetail & {
  __typename?: 'EdgeAgentEndpointDetail';
  /** Full host name that is used to connect to the endpoint. This is the part that will be placed into an agent config named `infinite_tracing.trace_observer.host`. */
  host: Scalars['String']['output'];
  /** Port that is used to connect to the endpoint. This is the part that will be placed into an agent config named `infinite_tracing.trace_observer.port`. */
  port: Scalars['Int']['output'];
};

/** Compliance type codes that can be applied to a trace observer */
export enum EdgeComplianceTypeCode {
  /** Fedramp compliant */
  Fedramp = 'FEDRAMP'
}

/** Data required to create a span attribute trace filter rule. */
export type EdgeCreateSpanAttributeRuleInput = {
  /** The action that this trace filter rule takes if it matches the provided attribute name and value */
  action: EdgeTraceFilterAction;
  /** Name of the attribute to match on */
  key: Scalars['String']['input'];
  /** Type of match to apply to the attribute name (EQUALS, LIKE). Key match type is required. */
  keyOperator: EdgeSpanAttributeKeyOperator;
  /** Value of the attribute to match on. Value is required unless the `SpanAttributeValueOperator` is set to `IS_NOT_NULL` */
  value?: InputMaybe<Scalars['String']['input']>;
  /** Type of match to apply to the attribute value (EQUALS, LIKE, IS_NOT_NULL). */
  valueOperator: EdgeSpanAttributeValueOperator;
};

/** Description of errors that may occur while attempting to create a span attribute trace filter rule. */
export type EdgeCreateSpanAttributeRuleResponseError = {
  __typename?: 'EdgeCreateSpanAttributeRuleResponseError';
  /** Error message, with further detail to help resolve the issue. */
  message: Scalars['String']['output'];
  /** Error that may occur while attempting to create a trace filter rule. */
  type: EdgeCreateSpanAttributeRuleResponseErrorType;
};

/** Known error codes and messages for `CreateSpanAttributeRuleResponseError`. */
export enum EdgeCreateSpanAttributeRuleResponseErrorType {
  /** Duplicate span attribute trace filter rules found */
  DuplicateRules = 'DUPLICATE_RULES',
  /** The trace filter rule creation exceeds the number of allowed span attribute rules for a trace observer */
  ExceedsSpanAttributeRuleLimits = 'EXCEEDS_SPAN_ATTRIBUTE_RULE_LIMITS',
  /** Invalid trace filter rule input provided. */
  InvalidInput = 'INVALID_INPUT',
  /** No trace observer was found with the id given. */
  NotFound = 'NOT_FOUND',
  /** Span attribute trace filter rules found that would cancel each other out */
  OpposingRules = 'OPPOSING_RULES'
}

/** Successfully created span attribute trace filter rule, or one or more error responses if there were issues. */
export type EdgeCreateSpanAttributeRulesResponse = {
  __typename?: 'EdgeCreateSpanAttributeRulesResponse';
  /** Errors that may occur when creating a `SpanAttributeTraceFilter`. Defaults to `null` in case of success. */
  errors?: Maybe<Array<Maybe<EdgeCreateSpanAttributeRuleResponseError>>>;
  /** The trace filter rules that were created. Defaults to `null` in case of failure. */
  rules?: Maybe<Array<Maybe<EdgeSpanAttributeRule>>>;
};

/** Array of responses, one for each span attribute trace filter rule creation request. */
export type EdgeCreateTraceFilterRuleResponses = {
  __typename?: 'EdgeCreateTraceFilterRuleResponses';
  /** Span attribute trace filter rule creation response */
  spanAttributeRules: EdgeCreateSpanAttributeRulesResponse;
};

/** Input for creating multiple trace filter rules */
export type EdgeCreateTraceFilterRulesInput = {
  /** One or more `CreateSpanAttributeRuleInput` that describe the span attribute trace filter rule(s) to be created. */
  spanAttributeRules?: InputMaybe<Array<EdgeCreateSpanAttributeRuleInput>>;
};

/** Data required to create a trace observer. */
export type EdgeCreateTraceObserverInput = {
  /** Optional list of compliance types (e.g., FedRAMP) applied to this trace observer. */
  complianceTypes?: InputMaybe<Array<EdgeComplianceTypeCode>>;
  /** When set to `true` a trace observer will write trace metrics to the current account. */
  monitoring?: InputMaybe<Scalars['Boolean']['input']>;
  /** Name of the trace observer. */
  name: Scalars['String']['input'];
  /** Provider and region where the trace observer must run. Currently, only AWS regions are supported. */
  providerRegion: EdgeProviderRegion;
};

/** Successfully created trace observers, or one or more error responses if there were issues. */
export type EdgeCreateTraceObserverResponse = {
  __typename?: 'EdgeCreateTraceObserverResponse';
  /** Errors that may occur when creating a `TraceObserver`. Defaults to `null` in case of success. */
  errors?: Maybe<Array<Maybe<EdgeCreateTraceObserverResponseError>>>;
  /** The trace observer defined in `CreateTraceObserverInput`. Defaults to `null` in case of failure. */
  traceObserver?: Maybe<EdgeTraceObserver>;
};

/** Description of errors that may occur while attempting to create a trace observer. */
export type EdgeCreateTraceObserverResponseError = {
  __typename?: 'EdgeCreateTraceObserverResponseError';
  /** Error message, with further detail to help resolve the issue. */
  message: Scalars['String']['output'];
  /** Error that may occur while attempting to create a trace observer. */
  type: EdgeCreateTraceObserverResponseErrorType;
};

/** Known error codes and messages for `CreateTraceObserverResponseError`. */
export enum EdgeCreateTraceObserverResponseErrorType {
  /** A trace observer already exists for this account family and provider region. */
  AlreadyExists = 'ALREADY_EXISTS',
  /** Trace observers arent available in provider region. */
  NoAvailabilityInRegion = 'NO_AVAILABILITY_IN_REGION'
}

/** Array of responses, one for each trace observer creation request. */
export type EdgeCreateTraceObserverResponses = {
  __typename?: 'EdgeCreateTraceObserverResponses';
  /** Array of trace observer creation responses, one for each `CreateTraceObserverInput`. */
  responses: Array<EdgeCreateTraceObserverResponse>;
};

/** A data source (i.e., New Relic entity) that is associated with this trace observer. Currently, we support adding Browser, Lambda, and Mobile entities as data sources. */
export type EdgeDataSource = {
  __typename?: 'EdgeDataSource';
  /** The entity representing this data source. */
  entity?: Maybe<EntityOutline>;
  /** The status of whether data is being sent to this trace observer for this data source. */
  status: EdgeDataSourceStatusType;
};

/** A group of data sources that are associated with this trace observer. */
export type EdgeDataSourceGroup = {
  __typename?: 'EdgeDataSourceGroup';
  /** The list of data sources in this group. */
  dataSources: Array<EdgeDataSource>;
};

/** Data required to change the data source group. */
export type EdgeDataSourceGroupInput = {
  /** The entity guids representing the entities you would like to update. */
  guids?: InputMaybe<Array<Scalars['EntityGuid']['input']>>;
  /** The type of update that should be performed with the supplied entity guids. */
  updateType: EdgeDataSourceGroupUpdateType;
};

/** The type of update you would like to apply to the existing data source group. */
export enum EdgeDataSourceGroupUpdateType {
  /** Add the supplied entity guids to those that are currently active. */
  Add = 'ADD',
  /** Remove the supplied entity guids from those that are currently active. */
  Remove = 'REMOVE',
  /** Replace the currently active entity guids with the ones supplied. */
  Replace = 'REPLACE'
}

/** The status of whether data is being sent to the trace observer for a particular data source. */
export enum EdgeDataSourceStatusType {
  /** The data source telemetry is being sent to this trace observer. */
  Active = 'ACTIVE',
  /** The data source telemetry is *not* being sent to this trace observer. */
  Inactive = 'INACTIVE'
}

/** Successfully deleted span attribute trace filter rule, or one or more error responses if there were issues. */
export type EdgeDeleteSpanAttributeRuleResponse = {
  __typename?: 'EdgeDeleteSpanAttributeRuleResponse';
  /** Errors that may occur when deleting a `SpanAttributeRule`. Defaults to `null` in case of success. */
  errors?: Maybe<Array<Maybe<EdgeDeleteSpanAttributeRuleResponseError>>>;
  /** The trace filter rule that was deleted. Defaults to `null` in case of failure. */
  rule?: Maybe<EdgeSpanAttributeRule>;
};

/** Description of errors that may occur while attempting to delete a span attribute trace filter. */
export type EdgeDeleteSpanAttributeRuleResponseError = {
  __typename?: 'EdgeDeleteSpanAttributeRuleResponseError';
  /** Error message, with further detail to help resolve the issue. */
  message: Scalars['String']['output'];
  /** Error that may occur while attempting to delete a span attribute trace filter. */
  type: EdgeDeleteSpanAttributeRuleResponseErrorType;
};

/** Known error codes and messages for `DeleteSpanAttributeRuleResponseError`. */
export enum EdgeDeleteSpanAttributeRuleResponseErrorType {
  /** No trace observer was found with the id given. */
  NotFound = 'NOT_FOUND'
}

/** Array of responses, one for each trace filter rule deletion request */
export type EdgeDeleteTraceFilterRuleResponses = {
  __typename?: 'EdgeDeleteTraceFilterRuleResponses';
  /** Array of span attribute trace filter rule deletion responses, one for each id provided to `DeleteTraceFilterRulesInput`. */
  spanAttributeRules: Array<EdgeDeleteSpanAttributeRuleResponse>;
};

/** Input for deleting multiple trace filter rules by id */
export type EdgeDeleteTraceFilterRulesInput = {
  /** One or more SpanAttributeRule id(s) to be deleted. */
  spanAttributeRuleIds?: InputMaybe<Array<Scalars['Int']['input']>>;
};

/** Data required to delete a trace observer. */
export type EdgeDeleteTraceObserverInput = {
  /** Globally unique identifier of the trace observer being deleted. */
  id: Scalars['Int']['input'];
};

/** Successfully deleted trace observers, or one or more error responses if there were issues. */
export type EdgeDeleteTraceObserverResponse = {
  __typename?: 'EdgeDeleteTraceObserverResponse';
  /** Errors that may occur when deleting a `TraceObserver`. Defaults to `null` in case of success. */
  errors?: Maybe<Array<Maybe<EdgeDeleteTraceObserverResponseError>>>;
  /** The trace observer that was deleted. Defaults to `null` in case of failure. */
  traceObserver?: Maybe<EdgeTraceObserver>;
};

/** Description of errors that may occur while attempting to delete a trace observer. */
export type EdgeDeleteTraceObserverResponseError = {
  __typename?: 'EdgeDeleteTraceObserverResponseError';
  /** Error message, with further detail to help resolve the issue. */
  message: Scalars['String']['output'];
  /** Error that may occur while attempting to delete a trace observer. */
  type: EdgeDeleteTraceObserverResponseErrorType;
};

/** Known error codes and messages for `DeleteTraceObserverResponseError`. */
export enum EdgeDeleteTraceObserverResponseErrorType {
  /** The trace observer has already been deleted. */
  AlreadyDeleted = 'ALREADY_DELETED',
  /** No trace observer was found with the id given. */
  NotFound = 'NOT_FOUND'
}

/** Array of responses, one for each trace observer deletion request. */
export type EdgeDeleteTraceObserverResponses = {
  __typename?: 'EdgeDeleteTraceObserverResponses';
  /** Array of trace observer deletion responses, one for each `DeleteTraceObserverInput`. */
  responses: Array<EdgeDeleteTraceObserverResponse>;
};

/** An `Endpoint` describes access to an endpoint pointing to a trace observer. Currently, only one endpoint per trace observer is supported. */
export type EdgeEndpoint = {
  __typename?: 'EdgeEndpoint';
  /** Connection information related to the agent configuration. */
  agent: EdgeAgentEndpointDetail;
  /** Type of the endpoint. */
  endpointType: EdgeEndpointType;
  /** Connection information related to the Infinite Tracing Trace API (HTTP 1.1) configuration. */
  https: EdgeHttpsEndpointDetail;
  /** Status of the endpoint. */
  status: EdgeEndpointStatus;
};

/** The information common to all endpoints. */
export type EdgeEndpointDetail = {
  /** Full host name that is used to connect to the endpoint. */
  host: Scalars['String']['output'];
  /** Port that is used to connect to the endpoint. */
  port: Scalars['Int']['output'];
};

/** Status of the endpoint. */
export enum EdgeEndpointStatus {
  /** The endpoint has been created and is available for use. */
  Created = 'CREATED',
  /** The endpoint has been deleted and is no longer available for use. */
  Deleted = 'DELETED'
}

/** Type of connection established with the trace observer. Currently, only `PUBLIC` is supported. */
export enum EdgeEndpointType {
  /** PUBLIC: the endpoint is reachable on the internet. */
  Public = 'PUBLIC'
}

/** All the details necessary to configure an integration to connect to the Infinite Tracing Trace API (HTTP 1.1) endpoint. */
export type EdgeHttpsEndpointDetail = EdgeEndpointDetail & {
  __typename?: 'EdgeHttpsEndpointDetail';
  /** Full host name that is used to connect to the endpoint. */
  host: Scalars['String']['output'];
  /** Port that is used to connect to the endpoint. */
  port: Scalars['Int']['output'];
  /**
   * Full URL used to send data to the endpoint. For instance, if you were using the
   * [Java Telemetry SDK](https://docs.newrelic.com/docs/data-ingest-apis/get-data-new-relic/new-relic-sdks/telemetry-sdks-send-custom-telemetry-data-new-relic)
   * this is the data you would use to create a `URI` to pass to the [`uriOverride`](https://github.com/newrelic/newrelic-telemetry-sdk-java/blob/85e526cf6fbba0640f20d2d7a3ab0dab89f958b3/telemetry_core/src/main/java/com/newrelic/telemetry/AbstractSenderBuilder.java#L37-L48)
   * method.
   */
  url: Scalars['String']['output'];
};

/** Provider and region where the trace observer is located. Currently, only AWS regions are supported. */
export enum EdgeProviderRegion {
  /** Provider: `AWS`, Region: `ap-southeast-1` */
  AwsApSoutheast_1 = 'AWS_AP_SOUTHEAST_1',
  /** Provider: `AWS`, Region: `ap-southeast-2` */
  AwsApSoutheast_2 = 'AWS_AP_SOUTHEAST_2',
  /** Provider: `AWS`, Region: `eu-central-1` */
  AwsEuCentral_1 = 'AWS_EU_CENTRAL_1',
  /** Provider: `AWS`, Region: `eu-west-1` */
  AwsEuWest_1 = 'AWS_EU_WEST_1',
  /** Provider: `AWS`, Region: `us-east-1` */
  AwsUsEast_1 = 'AWS_US_EAST_1',
  /** Provider: `AWS`, Region: `us-east-2` */
  AwsUsEast_2 = 'AWS_US_EAST_2',
  /** Provider: `AWS`, Region: `us-west-2` */
  AwsUsWest_2 = 'AWS_US_WEST_2'
}

/** Contains all of the data that is used to sample traces based on random selection. */
export type EdgeRandomTraceFilter = {
  __typename?: 'EdgeRandomTraceFilter';
  /** The percent of traces to keep when selected at random. */
  percentKept: Scalars['Float']['output'];
};

/** Data required to change the random trace filter configuration. */
export type EdgeRandomTraceFilterInput = {
  /** The percentage of randomly selected traces to keep. Acceptable values are between 0.0001 and 100. */
  percentKept: Scalars['Float']['input'];
};

/** Span attribute key operator types */
export enum EdgeSpanAttributeKeyOperator {
  /** Matches on an exact value */
  Equals = 'EQUALS',
  /** Matches on a value that starts-with and/or ends-with the provided value */
  Like = 'LIKE'
}

/** A `SpanAttributeRule` applies a filtering rule (keep or discard) to traces within a particular `TraceObserver` */
export type EdgeSpanAttributeRule = {
  __typename?: 'EdgeSpanAttributeRule';
  /** The action that this filter takes if it matches the provided attribute name and value */
  action: EdgeTraceFilterAction;
  /** Globally unique identifier of this trace filter. */
  id: Scalars['Int']['output'];
  /** Name of the attribute that this filter matches on */
  key: Scalars['String']['output'];
  /** Type of match to apply to the attribute name (EQUALS, LIKE). */
  keyOperator: EdgeSpanAttributeKeyOperator;
  /** Value of the attribute that this filter matches on. */
  value?: Maybe<Scalars['String']['output']>;
  /** Type of match to apply to the attribute value (EQUALS, LIKE, IS_NOT_NULL). */
  valueOperator: EdgeSpanAttributeValueOperator;
};

/** Span attribute value operator types */
export enum EdgeSpanAttributeValueOperator {
  /** Matches on an exact value */
  Equals = 'EQUALS',
  /** Matches on any value */
  IsNotNull = 'IS_NOT_NULL',
  /** Matches on a value that starts-with and/or ends-with the provided value */
  Like = 'LIKE'
}

/** Contains all of the data that is used to sample traces based on their attributes. */
export type EdgeSpanAttributesTraceFilter = {
  __typename?: 'EdgeSpanAttributesTraceFilter';
  /** The list of rules that determine whether to keep or drop a trace based on a span attribute. */
  spanAttributeRules: Array<EdgeSpanAttributeRule>;
};

/** Type of action to perform when a `TraceFilter` match occurs */
export enum EdgeTraceFilterAction {
  /** Discards traces that match the filter */
  Discard = 'DISCARD',
  /** Keeps traces that match the filter */
  Keep = 'KEEP'
}

/** A container for all trace filter rule types */
export type EdgeTraceFilters = {
  __typename?: 'EdgeTraceFilters';
  /** Random trace filter configuration applied to the trace observer. */
  randomTraceFilter: EdgeRandomTraceFilter;
  /** Span attribute trace filter configuration applied to the trace observer. */
  spanAttributesTraceFilter: EdgeSpanAttributesTraceFilter;
};

/** A `TraceObserver` handles a group of tracing services for an account family. */
export type EdgeTraceObserver = {
  __typename?: 'EdgeTraceObserver';
  /** Optional list of compliance types (e.g., FedRAMP) applied to this trace observer. */
  complianceTypes?: Maybe<Array<EdgeComplianceTypeCode>>;
  /** The group of data sources if any have been assigned to this trace observer. */
  dataSourceGroup?: Maybe<EdgeDataSourceGroup>;
  /** List of endpoints associated with this trace observer. Currently, only one endpoint per trace observer is supported. */
  endpoints: Array<EdgeEndpoint>;
  /** Globally unique identifier of this trace observer. */
  id: Scalars['Int']['output'];
  /** Which account monitoring metrics are being written to for this trace observer (if specified) */
  monitoringAccountId?: Maybe<Scalars['Int']['output']>;
  /** Human-readable name of this trace observer. */
  name: Scalars['String']['output'];
  /** Provider-specific region of this endpoint (for example, `AWS_US_EAST_1`). Currently, only AWS regions are supported. */
  providerRegion: EdgeProviderRegion;
  /** Status of the trace observer. */
  status: EdgeTraceObserverStatus;
  /** Trace filters applied to the trace observer. */
  traceFilters: EdgeTraceFilters;
};

/** Status of the trace observer. */
export enum EdgeTraceObserverStatus {
  /** The trace observer has been created and is available for use. */
  Created = 'CREATED',
  /** The trace observer has been deleted and is no longer available for use. */
  Deleted = 'DELETED'
}

/** This field provides access to Tracing data. */
export type EdgeTracing = {
  __typename?: 'EdgeTracing';
  /** Lists the existing trace observers for this account family. */
  traceObservers?: Maybe<Array<EdgeTraceObserver>>;
};


/** This field provides access to Tracing data. */
export type EdgeTracingTraceObserversArgs = {
  ids?: InputMaybe<Array<Scalars['Int']['input']>>;
};

/** Data required to update a trace observer. */
export type EdgeUpdateTraceObserverInput = {
  /** When set, allows updating the data source group. */
  dataSourceGroupConfig?: InputMaybe<EdgeDataSourceGroupInput>;
  /** Globally unique identifier of the trace observer being updated. */
  id: Scalars['Int']['input'];
  /** When set to `true` a trace observer will write trace metrics to the current account. */
  monitoring?: InputMaybe<Scalars['Boolean']['input']>;
  /** Name of the trace observer. */
  name?: InputMaybe<Scalars['String']['input']>;
  /** When set, allows changing the random trace filter configuration. */
  randomTraceFilterConfig?: InputMaybe<EdgeRandomTraceFilterInput>;
};

/** Successfully updated trace observers, or one or more error responses if there were issues. */
export type EdgeUpdateTraceObserverResponse = {
  __typename?: 'EdgeUpdateTraceObserverResponse';
  /** Errors that may occur when creating a `TraceObserver`. Defaults to `null` in case of success. */
  errors?: Maybe<Array<Maybe<EdgeUpdateTraceObserverResponseError>>>;
  /** The trace observer defined in `UpdateTraceObserverInput`. Defaults to `null` in case of failure. */
  traceObserver?: Maybe<EdgeTraceObserver>;
};

/** Description of errors that may occur while attempting to update a trace observer. */
export type EdgeUpdateTraceObserverResponseError = {
  __typename?: 'EdgeUpdateTraceObserverResponseError';
  /** Error message, with further detail to help resolve the issue. */
  message: Scalars['String']['output'];
  /** Error that may occur while attempting to create a trace observer. */
  type: EdgeUpdateTraceObserverResponseErrorType;
};

/** Known error codes and messages for `UpdateTraceObserverResponseError`. */
export enum EdgeUpdateTraceObserverResponseErrorType {
  /** Invalid input provided. */
  InvalidInput = 'INVALID_INPUT',
  /** No trace observer was found with the id given. */
  NotFound = 'NOT_FOUND'
}

/** Array of responses, one for each trace observer update request. */
export type EdgeUpdateTraceObserverResponses = {
  __typename?: 'EdgeUpdateTraceObserverResponses';
  /** Array of trace observer update responses, one for each `UpdateTraceObserverInput`. */
  responses: Array<EdgeUpdateTraceObserverResponse>;
};

/** Represents all the visualization types available for embedded charts. */
export enum EmbeddedChartType {
  Apdex = 'APDEX',
  Area = 'AREA',
  Bar = 'BAR',
  Baseline = 'BASELINE',
  Billboard = 'BILLBOARD',
  Bullet = 'BULLET',
  Empty = 'EMPTY',
  EventFeed = 'EVENT_FEED',
  Funnel = 'FUNNEL',
  Heatmap = 'HEATMAP',
  Histogram = 'HISTOGRAM',
  Json = 'JSON',
  Line = 'LINE',
  Markdown = 'MARKDOWN',
  Pie = 'PIE',
  Scatter = 'SCATTER',
  StackedHorizontalBar = 'STACKED_HORIZONTAL_BAR',
  Table = 'TABLE',
  TrafficLight = 'TRAFFIC_LIGHT',
  VerticalBar = 'VERTICAL_BAR'
}

export type EntitlementAttribute = {
  __typename?: 'EntitlementAttribute';
  key?: Maybe<Scalars['String']['output']>;
  value?: Maybe<Scalars['String']['output']>;
};

/**
 * The `Entity` interface allows fetching detailed entity information for a single entity.
 *
 * To understand more about entities and entity types, look at [our docs](https://docs.newrelic.com/docs/what-are-new-relic-entities).
 */
export type Entity = {
  account?: Maybe<AccountOutline>;
  /** The New Relic account ID associated with this entity. */
  accountId?: Maybe<Scalars['Int']['output']>;
  /** The current alerting severity of the entity. */
  alertSeverity?: Maybe<EntityAlertSeverity>;
  /**
   * The alert status of the entity.
   * @deprecated Please use `alertSeverity` and `reporting`
   */
  alertStatus?: Maybe<EntityAlertStatus>;
  /** Violations on the entity that were open during the specified time window. This will return up to 500 violations - if there are more in the time window selected, you must narrow the time window or look at fewer entities. */
  alertViolations?: Maybe<Array<Maybe<EntityAlertViolation>>>;
  /** Retrieve the deployment event(s). Ordered by timestamp DESC. */
  deploymentSearch?: Maybe<ChangeTrackingDeploymentSearchResult>;
  /** The entity's domain */
  domain?: Maybe<Scalars['String']['output']>;
  /** A value representing the combination of the entity's domain and type. */
  entityType?: Maybe<EntityType>;
  /** The date of last time the entity has updated any of its fields. */
  firstIndexedAt?: Maybe<Scalars['EpochMilliseconds']['output']>;
  /** The list of golden metrics for a specific entity */
  goldenMetrics?: Maybe<EntityGoldenContextScopedGoldenMetrics>;
  /**
   * For the golden signal on this entity, show correlated signals from related entities.
   * Well inspect the golden signals for all related entities and return a sorted list.
   * You can also filter the results.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  goldenSignalCorrelations?: Maybe<GoldenSignalCorrelationResult>;
  /**
   * The deviation from normal of golden signal(s) for the given entity.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  goldenSignalDeviations?: Maybe<Array<Maybe<GoldenSignalSignalDeviation>>>;
  /**
   * The stored golden signal(s) for the given entity.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  goldenSignalValues?: Maybe<GoldenSignalValues>;
  /**
   * The stored golden signal(s) for the given entity. To be removed, use goldenSignalValues instead.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  goldenSignalValuesV2?: Maybe<GoldenSignalValues>;
  /** The list of golden tags for a specific entityType. */
  goldenTags?: Maybe<EntityGoldenContextScopedGoldenTags>;
  /** A unique entity identifier. */
  guid?: Maybe<Scalars['EntityGuid']['output']>;
  /** The time the entity was indexed. */
  indexedAt?: Maybe<Scalars['EpochMilliseconds']['output']>;
  /** The last time the entity's reporting status changed. */
  lastReportingChangeAt?: Maybe<Scalars['EpochMilliseconds']['output']>;
  /** The name of this entity. */
  name?: Maybe<Scalars['String']['output']>;
  nerdStorage?: Maybe<NerdStorageEntityScope>;
  nerdStoreCollection?: Maybe<Array<Maybe<NerdStoreCollectionMember>>>;
  nerdStoreDocument?: Maybe<Scalars['NerdStoreDocument']['output']>;
  /**
   * Make an `Entity` scoped query to NRDB with a NRQL string.
   *
   * A relevant `WHERE` clause will be added to your query to scope data to the entity in question.
   *
   * See the [NRQL Docs](https://docs.newrelic.com/docs/insights/nrql-new-relic-query-language/nrql-resources/nrql-syntax-components-functions) for more information about generating a query string.
   */
  nrdbQuery?: Maybe<NrdbResultContainer>;
  /**
   * Poll for the results of a previously-executed asychronous NRDB query.
   *
   * The `queryId` is available in the `queryProgress` data returned by the original asynchronous query.
   *
   * See [this page](https://docs.newrelic.com/docs/apis/nerdgraph/examples/async-queries-nrql-tutorial) for additional asynchronous query documentation.
   * @deprecated This field is experimental! It may change at any time.
   *
   */
  nrdbQueryProgress?: Maybe<NrdbResultContainer>;
  /** The url to the entity. */
  permalink?: Maybe<Scalars['String']['output']>;
  /** Recent violations on the entity. */
  recentAlertViolations?: Maybe<Array<Maybe<EntityAlertViolation>>>;
  /** The recommended service levels for the entity. */
  recommendedServiceLevel?: Maybe<ServiceLevelRecommendation>;
  /** Related dashboards results */
  relatedDashboards: RelatedDashboardsRelatedDashboardResult;
  /** Related entities result with optional filtering. */
  relatedEntities?: Maybe<EntityRelationshipRelatedEntitiesResult>;
  /** Relationship traversal results with optional filtering. WARNING: this query is still experimental, and subject to breaking changes. */
  relationshipTraversal?: Maybe<EntityRelationshipTraversalResult>;
  /**
   * A list of the entities' relationships.
   *
   * For more information, visit [our docs](https://docs.newrelic.com/docs/apis/graphql-api/tutorials/graphql-relationships-api-tutorial).
   * @deprecated This field is deprecated! Please use `relatedEntities`.
   */
  relationships?: Maybe<Array<Maybe<EntityRelationship>>>;
  /** The reporting status of the entity. If New Relic is successfully collecting data from your application, this will be true. */
  reporting?: Maybe<Scalars['Boolean']['output']>;
  /** The service level defined for the entity. */
  serviceLevel?: Maybe<ServiceLevelDefinition>;
  /** The list of summary metrics. */
  summaryMetrics?: Maybe<Array<Maybe<EntitySummaryMetric>>>;
  /**
   * The tags applied to the entity.
   *
   * For details on tags, as well as query and mutation examples, visit [our docs](https://docs.newrelic.com/docs/apis/graphql-api/tutorials/graphql-tagging-api-tutorial).
   */
  tags?: Maybe<Array<Maybe<EntityTag>>>;
  /** The tags applied to the entity with their metadata. */
  tagsWithMetadata?: Maybe<Array<Maybe<EntityTagWithMetadata>>>;
  /** Look up Distributed Tracing summary data for the selected `EntityGuid` */
  tracingSummary?: Maybe<DistributedTracingEntityTracingSummary>;
  /** The entity's type */
  type?: Maybe<Scalars['String']['output']>;
  /** List of templates availables for this entity. */
  uiTemplates?: Maybe<Array<EntityDashboardTemplatesUi>>;
};


/**
 * The `Entity` interface allows fetching detailed entity information for a single entity.
 *
 * To understand more about entities and entity types, look at [our docs](https://docs.newrelic.com/docs/what-are-new-relic-entities).
 */
export type EntityAlertViolationsArgs = {
  endTime: Scalars['EpochMilliseconds']['input'];
  startTime: Scalars['EpochMilliseconds']['input'];
};


/**
 * The `Entity` interface allows fetching detailed entity information for a single entity.
 *
 * To understand more about entities and entity types, look at [our docs](https://docs.newrelic.com/docs/what-are-new-relic-entities).
 */
export type EntityDeploymentSearchArgs = {
  filter?: InputMaybe<ChangeTrackingSearchFilter>;
};


/**
 * The `Entity` interface allows fetching detailed entity information for a single entity.
 *
 * To understand more about entities and entity types, look at [our docs](https://docs.newrelic.com/docs/what-are-new-relic-entities).
 */
export type EntityGoldenMetricsArgs = {
  context?: InputMaybe<EntityGoldenContextInput>;
  timeWindow?: InputMaybe<EntityGoldenNrqlTimeWindowInput>;
};


/**
 * The `Entity` interface allows fetching detailed entity information for a single entity.
 *
 * To understand more about entities and entity types, look at [our docs](https://docs.newrelic.com/docs/what-are-new-relic-entities).
 */
export type EntityGoldenSignalCorrelationsArgs = {
  filter?: InputMaybe<GoldenSignalCorrelationsEntityFilter>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  timeWindow?: InputMaybe<TimeWindowInput>;
};


/**
 * The `Entity` interface allows fetching detailed entity information for a single entity.
 *
 * To understand more about entities and entity types, look at [our docs](https://docs.newrelic.com/docs/what-are-new-relic-entities).
 */
export type EntityGoldenSignalDeviationsArgs = {
  comparisonTimeWindow?: InputMaybe<TimeWindowInput>;
  evaluationTimeWindow?: InputMaybe<TimeWindowInput>;
};


/**
 * The `Entity` interface allows fetching detailed entity information for a single entity.
 *
 * To understand more about entities and entity types, look at [our docs](https://docs.newrelic.com/docs/what-are-new-relic-entities).
 */
export type EntityGoldenSignalValuesArgs = {
  timeWindow?: InputMaybe<TimeWindowInput>;
};


/**
 * The `Entity` interface allows fetching detailed entity information for a single entity.
 *
 * To understand more about entities and entity types, look at [our docs](https://docs.newrelic.com/docs/what-are-new-relic-entities).
 */
export type EntityGoldenSignalValuesV2Args = {
  timeWindow?: InputMaybe<TimeWindowInput>;
};


/**
 * The `Entity` interface allows fetching detailed entity information for a single entity.
 *
 * To understand more about entities and entity types, look at [our docs](https://docs.newrelic.com/docs/what-are-new-relic-entities).
 */
export type EntityGoldenTagsArgs = {
  context?: InputMaybe<EntityGoldenContextInput>;
};


/**
 * The `Entity` interface allows fetching detailed entity information for a single entity.
 *
 * To understand more about entities and entity types, look at [our docs](https://docs.newrelic.com/docs/what-are-new-relic-entities).
 */
export type EntityNerdStoreCollectionArgs = {
  collection: Scalars['String']['input'];
  scopeByActor?: InputMaybe<Scalars['Boolean']['input']>;
};


/**
 * The `Entity` interface allows fetching detailed entity information for a single entity.
 *
 * To understand more about entities and entity types, look at [our docs](https://docs.newrelic.com/docs/what-are-new-relic-entities).
 */
export type EntityNerdStoreDocumentArgs = {
  collection: Scalars['String']['input'];
  documentId: Scalars['String']['input'];
  scopeByActor?: InputMaybe<Scalars['Boolean']['input']>;
};


/**
 * The `Entity` interface allows fetching detailed entity information for a single entity.
 *
 * To understand more about entities and entity types, look at [our docs](https://docs.newrelic.com/docs/what-are-new-relic-entities).
 */
export type EntityNrdbQueryArgs = {
  async?: InputMaybe<Scalars['Boolean']['input']>;
  nrql: Scalars['Nrql']['input'];
  options?: InputMaybe<NrqlQueryOptions>;
  timeout?: InputMaybe<Scalars['Seconds']['input']>;
};


/**
 * The `Entity` interface allows fetching detailed entity information for a single entity.
 *
 * To understand more about entities and entity types, look at [our docs](https://docs.newrelic.com/docs/what-are-new-relic-entities).
 */
export type EntityNrdbQueryProgressArgs = {
  queryId: Scalars['ID']['input'];
};


/**
 * The `Entity` interface allows fetching detailed entity information for a single entity.
 *
 * To understand more about entities and entity types, look at [our docs](https://docs.newrelic.com/docs/what-are-new-relic-entities).
 */
export type EntityRecentAlertViolationsArgs = {
  count?: InputMaybe<Scalars['Int']['input']>;
};


/**
 * The `Entity` interface allows fetching detailed entity information for a single entity.
 *
 * To understand more about entities and entity types, look at [our docs](https://docs.newrelic.com/docs/what-are-new-relic-entities).
 */
export type EntityRelatedEntitiesArgs = {
  cursor?: InputMaybe<Scalars['String']['input']>;
  filter?: InputMaybe<EntityRelationshipEdgeFilter>;
  limit?: InputMaybe<Scalars['Int']['input']>;
};


/**
 * The `Entity` interface allows fetching detailed entity information for a single entity.
 *
 * To understand more about entities and entity types, look at [our docs](https://docs.newrelic.com/docs/what-are-new-relic-entities).
 */
export type EntityRelationshipTraversalArgs = {
  cursor?: InputMaybe<Scalars['String']['input']>;
  hopFilters?: InputMaybe<EntityRelationshipTraversalHopFilters>;
  hops?: InputMaybe<Scalars['Int']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
};


/**
 * The `Entity` interface allows fetching detailed entity information for a single entity.
 *
 * To understand more about entities and entity types, look at [our docs](https://docs.newrelic.com/docs/what-are-new-relic-entities).
 */
export type EntityRelationshipsArgs = {
  endTime?: InputMaybe<Scalars['EpochMilliseconds']['input']>;
  filter?: InputMaybe<EntityRelationshipFilter>;
};


/**
 * The `Entity` interface allows fetching detailed entity information for a single entity.
 *
 * To understand more about entities and entity types, look at [our docs](https://docs.newrelic.com/docs/what-are-new-relic-entities).
 */
export type EntitySummaryMetricsArgs = {
  timeWindow?: InputMaybe<TimeWindowInput>;
};


/**
 * The `Entity` interface allows fetching detailed entity information for a single entity.
 *
 * To understand more about entities and entity types, look at [our docs](https://docs.newrelic.com/docs/what-are-new-relic-entities).
 */
export type EntityTracingSummaryArgs = {
  timeWindow?: InputMaybe<TimeWindowInput>;
};

/** The alert severity of the entity. */
export enum EntityAlertSeverity {
  /** Indicates an entity has a critical violation in progress. */
  Critical = 'CRITICAL',
  /** Indicates an entity has no violations and therefore is not alerting. */
  NotAlerting = 'NOT_ALERTING',
  /** Indicates an entity is not configured for alerting. */
  NotConfigured = 'NOT_CONFIGURED',
  /** Indicates an entity  has a warning violation in progress. */
  Warning = 'WARNING'
}

export enum EntityAlertStatus {
  /** Not alerting */
  Green = 'GREEN',
  /** Entity not reporting */
  Grey = 'GREY',
  /** No alerts set up */
  LightGreen = 'LIGHT_GREEN',
  /** Critical violation */
  Red = 'RED',
  /** Warning violation */
  Yellow = 'YELLOW'
}

/** The alert violation for an entity */
export type EntityAlertViolation = {
  __typename?: 'EntityAlertViolation';
  /** A link to the agent in the time window in which the violation occurred. */
  agentUrl?: Maybe<Scalars['String']['output']>;
  /** The severity of the violation. */
  alertSeverity?: Maybe<EntityAlertSeverity>;
  /**
   * The current alert status of the violation.
   * @deprecated Please use `alertSeverity`.
   */
  alertStatus?: Maybe<EntityAlertStatus>;
  /** Timestamp of when the violation was closed. */
  closedAt?: Maybe<Scalars['EpochMilliseconds']['output']>;
  /** The description of the violation. */
  label?: Maybe<Scalars['String']['output']>;
  /** The priority of the violation. */
  level?: Maybe<Scalars['String']['output']>;
  /** Timestamp of when the violation was opened. */
  openedAt?: Maybe<Scalars['EpochMilliseconds']['output']>;
  /** The id of the violation. */
  violationId?: Maybe<Scalars['EntityAlertViolationInt']['output']>;
  /** A link to the violation if it is connected to an incident. */
  violationUrl?: Maybe<Scalars['String']['output']>;
};

/** A collection of user defined Entities and Entity Search queries. */
export type EntityCollection = {
  __typename?: 'EntityCollection';
  /** The account the collection is part of */
  account?: Maybe<AccountReference>;
  /** The user who created the collection */
  createdBy?: Maybe<UserReference>;
  /** The definition of the collection. */
  definition?: Maybe<EntityCollectionDefinition>;
  /** The GUID of the Entity */
  guid?: Maybe<Scalars['EntityGuid']['output']>;
  /** The result of searching for the members of the collection. */
  members?: Maybe<EntitySearch>;
  /** The name of the collection. */
  name?: Maybe<Scalars['String']['output']>;
  /** The type of Collection */
  type?: Maybe<EntityCollectionType>;
};

/** The definition of a collection. */
export type EntityCollectionDefinition = {
  __typename?: 'EntityCollectionDefinition';
  /** A list of entity GUIDs. These entities will belong to the collection as long as their accounts are included in the scope accounts of the collection. */
  entityGuids?: Maybe<Array<Maybe<Scalars['EntityGuid']['output']>>>;
  /** The Entity Search query that returns the full collection of entities. */
  entitySearchQuery?: Maybe<Scalars['String']['output']>;
  /** The Accounts that will be used to scope the collection. */
  scopeAccounts?: Maybe<EntityCollectionScopeAccounts>;
  /** A list of entity search queries. The resulting entities will be limited to the scope accounts of the collection. */
  searchQueries?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
};

/** The Accounts used to scope a collection. */
export type EntityCollectionScopeAccounts = {
  __typename?: 'EntityCollectionScopeAccounts';
  /** The Account IDs that make up the account scoping. */
  accountIds?: Maybe<Array<Maybe<Scalars['Int']['output']>>>;
};

/** Indicates where this collection is used */
export enum EntityCollectionType {
  /** Collections that define the entities that belong to a team */
  Team = 'TEAM',
  /** Collections that define the entities that belong to a workload */
  Workload = 'WORKLOAD',
  /** Collections that define the entity groups that are used to calculate the status of a workload */
  WorkloadStatusRuleGroup = 'WORKLOAD_STATUS_RULE_GROUP'
}

/** A type that encapsulates the templates configuration for the UI. */
export type EntityDashboardTemplatesUi = {
  __typename?: 'EntityDashboardTemplatesUi';
  /** The template to feed mosaic with in order to build an interface. */
  template?: Maybe<Scalars['EntityDashboardTemplatesRawMosaicTemplate']['output']>;
};

/** Type that wraps the errors from a entity delete operation. */
export type EntityDeleteError = {
  __typename?: 'EntityDeleteError';
  /** Guid related to the error. */
  guid?: Maybe<Scalars['EntityGuid']['output']>;
  /** User-friendly message describing the error. */
  message: Scalars['String']['output'];
  /** Describes all potential error types that a delete operation might return. */
  type: EntityDeleteErrorType;
};

/** List of all potential error types that an entity delete operation might return. */
export enum EntityDeleteErrorType {
  /** Forbidden request */
  Forbidden = 'FORBIDDEN',
  /** Internal error */
  InternalError = 'INTERNAL_ERROR',
  /** Invalid input */
  InvalidInput = 'INVALID_INPUT'
}

/** Response type for delete operations over entities. */
export type EntityDeleteResult = {
  __typename?: 'EntityDeleteResult';
  /** List that contains the guids of the deleted entities */
  deletedEntities: Array<Scalars['EntityGuid']['output']>;
  /** List of failures for the delete operation. */
  failures: Array<EntityDeleteError>;
};

/** metrics aggregated by title and name. */
export type EntityGoldenAggregatedMetrics = {
  __typename?: 'EntityGoldenAggregatedMetrics';
  /** The synthesised metric name. i.e: newrelic.goldenmetrics.apm.application.throughput */
  metricName: Scalars['String']['output'];
  /** The name of the golden metric. */
  name: Scalars['String']['output'];
  /** queries aggregated by accountID */
  queries?: Maybe<Array<Maybe<EntityGoldenAggregatedQueries>>>;
  /** The title of the golden metric. */
  title: Scalars['String']['output'];
  /** The unit used to represent the golden metric. */
  unit: EntityGoldenMetricUnit;
};

/** queries aggregated by accountId. for multiple guids under same account and domainType will be concatenated in IN CLAUSE of query */
export type EntityGoldenAggregatedQueries = {
  __typename?: 'EntityGoldenAggregatedQueries';
  /** accountID that the golden metrics belong to */
  accountId: Scalars['Int']['output'];
  /** The definition of the golden metric. */
  definition: EntityGoldenMetricDefinition;
  /** Original definition of the golden metric as it's defined in the public repo https://github.com/newrelic/entity-definitions. */
  originalDefinition: EntityGoldenMetricDefinition;
  /** Original query as it is defined in the public repo https://github.com/newrelic/entity-definitions. */
  originalQuery: Scalars['String']['output'];
  /** The golden metric NRQL query. */
  query: Scalars['String']['output'];
};

/** An object that represent the context. */
export type EntityGoldenContext = {
  __typename?: 'EntityGoldenContext';
  /** Account context. */
  account?: Maybe<Scalars['Int']['output']>;
  /** Collection guid context. */
  guid?: Maybe<Scalars['EntityGuid']['output']>;
};

/** Input type used to define the context for the golden metrics. */
export type EntityGoldenContextInput = {
  /** Account context. */
  account?: InputMaybe<Scalars['Int']['input']>;
  /** Collection guid context. */
  guid?: InputMaybe<Scalars['EntityGuid']['input']>;
};

/** An object that represents the golden metrics scoped by context */
export type EntityGoldenContextScopedGoldenMetrics = {
  __typename?: 'EntityGoldenContextScopedGoldenMetrics';
  /** Context for the golden metric */
  context: EntityGoldenContext;
  /** Metrics for the domain and type */
  metrics: Array<EntityGoldenMetric>;
};

/** An object that represents the golden tags scoped by context */
export type EntityGoldenContextScopedGoldenTags = {
  __typename?: 'EntityGoldenContextScopedGoldenTags';
  /** Context for the golden tags */
  context: EntityGoldenContext;
  /** Tags for the domain and type */
  tags: Array<EntityGoldenTag>;
};

/** Types of references for the default WHERE clause. */
export enum EntityGoldenEventObjectId {
  /** The WHERE clause will be done against a domainId. */
  DomainIds = 'DOMAIN_IDS',
  /** The WHERE clause will be done against a GUID. */
  EntityGuids = 'ENTITY_GUIDS',
  /**
   * The WHERE clause will be done against the name of the entity.
   * @deprecated This use case will be removed in future versions.
   */
  EntityNames = 'ENTITY_NAMES'
}

/** The different error types in golden metrics */
export type EntityGoldenGoldenMetricsError = {
  __typename?: 'EntityGoldenGoldenMetricsError';
  /** The error description */
  message?: Maybe<Scalars['String']['output']>;
  /** An error type */
  type: EntityGoldenGoldenMetricsErrorType;
};

/** An object that represents a golden metrics error */
export enum EntityGoldenGoldenMetricsErrorType {
  /** The context defined in the request is not valid. */
  InvalidContext = 'INVALID_CONTEXT',
  /** The domain type defined in the request is not valid. */
  InvalidDomainType = 'INVALID_DOMAIN_TYPE',
  /** There is some parameter validation that has failed */
  InvalidQueryParams = 'INVALID_QUERY_PARAMS',
  /** Number of metrics defined in the requests exceeds the limit. */
  LimitExceeded = 'LIMIT_EXCEEDED',
  /** The user does not have permissions to perform the operation. */
  NotAuthorized = 'NOT_AUTHORIZED'
}

/** golden metrics grouped by domainType and account */
export type EntityGoldenGroupedGoldenMetrics = {
  __typename?: 'EntityGoldenGroupedGoldenMetrics';
  /** entity domain and entity type which the grouped golden metrics belong to */
  domainType: DomainType;
  /** golden metrics grouped by account */
  metrics: Array<EntityGoldenAggregatedMetrics>;
};

/** An object that represents a golden metric. */
export type EntityGoldenMetric = {
  __typename?: 'EntityGoldenMetric';
  /** The definition of the golden metric. */
  definition: EntityGoldenMetricDefinition;
  /** The synthesised metric name. i.e: newrelic.goldenmetrics.apm.application.throughput */
  metricName: Scalars['String']['output'];
  /** The name of the golden metric. */
  name: Scalars['String']['output'];
  /** The definitions of the golden metric as they are defined in the public repo https://github.com/newrelic/entity-definitions. */
  originalDefinitions: Array<EntityGoldenOriginalDefinitionWithSelector>;
  /** Original queries as they are defined in the public repo https://github.com/newrelic/entity-definitions. */
  originalQueries: Array<EntityGoldenOriginalQueryWithSelector>;
  /** The golden metric NRQL query. */
  query: Scalars['String']['output'];
  /** The title of the golden metric. */
  title: Scalars['String']['output'];
  /** The unit used to represent the golden metric. */
  unit: EntityGoldenMetricUnit;
};

/** The definition of the metric. */
export type EntityGoldenMetricDefinition = {
  __typename?: 'EntityGoldenMetricDefinition';
  /** The field used to filter the entity in the metric. This will be added to the WHERE by default. */
  eventId: Scalars['String']['output'];
  /** Indicates if the eventId field references a GUID, a domainId or an entity name. */
  eventObjectId: EntityGoldenEventObjectId;
  /** The field to FACET by. */
  facet: Scalars['String']['output'];
  /** The FROM clause of the query. */
  from: Scalars['String']['output'];
  /** The SELECT clause of the query. */
  select: Scalars['String']['output'];
  /** If a complementary WHERE clause is required to identify the entity type this field will contain it. */
  where?: Maybe<Scalars['String']['output']>;
};

/** Input type for the metrics. */
export type EntityGoldenMetricInput = {
  /** The field that is used identifies the entities. Default: entity.guid */
  eventId?: InputMaybe<Scalars['String']['input']>;
  /** The field to FACET by. Default: entity.name */
  facet?: InputMaybe<Scalars['String']['input']>;
  /** The FROM clause of the query. Default: Metric */
  from?: InputMaybe<Scalars['String']['input']>;
  /** The name of the metric */
  name: Scalars['String']['input'];
  /** The SELECT clause of the query. */
  select: Scalars['String']['input'];
  /** The title of the metric */
  title: Scalars['String']['input'];
  /** If a complementary WHERE clause is given this field will contain it. */
  where?: InputMaybe<Scalars['String']['input']>;
};

/** The different units that can be used to express golden metrics. */
export enum EntityGoldenMetricUnit {
  /** Apdex (Application Performance Index). */
  Apdex = 'APDEX',
  /** Bits. */
  Bits = 'BITS',
  /** Bits per second. */
  BitsPerSecond = 'BITS_PER_SECOND',
  /** Bytes. */
  Bytes = 'BYTES',
  /** Bytes per second. */
  BytesPerSecond = 'BYTES_PER_SECOND',
  /** Degrees celsius. */
  Celsius = 'CELSIUS',
  /** Count. */
  Count = 'COUNT',
  /** Hertz. */
  Hertz = 'HERTZ',
  /** Messages per second. */
  MessagesPerSecond = 'MESSAGES_PER_SECOND',
  /** Milliseconds. */
  Ms = 'MS',
  /** Operations per second. */
  OperationsPerSecond = 'OPERATIONS_PER_SECOND',
  /** Pages loaded per second. */
  PagesPerSecond = 'PAGES_PER_SECOND',
  /** Percentage. */
  Percentage = 'PERCENTAGE',
  /** Requests received per minute. */
  RequestsPerMinute = 'REQUESTS_PER_MINUTE',
  /** Requests received per second. */
  RequestsPerSecond = 'REQUESTS_PER_SECOND',
  /** Seconds. */
  Seconds = 'SECONDS',
  /** Timestamp. */
  Timestamp = 'TIMESTAMP'
}

/** An object that represents the golden metrics scoped by domain and type */
export type EntityGoldenMetricsDomainTypeScoped = {
  __typename?: 'EntityGoldenMetricsDomainTypeScoped';
  /** Context for the golden metric */
  context: EntityGoldenContext;
  /** Domain type for the golden metrics */
  domainType: DomainType;
  /** Metrics for the domain and type */
  metrics: Array<EntityGoldenMetric>;
};

/** An object that represents the golden metrics scoped by domain and type mutation result */
export type EntityGoldenMetricsDomainTypeScopedResponse = {
  __typename?: 'EntityGoldenMetricsDomainTypeScopedResponse';
  /** The list of the errors */
  errors?: Maybe<Array<EntityGoldenGoldenMetricsError>>;
  /** The metrics results of the mutations */
  metrics?: Maybe<EntityGoldenMetricsDomainTypeScoped>;
};

/** Time range to apply to the golden metric NRQL query */
export type EntityGoldenNrqlTimeWindowInput = {
  /** Start time. */
  since?: InputMaybe<Scalars['Nrql']['input']>;
  /** End time. */
  until?: InputMaybe<Scalars['Nrql']['input']>;
};

/** Represents a metric definition for a give metric selector value. */
export type EntityGoldenOriginalDefinitionWithSelector = {
  __typename?: 'EntityGoldenOriginalDefinitionWithSelector';
  /** The definition of the golden metric. */
  definition: EntityGoldenMetricDefinition;
  /** The value of the selector. Currently, this is the value of the instrumentation provider. */
  selectorValue: Scalars['String']['output'];
};

/** Object that represents a nrql metric with its metric selector */
export type EntityGoldenOriginalQueryWithSelector = {
  __typename?: 'EntityGoldenOriginalQueryWithSelector';
  /** The golden metric NRQL query. */
  query: Scalars['String']['output'];
  /** The value of the selector. Currently, this is the value of the instrumentation provider. */
  selectorValue: Scalars['String']['output'];
};

/** An object that represents a golden tag. */
export type EntityGoldenTag = {
  __typename?: 'EntityGoldenTag';
  /** The golden tag key. */
  key: Scalars['String']['output'];
};

/** An input that represents a golden tag */
export type EntityGoldenTagInput = {
  /** The golden tag key. */
  key: Scalars['String']['input'];
};

/** An object that represents the golden tags scoped by domain and type */
export type EntityGoldenTagsDomainTypeScoped = {
  __typename?: 'EntityGoldenTagsDomainTypeScoped';
  /** Context for the golden tags */
  context: EntityGoldenContext;
  /** Domain type for the golden tags */
  domainType: DomainType;
  /** Tags for the domain and type */
  tags: Array<EntityGoldenTag>;
};

/** An object that represents the golden tags scoped by domain and type mutation result */
export type EntityGoldenTagsDomainTypeScopedResponse = {
  __typename?: 'EntityGoldenTagsDomainTypeScopedResponse';
  /** The list of the errors */
  errors?: Maybe<Array<EntityGoldenGoldenMetricsError>>;
  /** The tags results of the mutations */
  tags?: Maybe<EntityGoldenTagsDomainTypeScoped>;
};

export type EntityGuidSegments = {
  __typename?: 'EntityGuidSegments';
  accountId?: Maybe<Scalars['Int']['output']>;
  domain?: Maybe<Scalars['String']['output']>;
  domainId?: Maybe<Scalars['String']['output']>;
  guid?: Maybe<Scalars['EntityGuid']['output']>;
  type?: Maybe<Scalars['String']['output']>;
};

/** The type of Infrastructure Integration */
export enum EntityInfrastructureIntegrationType {
  /** APACHE_SERVER integration */
  ApacheServer = 'APACHE_SERVER',
  /** AWSELASTICSEARCHNODE integration */
  Awselasticsearchnode = 'AWSELASTICSEARCHNODE',
  /** AWS_ALB integration */
  AwsAlb = 'AWS_ALB',
  /** AWS_ALB_LISTENER integration */
  AwsAlbListener = 'AWS_ALB_LISTENER',
  /** AWS_ALB_LISTENER_RULE integration */
  AwsAlbListenerRule = 'AWS_ALB_LISTENER_RULE',
  /** AWS_ALB_TARGET_GROUP integration */
  AwsAlbTargetGroup = 'AWS_ALB_TARGET_GROUP',
  /** AWS_API_GATEWAY_API integration */
  AwsApiGatewayApi = 'AWS_API_GATEWAY_API',
  /** AWS_API_GATEWAY_RESOURCE integration */
  AwsApiGatewayResource = 'AWS_API_GATEWAY_RESOURCE',
  /** AWS_API_GATEWAY_RESOURCE_WITH_METRICS integration */
  AwsApiGatewayResourceWithMetrics = 'AWS_API_GATEWAY_RESOURCE_WITH_METRICS',
  /** AWS_API_GATEWAY_STAGE integration */
  AwsApiGatewayStage = 'AWS_API_GATEWAY_STAGE',
  /** AWS_AUTO_SCALING_GROUP integration */
  AwsAutoScalingGroup = 'AWS_AUTO_SCALING_GROUP',
  /** AWS_AUTO_SCALING_INSTANCE integration */
  AwsAutoScalingInstance = 'AWS_AUTO_SCALING_INSTANCE',
  /** AWS_AUTO_SCALING_LAUNCH_CONFIGURATION integration */
  AwsAutoScalingLaunchConfiguration = 'AWS_AUTO_SCALING_LAUNCH_CONFIGURATION',
  /** AWS_AUTO_SCALING_POLICY integration */
  AwsAutoScalingPolicy = 'AWS_AUTO_SCALING_POLICY',
  /** AWS_AUTO_SCALING_REGION_LIMIT integration */
  AwsAutoScalingRegionLimit = 'AWS_AUTO_SCALING_REGION_LIMIT',
  /** AWS_BILLING_ACCOUNT_COST integration */
  AwsBillingAccountCost = 'AWS_BILLING_ACCOUNT_COST',
  /** AWS_BILLING_ACCOUNT_SERVICE_COST integration */
  AwsBillingAccountServiceCost = 'AWS_BILLING_ACCOUNT_SERVICE_COST',
  /** AWS_BILLING_BUDGET integration */
  AwsBillingBudget = 'AWS_BILLING_BUDGET',
  /** AWS_BILLING_SERVICE_COST integration */
  AwsBillingServiceCost = 'AWS_BILLING_SERVICE_COST',
  /** AWS_CLOUD_FRONT_DISTRIBUTION integration */
  AwsCloudFrontDistribution = 'AWS_CLOUD_FRONT_DISTRIBUTION',
  /** AWS_CLOUD_TRAIL integration */
  AwsCloudTrail = 'AWS_CLOUD_TRAIL',
  /** AWS_DYNAMO_DB_GLOBAL_SECONDARY_INDEX integration */
  AwsDynamoDbGlobalSecondaryIndex = 'AWS_DYNAMO_DB_GLOBAL_SECONDARY_INDEX',
  /** AWS_DYNAMO_DB_REGION integration */
  AwsDynamoDbRegion = 'AWS_DYNAMO_DB_REGION',
  /** AWS_DYNAMO_DB_TABLE integration */
  AwsDynamoDbTable = 'AWS_DYNAMO_DB_TABLE',
  /** AWS_EBS_VOLUME integration */
  AwsEbsVolume = 'AWS_EBS_VOLUME',
  /** AWS_ECS_CLUSTER integration */
  AwsEcsCluster = 'AWS_ECS_CLUSTER',
  /** AWS_ECS_SERVICE integration */
  AwsEcsService = 'AWS_ECS_SERVICE',
  /** AWS_EFS_FILE_SYSTEM integration */
  AwsEfsFileSystem = 'AWS_EFS_FILE_SYSTEM',
  /** AWS_ELASTICSEARCH_CLUSTER integration */
  AwsElasticsearchCluster = 'AWS_ELASTICSEARCH_CLUSTER',
  /** AWS_ELASTICSEARCH_INSTANCE integration */
  AwsElasticsearchInstance = 'AWS_ELASTICSEARCH_INSTANCE',
  /** AWS_ELASTIC_BEANSTALK_ENVIRONMENT integration */
  AwsElasticBeanstalkEnvironment = 'AWS_ELASTIC_BEANSTALK_ENVIRONMENT',
  /** AWS_ELASTIC_BEANSTALK_INSTANCE integration */
  AwsElasticBeanstalkInstance = 'AWS_ELASTIC_BEANSTALK_INSTANCE',
  /** AWS_ELASTIC_MAP_REDUCE_CLUSTER integration */
  AwsElasticMapReduceCluster = 'AWS_ELASTIC_MAP_REDUCE_CLUSTER',
  /** AWS_ELASTIC_MAP_REDUCE_INSTANCE integration */
  AwsElasticMapReduceInstance = 'AWS_ELASTIC_MAP_REDUCE_INSTANCE',
  /** AWS_ELASTIC_MAP_REDUCE_INSTANCE_FLEET integration */
  AwsElasticMapReduceInstanceFleet = 'AWS_ELASTIC_MAP_REDUCE_INSTANCE_FLEET',
  /** AWS_ELASTIC_MAP_REDUCE_INSTANCE_GROUP integration */
  AwsElasticMapReduceInstanceGroup = 'AWS_ELASTIC_MAP_REDUCE_INSTANCE_GROUP',
  /** AWS_ELASTI_CACHE_MEMCACHED_CLUSTER integration */
  AwsElastiCacheMemcachedCluster = 'AWS_ELASTI_CACHE_MEMCACHED_CLUSTER',
  /** AWS_ELASTI_CACHE_MEMCACHED_NODE integration */
  AwsElastiCacheMemcachedNode = 'AWS_ELASTI_CACHE_MEMCACHED_NODE',
  /** AWS_ELASTI_CACHE_REDIS_CLUSTER integration */
  AwsElastiCacheRedisCluster = 'AWS_ELASTI_CACHE_REDIS_CLUSTER',
  /** AWS_ELASTI_CACHE_REDIS_NODE integration */
  AwsElastiCacheRedisNode = 'AWS_ELASTI_CACHE_REDIS_NODE',
  /** AWS_ELB integration */
  AwsElb = 'AWS_ELB',
  /** AWS_HEALTH_ISSUE integration */
  AwsHealthIssue = 'AWS_HEALTH_ISSUE',
  /** AWS_HEALTH_NOTIFICATION integration */
  AwsHealthNotification = 'AWS_HEALTH_NOTIFICATION',
  /** AWS_HEALTH_SCHEDULED_CHANGE integration */
  AwsHealthScheduledChange = 'AWS_HEALTH_SCHEDULED_CHANGE',
  /** AWS_HEALTH_UNKNOWN integration */
  AwsHealthUnknown = 'AWS_HEALTH_UNKNOWN',
  /** AWS_IAM integration */
  AwsIam = 'AWS_IAM',
  /** AWS_IAM_GROUP integration */
  AwsIamGroup = 'AWS_IAM_GROUP',
  /** AWS_IAM_OPEN_ID_PROVIDER integration */
  AwsIamOpenIdProvider = 'AWS_IAM_OPEN_ID_PROVIDER',
  /** AWS_IAM_POLICY integration */
  AwsIamPolicy = 'AWS_IAM_POLICY',
  /** AWS_IAM_ROLE integration */
  AwsIamRole = 'AWS_IAM_ROLE',
  /** AWS_IAM_SAML_PROVIDER integration */
  AwsIamSamlProvider = 'AWS_IAM_SAML_PROVIDER',
  /** AWS_IAM_SERVER_CERTIFICATE integration */
  AwsIamServerCertificate = 'AWS_IAM_SERVER_CERTIFICATE',
  /** AWS_IAM_USER integration */
  AwsIamUser = 'AWS_IAM_USER',
  /** AWS_IAM_VIRTUAL_MFA_DEVICE integration */
  AwsIamVirtualMfaDevice = 'AWS_IAM_VIRTUAL_MFA_DEVICE',
  /** AWS_IOT_BROKER integration */
  AwsIotBroker = 'AWS_IOT_BROKER',
  /** AWS_IOT_RULE integration */
  AwsIotRule = 'AWS_IOT_RULE',
  /** AWS_IOT_RULE_ACTION integration */
  AwsIotRuleAction = 'AWS_IOT_RULE_ACTION',
  /** AWS_KINESIS_DELIVERY_STREAM integration */
  AwsKinesisDeliveryStream = 'AWS_KINESIS_DELIVERY_STREAM',
  /** AWS_KINESIS_STREAM integration */
  AwsKinesisStream = 'AWS_KINESIS_STREAM',
  /** AWS_KINESIS_STREAM_SHARD integration */
  AwsKinesisStreamShard = 'AWS_KINESIS_STREAM_SHARD',
  /** AWS_LAMBDA_AGENT_TRANSACTION integration */
  AwsLambdaAgentTransaction = 'AWS_LAMBDA_AGENT_TRANSACTION',
  /** AWS_LAMBDA_AGENT_TRANSACTION_ERROR integration */
  AwsLambdaAgentTransactionError = 'AWS_LAMBDA_AGENT_TRANSACTION_ERROR',
  /** AWS_LAMBDA_EDGE_FUNCTION integration */
  AwsLambdaEdgeFunction = 'AWS_LAMBDA_EDGE_FUNCTION',
  /** AWS_LAMBDA_EVENT_SOURCE_MAPPING integration */
  AwsLambdaEventSourceMapping = 'AWS_LAMBDA_EVENT_SOURCE_MAPPING',
  /** AWS_LAMBDA_FUNCTION integration */
  AwsLambdaFunction = 'AWS_LAMBDA_FUNCTION',
  /** AWS_LAMBDA_FUNCTION_ALIAS integration */
  AwsLambdaFunctionAlias = 'AWS_LAMBDA_FUNCTION_ALIAS',
  /** AWS_LAMBDA_OPERATION integration */
  AwsLambdaOperation = 'AWS_LAMBDA_OPERATION',
  /** AWS_LAMBDA_REGION integration */
  AwsLambdaRegion = 'AWS_LAMBDA_REGION',
  /** AWS_LAMBDA_SPAN integration */
  AwsLambdaSpan = 'AWS_LAMBDA_SPAN',
  /** AWS_LAMBDA_TRACE integration */
  AwsLambdaTrace = 'AWS_LAMBDA_TRACE',
  /** AWS_RDS_DB_CLUSTER integration */
  AwsRdsDbCluster = 'AWS_RDS_DB_CLUSTER',
  /** AWS_RDS_DB_INSTANCE integration */
  AwsRdsDbInstance = 'AWS_RDS_DB_INSTANCE',
  /** AWS_REDSHIFT_CLUSTER integration */
  AwsRedshiftCluster = 'AWS_REDSHIFT_CLUSTER',
  /** AWS_REDSHIFT_NODE integration */
  AwsRedshiftNode = 'AWS_REDSHIFT_NODE',
  /** AWS_ROUTE53_HEALTH_CHECK integration */
  AwsRoute53HealthCheck = 'AWS_ROUTE53_HEALTH_CHECK',
  /** AWS_ROUTE53_ZONE integration */
  AwsRoute53Zone = 'AWS_ROUTE53_ZONE',
  /** AWS_ROUTE53_ZONE_RECORD_SET integration */
  AwsRoute53ZoneRecordSet = 'AWS_ROUTE53_ZONE_RECORD_SET',
  /** AWS_S3_BUCKET integration */
  AwsS3Bucket = 'AWS_S3_BUCKET',
  /** AWS_S3_BUCKET_REQUESTS integration */
  AwsS3BucketRequests = 'AWS_S3_BUCKET_REQUESTS',
  /** AWS_SES_CONFIGURATION_SET integration */
  AwsSesConfigurationSet = 'AWS_SES_CONFIGURATION_SET',
  /** AWS_SES_EVENT_DESTINATION integration */
  AwsSesEventDestination = 'AWS_SES_EVENT_DESTINATION',
  /** AWS_SES_RECEIPT_FILTER integration */
  AwsSesReceiptFilter = 'AWS_SES_RECEIPT_FILTER',
  /** AWS_SES_RECEIPT_RULE integration */
  AwsSesReceiptRule = 'AWS_SES_RECEIPT_RULE',
  /** AWS_SES_RECEIPT_RULE_SET integration */
  AwsSesReceiptRuleSet = 'AWS_SES_RECEIPT_RULE_SET',
  /** AWS_SES_REGION integration */
  AwsSesRegion = 'AWS_SES_REGION',
  /** AWS_SNS_SUBSCRIPTION integration */
  AwsSnsSubscription = 'AWS_SNS_SUBSCRIPTION',
  /** AWS_SNS_TOPIC integration */
  AwsSnsTopic = 'AWS_SNS_TOPIC',
  /** AWS_SQS_QUEUE integration */
  AwsSqsQueue = 'AWS_SQS_QUEUE',
  /** AWS_VPC integration */
  AwsVpc = 'AWS_VPC',
  /** AWS_VPC_ENDPOINT integration */
  AwsVpcEndpoint = 'AWS_VPC_ENDPOINT',
  /** AWS_VPC_INTERNET_GATEWAY integration */
  AwsVpcInternetGateway = 'AWS_VPC_INTERNET_GATEWAY',
  /** AWS_VPC_NAT_GATEWAY integration */
  AwsVpcNatGateway = 'AWS_VPC_NAT_GATEWAY',
  /** AWS_VPC_NETWORK_ACL integration */
  AwsVpcNetworkAcl = 'AWS_VPC_NETWORK_ACL',
  /** AWS_VPC_NETWORK_INTERFACE integration */
  AwsVpcNetworkInterface = 'AWS_VPC_NETWORK_INTERFACE',
  /** AWS_VPC_PEERING_CONNECTION integration */
  AwsVpcPeeringConnection = 'AWS_VPC_PEERING_CONNECTION',
  /** AWS_VPC_ROUTE_TABLE integration */
  AwsVpcRouteTable = 'AWS_VPC_ROUTE_TABLE',
  /** AWS_VPC_SECURITY_GROUP integration */
  AwsVpcSecurityGroup = 'AWS_VPC_SECURITY_GROUP',
  /** AWS_VPC_SUBNET integration */
  AwsVpcSubnet = 'AWS_VPC_SUBNET',
  /** AWS_VPC_VPN_CONNECTION integration */
  AwsVpcVpnConnection = 'AWS_VPC_VPN_CONNECTION',
  /** AWS_VPC_VPN_TUNNEL integration */
  AwsVpcVpnTunnel = 'AWS_VPC_VPN_TUNNEL',
  /** AZURE_APP_SERVICE_HOST_NAME integration */
  AzureAppServiceHostName = 'AZURE_APP_SERVICE_HOST_NAME',
  /** AZURE_APP_SERVICE_WEB_APP integration */
  AzureAppServiceWebApp = 'AZURE_APP_SERVICE_WEB_APP',
  /** AZURE_COSMOS_DB_ACCOUNT integration */
  AzureCosmosDbAccount = 'AZURE_COSMOS_DB_ACCOUNT',
  /** AZURE_FUNCTIONS_APP integration */
  AzureFunctionsApp = 'AZURE_FUNCTIONS_APP',
  /** AZURE_LOAD_BALANCER integration */
  AzureLoadBalancer = 'AZURE_LOAD_BALANCER',
  /** AZURE_LOAD_BALANCER_BACKEND integration */
  AzureLoadBalancerBackend = 'AZURE_LOAD_BALANCER_BACKEND',
  /** AZURE_LOAD_BALANCER_FRONTEND_IP integration */
  AzureLoadBalancerFrontendIp = 'AZURE_LOAD_BALANCER_FRONTEND_IP',
  /** AZURE_LOAD_BALANCER_INBOUND_NAT_POOL integration */
  AzureLoadBalancerInboundNatPool = 'AZURE_LOAD_BALANCER_INBOUND_NAT_POOL',
  /** AZURE_LOAD_BALANCER_INBOUND_NAT_RULE integration */
  AzureLoadBalancerInboundNatRule = 'AZURE_LOAD_BALANCER_INBOUND_NAT_RULE',
  /** AZURE_LOAD_BALANCER_PROBE integration */
  AzureLoadBalancerProbe = 'AZURE_LOAD_BALANCER_PROBE',
  /** AZURE_LOAD_BALANCER_RULE integration */
  AzureLoadBalancerRule = 'AZURE_LOAD_BALANCER_RULE',
  /** AZURE_MARIADB_SERVER integration */
  AzureMariadbServer = 'AZURE_MARIADB_SERVER',
  /** AZURE_MYSQL_SERVER integration */
  AzureMysqlServer = 'AZURE_MYSQL_SERVER',
  /** AZURE_POSTGRESQL_SERVER integration */
  AzurePostgresqlServer = 'AZURE_POSTGRESQL_SERVER',
  /** AZURE_REDIS_CACHE integration */
  AzureRedisCache = 'AZURE_REDIS_CACHE',
  /** AZURE_REDIS_CACHE_SHARD integration */
  AzureRedisCacheShard = 'AZURE_REDIS_CACHE_SHARD',
  /** AZURE_SERVICE_BUS_NAMESPACE integration */
  AzureServiceBusNamespace = 'AZURE_SERVICE_BUS_NAMESPACE',
  /** AZURE_SERVICE_BUS_QUEUE integration */
  AzureServiceBusQueue = 'AZURE_SERVICE_BUS_QUEUE',
  /** AZURE_SERVICE_BUS_SUBSCRIPTION integration */
  AzureServiceBusSubscription = 'AZURE_SERVICE_BUS_SUBSCRIPTION',
  /** AZURE_SERVICE_BUS_TOPIC integration */
  AzureServiceBusTopic = 'AZURE_SERVICE_BUS_TOPIC',
  /** AZURE_SQL_DATABASE integration */
  AzureSqlDatabase = 'AZURE_SQL_DATABASE',
  /** AZURE_SQL_ELASTIC_POOL integration */
  AzureSqlElasticPool = 'AZURE_SQL_ELASTIC_POOL',
  /** AZURE_SQL_FIREWALL integration */
  AzureSqlFirewall = 'AZURE_SQL_FIREWALL',
  /** AZURE_SQL_REPLICATION_LINK integration */
  AzureSqlReplicationLink = 'AZURE_SQL_REPLICATION_LINK',
  /** AZURE_SQL_RESTORE_POINT integration */
  AzureSqlRestorePoint = 'AZURE_SQL_RESTORE_POINT',
  /** AZURE_SQL_SERVER integration */
  AzureSqlServer = 'AZURE_SQL_SERVER',
  /** AZURE_STORAGE_ACCOUNT integration */
  AzureStorageAccount = 'AZURE_STORAGE_ACCOUNT',
  /** AZURE_VIRTUAL_NETWORKS integration */
  AzureVirtualNetworks = 'AZURE_VIRTUAL_NETWORKS',
  /** AZURE_VIRTUAL_NETWORKS_IP_CONFIGURATION integration */
  AzureVirtualNetworksIpConfiguration = 'AZURE_VIRTUAL_NETWORKS_IP_CONFIGURATION',
  /** AZURE_VIRTUAL_NETWORKS_NETWORK_INTERFACE integration */
  AzureVirtualNetworksNetworkInterface = 'AZURE_VIRTUAL_NETWORKS_NETWORK_INTERFACE',
  /** AZURE_VIRTUAL_NETWORKS_PEERING integration */
  AzureVirtualNetworksPeering = 'AZURE_VIRTUAL_NETWORKS_PEERING',
  /** AZURE_VIRTUAL_NETWORKS_PUBLIC_IP_ADDRESS integration */
  AzureVirtualNetworksPublicIpAddress = 'AZURE_VIRTUAL_NETWORKS_PUBLIC_IP_ADDRESS',
  /** AZURE_VIRTUAL_NETWORKS_ROUTE integration */
  AzureVirtualNetworksRoute = 'AZURE_VIRTUAL_NETWORKS_ROUTE',
  /** AZURE_VIRTUAL_NETWORKS_ROUTE_TABLE integration */
  AzureVirtualNetworksRouteTable = 'AZURE_VIRTUAL_NETWORKS_ROUTE_TABLE',
  /** AZURE_VIRTUAL_NETWORKS_SECURITY_GROUP integration */
  AzureVirtualNetworksSecurityGroup = 'AZURE_VIRTUAL_NETWORKS_SECURITY_GROUP',
  /** AZURE_VIRTUAL_NETWORKS_SECURITY_RULE integration */
  AzureVirtualNetworksSecurityRule = 'AZURE_VIRTUAL_NETWORKS_SECURITY_RULE',
  /** AZURE_VIRTUAL_NETWORKS_SUBNET integration */
  AzureVirtualNetworksSubnet = 'AZURE_VIRTUAL_NETWORKS_SUBNET',
  /** CASSANDRA_NODE integration */
  CassandraNode = 'CASSANDRA_NODE',
  /** CONSUL_AGENT integration */
  ConsulAgent = 'CONSUL_AGENT',
  /** COUCHBASE_BUCKET integration */
  CouchbaseBucket = 'COUCHBASE_BUCKET',
  /** COUCHBASE_CLUSTER integration */
  CouchbaseCluster = 'COUCHBASE_CLUSTER',
  /** COUCHBASE_NODE integration */
  CouchbaseNode = 'COUCHBASE_NODE',
  /** COUCHBASE_QUERY_ENGINE integration */
  CouchbaseQueryEngine = 'COUCHBASE_QUERY_ENGINE',
  /** ELASTICSEARCH_NODE integration */
  ElasticsearchNode = 'ELASTICSEARCH_NODE',
  /** F5_NODE integration */
  F5Node = 'F5_NODE',
  /** F5_POOL integration */
  F5Pool = 'F5_POOL',
  /** F5_POOL_MEMBER integration */
  F5PoolMember = 'F5_POOL_MEMBER',
  /** F5_SYSTEM integration */
  F5System = 'F5_SYSTEM',
  /** F5_VIRTUAL_SERVER integration */
  F5VirtualServer = 'F5_VIRTUAL_SERVER',
  /** GCP_APP_ENGINE_SERVICE integration */
  GcpAppEngineService = 'GCP_APP_ENGINE_SERVICE',
  /** GCP_BIG_QUERY_DATA_SET integration */
  GcpBigQueryDataSet = 'GCP_BIG_QUERY_DATA_SET',
  /** GCP_BIG_QUERY_PROJECT integration */
  GcpBigQueryProject = 'GCP_BIG_QUERY_PROJECT',
  /** GCP_BIG_QUERY_TABLE integration */
  GcpBigQueryTable = 'GCP_BIG_QUERY_TABLE',
  /** GCP_CLOUD_FUNCTION integration */
  GcpCloudFunction = 'GCP_CLOUD_FUNCTION',
  /** GCP_CLOUD_SQL integration */
  GcpCloudSql = 'GCP_CLOUD_SQL',
  /** GCP_CLOUD_TASKS_QUEUE integration */
  GcpCloudTasksQueue = 'GCP_CLOUD_TASKS_QUEUE',
  /** GCP_HTTP_LOAD_BALANCER integration */
  GcpHttpLoadBalancer = 'GCP_HTTP_LOAD_BALANCER',
  /** GCP_INTERNAL_LOAD_BALANCER integration */
  GcpInternalLoadBalancer = 'GCP_INTERNAL_LOAD_BALANCER',
  /** GCP_KUBERNETES_CONTAINER integration */
  GcpKubernetesContainer = 'GCP_KUBERNETES_CONTAINER',
  /** GCP_KUBERNETES_NODE integration */
  GcpKubernetesNode = 'GCP_KUBERNETES_NODE',
  /** GCP_KUBERNETES_POD integration */
  GcpKubernetesPod = 'GCP_KUBERNETES_POD',
  /** GCP_PUB_SUB_SUBSCRIPTION integration */
  GcpPubSubSubscription = 'GCP_PUB_SUB_SUBSCRIPTION',
  /** GCP_PUB_SUB_TOPIC integration */
  GcpPubSubTopic = 'GCP_PUB_SUB_TOPIC',
  /** GCP_SPANNER_DATABASE integration */
  GcpSpannerDatabase = 'GCP_SPANNER_DATABASE',
  /** GCP_SPANNER_INSTANCE integration */
  GcpSpannerInstance = 'GCP_SPANNER_INSTANCE',
  /** GCP_STORAGE_BUCKET integration */
  GcpStorageBucket = 'GCP_STORAGE_BUCKET',
  /** GCP_TCP_SSL_PROXY_LOAD_BALANCER integration */
  GcpTcpSslProxyLoadBalancer = 'GCP_TCP_SSL_PROXY_LOAD_BALANCER',
  /** GCP_VIRTUAL_MACHINE_DISK integration */
  GcpVirtualMachineDisk = 'GCP_VIRTUAL_MACHINE_DISK',
  /** KAFKA_BROKER integration */
  KafkaBroker = 'KAFKA_BROKER',
  /** KAFKA_TOPIC integration */
  KafkaTopic = 'KAFKA_TOPIC',
  /** KUBERNETES_CLUSTER integration */
  KubernetesCluster = 'KUBERNETES_CLUSTER',
  /** MEMCACHED_INSTANCE integration */
  MemcachedInstance = 'MEMCACHED_INSTANCE',
  /** MSSQL_INSTANCE integration */
  MssqlInstance = 'MSSQL_INSTANCE',
  /** MYSQL_NODE integration */
  MysqlNode = 'MYSQL_NODE',
  /** NA integration */
  Na = 'NA',
  /** NGINX_SERVER integration */
  NginxServer = 'NGINX_SERVER',
  /** ORACLE_DB_INSTANCE integration */
  OracleDbInstance = 'ORACLE_DB_INSTANCE',
  /** POSTGRE_SQL_INSTANCE integration */
  PostgreSqlInstance = 'POSTGRE_SQL_INSTANCE',
  /** RABBIT_MQ_CLUSTER integration */
  RabbitMqCluster = 'RABBIT_MQ_CLUSTER',
  /** RABBIT_MQ_EXCHANGE integration */
  RabbitMqExchange = 'RABBIT_MQ_EXCHANGE',
  /** RABBIT_MQ_NODE integration */
  RabbitMqNode = 'RABBIT_MQ_NODE',
  /** RABBIT_MQ_QUEUE integration */
  RabbitMqQueue = 'RABBIT_MQ_QUEUE',
  /** REDIS_INSTANCE integration */
  RedisInstance = 'REDIS_INSTANCE',
  /** VARNISH_INSTANCE integration */
  VarnishInstance = 'VARNISH_INSTANCE'
}

/** Type that wraps the errors from a entity keep alive operation. */
export type EntityKeepAliveError = {
  __typename?: 'EntityKeepAliveError';
  /** Guid related to the error. */
  guid?: Maybe<Scalars['EntityGuid']['output']>;
  /** User-friendly message describing the error. */
  message: Scalars['String']['output'];
  /** Describes all potential error types that a keep alive operation might return. */
  type: EntityKeepAliveErrorType;
};

/** List of all potential error types that an entity keep alive operation might return. */
export enum EntityKeepAliveErrorType {
  /** Forbidden request */
  Forbidden = 'FORBIDDEN',
  /** Internal error */
  InternalError = 'INTERNAL_ERROR',
  /** Invalid input */
  InvalidInput = 'INVALID_INPUT'
}

/** Response type for keep alive operations over entities. */
export type EntityKeepAliveResult = {
  __typename?: 'EntityKeepAliveResult';
  /** List of failures for the keep alive operation. */
  failures: Array<EntityKeepAliveError>;
  /** List that contains the guids of the refreshed entities */
  refreshedEntities: Array<Scalars['EntityGuid']['output']>;
};

/**
 * The `EntityOutline` interface object allows fetching basic entity data for many entities at a time.
 *
 * To understand more about entities and entity types, look at [our docs](https://docs.newrelic.com/docs/what-are-new-relic-entities).
 */
export type EntityOutline = {
  account?: Maybe<AccountOutline>;
  /** The New Relic account ID associated with this entity. */
  accountId?: Maybe<Scalars['Int']['output']>;
  /** The current alerting severity of the entity. */
  alertSeverity?: Maybe<EntityAlertSeverity>;
  /**
   * The alert status of the entity.
   * @deprecated Please use `alertSeverity` and `reporting`
   */
  alertStatus?: Maybe<EntityAlertStatus>;
  /** The entity's domain */
  domain?: Maybe<Scalars['String']['output']>;
  /** A value representing the combination of the entity's domain and type. */
  entityType?: Maybe<EntityType>;
  /** The date of last time the entity has updated any of its fields. */
  firstIndexedAt?: Maybe<Scalars['EpochMilliseconds']['output']>;
  /** The list of golden metrics for a specific entity */
  goldenMetrics?: Maybe<EntityGoldenContextScopedGoldenMetrics>;
  /**
   * For the golden signal on this entity, show correlated signals from related entities.
   * Well inspect the golden signals for all related entities and return a sorted list.
   * You can also filter the results.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  goldenSignalCorrelations?: Maybe<GoldenSignalCorrelationResult>;
  /**
   * The deviation from normal of golden signal(s) for the given entity.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  goldenSignalDeviations?: Maybe<Array<Maybe<GoldenSignalSignalDeviation>>>;
  /**
   * The stored golden signal(s) for the given entity.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  goldenSignalValues?: Maybe<GoldenSignalValues>;
  /**
   * The stored golden signal(s) for the given entity. To be removed, use goldenSignalValues instead.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  goldenSignalValuesV2?: Maybe<GoldenSignalValues>;
  /** The list of golden tags for a specific entityType. */
  goldenTags?: Maybe<EntityGoldenContextScopedGoldenTags>;
  /** A unique entity identifier. */
  guid?: Maybe<Scalars['EntityGuid']['output']>;
  /** The time the entity was indexed. */
  indexedAt?: Maybe<Scalars['EpochMilliseconds']['output']>;
  /** The last time the entity's reporting status changed. */
  lastReportingChangeAt?: Maybe<Scalars['EpochMilliseconds']['output']>;
  /** The name of this entity. */
  name?: Maybe<Scalars['String']['output']>;
  /** The url to the entity. */
  permalink?: Maybe<Scalars['String']['output']>;
  /** The recommended service levels for the entity. */
  recommendedServiceLevel?: Maybe<ServiceLevelRecommendation>;
  /** Related dashboards results */
  relatedDashboards: RelatedDashboardsRelatedDashboardResult;
  /** The reporting status of the entity. If New Relic is successfully collecting data from your application, this will be true. */
  reporting?: Maybe<Scalars['Boolean']['output']>;
  /** The service level defined for the entity. */
  serviceLevel?: Maybe<ServiceLevelDefinition>;
  /** The list of summary metrics. */
  summaryMetrics?: Maybe<Array<Maybe<EntitySummaryMetric>>>;
  /**
   * The tags applied to the entity.
   *
   * For details on tags, as well as query and mutation examples, visit [our docs](https://docs.newrelic.com/docs/apis/graphql-api/tutorials/graphql-tagging-api-tutorial).
   */
  tags?: Maybe<Array<Maybe<EntityTag>>>;
  /** The entity's type */
  type?: Maybe<Scalars['String']['output']>;
  /** List of templates availables for this entity. */
  uiTemplates?: Maybe<Array<EntityDashboardTemplatesUi>>;
};


/**
 * The `EntityOutline` interface object allows fetching basic entity data for many entities at a time.
 *
 * To understand more about entities and entity types, look at [our docs](https://docs.newrelic.com/docs/what-are-new-relic-entities).
 */
export type EntityOutlineGoldenMetricsArgs = {
  context?: InputMaybe<EntityGoldenContextInput>;
  timeWindow?: InputMaybe<EntityGoldenNrqlTimeWindowInput>;
};


/**
 * The `EntityOutline` interface object allows fetching basic entity data for many entities at a time.
 *
 * To understand more about entities and entity types, look at [our docs](https://docs.newrelic.com/docs/what-are-new-relic-entities).
 */
export type EntityOutlineGoldenSignalCorrelationsArgs = {
  filter?: InputMaybe<GoldenSignalCorrelationsEntityFilter>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  timeWindow?: InputMaybe<TimeWindowInput>;
};


/**
 * The `EntityOutline` interface object allows fetching basic entity data for many entities at a time.
 *
 * To understand more about entities and entity types, look at [our docs](https://docs.newrelic.com/docs/what-are-new-relic-entities).
 */
export type EntityOutlineGoldenSignalDeviationsArgs = {
  comparisonTimeWindow?: InputMaybe<TimeWindowInput>;
  evaluationTimeWindow?: InputMaybe<TimeWindowInput>;
};


/**
 * The `EntityOutline` interface object allows fetching basic entity data for many entities at a time.
 *
 * To understand more about entities and entity types, look at [our docs](https://docs.newrelic.com/docs/what-are-new-relic-entities).
 */
export type EntityOutlineGoldenSignalValuesArgs = {
  timeWindow?: InputMaybe<TimeWindowInput>;
};


/**
 * The `EntityOutline` interface object allows fetching basic entity data for many entities at a time.
 *
 * To understand more about entities and entity types, look at [our docs](https://docs.newrelic.com/docs/what-are-new-relic-entities).
 */
export type EntityOutlineGoldenSignalValuesV2Args = {
  timeWindow?: InputMaybe<TimeWindowInput>;
};


/**
 * The `EntityOutline` interface object allows fetching basic entity data for many entities at a time.
 *
 * To understand more about entities and entity types, look at [our docs](https://docs.newrelic.com/docs/what-are-new-relic-entities).
 */
export type EntityOutlineGoldenTagsArgs = {
  context?: InputMaybe<EntityGoldenContextInput>;
};


/**
 * The `EntityOutline` interface object allows fetching basic entity data for many entities at a time.
 *
 * To understand more about entities and entity types, look at [our docs](https://docs.newrelic.com/docs/what-are-new-relic-entities).
 */
export type EntityOutlineSummaryMetricsArgs = {
  timeWindow?: InputMaybe<TimeWindowInput>;
};

/** An entity relationship */
export type EntityRelationship = {
  __typename?: 'EntityRelationship';
  /**
   * The source entity of the relationship.
   * @deprecated `relationships` and its subfields are deprecated. Please use `relatedEntities`.
   */
  source?: Maybe<EntityRelationshipNode>;
  /**
   * The target entity of the relationship.
   * @deprecated `relationships` and its subfields are deprecated. Please use `relatedEntities`.
   */
  target?: Maybe<EntityRelationshipNode>;
  /** The type of the relationship. For details, visit [our docs](https://docs.newrelic.com/docs/apis/graphql-api/tutorials/graphql-relationships-api-tutorial). */
  type?: Maybe<EntityRelationshipType>;
};

/** An entity relationship automatically detected by NewRelic. */
export type EntityRelationshipDetectedEdge = EntityRelationshipEdge & {
  __typename?: 'EntityRelationshipDetectedEdge';
  /** The time the relationship was created. */
  createdAt: Scalars['EpochMilliseconds']['output'];
  /** The source entity of the relationship. */
  source: EntityRelationshipVertex;
  /** The target entity of the relationship. */
  target: EntityRelationshipVertex;
  /** The type of the relationship. */
  type: EntityRelationshipEdgeType;
};

/** An entity relationship. */
export type EntityRelationshipEdge = {
  /** The time the relationship was created. */
  createdAt: Scalars['EpochMilliseconds']['output'];
  /** The source entity of the relationship. */
  source: EntityRelationshipVertex;
  /** The target entity of the relationship. */
  target: EntityRelationshipVertex;
  /** The type of the relationship. */
  type: EntityRelationshipEdgeType;
};

/** Values for relationship direction filter. */
export enum EntityRelationshipEdgeDirection {
  /** Traverse both inbound and outbound connections. */
  Both = 'BOTH',
  /** Traverse inbound connections to the source of the relationship. */
  Inbound = 'INBOUND',
  /** Traverse outbound connections to the target of the relationship. */
  Outbound = 'OUTBOUND'
}

/** EntityRelationship edge filter. */
export type EntityRelationshipEdgeFilter = {
  /** Filter by direction of relationship. */
  direction?: InputMaybe<EntityRelationshipEdgeDirection>;
  /** Filter on entity domain-types. */
  entityDomainTypes?: InputMaybe<EntityRelationshipEntityDomainTypeFilter>;
  /** Filter on relationship types. */
  relationshipTypes?: InputMaybe<EntityRelationshipEdgeTypeFilter>;
};

/** The type of the relationship. */
export enum EntityRelationshipEdgeType {
  /** The target entity contains the code for the source entity. */
  BuiltFrom = 'BUILT_FROM',
  /** The source entity calls the target entity. */
  Calls = 'CALLS',
  /** The source entity has a connection to the target entity. */
  ConnectsTo = 'CONNECTS_TO',
  /** The source entity consumes messages from a target kafka topic or other queue systems. */
  Consumes = 'CONSUMES',
  /** The source entity contains the target entity. */
  Contains = 'CONTAINS',
  /** The source entity hosts the target. */
  Hosts = 'HOSTS',
  /** The source and target entities are perspectives on the same thing. */
  Is = 'IS',
  /** The source entity manages the target, that represents a subsystem of the source. */
  Manages = 'MANAGES',
  /** The source entity is used to measure the target entity. */
  Measures = 'MEASURES',
  /** The source operates in the target entity, e.g. a region or a data center. */
  OperatesIn = 'OPERATES_IN',
  /** The source entity owns the target entity. */
  Owns = 'OWNS',
  /** The source entity produces messages to a target kafka topic or other queue systems. */
  Produces = 'PRODUCES',
  /** The source is an Application that serves the target Browser application. */
  Serves = 'SERVES'
}

/** Filter on relationship types. */
export type EntityRelationshipEdgeTypeFilter = {
  /** Filter the relationships to those that are not of specific relationship types. */
  exclude?: InputMaybe<Array<EntityRelationshipEdgeType>>;
  /** Filter the relationships to those of specific relationship types. */
  include?: InputMaybe<Array<EntityRelationshipEdgeType>>;
};

/** Filter on entity domain-types. */
export type EntityRelationshipEntityDomainTypeFilter = {
  /** Filter based on the isAlertable field in the entity domain type definition. If true, will exclude all non alertable entities from the result. If false, will exclude the alertable entities. */
  alertable?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter the relationships to those between entities that are not of specific domain-types. */
  exclude?: InputMaybe<Array<DomainTypeInput>>;
  /** Filter the relationships to those between entities of specific domain-types. */
  include?: InputMaybe<Array<DomainTypeInput>>;
};

/**
 * Filter on related entities by health information.
 * alertingAtLeastOnceSince and anomalousAtLeastOnceSince are joined by an OR operator.
 */
export type EntityRelationshipEntityHealthFilter = {
  /** Filter on related entities that were alerting at least once since this time. Maximum time is X. */
  alertingAtLeastOnceSince?: InputMaybe<Scalars['EpochMilliseconds']['input']>;
  /** Filter on related entities that were anomalous at least once since this time. Maximum time is X. */
  anomalousAtLeastOnceSince?: InputMaybe<Scalars['EpochMilliseconds']['input']>;
};

/** Entity search query options. */
export type EntityRelationshipEntitySearchOptions = {
  /** Whether or not matching on tag keys and values should be case-sensitive. */
  caseSensitiveTagMatching?: InputMaybe<Scalars['Boolean']['input']>;
  /** A limit to apply to the number of entities retrieved. */
  limit?: InputMaybe<Scalars['Int']['input']>;
};

/** Entity search query to retrieve entities. */
export type EntityRelationshipEntitySearchQueryInput = {
  /** Additional entity search query options. */
  options?: InputMaybe<EntityRelationshipEntitySearchOptions>;
  /** Entity search query. */
  query: Scalars['EntitySearchQuery']['input'];
};

/** Relationship filter */
export type EntityRelationshipFilter = {
  /** Filter the relationships to those that contain a specific entity type. */
  entityType?: InputMaybe<Array<InputMaybe<EntityType>>>;
  /** Filter the relationships to those that contain a specific Infrastructure integration entity type */
  infrastructureIntegrationType?: InputMaybe<Array<InputMaybe<EntityInfrastructureIntegrationType>>>;
};

/** Allows specifying multiple relationship filters for a given hop. */
export type EntityRelationshipHopFilter = {
  /** Filters to apply for that hop. A relationship is returned if it satisfies any of the filters. */
  filters: Array<EntityRelationshipTraversalFilter>;
  /** Hop for which the relationship filters will be applied to. */
  hop: Scalars['Int']['input'];
};

/** A node in an Entity relationship. */
export type EntityRelationshipNode = {
  __typename?: 'EntityRelationshipNode';
  /**
   * The Account ID for the relationship node.
   * @deprecated `relationships` and its subfields are deprecated. Please use `relatedEntities`.
   */
  accountId?: Maybe<Scalars['Int']['output']>;
  entity?: Maybe<EntityOutline>;
  /**
   * The `EntityType` of the relationship node.
   * @deprecated `relationships` and its subfields are deprecated. Please use `relatedEntities`.
   */
  entityType?: Maybe<EntityType>;
  /**
   * The Entity `guid` for the relationship node.
   * @deprecated `relationships` and its subfields are deprecated. Please use `relatedEntities`.
   */
  guid?: Maybe<Scalars['EntityGuid']['output']>;
};

/** Response containing entity relationships. */
export type EntityRelationshipRelatedEntitiesResult = {
  __typename?: 'EntityRelationshipRelatedEntitiesResult';
  /** The total number of entity relationships. */
  count: Scalars['Int']['output'];
  /** The next cursor for fetching additional paginated results. */
  nextCursor?: Maybe<Scalars['String']['output']>;
  /** The list of  entity relationships. */
  results: Array<EntityRelationshipEdge>;
};

/** Relationship search query filters. */
export type EntityRelationshipSearchFilters = {
  /**
   * Apply filters to all the hops of the traversal.
   * If no filter is specified, then all relationships are traversed in BOTH directions up to the number of hops specified in the "hops" parameter.
   * A relationship is returned if it satisfies any of the filters.
   */
  default: Array<EntityRelationshipTraversalFilter>;
};

/** Relationship search query response. */
export type EntityRelationshipSearchResponse = {
  __typename?: 'EntityRelationshipSearchResponse';
  /** Response given as a list of entity relationships. */
  relationships: Array<EntityRelationshipEdge>;
};

/** Traversal edge filter. */
export type EntityRelationshipTraversalFilter = {
  /** Filter by direction of relationship. */
  direction?: InputMaybe<EntityRelationshipEdgeDirection>;
  /** Filter related entities by health information. */
  entityHealth?: InputMaybe<EntityRelationshipEntityHealthFilter>;
  /**
   * Filter on entity domain-types. Used as:
   * Domain-type of source vertex if direction is OUTBOUND.
   * Domain-type of target vertex if direction is INBOUND.
   * Domain-type of source or target vertex if direction is BOTH.
   */
  fromEntityDomainTypes?: InputMaybe<EntityRelationshipEntityDomainTypeFilter>;
  /** Filter on relationship types. */
  relationshipTypes?: InputMaybe<EntityRelationshipEdgeTypeFilter>;
  /**
   * Filter on related entities domain-types. Used as:
   * Domain-type of target vertex if direction is OUTBOUND.
   * Domain-type of source vertex if direction is INBOUND.
   * Domain-type of target or source if direction is BOTH.
   */
  toEntityDomainTypes?: InputMaybe<EntityRelationshipEntityDomainTypeFilter>;
};

/** Allows specifying multiple relationship filters for a set of hops. */
export type EntityRelationshipTraversalHopFilters = {
  /**
   * Relationship filters to apply for all hops that do not have explicit filters defined.
   * If no default filter is specified, then, for each hop that does
   * not have explicit filters defined, all relationships are traversed in BOTH directions.
   * A relationship is returned if it satisfies any of the filters.
   */
  default?: InputMaybe<Array<EntityRelationshipTraversalFilter>>;
  /** Set of hop filters, each with their own set of relationship filters. */
  hopFilters?: InputMaybe<Array<EntityRelationshipHopFilter>>;
};

/** Response containing entity relationships. */
export type EntityRelationshipTraversalResult = {
  __typename?: 'EntityRelationshipTraversalResult';
  /** The next cursor for fetching additional paginated results. */
  nextCursor?: Maybe<Scalars['String']['output']>;
  /** The list of entity relationships. */
  results: Array<EntityRelationshipEdge>;
};

/**
 * The type of the relationship.
 *
 * For details, visit [our docs](https://docs.newrelic.com/docs/apis/graphql-api/tutorials/graphql-relationships-api-tutorial).
 */
export enum EntityRelationshipType {
  /**
   * The source repository containing the code for the target
   * @deprecated `relationships` and its subfields are deprecated. Please use `relatedEntities`.
   */
  BuiltFrom = 'BUILT_FROM',
  /**
   * The source entity calls the target entity.
   * @deprecated `relationships` and its subfields are deprecated. Please use `relatedEntities`.
   */
  Calls = 'CALLS',
  /**
   * The source establishes TCP connections to the target
   * @deprecated `relationships` and its subfields are deprecated. Please use `relatedEntities`.
   */
  ConnectsTo = 'CONNECTS_TO',
  /**
   * The source entity contains the target entity
   * @deprecated `relationships` and its subfields are deprecated. Please use `relatedEntities`.
   */
  Contains = 'CONTAINS',
  /**
   * The source entity hosts the target
   * @deprecated `relationships` and its subfields are deprecated. Please use `relatedEntities`.
   */
  Hosts = 'HOSTS',
  /**
   * The source and target entities are perspectives on the same thing
   * @deprecated `relationships` and its subfields are deprecated. Please use `relatedEntities`.
   */
  Is = 'IS',
  /**
   * The source is an Application that serves the target Browser application
   * @deprecated `relationships` and its subfields are deprecated. Please use `relatedEntities`.
   */
  Serves = 'SERVES',
  /**
   * Type not known
   * @deprecated `relationships` and its subfields are deprecated. Please use `relatedEntities`.
   */
  Unknown = 'UNKNOWN'
}

/** The different error types for the entityRelationshipUserDefinedCreateOrReplace mutation. */
export enum EntityRelationshipUserDefinedCreateOrReplaceErrorType {
  /** Number of user-defined relationships for a given entity has exceeded the limit (2000 relationships). */
  LimitExceeded = 'LIMIT_EXCEEDED',
  /** The operation is not allowed. */
  NotAllowed = 'NOT_ALLOWED',
  /** The user does not have permissions to perform the operation. */
  NotAuthorized = 'NOT_AUTHORIZED'
}

/** The result of the entityRelationshipUserDefinedCreateOrReplace mutation. */
export type EntityRelationshipUserDefinedCreateOrReplaceResult = {
  __typename?: 'EntityRelationshipUserDefinedCreateOrReplaceResult';
  /** The list of errors that occurred when executing the mutation. */
  errors?: Maybe<Array<EntityRelationshipUserDefinedCreateOrReplaceResultError>>;
};

/** The entityRelationshipUserDefinedCreateOrReplace result error. */
export type EntityRelationshipUserDefinedCreateOrReplaceResultError = {
  __typename?: 'EntityRelationshipUserDefinedCreateOrReplaceResultError';
  /** A message explaining what the error is about. */
  message: Scalars['String']['output'];
  /** The mutation error type. */
  type: EntityRelationshipUserDefinedCreateOrReplaceErrorType;
};

/** The different error types for the entityRelationshipUserDefinedDelete mutation. */
export enum EntityRelationshipUserDefinedDeleteErrorType {
  /** The user does not have permissions to perform the operation. */
  NotAuthorized = 'NOT_AUTHORIZED'
}

/** The result of the entityRelationshipUserDefinedDelete mutation. */
export type EntityRelationshipUserDefinedDeleteResult = {
  __typename?: 'EntityRelationshipUserDefinedDeleteResult';
  /** The list of errors that occurred when executing the mutation. */
  errors?: Maybe<Array<EntityRelationshipUserDefinedDeleteResultError>>;
};

/** The entityRelationshipUserDefinedDelete result error. */
export type EntityRelationshipUserDefinedDeleteResultError = {
  __typename?: 'EntityRelationshipUserDefinedDeleteResultError';
  /** A message explaining what the error is about. */
  message: Scalars['String']['output'];
  /** The mutation error type. */
  type: EntityRelationshipUserDefinedDeleteErrorType;
};

/** An entity user-defined relationship. */
export type EntityRelationshipUserDefinedEdge = EntityRelationshipEdge & {
  __typename?: 'EntityRelationshipUserDefinedEdge';
  /** The time the relationship was created. */
  createdAt: Scalars['EpochMilliseconds']['output'];
  /** The user that created the relationship. */
  createdByUser?: Maybe<UserReference>;
  /** The source entity of the relationship. */
  source: EntityRelationshipVertex;
  /** The target entity of the relationship. */
  target: EntityRelationshipVertex;
  /** The type of the relationship. */
  type: EntityRelationshipEdgeType;
};

/** A vertex in an entity relationship edge. */
export type EntityRelationshipVertex = {
  __typename?: 'EntityRelationshipVertex';
  /** The account ID of the relationship node. */
  accountId: Scalars['Int']['output'];
  /** The entity of the relationship node. */
  entity?: Maybe<EntityOutline>;
  /** The entity guid of the relationship node. */
  guid: Scalars['EntityGuid']['output'];
};

/**
 * A data structure that contains the detailed response of an entity search.
 *
 * The direct search result is available through `results`. Information about the
 * query itself is available through `query`, `types`, and `count`.
 */
export type EntitySearch = {
  __typename?: 'EntitySearch';
  /** The number of entities returned by the entity search. */
  count?: Maybe<Scalars['Int']['output']>;
  /**
   * A count of the Entity Search results faceted by a chosen set of criteria.
   *
   * Note: Unlike a NRQL facet, the facet results do not include entities where the facet value does not exist. Additionally, entities can be tagged with multiple tag values for one tag key. For these reasons, depending on the facet values chosen, the `counts` field will not always equal the `entitySearch.count` field.
   */
  counts?: Maybe<Array<Maybe<EntitySearchCounts>>>;
  /**
   * A count of the Entity Search results faceted by a chosen set of criteria.
   *
   * Note: Unlike a NRQL facet, the facet results do not include entities where the facet value does not exist. Additionally, entities can be tagged with multiple tag values for one tag key. For these reasons, depending on the facet values chosen, the `counts` field will not always equal the `entitySearch.count` field.
   */
  facetedCounts?: Maybe<EntitySearchFacetedCountsResult>;
  /** Results of the entity search grouped by the supplied criteria. */
  groupedResults?: Maybe<Array<Maybe<EntitySearchGroupedResult>>>;
  /** The entity search query string that was generated by the `query` argument or the `queryBuilder` argument. */
  query?: Maybe<Scalars['String']['output']>;
  /** The paginated results of the entity search. */
  results?: Maybe<EntitySearchResult>;
  /** The entity types returned by the entity search. */
  types?: Maybe<Array<Maybe<EntitySearchTypes>>>;
};


/**
 * A data structure that contains the detailed response of an entity search.
 *
 * The direct search result is available through `results`. Information about the
 * query itself is available through `query`, `types`, and `count`.
 */
export type EntitySearchCountsArgs = {
  facet?: InputMaybe<Array<EntitySearchCountsFacet>>;
  facetTags?: InputMaybe<Array<Scalars['String']['input']>>;
};


/**
 * A data structure that contains the detailed response of an entity search.
 *
 * The direct search result is available through `results`. Information about the
 * query itself is available through `query`, `types`, and `count`.
 */
export type EntitySearchFacetedCountsArgs = {
  facets: Array<EntitySearchCountsFacetInput>;
};


/**
 * A data structure that contains the detailed response of an entity search.
 *
 * The direct search result is available through `results`. Information about the
 * query itself is available through `query`, `types`, and `count`.
 */
export type EntitySearchGroupedResultsArgs = {
  by: EntitySearchGroupingCriterion;
  options?: InputMaybe<EntitySearchGroupedResultsOptions>;
};


/**
 * A data structure that contains the detailed response of an entity search.
 *
 * The direct search result is available through `results`. Information about the
 * query itself is available through `query`, `types`, and `count`.
 */
export type EntitySearchResultsArgs = {
  cursor?: InputMaybe<Scalars['String']['input']>;
};

/** The groupings and counts of entities returned for the specified criteria. */
export type EntitySearchCounts = {
  __typename?: 'EntitySearchCounts';
  /** The number of entities that match the specified criteria. */
  count?: Maybe<Scalars['Int']['output']>;
  /** The group of entities returned for the specified criteria. */
  facet?: Maybe<Scalars['AttributeMap']['output']>;
};

/** Possible entity search count facets. */
export enum EntitySearchCountsFacet {
  /** Facet by account id. */
  AccountId = 'ACCOUNT_ID',
  /** Facet by alert severity. */
  AlertSeverity = 'ALERT_SEVERITY',
  /** Facet by entity domain. */
  Domain = 'DOMAIN',
  /** Facet by entity domain and entity type. */
  DomainType = 'DOMAIN_TYPE',
  /** Facet by entity name */
  Name = 'NAME',
  /** Facet by reporting state. */
  Reporting = 'REPORTING',
  /** Facet by entity type. */
  Type = 'TYPE'
}

/** An object representing facets to count by. */
export type EntitySearchCountsFacetInput = {
  /** A criterion on which to facet entity search counts. */
  facetCriterion: FacetCriterion;
  /** The ordering that will be applied to the entity search facet. */
  orderBy?: InputMaybe<SortBy>;
};

/** The result of a faceted entity search counts query. */
export type EntitySearchFacetedCountsResult = {
  __typename?: 'EntitySearchFacetedCountsResult';
  /** The groupings and counts of entities returned for the specified criteria. */
  counts?: Maybe<Array<Maybe<EntitySearchCounts>>>;
  /** The list of facets for which the search results exceeded the limit. */
  facetLimits?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
};

/** Operator to apply to a golden metric filter. */
export enum EntitySearchFilterOperator {
  /**
   * Equal.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  Eq = 'EQ',
  /**
   * Greater than.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  Gt = 'GT',
  /**
   * Greater than or equal.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  Gte = 'GTE',
  /**
   * Less than.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  Lt = 'LT',
  /**
   * Less than or equal.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  Lte = 'LTE'
}

/** Entity search results that have been grouped by criteria */
export type EntitySearchGroupedResult = {
  __typename?: 'EntitySearchGroupedResult';
  /** The total number of entities in this group */
  count?: Maybe<Scalars['Int']['output']>;
  /**
   * The entities contained in this group.
   *
   * For information on New Relic entities, visit [our docs](https://docs.newrelic.com/docs/what-are-new-relic-entities).
   *
   * To see some query examples of entity information,
   * visit [our entity GraphQL API docs](https://docs.newrelic.com/docs/apis/graphql-api/tutorials/use-new-relic-graphql-api-query-entities).
   */
  entities?: Maybe<Array<Maybe<EntityOutline>>>;
  /** The group value for this collection of entities */
  group?: Maybe<Scalars['AttributeMap']['output']>;
};

/** Additional entity search result grouping options. */
export type EntitySearchGroupedResultsOptions = {
  /** Max number of groups that will be returned. Default value is 83. Note that the number of results per group will come from `groupLimit` divided by the limit input field. */
  groupLimit?: InputMaybe<Scalars['Int']['input']>;
  /**
   * A list of group values to filter grouped results by. For example, if you group search results by account ID, and add a `groupValueFilter` of `["1", "2"]`, the only groups returned will be groups for accounts 1 and 2 (if entities belonging to those accounts are returned by the search).
   *
   * Note this should always be a list of strings, even when the value is normally an int (ex: account ID).
   */
  groupValuesFilter?: InputMaybe<Array<Scalars['String']['input']>>;
};

/** Entity attributes to group by. */
export enum EntitySearchGroupingAttribute {
  /** Group by account id. */
  AccountId = 'ACCOUNT_ID',
  /** Group by alert severity. */
  AlertSeverity = 'ALERT_SEVERITY',
  /** Group by entity domain. */
  Domain = 'DOMAIN',
  /** Group by entity domain and entity type. */
  DomainType = 'DOMAIN_TYPE',
  /** Group by entity name */
  Name = 'NAME',
  /** Group by reporting state. */
  Reporting = 'REPORTING',
  /** Group by entity type. */
  Type = 'TYPE'
}

/** A single value to group entity results by. You may supply either an entity `attribute` or `tag` value, but not both. */
export type EntitySearchGroupingCriterion = {
  /** An entity attribute to group results by. */
  attribute?: InputMaybe<EntitySearchGroupingAttribute>;
  /**
   * An entity tag key to group by. Do not use a `tags.` prefix.
   * Examples: "environment", "team".
   */
  tag?: InputMaybe<Scalars['String']['input']>;
};

/** Metric filter to apply on entities. */
export type EntitySearchMetricFilterInput = {
  /** Golden metric name. Needs to belong to the domain-type provided in 'domainType' argument. */
  name: Scalars['String']['input'];
  /** Filter operator. */
  operator: EntitySearchFilterOperator;
  /** Golden metric value. */
  value: Scalars['Float']['input'];
};

/** Metric sort to apply on entities. */
export type EntitySearchMetricSortByInput = {
  /** Sort direction, either ascending or descending. */
  direction: EntitySearchSortByDirection;
  /** Golden metric name to sort by. Needs to belong to the domain-type provided in 'domainType' argument. */
  name: Scalars['String']['input'];
};

/** Additional entity search options. */
export type EntitySearchOptions = {
  /** Whether or not matching on tag keys and values should be case-sensitive. */
  caseSensitiveTagMatching?: InputMaybe<Scalars['Boolean']['input']>;
  /** A limit to apply to the number of entities returned. Note: this option can only _lower_ the default limits. */
  limit?: InputMaybe<Scalars['Int']['input']>;
  /** Specify which tags to include with search results. Does not affect which entities are returned. */
  tagFilter?: InputMaybe<Array<Scalars['String']['input']>>;
};

/** An object that can be used to discover and create the entity search query argument. */
export type EntitySearchQueryBuilder = {
  /** The alerting severity of the entity. */
  alertSeverity?: InputMaybe<EntityAlertSeverity>;
  /** The alertable status of the entity */
  alertable?: InputMaybe<Scalars['Boolean']['input']>;
  /** The entity domain. This is not a complete list of entity domains available; it is a way to explore the most popular domains. */
  domain?: InputMaybe<EntitySearchQueryBuilderDomain>;
  /**
   * **WARNING! This argument is deprecated and will not be updated with new infrastructure integration types.** If you want to query for a type not in this list, use the `query` argument instead of `queryBuilder`. To see the query string that is generated by your `queryBuilder` search, ask for the `query` field in the result object. You can then use this to build a query supplied to the `query` argument and remove your `queryBuilder`.
   *
   * The Infrastructure integration type. This should be used in place of the `type` field to search for Infrastructure integration specific types.
   */
  infrastructureIntegrationType?: InputMaybe<EntityInfrastructureIntegrationType>;
  /** The entity name. */
  name?: InputMaybe<Scalars['String']['input']>;
  /** The reporting status of the entity. */
  reporting?: InputMaybe<Scalars['Boolean']['input']>;
  /** A list of tags applied to the entity. */
  tags?: InputMaybe<Array<EntitySearchQueryBuilderTag>>;
  /**
   * The entity type.
   *
   * This is not a complete list of entity types available; it is a way to explore the most popular types.
   *
   * If you are querying for Infrastructure integration types, use the `infrastructureIntegrationType` field instead of `type`.
   */
  type?: InputMaybe<EntitySearchQueryBuilderType>;
};

/** The domain to search */
export enum EntitySearchQueryBuilderDomain {
  /** Any APM entity */
  Apm = 'APM',
  /** Any Browser entity */
  Browser = 'BROWSER',
  /** Any External entity */
  Ext = 'EXT',
  /** Any Infrastructure entity */
  Infra = 'INFRA',
  /** Any Mobile entity */
  Mobile = 'MOBILE',
  /** Any Synthetics entity */
  Synth = 'SYNTH'
}

/** An entity tag. */
export type EntitySearchQueryBuilderTag = {
  /**
   * The tag key. You can search using a `tags.` prefix or omit it and receive the same results.
   *
   * Examples: `tags.environment`, `environment`.
   */
  key: Scalars['String']['input'];
  /** The tag value. */
  value: Scalars['String']['input'];
};

/** The type of entity */
export enum EntitySearchQueryBuilderType {
  /** An application */
  Application = 'APPLICATION',
  /** A dashboard */
  Dashboard = 'DASHBOARD',
  /** A host */
  Host = 'HOST',
  /** A monitor */
  Monitor = 'MONITOR',
  /** A workload */
  Workload = 'WORKLOAD'
}

/** A section of the entity search results. If there is a `nextCursor` present, there are more results available. */
export type EntitySearchResult = {
  __typename?: 'EntitySearchResult';
  /** The accounts that hold the entities contained in this section entity search results. */
  accounts?: Maybe<Array<Maybe<AccountAccessInfo>>>;
  /**
   * The entities contained in this section of the entity search results.
   *
   * For information on New Relic entities, visit [our docs](https://docs.newrelic.com/docs/what-are-new-relic-entities).
   *
   * To see some query examples of entity information,
   * visit [our entity GraphQL API docs](https://docs.newrelic.com/docs/apis/graphql-api/tutorials/use-new-relic-graphql-api-query-entities).
   */
  entities?: Maybe<Array<Maybe<EntityOutline>>>;
  /** Contains information about the different entity types returned in the entity search results. */
  entityTypes?: Maybe<Array<Maybe<EntityTypeResults>>>;
  /** golden metrics grouped by domainAndEntityType-accountId-entityGuid */
  groupedGoldenMetrics?: Maybe<Array<Maybe<EntityGoldenGroupedGoldenMetrics>>>;
  /** The next cursor for fetching additional paginated entity search results. */
  nextCursor?: Maybe<Scalars['String']['output']>;
};


/** A section of the entity search results. If there is a `nextCursor` present, there are more results available. */
export type EntitySearchResultGroupedGoldenMetricsArgs = {
  context?: InputMaybe<EntityGoldenContextInput>;
  timeWindow?: InputMaybe<EntityGoldenNrqlTimeWindowInput>;
};

/** Sorting direction to apply to a golden metric sorting. */
export enum EntitySearchSortByDirection {
  /**
   * Ascending sort order.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  Asc = 'ASC',
  /**
   * Descending sort order.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  Desc = 'DESC'
}

/** Entities returned from a search. */
export type EntitySearchSortByGoldenMetricResult = {
  __typename?: 'EntitySearchSortByGoldenMetricResult';
  /**
   * Entities returned.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  entities: Array<Maybe<EntityOutline>>;
  /**
   * Pagination cursor.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  nextCursor?: Maybe<Scalars['String']['output']>;
  /**
   * Total count of entities results.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  totalCount: Scalars['Int']['output'];
};

/** Possible entity sorting criteria. */
export enum EntitySearchSortCriteria {
  /** Sort by alert severity. */
  AlertSeverity = 'ALERT_SEVERITY',
  /** Sort by entity domain. */
  Domain = 'DOMAIN',
  /** Sort by relevance. Note that these results can't be paginated. */
  MostRelevant = 'MOST_RELEVANT',
  /** Sort by entity name. */
  Name = 'NAME',
  /** Sort by reporting state. */
  Reporting = 'REPORTING',
  /** Sort by entity type. */
  Type = 'TYPE'
}

/** A detailed entity search response object type. */
export type EntitySearchTypes = {
  __typename?: 'EntitySearchTypes';
  /** The number of results with this type. */
  count?: Maybe<Scalars['Int']['output']>;
  /** The domain of the search result group. */
  domain?: Maybe<Scalars['String']['output']>;
  /** The combined domain & type of the search result group. */
  entityType?: Maybe<EntityType>;
  /** The type of the search result group. */
  type?: Maybe<Scalars['String']['output']>;
};

/** A single summary metric object. */
export type EntitySummaryMetric = {
  __typename?: 'EntitySummaryMetric';
  /** The name of the summary metric. */
  name?: Maybe<Scalars['String']['output']>;
  /** The human-readable title of the summary metric. */
  title?: Maybe<Scalars['String']['output']>;
  /** The value of the summary metric. */
  value?: Maybe<EntitySummaryMetricValue>;
};

/** An object which provides the definition of a single entity summary metric. */
export type EntitySummaryMetricDefinition = {
  __typename?: 'EntitySummaryMetricDefinition';
  /** The name of the summary metric. */
  name: Scalars['String']['output'];
  /** The human-readable title of the summary metric. */
  title: Scalars['String']['output'];
  /** The unit of the summary metric. */
  unit: EntitySummaryMetricUnit;
};

/** The different units that can be used to express summary metrics. */
export enum EntitySummaryMetricUnit {
  /** Apdex (Application Performance Index). */
  Apdex = 'APDEX',
  /** Bits. */
  Bits = 'BITS',
  /** Bits per second. */
  BitsPerSecond = 'BITS_PER_SECOND',
  /** Bytes. */
  Bytes = 'BYTES',
  /** Bytes per second. */
  BytesPerSecond = 'BYTES_PER_SECOND',
  /** Degrees celsius. */
  Celsius = 'CELSIUS',
  /** Count. */
  Count = 'COUNT',
  /** Hertz. */
  Hertz = 'HERTZ',
  /** Messages per second. */
  MessagesPerSecond = 'MESSAGES_PER_SECOND',
  /** Milliseconds. */
  Ms = 'MS',
  /** Operations per second. */
  OperationsPerSecond = 'OPERATIONS_PER_SECOND',
  /** Pages loaded per second. */
  PagesPerSecond = 'PAGES_PER_SECOND',
  /** Percentage. */
  Percentage = 'PERCENTAGE',
  /** Requests received per minute. */
  RequestsPerMinute = 'REQUESTS_PER_MINUTE',
  /** Requests received per second. */
  RequestsPerSecond = 'REQUESTS_PER_SECOND',
  /** Seconds. */
  Seconds = 'SECONDS',
  /** String. */
  String = 'STRING',
  /** Timestamp. */
  Timestamp = 'TIMESTAMP'
}

/** The interface representing the summary metric value. */
export type EntitySummaryMetricValue = {
  /** The unit of the summary metric. */
  unit?: Maybe<EntitySummaryMetricUnit>;
};

/** A numeric summary metric value. */
export type EntitySummaryNumericMetricValue = EntitySummaryMetricValue & {
  __typename?: 'EntitySummaryNumericMetricValue';
  /** The numeric value of a summary metric. */
  numericValue?: Maybe<Scalars['Float']['output']>;
  /** The unit of the summary metric. */
  unit?: Maybe<EntitySummaryMetricUnit>;
};

/** A string summary metric value. */
export type EntitySummaryStringMetricValue = EntitySummaryMetricValue & {
  __typename?: 'EntitySummaryStringMetricValue';
  /** The string value of a summary metric. */
  stringValue?: Maybe<Scalars['String']['output']>;
  /** The unit of the summary metric. */
  unit?: Maybe<EntitySummaryMetricUnit>;
};

/** A tag that has been applied to an entity. */
export type EntityTag = {
  __typename?: 'EntityTag';
  /** The tag's key */
  key?: Maybe<Scalars['String']['output']>;
  /** A list of the tag values */
  values?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
};

/** The value and metadata of a single entity tag. */
export type EntityTagValueWithMetadata = {
  __typename?: 'EntityTagValueWithMetadata';
  /** Whether or not the tag can be mutated by the user. */
  mutable?: Maybe<Scalars['Boolean']['output']>;
  /** The tag value. */
  value?: Maybe<Scalars['String']['output']>;
};

/** The tags with metadata of the entity. */
export type EntityTagWithMetadata = {
  __typename?: 'EntityTagWithMetadata';
  /** The tag's key. */
  key?: Maybe<Scalars['String']['output']>;
  /** A list of tag values with metadata information. */
  values?: Maybe<Array<Maybe<EntityTagValueWithMetadata>>>;
};

/** The specific type of entity */
export enum EntityType {
  /** An APM Application */
  ApmApplicationEntity = 'APM_APPLICATION_ENTITY',
  /** A database instance seen by an APM Application */
  ApmDatabaseInstanceEntity = 'APM_DATABASE_INSTANCE_ENTITY',
  /** An external service seen by an APM Application */
  ApmExternalServiceEntity = 'APM_EXTERNAL_SERVICE_ENTITY',
  /** A Browser Application */
  BrowserApplicationEntity = 'BROWSER_APPLICATION_ENTITY',
  /** A Dashboard entity */
  DashboardEntity = 'DASHBOARD_ENTITY',
  /** An External entity. For more information about defining External entities, see the [open source documentation](https://github.com/newrelic-experimental/entity-synthesis-definitions). */
  ExternalEntity = 'EXTERNAL_ENTITY',
  /** A Generic entity with no detailed data */
  GenericEntity = 'GENERIC_ENTITY',
  /** An Infrastructure entity */
  GenericInfrastructureEntity = 'GENERIC_INFRASTRUCTURE_ENTITY',
  /** An Infrastructure Integration AWS Lambda Function entity */
  InfrastructureAwsLambdaFunctionEntity = 'INFRASTRUCTURE_AWS_LAMBDA_FUNCTION_ENTITY',
  /** An Infrastructure Host entity */
  InfrastructureHostEntity = 'INFRASTRUCTURE_HOST_ENTITY',
  /** A Key Transaction entity */
  KeyTransactionEntity = 'KEY_TRANSACTION_ENTITY',
  /** A Mobile Application */
  MobileApplicationEntity = 'MOBILE_APPLICATION_ENTITY',
  /** A Secure Credential entity */
  SecureCredentialEntity = 'SECURE_CREDENTIAL_ENTITY',
  /** A Synthetic Monitor entity */
  SyntheticMonitorEntity = 'SYNTHETIC_MONITOR_ENTITY',
  /** A Team Entity */
  TeamEntity = 'TEAM_ENTITY',
  /** A Third Party Service entity */
  ThirdPartyServiceEntity = 'THIRD_PARTY_SERVICE_ENTITY',
  /** A entity that is unavailable */
  UnavailableEntity = 'UNAVAILABLE_ENTITY',
  /** A Workload entity */
  WorkloadEntity = 'WORKLOAD_ENTITY'
}

/** Detailed information about entity types. */
export type EntityTypeResults = {
  __typename?: 'EntityTypeResults';
  /** The domain of the entity type. */
  domain?: Maybe<Scalars['String']['output']>;
  /** The list of golden metrics for a specific entityType. This query will contain a template query with a WHERE filtering by GUID or domainId. You will need to replace the 'DOMAIN_IDS' or 'ENTITY_GUIDS' strings with the list of ids you want to display */
  goldenMetrics?: Maybe<EntityGoldenContextScopedGoldenMetrics>;
  /** The list of golden tags for a specific entityType. */
  goldenTags?: Maybe<EntityGoldenContextScopedGoldenTags>;
  /** The id of the entity type. */
  id?: Maybe<Scalars['String']['output']>;
  /** The list of metric definitions. */
  summaryMetricDefinitions?: Maybe<Array<EntitySummaryMetricDefinition>>;
  /** The type of the entity type. */
  type?: Maybe<Scalars['String']['output']>;
  /** Entity type UI definitions for this domain and type */
  uiDefinitions?: Maybe<EntityTypeUiDefinitionsResult>;
};


/** Detailed information about entity types. */
export type EntityTypeResultsGoldenMetricsArgs = {
  context?: InputMaybe<EntityGoldenContextInput>;
  timeWindow?: InputMaybe<EntityGoldenNrqlTimeWindowInput>;
};


/** Detailed information about entity types. */
export type EntityTypeResultsGoldenTagsArgs = {
  context?: InputMaybe<EntityGoldenContextInput>;
};


/** Detailed information about entity types. */
export type EntityTypeResultsUiDefinitionsArgs = {
  version?: InputMaybe<Scalars['String']['input']>;
};

/** Represents an entity type context. */
export type EntityTypeUiDefinitionsContext = {
  __typename?: 'EntityTypeUiDefinitionsContext';
  /** Only entities of the following domain types are able to use this entity type. */
  entityTypesDomainType?: Maybe<Array<Maybe<DomainType>>>;
  /** Only the following entity guids are able to use this entity type. */
  entityTypesGuid?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
  /** Only launchers in the following list are able to use this entity type. */
  launchers?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
  /** Only nerdlets in the following list are able to use this entity type. */
  nerdlets?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
};

/** An object that represents the slug name for a dashboard by provider */
export type EntityTypeUiDefinitionsDashboardProvider = {
  __typename?: 'EntityTypeUiDefinitionsDashboardProvider';
  /** Entity type's slug dashboard name for New Relic agent provider. */
  newRelic?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
  /** Entity type's slug dashboard name for Open Telemetry provider. */
  openTelemetry?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
};

/** Represents an entity context for the entity type. */
export type EntityTypeUiDefinitionsEntityContext = {
  __typename?: 'EntityTypeUiDefinitionsEntityContext';
  /** List of the entity context widgets for the entity type. */
  items: Array<Scalars['String']['output']>;
};

/** Represents a nerdlet section. */
export type EntityTypeUiDefinitionsNerdletSection = {
  __typename?: 'EntityTypeUiDefinitionsNerdletSection';
  /** Name of the section. */
  name: Scalars['String']['output'];
  /** Nerdlets that belong to the section. */
  nerdlets: Array<Maybe<Scalars['String']['output']>>;
};

/** Represents an entity relationships context for the entity type. */
export type EntityTypeUiDefinitionsRelationshipsContext = {
  __typename?: 'EntityTypeUiDefinitionsRelationshipsContext';
  /** Enabling the relationships context for the entity type. */
  enabled: Scalars['Boolean']['output'];
};

/** An object that an entity type UI definition. */
export type EntityTypeUiDefinitionsResult = {
  __typename?: 'EntityTypeUiDefinitionsResult';
  /** The category of the entity type. This is used in the New Relic One platform to group entity types. */
  category: Scalars['String']['output'];
  /** Context for this entity type. */
  context?: Maybe<EntityTypeUiDefinitionsContext>;
  /** Entity type's description. */
  description: Scalars['String']['output'];
  /** Entity type's display name. */
  displayName: Scalars['String']['output'];
  /** Entity type's plural display name. When present, it should override the default pluralization. */
  displayNamePlural?: Maybe<Scalars['String']['output']>;
  /** Domain of an entity. */
  domain: Scalars['String']['output'];
  /** Entity type's provider object with name slug for domain specific dashboard name. */
  domainDashboardSlug?: Maybe<EntityTypeUiDefinitionsDashboardProvider>;
  /** The Legacy product name this entity type is replacing. */
  domainName?: Maybe<Scalars['String']['output']>;
  /** The entity context for the entity type. */
  entityContext?: Maybe<EntityTypeUiDefinitionsEntityContext>;
  /** The icon to be used for this Entity Type. It has to be the name of any of the icons in NR-UI. */
  icon: Scalars['String']['output'];
  /** Indicates if this entity type is a collection that can contain one or more other entity types i.e. 'FAVORITE' (Watching) or 'ALERT' (Alerting). */
  isCollection?: Maybe<Scalars['Boolean']['output']>;
  /** The nerdlet sections to be shown in the entity detail view. */
  nerdletSections?: Maybe<Array<Maybe<EntityTypeUiDefinitionsNerdletSection>>>;
  /** The id of the Nerdlet to be rendered as the overview for this type of entity in the Explorer. */
  overviewNerdletId?: Maybe<Scalars['String']['output']>;
  /** Entity type's provider object with name slugs for Quickstart dashboards. */
  quickstartDashboardSlug?: Maybe<EntityTypeUiDefinitionsDashboardProvider>;
  /** The entity relationships context for the entity type. */
  relationshipsContext?: Maybe<EntityTypeUiDefinitionsRelationshipsContext>;
  /** Type of an entity within the given domain. */
  type: Scalars['String']['output'];
};

export type ErrorTrace = {
  __typename?: 'ErrorTrace';
  accountId?: Maybe<Scalars['Int']['output']>;
  agentAttributesMap?: Maybe<Scalars['AttributeMap']['output']>;
  count?: Maybe<Scalars['Int']['output']>;
  exception?: Maybe<Scalars['String']['output']>;
  expected?: Maybe<Scalars['Boolean']['output']>;
  host?: Maybe<Scalars['String']['output']>;
  id?: Maybe<Scalars['String']['output']>;
  intrinsicAttributesMap?: Maybe<Scalars['AttributeMap']['output']>;
  message?: Maybe<Scalars['String']['output']>;
  path?: Maybe<Scalars['String']['output']>;
  stackTrace?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
  timestamp?: Maybe<Scalars['EpochMilliseconds']['output']>;
  userAttributesMap?: Maybe<Scalars['AttributeMap']['output']>;
};

/** Assign error group error */
export type ErrorTrackingAssignErrorGroupError = ErrorTrackingResponseError & {
  __typename?: 'ErrorTrackingAssignErrorGroupError';
  /**
   * The description of the error
   * @deprecated This field is experimental and subject to breaking changes.
   */
  description: Scalars['String']['output'];
  /**
   * The error type
   * @deprecated This field is experimental and subject to breaking changes.
   */
  type: ErrorTrackingAssignErrorGroupErrorType;
};

/** Type of assign error group error. */
export enum ErrorTrackingAssignErrorGroupErrorType {
  /**
   * The user does not have permissions to perform the operation.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  NotAuthorized = 'NOT_AUTHORIZED'
}

/** Input for assignment mutation. */
export type ErrorTrackingAssignErrorGroupInput = {
  /** Id of the user that will be assigned. */
  userId: Scalars['Int']['input'];
};

/** Response for error group assignment mutation. */
export type ErrorTrackingAssignErrorGroupResponse = {
  __typename?: 'ErrorTrackingAssignErrorGroupResponse';
  /**
   * User that was assigned to the error group.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  assignedUser?: Maybe<UserReference>;
  /**
   * List of errors encountered.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  errors?: Maybe<Array<ErrorTrackingAssignErrorGroupError>>;
};

/** Comment on error group error */
export type ErrorTrackingCommentOnErrorGroupError = ErrorTrackingResponseError & {
  __typename?: 'ErrorTrackingCommentOnErrorGroupError';
  /**
   * The description of the error
   * @deprecated This field is experimental and subject to breaking changes.
   */
  description: Scalars['String']['output'];
  /**
   * The error type
   * @deprecated This field is experimental and subject to breaking changes.
   */
  type: ErrorTrackingCommentOnErrorGroupErrorType;
};

/** Type of comment on error group error. */
export enum ErrorTrackingCommentOnErrorGroupErrorType {
  /**
   * Comment is too old to edit
   * @deprecated This field is experimental and subject to breaking changes.
   */
  CommentTooOld = 'COMMENT_TOO_OLD',
  /**
   * The user does not have permissions to perform the operation.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  NotAuthorized = 'NOT_AUTHORIZED'
}

/** The input object that represents an error group comment. */
export type ErrorTrackingCommentOnErrorGroupInput = {
  /** Text body of the comment. */
  text: Scalars['String']['input'];
};

/** Response for comment on error group mutation. */
export type ErrorTrackingCommentOnErrorGroupResponse = {
  __typename?: 'ErrorTrackingCommentOnErrorGroupResponse';
  /**
   * The updated/added comment
   * @deprecated This field is experimental and subject to breaking changes.
   */
  comment: ErrorTrackingErrorGroupComment;
  /**
   * List of errors encountered.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  errors?: Maybe<Array<ErrorTrackingCommentOnErrorGroupError>>;
};

/** Error group channel configuration error */
export type ErrorTrackingConfigureErrorGroupChannelError = ErrorTrackingResponseError & {
  __typename?: 'ErrorTrackingConfigureErrorGroupChannelError';
  /**
   * The description of the error
   * @deprecated This field is experimental and subject to breaking changes.
   */
  description: Scalars['String']['output'];
  /**
   * The error type
   * @deprecated This field is experimental and subject to breaking changes.
   */
  type: ErrorTrackingConfigureErrorGroupChannelErrorType;
};

/** Type of error group channel configuration error. */
export enum ErrorTrackingConfigureErrorGroupChannelErrorType {
  /**
   * The channelId supplied is not valid.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  InvalidChannelId = 'INVALID_CHANNEL_ID',
  /**
   * The user does not have permissions to perform the operation.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  NotAuthorized = 'NOT_AUTHORIZED'
}

/** Response for error group channel configuration mutation. */
export type ErrorTrackingConfigureErrorGroupChannelResponse = {
  __typename?: 'ErrorTrackingConfigureErrorGroupChannelResponse';
  /**
   * The channel used to send
   * @deprecated This field is experimental and subject to breaking changes.
   */
  channel?: Maybe<ErrorTrackingNotificationChannel>;
  /**
   * List of errors encountered.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  errors?: Maybe<Array<ErrorTrackingConfigureErrorGroupChannelError>>;
  /**
   * Initiated Session
   * @deprecated This field is experimental and subject to breaking changes.
   */
  session?: Maybe<ErrorTrackingNotificationSession>;
};

/** Configure notification policy error */
export type ErrorTrackingConfigureNotificationPolicyError = ErrorTrackingResponseError & {
  __typename?: 'ErrorTrackingConfigureNotificationPolicyError';
  /**
   * The description of the error
   * @deprecated This field is experimental and subject to breaking changes.
   */
  description: Scalars['String']['output'];
  /**
   * The error type
   * @deprecated This field is experimental and subject to breaking changes.
   */
  type: ErrorTrackingConfigureNotificationPolicyErrorType;
};

/** Type of configure notification policy error. */
export enum ErrorTrackingConfigureNotificationPolicyErrorType {
  /**
   * The user does not have permissions to perform the operation.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  NotAuthorized = 'NOT_AUTHORIZED'
}

/** The input object that represents a notification policy. */
export type ErrorTrackingConfigureNotificationPolicyInput = {
  /** Channels to be associated with the policy. */
  channels?: InputMaybe<Array<ErrorTrackingNotificationChannelInput>>;
  /** Name for the new policy. */
  name: Scalars['String']['input'];
};

/** Response for notification policy mutation. */
export type ErrorTrackingConfigureNotificationPolicyResponse = {
  __typename?: 'ErrorTrackingConfigureNotificationPolicyResponse';
  /**
   * List of errors encountered.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  errors?: Maybe<Array<ErrorTrackingConfigureNotificationPolicyError>>;
  /**
   * Policy that was created or updated.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  policy?: Maybe<ErrorTrackingNotificationPolicy>;
};

/** Delete comment from error group error */
export type ErrorTrackingDeleteCommentFromErrorGroupError = ErrorTrackingResponseError & {
  __typename?: 'ErrorTrackingDeleteCommentFromErrorGroupError';
  /**
   * The description of the error
   * @deprecated This field is experimental and subject to breaking changes.
   */
  description: Scalars['String']['output'];
  /**
   * The error type
   * @deprecated This field is experimental and subject to breaking changes.
   */
  type: ErrorTrackingDeleteCommentFromErrorGroupErrorType;
};

/** Type of delete comment from error group error. */
export enum ErrorTrackingDeleteCommentFromErrorGroupErrorType {
  /**
   * Comment is too old to edit
   * @deprecated This field is experimental and subject to breaking changes.
   */
  CommentTooOld = 'COMMENT_TOO_OLD',
  /**
   * The user does not have permissions to perform the operation.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  NotAuthorized = 'NOT_AUTHORIZED'
}

/** The input object that represents an error group comment to be deleted. */
export type ErrorTrackingDeleteCommentFromErrorGroupInput = {
  /** Id of the comment author. */
  authorId?: InputMaybe<Scalars['Int']['input']>;
  /** Comment creation time. */
  timestamp: Scalars['EpochMilliseconds']['input'];
};

/** Response for delete comment from error group mutation. */
export type ErrorTrackingDeleteCommentFromErrorGroupResponse = {
  __typename?: 'ErrorTrackingDeleteCommentFromErrorGroupResponse';
  /**
   * List of errors encountered.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  errors?: Maybe<Array<ErrorTrackingDeleteCommentFromErrorGroupError>>;
};

/** Error group channel deletion error */
export type ErrorTrackingDeleteErrorGroupChannelError = ErrorTrackingResponseError & {
  __typename?: 'ErrorTrackingDeleteErrorGroupChannelError';
  /**
   * The description of the error
   * @deprecated This field is experimental and subject to breaking changes.
   */
  description: Scalars['String']['output'];
  /**
   * The error type
   * @deprecated This field is experimental and subject to breaking changes.
   */
  type: ErrorTrackingDeleteErrorGroupChannelErrorType;
};

/** Type of error group channel deletion error. */
export enum ErrorTrackingDeleteErrorGroupChannelErrorType {
  /**
   * The channelId supplied is not valid.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  InvalidChannelId = 'INVALID_CHANNEL_ID',
  /**
   * The user does not have permissions to perform the operation.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  NotAuthorized = 'NOT_AUTHORIZED'
}

/** Response for error group channel delete mutation. */
export type ErrorTrackingDeleteErrorGroupChannelResponse = {
  __typename?: 'ErrorTrackingDeleteErrorGroupChannelResponse';
  /**
   * The id of the deleted channel
   * @deprecated This field is experimental and subject to breaking changes.
   */
  channelId?: Maybe<Scalars['ID']['output']>;
  /**
   * List of errors encountered.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  errors?: Maybe<Array<ErrorTrackingDeleteErrorGroupChannelError>>;
};

/** Delete notification policy error */
export type ErrorTrackingDeleteNotificationPolicyError = ErrorTrackingResponseError & {
  __typename?: 'ErrorTrackingDeleteNotificationPolicyError';
  /**
   * The description of the error
   * @deprecated This field is experimental and subject to breaking changes.
   */
  description: Scalars['String']['output'];
  /**
   * The error type
   * @deprecated This field is experimental and subject to breaking changes.
   */
  type: ErrorTrackingDeleteNotificationPolicyErrorType;
};

/** Type of delete notification policy error. */
export enum ErrorTrackingDeleteNotificationPolicyErrorType {
  /**
   * The user does not have permissions to perform the operation.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  NotAuthorized = 'NOT_AUTHORIZED'
}

/** Response for delete notification policy mutation. */
export type ErrorTrackingDeleteNotificationPolicyResponse = {
  __typename?: 'ErrorTrackingDeleteNotificationPolicyResponse';
  /**
   * List of errors encountered.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  errors?: Maybe<Array<ErrorTrackingDeleteNotificationPolicyError>>;
  /**
   * The workload guid of the deleted policy
   * @deprecated This field is experimental and subject to breaking changes.
   */
  workloadGuid: Scalars['EntityGuid']['output'];
};

/** A grouping of similar error events. */
export type ErrorTrackingErrorGroup = {
  __typename?: 'ErrorTrackingErrorGroup';
  /**
   * User assigned to the error group
   * @deprecated This field is experimental and subject to breaking changes.
   */
  assignedUser?: Maybe<UserReference>;
  /**
   * Notifications channels associated with the error group
   * @deprecated This field is experimental and subject to breaking changes.
   */
  channels?: Maybe<Array<ErrorTrackingNotificationChannel>>;
  /**
   * User comments
   * @deprecated This field is experimental and subject to breaking changes.
   */
  comments?: Maybe<ErrorTrackingErrorGroupCommentsResponse>;
  /**
   * A unique identifier for the error group
   * @deprecated This field is experimental and subject to breaking changes.
   */
  id: Scalars['ID']['output'];
  /**
   * Notification sessions generated from this error group
   * @deprecated This field is experimental and subject to breaking changes.
   */
  notificationSessions?: Maybe<ErrorTrackingErrorGroupNotificationSessionsResponse>;
  /**
   * Value to indicate the current state of the group.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  state?: Maybe<ErrorTrackingErrorGroupState>;
};


/** A grouping of similar error events. */
export type ErrorTrackingErrorGroupCommentsArgs = {
  after?: InputMaybe<Scalars['EpochMilliseconds']['input']>;
  cursor?: InputMaybe<Scalars['String']['input']>;
};


/** A grouping of similar error events. */
export type ErrorTrackingErrorGroupNotificationSessionsArgs = {
  cursor?: InputMaybe<Scalars['String']['input']>;
  destinationType?: InputMaybe<ErrorTrackingNotificationDestination>;
};

/** Input for error group channel configuration mutation. */
export type ErrorTrackingErrorGroupChannelInput = {
  /** Unique identifier of the notification channel */
  channelId: Scalars['ID']['input'];
};

/** A comment associated with an error group. */
export type ErrorTrackingErrorGroupComment = {
  __typename?: 'ErrorTrackingErrorGroupComment';
  /**
   * User that authored the comment.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  author: UserReference;
  /**
   * Comment deletion status
   * @deprecated This field is experimental and subject to breaking changes.
   */
  deleted: Scalars['Boolean']['output'];
  /**
   * Timestamp of last update.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  editedAt?: Maybe<Scalars['EpochMilliseconds']['output']>;
  /**
   * Text body of the comment.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  text: Scalars['String']['output'];
  /**
   * Comment creation time.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  timestamp: Scalars['EpochMilliseconds']['output'];
};

/** Response for error group comments. */
export type ErrorTrackingErrorGroupCommentsResponse = {
  __typename?: 'ErrorTrackingErrorGroupCommentsResponse';
  /**
   * Cursor to get the next page of results.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  nextCursor?: Maybe<Scalars['String']['output']>;
  /**
   * List of comments.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  results?: Maybe<Array<ErrorTrackingErrorGroupComment>>;
  /**
   * Total comments matching query
   * @deprecated This field is experimental and subject to breaking changes.
   */
  totalCount?: Maybe<Scalars['Int']['output']>;
};

/** Number of error group events. */
export type ErrorTrackingErrorGroupCount = {
  __typename?: 'ErrorTrackingErrorGroupCount';
  /**
   * Numeric count of the events
   * @deprecated This field is experimental and subject to breaking changes.
   */
  count: Scalars['Int']['output'];
};

/** Response for error group sessions. */
export type ErrorTrackingErrorGroupNotificationSessionsResponse = {
  __typename?: 'ErrorTrackingErrorGroupNotificationSessionsResponse';
  /**
   * Cursor to get the next page of results.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  nextCursor?: Maybe<Scalars['String']['output']>;
  /**
   * List of sessions.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  results?: Maybe<Array<ErrorTrackingNotificationSession>>;
  /**
   * Total sessions matching query
   * @deprecated This field is experimental and subject to breaking changes.
   */
  totalCount?: Maybe<Scalars['Int']['output']>;
};

/** Current state of the error group. */
export enum ErrorTrackingErrorGroupState {
  /**
   * Error group is ignored.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  Ignored = 'IGNORED',
  /**
   * Error group is resolved.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  Resolved = 'RESOLVED',
  /**
   * Error group is unresolved.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  Unresolved = 'UNRESOLVED'
}

/** Channel configured in the notifications gateway */
export type ErrorTrackingNotificationChannel = {
  __typename?: 'ErrorTrackingNotificationChannel';
  /**
   * The destination of the notification
   * @deprecated This field is experimental and subject to breaking changes.
   */
  destination?: Maybe<ErrorTrackingNotificationDestination>;
  /**
   * The unique identifier of the notifications service channel used for delivery
   * @deprecated This field is experimental and subject to breaking changes.
   */
  id: Scalars['ID']['output'];
};

/** Input for channel configuration mutation. */
export type ErrorTrackingNotificationChannelInput = {
  /** Unique identifier of the notifications service channel used for delivery */
  channelId: Scalars['ID']['input'];
};

/** Notification Destination type */
export enum ErrorTrackingNotificationDestination {
  /**
   * Jira Classic destination
   * @deprecated This field is experimental and subject to breaking changes.
   */
  JiraClassic = 'JIRA_CLASSIC',
  /**
   * Slack destination
   * @deprecated This field is experimental and subject to breaking changes.
   */
  Slack = 'SLACK'
}

/** A notification sent from a channel. */
export type ErrorTrackingNotificationEvent = {
  __typename?: 'ErrorTrackingNotificationEvent';
  /**
   * Time of event
   * @deprecated This field is experimental and subject to breaking changes.
   */
  createdAt: Scalars['EpochMilliseconds']['output'];
  /**
   * Notification event response
   * @deprecated This field is experimental and subject to breaking changes.
   */
  evidence?: Maybe<Scalars['String']['output']>;
  /**
   * Event status
   * @deprecated This field is experimental and subject to breaking changes.
   */
  status?: Maybe<ErrorTrackingNotificationEventStatus>;
};

/** Notification Event Status type */
export enum ErrorTrackingNotificationEventStatus {
  /**
   * Failed
   * @deprecated This field is experimental and subject to breaking changes.
   */
  Fail = 'FAIL',
  /**
   * Successful
   * @deprecated This field is experimental and subject to breaking changes.
   */
  Success = 'SUCCESS'
}

/** Policy associated with a workload and grouping rule for notifications. */
export type ErrorTrackingNotificationPolicy = {
  __typename?: 'ErrorTrackingNotificationPolicy';
  /**
   * List of possible routes for delivery, first match will be used
   * @deprecated This field is experimental and subject to breaking changes.
   */
  channels: Array<ErrorTrackingNotificationChannel>;
  /**
   * Unique identifier of the policy.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  id: Scalars['ID']['output'];
  /**
   * Name of the policy.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  name: Scalars['String']['output'];
  /**
   * Unique identifier of the workload the policy is associated with.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  workloadGuid: Scalars['EntityGuid']['output'];
};

/** A unique session initiated via notification channel. */
export type ErrorTrackingNotificationSession = {
  __typename?: 'ErrorTrackingNotificationSession';
  /**
   * Notification channel used to generate the session
   * @deprecated This field is experimental and subject to breaking changes.
   */
  channel: ErrorTrackingNotificationChannel;
  /**
   * Notification events related to the session
   * @deprecated This field is experimental and subject to breaking changes.
   */
  events?: Maybe<Array<ErrorTrackingNotificationEvent>>;
  /**
   * Unique identifier of the session
   * @deprecated This field is experimental and subject to breaking changes.
   */
  id: Scalars['ID']['output'];
  /**
   * Timestamp when session was initiated
   * @deprecated This field is experimental and subject to breaking changes.
   */
  initiatedAt: Scalars['EpochMilliseconds']['output'];
};

/** Response error interface */
export type ErrorTrackingResponseError = {
  /**
   * The description of the error
   * @deprecated This field is experimental and subject to breaking changes.
   */
  description: Scalars['String']['output'];
};

/** Configure notification policy error */
export type ErrorTrackingUpdateErrorGroupStateError = ErrorTrackingResponseError & {
  __typename?: 'ErrorTrackingUpdateErrorGroupStateError';
  /**
   * The description of the error
   * @deprecated This field is experimental and subject to breaking changes.
   */
  description: Scalars['String']['output'];
  /**
   * The error type
   * @deprecated This field is experimental and subject to breaking changes.
   */
  type: ErrorTrackingUpdateErrorGroupStateErrorType;
};

/** Type of update error group state error. */
export enum ErrorTrackingUpdateErrorGroupStateErrorType {
  /**
   * The user does not have permissions to perform the operation.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  NotAuthorized = 'NOT_AUTHORIZED'
}

/** Input for state transition mutation. */
export type ErrorTrackingUpdateErrorGroupStateInput = {
  /** State that the error group should transition to. */
  state?: InputMaybe<ErrorTrackingErrorGroupState>;
};

/** Response for error group state mutation. */
export type ErrorTrackingUpdateErrorGroupStateResponse = {
  __typename?: 'ErrorTrackingUpdateErrorGroupStateResponse';
  /**
   * List of errors encountered.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  errors?: Maybe<Array<ErrorTrackingUpdateErrorGroupStateError>>;
  /**
   * Updated state value.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  state?: Maybe<ErrorTrackingErrorGroupState>;
};

export type ErrorsInboxActorStitchedFields = {
  __typename?: 'ErrorsInboxActorStitchedFields';
  /** Retrieve metadata on a specific error group. */
  errorGroup?: Maybe<ErrorsInboxErrorGroup>;
  /** List of error group state values */
  errorGroupStateTypes?: Maybe<Array<ErrorsInboxErrorGroupStateTypeResult>>;
  /** Search error groups. */
  errorGroups?: Maybe<ErrorsInboxErrorGroupsResponse>;
  /** Errors inbox notification policy. */
  notificationPolicy?: Maybe<ErrorsInboxNotificationPolicy>;
};


export type ErrorsInboxActorStitchedFieldsErrorGroupArgs = {
  errorEvent?: InputMaybe<ErrorsInboxErrorEventInput>;
  id?: InputMaybe<Scalars['ID']['input']>;
};


export type ErrorsInboxActorStitchedFieldsErrorGroupsArgs = {
  cursor?: InputMaybe<Scalars['String']['input']>;
  entityGuids?: InputMaybe<Array<Scalars['EntityGuid']['input']>>;
  filter?: InputMaybe<ErrorsInboxErrorGroupSearchFilterInput>;
  query?: InputMaybe<Scalars['String']['input']>;
  sortBy?: InputMaybe<Array<ErrorsInboxErrorGroupSortOrderInput>>;
  timeWindow?: InputMaybe<TimeWindowInput>;
};


export type ErrorsInboxActorStitchedFieldsNotificationPolicyArgs = {
  entityGuid: Scalars['EntityGuid']['input'];
};

/** Assign error group error */
export type ErrorsInboxAssignErrorGroupError = ErrorsInboxResponseError & {
  __typename?: 'ErrorsInboxAssignErrorGroupError';
  /** The description of the error */
  description: Scalars['String']['output'];
  /** The error type */
  type: ErrorsInboxAssignErrorGroupErrorType;
};

/** Type of assign error group error. */
export enum ErrorsInboxAssignErrorGroupErrorType {
  /** The user does not have permissions to perform the operation. */
  NotAuthorized = 'NOT_AUTHORIZED'
}

/** Input for assignment mutation. */
export type ErrorsInboxAssignErrorGroupInput = {
  /** Email address of the user that will be assigned. */
  userEmail?: InputMaybe<Scalars['String']['input']>;
  /** Id of the user that will be assigned. */
  userId?: InputMaybe<Scalars['Int']['input']>;
};

/** Response for error group assignment mutation. */
export type ErrorsInboxAssignErrorGroupResponse = {
  __typename?: 'ErrorsInboxAssignErrorGroupResponse';
  /**
   * User that was assigned to the error group.
   * @deprecated No longer supported
   */
  assignedUser?: Maybe<UserReference>;
  /** User that was assigned to the error group. */
  assignment?: Maybe<ErrorsInboxAssignment>;
  /** List of errors encountered. */
  errors?: Maybe<Array<ErrorsInboxAssignErrorGroupError>>;
};

/** User assigned to an error group. */
export type ErrorsInboxAssignment = {
  __typename?: 'ErrorsInboxAssignment';
  /** Email address of the user. */
  email?: Maybe<Scalars['String']['output']>;
  /** Additional user data for New Relic users. */
  userInfo?: Maybe<UserReference>;
};

/** Input type for assignment search filter */
export type ErrorsInboxAssignmentSearchFilterInput = {
  /** Filter by assigned user email. */
  userEmail?: InputMaybe<Scalars['String']['input']>;
  /** Filter by assigned user id */
  userId?: InputMaybe<Scalars['Int']['input']>;
};

/** The input object that represents a notification policy. */
export type ErrorsInboxConfigureNotificationPolicyInput = {
  /** Channels to be associated with the policy. */
  channels?: InputMaybe<Array<ErrorsInboxNotificationChannelInput>>;
  /** Name for the new policy. */
  name: Scalars['String']['input'];
};

/** Response for notification policy mutation. */
export type ErrorsInboxConfigureNotificationPolicyResponse = {
  __typename?: 'ErrorsInboxConfigureNotificationPolicyResponse';
  /** Policy that was created or updated. */
  policy?: Maybe<ErrorsInboxNotificationPolicy>;
};

/** Response for delete resource mutation. */
export type ErrorsInboxDeleteErrorGroupResourceResponse = {
  __typename?: 'ErrorsInboxDeleteErrorGroupResourceResponse';
  /** Id of the deleted resource */
  resourceId: Scalars['ID']['output'];
};

/** Response for delete notification policy mutation. */
export type ErrorsInboxDeleteNotificationPolicyResponse = {
  __typename?: 'ErrorsInboxDeleteNotificationPolicyResponse';
  /** The entity guid of the deleted policy */
  entityGuid: Scalars['EntityGuid']['output'];
};

/** Sort order direction */
export enum ErrorsInboxDirection {
  /** Descending sort order */
  Desc = 'DESC'
}

/** Entity suggestion used to populate filter suggestions */
export type ErrorsInboxEntitySuggestion = ErrorsInboxSuggestion & {
  __typename?: 'ErrorsInboxEntitySuggestion';
  /** Suggestion entity object */
  entity?: Maybe<EntityOutline>;
  /** String value of the suggestion */
  value: Scalars['String']['output'];
};

/** Input for error events. */
export type ErrorsInboxErrorEventInput = {
  /** Guid of entity that generated the event. */
  entityGuid: Scalars['EntityGuid']['input'];
  /** A set of attributes representing an event associated with an error */
  event?: InputMaybe<Scalars['ErrorsInboxRawEvent']['input']>;
  /** Error event message. */
  message?: InputMaybe<Scalars['String']['input']>;
  /** Error event name. */
  name?: InputMaybe<Scalars['String']['input']>;
  /** Source of error event (ex: TransactionError, Span) */
  source?: InputMaybe<ErrorsInboxEventSource>;
};

/** A grouping of similar error events with all fields. */
export type ErrorsInboxErrorGroup = ErrorsInboxErrorGroupBase & {
  __typename?: 'ErrorsInboxErrorGroup';
  /**
   * User assigned to the error group
   * @deprecated No longer supported
   */
  assignedUser?: Maybe<UserReference>;
  /** User assigned to the error group */
  assignment?: Maybe<ErrorsInboxAssignment>;
  /** User comments */
  comments?: Maybe<ErrorsInboxErrorGroupCommentsResponse>;
  /** Source entity Guid */
  entityGuid?: Maybe<Scalars['EntityGuid']['output']>;
  /** NRQL formatted query for retrieving error events */
  eventsQuery?: Maybe<Scalars['Nrql']['output']>;
  /** Time of first occurrence */
  firstSeenAt?: Maybe<Scalars['EpochMilliseconds']['output']>;
  /**
   * Versions running within 30 min after this error was first seen, ordered alphanumerically
   * Note: This field requires additional queries that may slow down the response
   */
  firstSeenVersions?: Maybe<Array<ErrorsInboxVersion>>;
  /** A unique identifier for the error group */
  id: Scalars['ID']['output'];
  /**
   * Indicates whether this error group was custom generated.
   * - false = this is a system-generated error group
   * - true = this is a custom error group, created and sent by the end user
   */
  isCustom?: Maybe<Scalars['Boolean']['output']>;
  /** Time of last occurrence */
  lastSeenAt?: Maybe<Scalars['EpochMilliseconds']['output']>;
  /**
   * Versions running within 30 min before this error was last seen, ordered alphanumerically
   * Note: This field requires additional queries that may slow down the response
   */
  lastSeenVersions?: Maybe<Array<ErrorsInboxVersion>>;
  /** Error group message */
  message?: Maybe<Scalars['String']['output']>;
  /** Error group name */
  name?: Maybe<Scalars['String']['output']>;
  /** The occurrences of this error group. */
  occurrences?: Maybe<ErrorsInboxOccurrences>;
  /** Time of regression occurrence for regressed error groups */
  regressedAt?: Maybe<Scalars['EpochMilliseconds']['output']>;
  /** List of resources associated with this error group */
  resources: ErrorsInboxResourcesResponse;
  /** The source event of the error group. */
  source?: Maybe<Scalars['String']['output']>;
  /** Value to indicate the current state of the group. */
  state?: Maybe<ErrorsInboxErrorGroupState>;
  /** Represents information for an error group's applied state. */
  stateInfo?: Maybe<ErrorsInboxStateInfo>;
  /** The public URL of the error group detail view. */
  url?: Maybe<Scalars['String']['output']>;
  /**
   * The user impact of this error group in the requested time window.
   * If no time window was provided, a default of 1 hour will be used.
   */
  usersImpacted?: Maybe<ErrorsInboxUsersImpacted>;
};


/** A grouping of similar error events with all fields. */
export type ErrorsInboxErrorGroupCommentsArgs = {
  after?: InputMaybe<Scalars['EpochMilliseconds']['input']>;
  cursor?: InputMaybe<Scalars['String']['input']>;
};


/** A grouping of similar error events with all fields. */
export type ErrorsInboxErrorGroupResourcesArgs = {
  cursor?: InputMaybe<Scalars['String']['input']>;
  filter?: InputMaybe<ErrorsInboxResourceFilterInput>;
};

/** A base set of fields for a grouping of similar error events. */
export type ErrorsInboxErrorGroupBase = {
  /**
   * User assigned to the error group
   * @deprecated No longer supported
   */
  assignedUser?: Maybe<UserReference>;
  /** User assigned to the error group */
  assignment?: Maybe<ErrorsInboxAssignment>;
  /** User comments */
  comments?: Maybe<ErrorsInboxErrorGroupCommentsResponse>;
  /** Source entity Guid */
  entityGuid?: Maybe<Scalars['EntityGuid']['output']>;
  /** NRQL formatted query for retrieving error events */
  eventsQuery?: Maybe<Scalars['Nrql']['output']>;
  /** Time of first occurrence */
  firstSeenAt?: Maybe<Scalars['EpochMilliseconds']['output']>;
  /** A unique identifier for the error group */
  id: Scalars['ID']['output'];
  /**
   * Indicates whether this error group was custom generated.
   * - false = this is a system-generated error group
   * - true = this is a custom error group, created and sent by the end user
   */
  isCustom?: Maybe<Scalars['Boolean']['output']>;
  /** Time of last occurrence */
  lastSeenAt?: Maybe<Scalars['EpochMilliseconds']['output']>;
  /** Error group message */
  message?: Maybe<Scalars['String']['output']>;
  /** Error group name */
  name?: Maybe<Scalars['String']['output']>;
  /** The occurrences of this error group. */
  occurrences?: Maybe<ErrorsInboxOccurrences>;
  /** Time of regression occurrence for regressed error groups */
  regressedAt?: Maybe<Scalars['EpochMilliseconds']['output']>;
  /** List of resources associated with this error group */
  resources: ErrorsInboxResourcesResponse;
  /** The source event of the error group. */
  source?: Maybe<Scalars['String']['output']>;
  /** Value to indicate the current state of the group. */
  state?: Maybe<ErrorsInboxErrorGroupState>;
  /** Represents information for an error group's applied state. */
  stateInfo?: Maybe<ErrorsInboxStateInfo>;
  /** The public URL of the error group detail view. */
  url?: Maybe<Scalars['String']['output']>;
  /**
   * The user impact of this error group in the requested time window.
   * If no time window was provided, a default of 1 hour will be used.
   */
  usersImpacted?: Maybe<ErrorsInboxUsersImpacted>;
};


/** A base set of fields for a grouping of similar error events. */
export type ErrorsInboxErrorGroupBaseCommentsArgs = {
  after?: InputMaybe<Scalars['EpochMilliseconds']['input']>;
  cursor?: InputMaybe<Scalars['String']['input']>;
};


/** A base set of fields for a grouping of similar error events. */
export type ErrorsInboxErrorGroupBaseResourcesArgs = {
  cursor?: InputMaybe<Scalars['String']['input']>;
  filter?: InputMaybe<ErrorsInboxResourceFilterInput>;
};

/** A comment associated with an error group. */
export type ErrorsInboxErrorGroupComment = {
  __typename?: 'ErrorsInboxErrorGroupComment';
  /** User that authored the comment. */
  author?: Maybe<UserReference>;
  /** Comment deletion status */
  deleted: Scalars['Boolean']['output'];
  /** Timestamp of last update. */
  editedAt?: Maybe<Scalars['EpochMilliseconds']['output']>;
  /** Text body of the comment. */
  text: Scalars['String']['output'];
  /** Comment creation time. */
  timestamp: Scalars['EpochMilliseconds']['output'];
};

/** Response for error group comments. */
export type ErrorsInboxErrorGroupCommentsResponse = {
  __typename?: 'ErrorsInboxErrorGroupCommentsResponse';
  /** Cursor to get the next page of results. */
  nextCursor?: Maybe<Scalars['String']['output']>;
  /** List of comments. */
  results?: Maybe<Array<ErrorsInboxErrorGroupComment>>;
  /** Total comments matching query */
  totalCount?: Maybe<Scalars['Int']['output']>;
};

/** A grouping of similar error events with minimal fields. */
export type ErrorsInboxErrorGroupOutline = ErrorsInboxErrorGroupBase & {
  __typename?: 'ErrorsInboxErrorGroupOutline';
  /**
   * User assigned to the error group
   * @deprecated No longer supported
   */
  assignedUser?: Maybe<UserReference>;
  /** User assigned to the error group */
  assignment?: Maybe<ErrorsInboxAssignment>;
  /** User comments */
  comments?: Maybe<ErrorsInboxErrorGroupCommentsResponse>;
  /** Source entity Guid */
  entityGuid?: Maybe<Scalars['EntityGuid']['output']>;
  /** NRQL formatted query for retrieving error events */
  eventsQuery?: Maybe<Scalars['Nrql']['output']>;
  /** Time of first occurrence */
  firstSeenAt?: Maybe<Scalars['EpochMilliseconds']['output']>;
  /** A unique identifier for the error group */
  id: Scalars['ID']['output'];
  /**
   * Indicates whether this error group was custom generated.
   * - false = this is a system-generated error group
   * - true = this is a custom error group, created and sent by the end user
   */
  isCustom?: Maybe<Scalars['Boolean']['output']>;
  /** Time of last occurrence */
  lastSeenAt?: Maybe<Scalars['EpochMilliseconds']['output']>;
  /** Error group message */
  message?: Maybe<Scalars['String']['output']>;
  /** Error group name */
  name?: Maybe<Scalars['String']['output']>;
  /** The occurrences of this error group. */
  occurrences?: Maybe<ErrorsInboxOccurrences>;
  /** Time of regression occurrence for regressed error groups */
  regressedAt?: Maybe<Scalars['EpochMilliseconds']['output']>;
  /** List of resources associated with this error group */
  resources: ErrorsInboxResourcesResponse;
  /** The source event of the error group. */
  source?: Maybe<Scalars['String']['output']>;
  /** Value to indicate the current state of the group. */
  state?: Maybe<ErrorsInboxErrorGroupState>;
  /** Represents information for an error group's applied state. */
  stateInfo?: Maybe<ErrorsInboxStateInfo>;
  /** The public URL of the error group detail view. */
  url?: Maybe<Scalars['String']['output']>;
  /**
   * The user impact of this error group in the requested time window.
   * If no time window was provided, a default of 1 hour will be used.
   */
  usersImpacted?: Maybe<ErrorsInboxUsersImpacted>;
};


/** A grouping of similar error events with minimal fields. */
export type ErrorsInboxErrorGroupOutlineCommentsArgs = {
  after?: InputMaybe<Scalars['EpochMilliseconds']['input']>;
  cursor?: InputMaybe<Scalars['String']['input']>;
};


/** A grouping of similar error events with minimal fields. */
export type ErrorsInboxErrorGroupOutlineResourcesArgs = {
  cursor?: InputMaybe<Scalars['String']['input']>;
  filter?: InputMaybe<ErrorsInboxResourceFilterInput>;
};

/** Set of filters for scoping error group searches */
export type ErrorsInboxErrorGroupSearchFilterInput = {
  /** Filter error groups by account ID */
  accountIds?: InputMaybe<Array<Scalars['Int']['input']>>;
  /** Filter error groups by the version of the application */
  applicationVersions?: InputMaybe<Array<Scalars['String']['input']>>;
  /** Filter error groups by assignment */
  assignment?: InputMaybe<Array<ErrorsInboxAssignmentSearchFilterInput>>;
  /** Filter error groups by id */
  ids?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** Filter error groups by assignment status */
  isAssigned?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter error groups by error group states */
  states?: InputMaybe<Array<ErrorsInboxErrorGroupState>>;
};

/** Sort fields */
export enum ErrorsInboxErrorGroupSortOrderField {
  /** Order by last occurrence in the current time window. */
  LastOccurrenceInWindow = 'LAST_OCCURRENCE_IN_WINDOW',
  /** Order by error group occurrences. */
  Occurrences = 'OCCURRENCES'
}

/** Sort object. */
export type ErrorsInboxErrorGroupSortOrderInput = {
  /** Sort object order. */
  direction: ErrorsInboxDirection;
  /** Sort object field. */
  field: ErrorsInboxErrorGroupSortOrderField;
};

/** Current state of the error group. */
export enum ErrorsInboxErrorGroupState {
  /** Error group is ignored. */
  Ignored = 'IGNORED',
  /** Error group is resolved. */
  Resolved = 'RESOLVED',
  /** Error group is unresolved. */
  Unresolved = 'UNRESOLVED'
}

/** Information about the error group state type */
export type ErrorsInboxErrorGroupStateTypeResult = {
  __typename?: 'ErrorsInboxErrorGroupStateTypeResult';
  /** Type of the error group state */
  type?: Maybe<ErrorsInboxErrorGroupState>;
};

/** Response for error groups. */
export type ErrorsInboxErrorGroupsResponse = {
  __typename?: 'ErrorsInboxErrorGroupsResponse';
  /**
   * List of values that can be used to filter error groups.
   *
   * Based on the current `query` (if specified), collect a list of `attribute` values
   * from the applicable set of error groups.
   *
   * For example, there are 3 error groups:
   * - name: Some error group 01, message: Some message 1
   * - name: Some error group 02, message: Some message 2
   * - name: Some error group 3, message: Some message 3
   *
   * If the current `query` is:
   *
   *     error.group.name LIKE '%error group 0%',
   *
   * then the following values will be returned for `error.group.message`:
   * - "Some message 1"
   * - "Some message 2"
   *
   * Note: this currently only supports standard error group attributes (ex: `error.group.name`, `error.group.message`,
   * `error.group.source`, `error.group.metadata.assignedUser`, `entity.name`).
   */
  filterSuggestions?: Maybe<ErrorsInboxFilterSuggestionsResponse>;
  /** Cursor to get the next page of results. */
  nextCursor?: Maybe<Scalars['String']['output']>;
  /** List of error groups. */
  results?: Maybe<Array<ErrorsInboxErrorGroupOutline>>;
  /** Total error groups matching query */
  totalCount?: Maybe<Scalars['Int']['output']>;
};


/** Response for error groups. */
export type ErrorsInboxErrorGroupsResponseFilterSuggestionsArgs = {
  attributes: Array<Scalars['String']['input']>;
};

/** Event source type (note: this list includes events currently supported by errors inbox) */
export enum ErrorsInboxEventSource {
  /** AwsLambdaInvocationError events */
  AwsLambdaInvocationError = 'AWS_LAMBDA_INVOCATION_ERROR',
  /** ErrorTrace events */
  ErrorTrace = 'ERROR_TRACE',
  /** JavaScriptError events */
  JavaScriptError = 'JAVA_SCRIPT_ERROR',
  /** MobileCrash events */
  MobileCrash = 'MOBILE_CRASH',
  /** MobileHandledException events */
  MobileHandledException = 'MOBILE_HANDLED_EXCEPTION',
  /** MobileRequestError events */
  MobileRequestError = 'MOBILE_REQUEST_ERROR',
  /** Span events */
  Span = 'SPAN',
  /** TransactionError events */
  TransactionError = 'TRANSACTION_ERROR'
}

/** Filter suggestion */
export type ErrorsInboxFilterSuggestion = {
  __typename?: 'ErrorsInboxFilterSuggestion';
  /** Error group attribute associated with the list of filter suggestions (ex: `error.group.name`) */
  attribute: Scalars['String']['output'];
  /** List of values that can be used to populate filter suggestions */
  suggestions?: Maybe<Array<ErrorsInboxSuggestion>>;
};

/** Response for filter suggestions. */
export type ErrorsInboxFilterSuggestionsResponse = {
  __typename?: 'ErrorsInboxFilterSuggestionsResponse';
  /** List of filter suggestions */
  results?: Maybe<Array<ErrorsInboxFilterSuggestion>>;
};

/** An single issue in JIRA */
export type ErrorsInboxJiraIssue = ErrorsInboxResource & {
  __typename?: 'ErrorsInboxJiraIssue';
  /** Unique resource identifier */
  id: Scalars['ID']['output'];
  /** Issue Id in JIRA */
  issueId: Scalars['ID']['output'];
  /** Url to access the issue in JIRA */
  url: Scalars['String']['output'];
};

/** Channel for notification delivery */
export type ErrorsInboxNotificationChannel = {
  __typename?: 'ErrorsInboxNotificationChannel';
  /** The destination of the notification */
  destination?: Maybe<ErrorsInboxNotificationDestination>;
  /** The unique identifier of the notifications channel used for delivery */
  id: Scalars['ID']['output'];
};

/** Input for channel configuration mutation. */
export type ErrorsInboxNotificationChannelInput = {
  /** Unique identifier of the notifications service channel used for delivery */
  channelId: Scalars['ID']['input'];
};

/** Notification Destination type */
export enum ErrorsInboxNotificationDestination {
  /** Jira Classic destination */
  JiraClassic = 'JIRA_CLASSIC',
  /** Slack destination */
  Slack = 'SLACK'
}

/** Notification policy associated with an entity. */
export type ErrorsInboxNotificationPolicy = {
  __typename?: 'ErrorsInboxNotificationPolicy';
  /** List of channels for delivery. */
  channels: Array<ErrorsInboxNotificationChannel>;
  /** Unique identifier of the entity the policy is associated with. */
  entityGuid: Scalars['EntityGuid']['output'];
  /** Unique identifier of the policy. */
  id: Scalars['ID']['output'];
  /** Name of the policy. */
  name: Scalars['String']['output'];
};

/** The occurrences of an error group */
export type ErrorsInboxOccurrences = {
  __typename?: 'ErrorsInboxOccurrences';
  /** Total number of expected occurrences in the given time window. */
  expectedCount?: Maybe<Scalars['Int']['output']>;
  /** Time of first occurrence in the given time window. */
  firstSeenAt?: Maybe<Scalars['EpochMilliseconds']['output']>;
  /** Time of last occurrence in the given time window. */
  lastSeenAt?: Maybe<Scalars['EpochMilliseconds']['output']>;
  /** Total number of occurrences in the given time window. */
  totalCount?: Maybe<Scalars['Int']['output']>;
};

/** Basic external resource */
export type ErrorsInboxResource = {
  /** Unique resource identifier */
  id: Scalars['ID']['output'];
  /** External resource url */
  url: Scalars['String']['output'];
};

/** Criteria for the resource filter */
export type ErrorsInboxResourceFilterInput = {
  /** Types of resources to include in the query */
  types?: InputMaybe<Array<ErrorsInboxResourceType>>;
};

/** A Type of resource */
export enum ErrorsInboxResourceType {
  /** A JIRA issue */
  JiraIssue = 'JIRA_ISSUE'
}

/** Response for error group resources. */
export type ErrorsInboxResourcesResponse = {
  __typename?: 'ErrorsInboxResourcesResponse';
  /** Cursor used to fetch the next set of results */
  nextCursor?: Maybe<Scalars['String']['output']>;
  /** The list of search results */
  results: Array<ErrorsInboxResource>;
  /** The total number of results that match the search */
  totalCount: Scalars['Int']['output'];
};

/** Response error interface */
export type ErrorsInboxResponseError = {
  /** The description of the error */
  description: Scalars['String']['output'];
};

/** Information for an error group's applied state */
export type ErrorsInboxStateInfo = {
  __typename?: 'ErrorsInboxStateInfo';
  /** Only available when resolving error groups.  Configures errors inbox to use change tracking to resolve an error group in the next tracked version. */
  resolveInNextVersion?: Maybe<Scalars['Boolean']['output']>;
  /** Error group state (ex: Resolved, Unresolved, Ignored) */
  state: ErrorsInboxErrorGroupState;
  /** Timestamp of the last error group state update */
  updatedAt?: Maybe<Scalars['EpochMilliseconds']['output']>;
  /** Versions of the entity for which an error group's state applies */
  versions?: Maybe<Array<ErrorsInboxVersion>>;
};

/** Input for the version related to an applied state (e.g., Resolved in version <stateVersion>). */
export type ErrorsInboxStateVersionInput = {
  /** Version strings */
  values?: InputMaybe<Array<Scalars['String']['input']>>;
};

/** Simple string suggestion used to populate filter suggestions */
export type ErrorsInboxStringSuggestion = ErrorsInboxSuggestion & {
  __typename?: 'ErrorsInboxStringSuggestion';
  /** String value of the suggestion */
  value: Scalars['String']['output'];
};

/** Suggestion used to populate filter suggestions */
export type ErrorsInboxSuggestion = {
  /** String value of the suggestion */
  value: Scalars['String']['output'];
};

/** Configure notification policy error */
export type ErrorsInboxUpdateErrorGroupStateError = ErrorsInboxResponseError & {
  __typename?: 'ErrorsInboxUpdateErrorGroupStateError';
  /** The description of the error */
  description: Scalars['String']['output'];
  /** The error type */
  type: ErrorsInboxUpdateErrorGroupStateErrorType;
};

/** Type of update error group state error. */
export enum ErrorsInboxUpdateErrorGroupStateErrorType {
  /** The user does not have permissions to perform the operation. */
  NotAuthorized = 'NOT_AUTHORIZED'
}

/** Response for error group state mutation. */
export type ErrorsInboxUpdateErrorGroupStateResponse = {
  __typename?: 'ErrorsInboxUpdateErrorGroupStateResponse';
  /**
   * List of errors encountered.
   * @deprecated No longer supported
   */
  errors?: Maybe<Array<ErrorsInboxUpdateErrorGroupStateError>>;
  /** Configures errors inbox to use change tracking to resolve an error group in the next tracked version. */
  resolveInNextVersion?: Maybe<Scalars['Boolean']['output']>;
  /** Updated state value. */
  state?: Maybe<ErrorsInboxErrorGroupState>;
  /** Versions of the entity for which an error group's state applies. */
  versions?: Maybe<Array<ErrorsInboxVersion>>;
};

/** User suggestion used to populate filter suggestions */
export type ErrorsInboxUserSuggestion = ErrorsInboxSuggestion & {
  __typename?: 'ErrorsInboxUserSuggestion';
  /** Suggestion user object */
  user?: Maybe<UserReference>;
  /** String value of the suggestion */
  value: Scalars['String']['output'];
};

/** The users impacted by an error group */
export type ErrorsInboxUsersImpacted = {
  __typename?: 'ErrorsInboxUsersImpacted';
  /**
   * Total number of users impacted in the requested time window.
   * If no time window was provided, a default of 1 hour will be used.
   */
  totalCount?: Maybe<Scalars['Int']['output']>;
};

/** Version details (ex: for first and last seen versions or an error group state) */
export type ErrorsInboxVersion = {
  __typename?: 'ErrorsInboxVersion';
  /** Version name */
  name?: Maybe<Scalars['String']['output']>;
};

/** A human-readable definition of an NRDB Event Type Attribute */
export type EventAttributeDefinition = {
  __typename?: 'EventAttributeDefinition';
  /**
   * This attribute's category
   * @deprecated This field no longer returns data.
   */
  category?: Maybe<Scalars['String']['output']>;
  /** A short description of this attribute */
  definition?: Maybe<Scalars['String']['output']>;
  /** The New Relic docs page for this attribute */
  documentationUrl?: Maybe<Scalars['String']['output']>;
  /** The human-friendly formatted name of the attribute */
  label?: Maybe<Scalars['String']['output']>;
  /** The name of the attribute */
  name?: Maybe<Scalars['String']['output']>;
};

/** A human-readable definition of an NRDB Event Type */
export type EventDefinition = {
  __typename?: 'EventDefinition';
  /** A list of attribute definitions for this event type */
  attributes?: Maybe<Array<Maybe<EventAttributeDefinition>>>;
  /** A short description of this event */
  definition?: Maybe<Scalars['String']['output']>;
  /** The human-friendly formatted name of the event */
  label?: Maybe<Scalars['String']['output']>;
  /** The name of the event */
  name?: Maybe<Scalars['String']['output']>;
};

export type EventTransformationRule = {
  __typename?: 'EventTransformationRule';
  description?: Maybe<Scalars['String']['output']>;
  enabled?: Maybe<Scalars['Boolean']['output']>;
  id?: Maybe<Scalars['Int']['output']>;
  inputEventTypes?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
  inputRetentionPolicies?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
  name?: Maybe<Scalars['String']['output']>;
  outputEventType?: Maybe<Scalars['String']['output']>;
  outputRetentionPolicy?: Maybe<Scalars['String']['output']>;
  selectedAttributes?: Maybe<Scalars['String']['output']>;
  whereClause?: Maybe<Scalars['String']['output']>;
};

export type EventTransformationRuleInput = {
  description?: InputMaybe<Scalars['String']['input']>;
  inputEventTypes: Array<Scalars['String']['input']>;
  inputRetentionPolicies: Array<Scalars['String']['input']>;
  name: Scalars['String']['input'];
  outputEventType: Scalars['String']['input'];
  outputRetentionPolicy: Scalars['String']['input'];
  selectedAttributes?: InputMaybe<Scalars['String']['input']>;
  whereClause: Scalars['String']['input'];
};

export type EventTransformationRuleListing = {
  __typename?: 'EventTransformationRuleListing';
  cursor?: Maybe<Scalars['String']['output']>;
  rules?: Maybe<Array<Maybe<EventTransformationRule>>>;
};

export type EventTransformationRuleUpdates = {
  enabled?: InputMaybe<Scalars['Boolean']['input']>;
  retentionPolicy?: InputMaybe<Scalars['String']['input']>;
  rule?: InputMaybe<EventTransformationRuleInput>;
};

/** Account stitched fields to enable autostitching in NerdGraph */
export type EventsToMetricsAccountStitchedFields = {
  __typename?: 'EventsToMetricsAccountStitchedFields';
  /** List all rules for your account. */
  allRules?: Maybe<EventsToMetricsListRuleResult>;
  /** List rules for your account by id. */
  rulesById?: Maybe<EventsToMetricsListRuleResult>;
};


/** Account stitched fields to enable autostitching in NerdGraph */
export type EventsToMetricsAccountStitchedFieldsRulesByIdArgs = {
  ruleIds: Array<InputMaybe<Scalars['ID']['input']>>;
};

/** Error details about the events to metrics rule that failed to be created and why. */
export type EventsToMetricsCreateRuleFailure = {
  __typename?: 'EventsToMetricsCreateRuleFailure';
  /** Information about why the create failed. */
  errors?: Maybe<Array<Maybe<EventsToMetricsError>>>;
  /** Input information about a submitted rule that was unable to be created. */
  submitted?: Maybe<EventsToMetricsCreateRuleSubmission>;
};

/** Details needed to create an events to metrics conversion rule. */
export type EventsToMetricsCreateRuleInput = {
  /** The account where the events exist and the metrics will be put. */
  accountId: Scalars['Int']['input'];
  /** Provides additional information about the rule. */
  description?: InputMaybe<Scalars['String']['input']>;
  /** The name of the rule. This must be unique within a given account. */
  name: Scalars['String']['input'];
  /** Explains how to create one or more metrics from events. */
  nrql: Scalars['String']['input'];
};

/** The result of which submitted events to metrics rules were successfully and unsuccessfully created */
export type EventsToMetricsCreateRuleResult = {
  __typename?: 'EventsToMetricsCreateRuleResult';
  /** Rules that were not created and why. */
  failures?: Maybe<Array<Maybe<EventsToMetricsCreateRuleFailure>>>;
  /** Rules that were successfully created. */
  successes?: Maybe<Array<Maybe<EventsToMetricsRule>>>;
};

/** The details that were submitted when creating an events to metrics conversion rule. */
export type EventsToMetricsCreateRuleSubmission = {
  __typename?: 'EventsToMetricsCreateRuleSubmission';
  /** The account where the events exist and the metrics will be put. */
  accountId: Scalars['Int']['output'];
  /** Provides additional information about the rule. */
  description?: Maybe<Scalars['String']['output']>;
  /** The name of the rule. This must be unique within a given account. */
  name: Scalars['String']['output'];
  /** Explains how to create one or more metrics from events. */
  nrql: Scalars['String']['output'];
};

/** Error details about the events to metrics rule that failed to be deleted and why. */
export type EventsToMetricsDeleteRuleFailure = {
  __typename?: 'EventsToMetricsDeleteRuleFailure';
  /** Information about why the delete failed. */
  errors?: Maybe<Array<Maybe<EventsToMetricsError>>>;
  /** Input information about a submitted rule that was unable to be deleted. */
  submitted?: Maybe<EventsToMetricsDeleteRuleSubmission>;
};

/** Identifying information about the events to metrics rule you want to delete. */
export type EventsToMetricsDeleteRuleInput = {
  /** A submitted account id. */
  accountId: Scalars['Int']['input'];
  /** A submitted rule id. */
  ruleId: Scalars['ID']['input'];
};

/** The result of which submitted events to metrics rules were successfully and unsuccessfully deleted. */
export type EventsToMetricsDeleteRuleResult = {
  __typename?: 'EventsToMetricsDeleteRuleResult';
  /** Information about the rules that could not be deleted. */
  failures?: Maybe<Array<Maybe<EventsToMetricsDeleteRuleFailure>>>;
  /** Rules that were successfully deleted. */
  successes?: Maybe<Array<Maybe<EventsToMetricsRule>>>;
};

/** The details that were submitted when deleteing an events to metrics conversion rule. */
export type EventsToMetricsDeleteRuleSubmission = {
  __typename?: 'EventsToMetricsDeleteRuleSubmission';
  /** A submitted account id. */
  accountId: Scalars['Int']['output'];
  /** A submitted rule id. */
  ruleId: Scalars['ID']['output'];
};

/** Error details when processing events to metrics rule requests. */
export type EventsToMetricsError = {
  __typename?: 'EventsToMetricsError';
  /** A detailed error message. */
  description?: Maybe<Scalars['String']['output']>;
  /** The category of error that occurred. */
  reason?: Maybe<EventsToMetricsErrorReason>;
};

/** General error categories. */
export enum EventsToMetricsErrorReason {
  /** Other errors. */
  General = 'GENERAL',
  /** Indicates some part of your submission was invalid. */
  InvalidInput = 'INVALID_INPUT',
  /** The user attempting to submit this rule is not authorized to do so. */
  UserNotAuthorized = 'USER_NOT_AUTHORIZED'
}

/** A list of rule details to be returned. */
export type EventsToMetricsListRuleResult = {
  __typename?: 'EventsToMetricsListRuleResult';
  /** Event-to-metric rules to be returned. */
  rules?: Maybe<Array<Maybe<EventsToMetricsRule>>>;
};

/** Information about an event-to-metric rule which creates metrics from events. */
export type EventsToMetricsRule = {
  __typename?: 'EventsToMetricsRule';
  /** Account with the event and where the metrics will be placed. */
  accountId: Scalars['Int']['output'];
  /** The time at which the rule was created */
  createdAt: Scalars['DateTime']['output'];
  /** Additional information about the rule. */
  description?: Maybe<Scalars['String']['output']>;
  /** True means this rule is enabled. False means the rule is currently not creating metrics. */
  enabled: Scalars['Boolean']['output'];
  /** The id, uniquely identifying the rule. */
  id: Scalars['ID']['output'];
  /** The name of the rule. This must be unique within an account. */
  name: Scalars['String']['output'];
  /** Explains how to create metrics from events. */
  nrql: Scalars['String']['output'];
  /** The time at which the rule was updated */
  updatedAt: Scalars['DateTime']['output'];
};

/** Error details about the events to metrics rule that failed to be updated and why. */
export type EventsToMetricsUpdateRuleFailure = {
  __typename?: 'EventsToMetricsUpdateRuleFailure';
  /** Information about why the update failed. */
  errors?: Maybe<Array<Maybe<EventsToMetricsError>>>;
  /** Input information about a failed update. */
  submitted?: Maybe<EventsToMetricsUpdateRuleSubmission>;
};

/** Identifying information about the events to metrics rule you want to update. */
export type EventsToMetricsUpdateRuleInput = {
  /** A submitted account id. */
  accountId: Scalars['Int']['input'];
  /** Changes the state of the rule as being enabled or disabled. */
  enabled: Scalars['Boolean']['input'];
  /** A submitted rule id. */
  ruleId: Scalars['ID']['input'];
};

/** The result of which submitted events to metrics rules were successfully and unsuccessfully update. */
export type EventsToMetricsUpdateRuleResult = {
  __typename?: 'EventsToMetricsUpdateRuleResult';
  /** Rules that failed to get updated. */
  failures?: Maybe<Array<Maybe<EventsToMetricsUpdateRuleFailure>>>;
  /** Rules that were successfully enabled or disabled. */
  successes?: Maybe<Array<Maybe<EventsToMetricsRule>>>;
};

/** The details that were submitted when updating an events to metrics conversion rule. */
export type EventsToMetricsUpdateRuleSubmission = {
  __typename?: 'EventsToMetricsUpdateRuleSubmission';
  /** A submitted account id. */
  accountId: Scalars['Int']['output'];
  /** Changes the state of the rule as being enabled or disabled. */
  enabled: Scalars['Boolean']['output'];
  /** A submitted rule id. */
  ruleId: Scalars['ID']['output'];
};

/** An External entity. */
export type ExternalEntity = AlertableEntity & Entity & {
  __typename?: 'ExternalEntity';
  account?: Maybe<AccountOutline>;
  /** The New Relic account ID associated with this entity. */
  accountId?: Maybe<Scalars['Int']['output']>;
  /** The current alerting severity of the entity. */
  alertSeverity?: Maybe<EntityAlertSeverity>;
  /**
   * The alert status of the entity.
   * @deprecated Please use `alertSeverity` and `reporting`
   */
  alertStatus?: Maybe<EntityAlertStatus>;
  /** Violations on the entity that were open during the specified time window. This will return up to 500 violations - if there are more in the time window selected, you must narrow the time window or look at fewer entities. */
  alertViolations?: Maybe<Array<Maybe<EntityAlertViolation>>>;
  /** Retrieve the deployment event(s). Ordered by timestamp DESC. */
  deploymentSearch?: Maybe<ChangeTrackingDeploymentSearchResult>;
  /** The entity's domain */
  domain?: Maybe<Scalars['String']['output']>;
  /** A value representing the combination of the entity's domain and type. */
  entityType?: Maybe<EntityType>;
  /** The date of last time the entity has updated any of its fields. */
  firstIndexedAt?: Maybe<Scalars['EpochMilliseconds']['output']>;
  /** The list of golden metrics for a specific entity */
  goldenMetrics?: Maybe<EntityGoldenContextScopedGoldenMetrics>;
  /**
   * For the golden signal on this entity, show correlated signals from related entities.
   * Well inspect the golden signals for all related entities and return a sorted list.
   * You can also filter the results.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  goldenSignalCorrelations?: Maybe<GoldenSignalCorrelationResult>;
  /**
   * The deviation from normal of golden signal(s) for the given entity.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  goldenSignalDeviations?: Maybe<Array<Maybe<GoldenSignalSignalDeviation>>>;
  /**
   * The stored golden signal(s) for the given entity.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  goldenSignalValues?: Maybe<GoldenSignalValues>;
  /**
   * The stored golden signal(s) for the given entity. To be removed, use goldenSignalValues instead.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  goldenSignalValuesV2?: Maybe<GoldenSignalValues>;
  /** The list of golden tags for a specific entityType. */
  goldenTags?: Maybe<EntityGoldenContextScopedGoldenTags>;
  /** A unique entity identifier. */
  guid?: Maybe<Scalars['EntityGuid']['output']>;
  /** The time the entity was indexed. */
  indexedAt?: Maybe<Scalars['EpochMilliseconds']['output']>;
  /** The last time the entity's reporting status changed. */
  lastReportingChangeAt?: Maybe<Scalars['EpochMilliseconds']['output']>;
  /** The name of this entity. */
  name?: Maybe<Scalars['String']['output']>;
  nerdStorage?: Maybe<NerdStorageEntityScope>;
  nerdStoreCollection?: Maybe<Array<Maybe<NerdStoreCollectionMember>>>;
  nerdStoreDocument?: Maybe<Scalars['NerdStoreDocument']['output']>;
  /**
   * Make an `Entity` scoped query to NRDB with a NRQL string.
   *
   * A relevant `WHERE` clause will be added to your query to scope data to the entity in question.
   *
   * See the [NRQL Docs](https://docs.newrelic.com/docs/insights/nrql-new-relic-query-language/nrql-resources/nrql-syntax-components-functions) for more information about generating a query string.
   */
  nrdbQuery?: Maybe<NrdbResultContainer>;
  /**
   * Poll for the results of a previously-executed asychronous NRDB query.
   *
   * The `queryId` is available in the `queryProgress` data returned by the original asynchronous query.
   *
   * See [this page](https://docs.newrelic.com/docs/apis/nerdgraph/examples/async-queries-nrql-tutorial) for additional asynchronous query documentation.
   * @deprecated This field is experimental! It may change at any time.
   *
   */
  nrdbQueryProgress?: Maybe<NrdbResultContainer>;
  /** The url to the entity. */
  permalink?: Maybe<Scalars['String']['output']>;
  /** Recent violations on the entity. */
  recentAlertViolations?: Maybe<Array<Maybe<EntityAlertViolation>>>;
  /** The recommended service levels for the entity. */
  recommendedServiceLevel?: Maybe<ServiceLevelRecommendation>;
  /** Related dashboards results */
  relatedDashboards: RelatedDashboardsRelatedDashboardResult;
  /** Related entities result with optional filtering. */
  relatedEntities?: Maybe<EntityRelationshipRelatedEntitiesResult>;
  /** Relationship traversal results with optional filtering. WARNING: this query is still experimental, and subject to breaking changes. */
  relationshipTraversal?: Maybe<EntityRelationshipTraversalResult>;
  /**
   * A list of the entities' relationships.
   *
   * For more information, visit [our docs](https://docs.newrelic.com/docs/apis/graphql-api/tutorials/graphql-relationships-api-tutorial).
   * @deprecated This field is deprecated! Please use `relatedEntities`.
   */
  relationships?: Maybe<Array<Maybe<EntityRelationship>>>;
  /** The reporting status of the entity. If New Relic is successfully collecting data from your application, this will be true. */
  reporting?: Maybe<Scalars['Boolean']['output']>;
  /** The service level defined for the entity. */
  serviceLevel?: Maybe<ServiceLevelDefinition>;
  /** The list of summary metrics. */
  summaryMetrics?: Maybe<Array<Maybe<EntitySummaryMetric>>>;
  /**
   * The tags applied to the entity.
   *
   * For details on tags, as well as query and mutation examples, visit [our docs](https://docs.newrelic.com/docs/apis/graphql-api/tutorials/graphql-tagging-api-tutorial).
   */
  tags?: Maybe<Array<Maybe<EntityTag>>>;
  /** The tags applied to the entity with their metadata. */
  tagsWithMetadata?: Maybe<Array<Maybe<EntityTagWithMetadata>>>;
  /** Look up Distributed Tracing summary data for the selected `EntityGuid` */
  tracingSummary?: Maybe<DistributedTracingEntityTracingSummary>;
  /** The entity's type */
  type?: Maybe<Scalars['String']['output']>;
  /** List of templates availables for this entity. */
  uiTemplates?: Maybe<Array<EntityDashboardTemplatesUi>>;
};


/** An External entity. */
export type ExternalEntityAlertViolationsArgs = {
  endTime: Scalars['EpochMilliseconds']['input'];
  startTime: Scalars['EpochMilliseconds']['input'];
};


/** An External entity. */
export type ExternalEntityDeploymentSearchArgs = {
  filter?: InputMaybe<ChangeTrackingSearchFilter>;
};


/** An External entity. */
export type ExternalEntityGoldenMetricsArgs = {
  context?: InputMaybe<EntityGoldenContextInput>;
  timeWindow?: InputMaybe<EntityGoldenNrqlTimeWindowInput>;
};


/** An External entity. */
export type ExternalEntityGoldenSignalCorrelationsArgs = {
  filter?: InputMaybe<GoldenSignalCorrelationsEntityFilter>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  timeWindow?: InputMaybe<TimeWindowInput>;
};


/** An External entity. */
export type ExternalEntityGoldenSignalDeviationsArgs = {
  comparisonTimeWindow?: InputMaybe<TimeWindowInput>;
  evaluationTimeWindow?: InputMaybe<TimeWindowInput>;
};


/** An External entity. */
export type ExternalEntityGoldenSignalValuesArgs = {
  timeWindow?: InputMaybe<TimeWindowInput>;
};


/** An External entity. */
export type ExternalEntityGoldenSignalValuesV2Args = {
  timeWindow?: InputMaybe<TimeWindowInput>;
};


/** An External entity. */
export type ExternalEntityGoldenTagsArgs = {
  context?: InputMaybe<EntityGoldenContextInput>;
};


/** An External entity. */
export type ExternalEntityNerdStoreCollectionArgs = {
  collection: Scalars['String']['input'];
  scopeByActor?: InputMaybe<Scalars['Boolean']['input']>;
};


/** An External entity. */
export type ExternalEntityNerdStoreDocumentArgs = {
  collection: Scalars['String']['input'];
  documentId: Scalars['String']['input'];
  scopeByActor?: InputMaybe<Scalars['Boolean']['input']>;
};


/** An External entity. */
export type ExternalEntityNrdbQueryArgs = {
  async?: InputMaybe<Scalars['Boolean']['input']>;
  nrql: Scalars['Nrql']['input'];
  options?: InputMaybe<NrqlQueryOptions>;
  timeout?: InputMaybe<Scalars['Seconds']['input']>;
};


/** An External entity. */
export type ExternalEntityNrdbQueryProgressArgs = {
  queryId: Scalars['ID']['input'];
};


/** An External entity. */
export type ExternalEntityRecentAlertViolationsArgs = {
  count?: InputMaybe<Scalars['Int']['input']>;
};


/** An External entity. */
export type ExternalEntityRelatedEntitiesArgs = {
  cursor?: InputMaybe<Scalars['String']['input']>;
  filter?: InputMaybe<EntityRelationshipEdgeFilter>;
  limit?: InputMaybe<Scalars['Int']['input']>;
};


/** An External entity. */
export type ExternalEntityRelationshipTraversalArgs = {
  cursor?: InputMaybe<Scalars['String']['input']>;
  hopFilters?: InputMaybe<EntityRelationshipTraversalHopFilters>;
  hops?: InputMaybe<Scalars['Int']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
};


/** An External entity. */
export type ExternalEntityRelationshipsArgs = {
  endTime?: InputMaybe<Scalars['EpochMilliseconds']['input']>;
  filter?: InputMaybe<EntityRelationshipFilter>;
};


/** An External entity. */
export type ExternalEntitySummaryMetricsArgs = {
  timeWindow?: InputMaybe<TimeWindowInput>;
};


/** An External entity. */
export type ExternalEntityTracingSummaryArgs = {
  timeWindow?: InputMaybe<TimeWindowInput>;
};

/** An External entity outline. */
export type ExternalEntityOutline = AlertableEntityOutline & EntityOutline & {
  __typename?: 'ExternalEntityOutline';
  account?: Maybe<AccountOutline>;
  /** The New Relic account ID associated with this entity. */
  accountId?: Maybe<Scalars['Int']['output']>;
  /** The current alerting severity of the entity. */
  alertSeverity?: Maybe<EntityAlertSeverity>;
  /**
   * The alert status of the entity.
   * @deprecated Please use `alertSeverity` and `reporting`
   */
  alertStatus?: Maybe<EntityAlertStatus>;
  /** The entity's domain */
  domain?: Maybe<Scalars['String']['output']>;
  /** A value representing the combination of the entity's domain and type. */
  entityType?: Maybe<EntityType>;
  /** The date of last time the entity has updated any of its fields. */
  firstIndexedAt?: Maybe<Scalars['EpochMilliseconds']['output']>;
  /** The list of golden metrics for a specific entity */
  goldenMetrics?: Maybe<EntityGoldenContextScopedGoldenMetrics>;
  /**
   * For the golden signal on this entity, show correlated signals from related entities.
   * Well inspect the golden signals for all related entities and return a sorted list.
   * You can also filter the results.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  goldenSignalCorrelations?: Maybe<GoldenSignalCorrelationResult>;
  /**
   * The deviation from normal of golden signal(s) for the given entity.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  goldenSignalDeviations?: Maybe<Array<Maybe<GoldenSignalSignalDeviation>>>;
  /**
   * The stored golden signal(s) for the given entity.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  goldenSignalValues?: Maybe<GoldenSignalValues>;
  /**
   * The stored golden signal(s) for the given entity. To be removed, use goldenSignalValues instead.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  goldenSignalValuesV2?: Maybe<GoldenSignalValues>;
  /** The list of golden tags for a specific entityType. */
  goldenTags?: Maybe<EntityGoldenContextScopedGoldenTags>;
  /** A unique entity identifier. */
  guid?: Maybe<Scalars['EntityGuid']['output']>;
  /** The time the entity was indexed. */
  indexedAt?: Maybe<Scalars['EpochMilliseconds']['output']>;
  /** The last time the entity's reporting status changed. */
  lastReportingChangeAt?: Maybe<Scalars['EpochMilliseconds']['output']>;
  /** The name of this entity. */
  name?: Maybe<Scalars['String']['output']>;
  /** The url to the entity. */
  permalink?: Maybe<Scalars['String']['output']>;
  /** The recommended service levels for the entity. */
  recommendedServiceLevel?: Maybe<ServiceLevelRecommendation>;
  /** Related dashboards results */
  relatedDashboards: RelatedDashboardsRelatedDashboardResult;
  /** The reporting status of the entity. If New Relic is successfully collecting data from your application, this will be true. */
  reporting?: Maybe<Scalars['Boolean']['output']>;
  /** The service level defined for the entity. */
  serviceLevel?: Maybe<ServiceLevelDefinition>;
  /** The list of summary metrics. */
  summaryMetrics?: Maybe<Array<Maybe<EntitySummaryMetric>>>;
  /**
   * The tags applied to the entity.
   *
   * For details on tags, as well as query and mutation examples, visit [our docs](https://docs.newrelic.com/docs/apis/graphql-api/tutorials/graphql-tagging-api-tutorial).
   */
  tags?: Maybe<Array<Maybe<EntityTag>>>;
  /** The entity's type */
  type?: Maybe<Scalars['String']['output']>;
  /** List of templates availables for this entity. */
  uiTemplates?: Maybe<Array<EntityDashboardTemplatesUi>>;
};


/** An External entity outline. */
export type ExternalEntityOutlineGoldenMetricsArgs = {
  context?: InputMaybe<EntityGoldenContextInput>;
  timeWindow?: InputMaybe<EntityGoldenNrqlTimeWindowInput>;
};


/** An External entity outline. */
export type ExternalEntityOutlineGoldenSignalCorrelationsArgs = {
  filter?: InputMaybe<GoldenSignalCorrelationsEntityFilter>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  timeWindow?: InputMaybe<TimeWindowInput>;
};


/** An External entity outline. */
export type ExternalEntityOutlineGoldenSignalDeviationsArgs = {
  comparisonTimeWindow?: InputMaybe<TimeWindowInput>;
  evaluationTimeWindow?: InputMaybe<TimeWindowInput>;
};


/** An External entity outline. */
export type ExternalEntityOutlineGoldenSignalValuesArgs = {
  timeWindow?: InputMaybe<TimeWindowInput>;
};


/** An External entity outline. */
export type ExternalEntityOutlineGoldenSignalValuesV2Args = {
  timeWindow?: InputMaybe<TimeWindowInput>;
};


/** An External entity outline. */
export type ExternalEntityOutlineGoldenTagsArgs = {
  context?: InputMaybe<EntityGoldenContextInput>;
};


/** An External entity outline. */
export type ExternalEntityOutlineSummaryMetricsArgs = {
  timeWindow?: InputMaybe<TimeWindowInput>;
};

/** A single faceting criterion. You may supply either a `facet` or a `tag` value, but not both. */
export type FacetCriterion = {
  /** One of a list of possible entity search facets. */
  facet?: InputMaybe<EntitySearchCountsFacet>;
  /** An entity tag key on which to facet entity search results. */
  tag?: InputMaybe<Scalars['String']['input']>;
};

/**
 * Feature Flags will be evaluated against existing flags only. Querying a flag that
 * does not exist will not create the flag.
 *
 * To create a flag, please visit the Feature Flag UI
 */
export type FeatureFlag = {
  __typename?: 'FeatureFlag';
  context?: Maybe<Array<Maybe<FeatureFlagContext>>>;
  name?: Maybe<Scalars['String']['output']>;
  value?: Maybe<Scalars['Boolean']['output']>;
};

export enum FeatureFlagContext {
  Account = 'ACCOUNT',
  Criteria = 'CRITERIA',
  NrAdmin = 'NR_ADMIN',
  User = 'USER'
}

/** A generic entity. */
export type GenericEntity = AlertableEntity & Entity & {
  __typename?: 'GenericEntity';
  account?: Maybe<AccountOutline>;
  /** The New Relic account ID associated with this entity. */
  accountId?: Maybe<Scalars['Int']['output']>;
  /** The current alerting severity of the entity. */
  alertSeverity?: Maybe<EntityAlertSeverity>;
  /**
   * The alert status of the entity.
   * @deprecated Please use `alertSeverity` and `reporting`
   */
  alertStatus?: Maybe<EntityAlertStatus>;
  /** Violations on the entity that were open during the specified time window. This will return up to 500 violations - if there are more in the time window selected, you must narrow the time window or look at fewer entities. */
  alertViolations?: Maybe<Array<Maybe<EntityAlertViolation>>>;
  /** Retrieve the deployment event(s). Ordered by timestamp DESC. */
  deploymentSearch?: Maybe<ChangeTrackingDeploymentSearchResult>;
  /** The entity's domain */
  domain?: Maybe<Scalars['String']['output']>;
  /** A value representing the combination of the entity's domain and type. */
  entityType?: Maybe<EntityType>;
  /** The date of last time the entity has updated any of its fields. */
  firstIndexedAt?: Maybe<Scalars['EpochMilliseconds']['output']>;
  /** The list of golden metrics for a specific entity */
  goldenMetrics?: Maybe<EntityGoldenContextScopedGoldenMetrics>;
  /**
   * For the golden signal on this entity, show correlated signals from related entities.
   * Well inspect the golden signals for all related entities and return a sorted list.
   * You can also filter the results.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  goldenSignalCorrelations?: Maybe<GoldenSignalCorrelationResult>;
  /**
   * The deviation from normal of golden signal(s) for the given entity.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  goldenSignalDeviations?: Maybe<Array<Maybe<GoldenSignalSignalDeviation>>>;
  /**
   * The stored golden signal(s) for the given entity.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  goldenSignalValues?: Maybe<GoldenSignalValues>;
  /**
   * The stored golden signal(s) for the given entity. To be removed, use goldenSignalValues instead.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  goldenSignalValuesV2?: Maybe<GoldenSignalValues>;
  /** The list of golden tags for a specific entityType. */
  goldenTags?: Maybe<EntityGoldenContextScopedGoldenTags>;
  /** A unique entity identifier. */
  guid?: Maybe<Scalars['EntityGuid']['output']>;
  /** The time the entity was indexed. */
  indexedAt?: Maybe<Scalars['EpochMilliseconds']['output']>;
  /** The last time the entity's reporting status changed. */
  lastReportingChangeAt?: Maybe<Scalars['EpochMilliseconds']['output']>;
  /** The name of this entity. */
  name?: Maybe<Scalars['String']['output']>;
  nerdStorage?: Maybe<NerdStorageEntityScope>;
  nerdStoreCollection?: Maybe<Array<Maybe<NerdStoreCollectionMember>>>;
  nerdStoreDocument?: Maybe<Scalars['NerdStoreDocument']['output']>;
  /**
   * Make an `Entity` scoped query to NRDB with a NRQL string.
   *
   * A relevant `WHERE` clause will be added to your query to scope data to the entity in question.
   *
   * See the [NRQL Docs](https://docs.newrelic.com/docs/insights/nrql-new-relic-query-language/nrql-resources/nrql-syntax-components-functions) for more information about generating a query string.
   */
  nrdbQuery?: Maybe<NrdbResultContainer>;
  /**
   * Poll for the results of a previously-executed asychronous NRDB query.
   *
   * The `queryId` is available in the `queryProgress` data returned by the original asynchronous query.
   *
   * See [this page](https://docs.newrelic.com/docs/apis/nerdgraph/examples/async-queries-nrql-tutorial) for additional asynchronous query documentation.
   * @deprecated This field is experimental! It may change at any time.
   *
   */
  nrdbQueryProgress?: Maybe<NrdbResultContainer>;
  /** The url to the entity. */
  permalink?: Maybe<Scalars['String']['output']>;
  /** Recent violations on the entity. */
  recentAlertViolations?: Maybe<Array<Maybe<EntityAlertViolation>>>;
  /** The recommended service levels for the entity. */
  recommendedServiceLevel?: Maybe<ServiceLevelRecommendation>;
  /** Related dashboards results */
  relatedDashboards: RelatedDashboardsRelatedDashboardResult;
  /** Related entities result with optional filtering. */
  relatedEntities?: Maybe<EntityRelationshipRelatedEntitiesResult>;
  /** Relationship traversal results with optional filtering. WARNING: this query is still experimental, and subject to breaking changes. */
  relationshipTraversal?: Maybe<EntityRelationshipTraversalResult>;
  /**
   * A list of the entities' relationships.
   *
   * For more information, visit [our docs](https://docs.newrelic.com/docs/apis/graphql-api/tutorials/graphql-relationships-api-tutorial).
   * @deprecated This field is deprecated! Please use `relatedEntities`.
   */
  relationships?: Maybe<Array<Maybe<EntityRelationship>>>;
  /** The reporting status of the entity. If New Relic is successfully collecting data from your application, this will be true. */
  reporting?: Maybe<Scalars['Boolean']['output']>;
  /** The service level defined for the entity. */
  serviceLevel?: Maybe<ServiceLevelDefinition>;
  /** The list of summary metrics. */
  summaryMetrics?: Maybe<Array<Maybe<EntitySummaryMetric>>>;
  /**
   * The tags applied to the entity.
   *
   * For details on tags, as well as query and mutation examples, visit [our docs](https://docs.newrelic.com/docs/apis/graphql-api/tutorials/graphql-tagging-api-tutorial).
   */
  tags?: Maybe<Array<Maybe<EntityTag>>>;
  /** The tags applied to the entity with their metadata. */
  tagsWithMetadata?: Maybe<Array<Maybe<EntityTagWithMetadata>>>;
  /** Look up Distributed Tracing summary data for the selected `EntityGuid` */
  tracingSummary?: Maybe<DistributedTracingEntityTracingSummary>;
  /** The entity's type */
  type?: Maybe<Scalars['String']['output']>;
  /** List of templates availables for this entity. */
  uiTemplates?: Maybe<Array<EntityDashboardTemplatesUi>>;
};


/** A generic entity. */
export type GenericEntityAlertViolationsArgs = {
  endTime: Scalars['EpochMilliseconds']['input'];
  startTime: Scalars['EpochMilliseconds']['input'];
};


/** A generic entity. */
export type GenericEntityDeploymentSearchArgs = {
  filter?: InputMaybe<ChangeTrackingSearchFilter>;
};


/** A generic entity. */
export type GenericEntityGoldenMetricsArgs = {
  context?: InputMaybe<EntityGoldenContextInput>;
  timeWindow?: InputMaybe<EntityGoldenNrqlTimeWindowInput>;
};


/** A generic entity. */
export type GenericEntityGoldenSignalCorrelationsArgs = {
  filter?: InputMaybe<GoldenSignalCorrelationsEntityFilter>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  timeWindow?: InputMaybe<TimeWindowInput>;
};


/** A generic entity. */
export type GenericEntityGoldenSignalDeviationsArgs = {
  comparisonTimeWindow?: InputMaybe<TimeWindowInput>;
  evaluationTimeWindow?: InputMaybe<TimeWindowInput>;
};


/** A generic entity. */
export type GenericEntityGoldenSignalValuesArgs = {
  timeWindow?: InputMaybe<TimeWindowInput>;
};


/** A generic entity. */
export type GenericEntityGoldenSignalValuesV2Args = {
  timeWindow?: InputMaybe<TimeWindowInput>;
};


/** A generic entity. */
export type GenericEntityGoldenTagsArgs = {
  context?: InputMaybe<EntityGoldenContextInput>;
};


/** A generic entity. */
export type GenericEntityNerdStoreCollectionArgs = {
  collection: Scalars['String']['input'];
  scopeByActor?: InputMaybe<Scalars['Boolean']['input']>;
};


/** A generic entity. */
export type GenericEntityNerdStoreDocumentArgs = {
  collection: Scalars['String']['input'];
  documentId: Scalars['String']['input'];
  scopeByActor?: InputMaybe<Scalars['Boolean']['input']>;
};


/** A generic entity. */
export type GenericEntityNrdbQueryArgs = {
  async?: InputMaybe<Scalars['Boolean']['input']>;
  nrql: Scalars['Nrql']['input'];
  options?: InputMaybe<NrqlQueryOptions>;
  timeout?: InputMaybe<Scalars['Seconds']['input']>;
};


/** A generic entity. */
export type GenericEntityNrdbQueryProgressArgs = {
  queryId: Scalars['ID']['input'];
};


/** A generic entity. */
export type GenericEntityRecentAlertViolationsArgs = {
  count?: InputMaybe<Scalars['Int']['input']>;
};


/** A generic entity. */
export type GenericEntityRelatedEntitiesArgs = {
  cursor?: InputMaybe<Scalars['String']['input']>;
  filter?: InputMaybe<EntityRelationshipEdgeFilter>;
  limit?: InputMaybe<Scalars['Int']['input']>;
};


/** A generic entity. */
export type GenericEntityRelationshipTraversalArgs = {
  cursor?: InputMaybe<Scalars['String']['input']>;
  hopFilters?: InputMaybe<EntityRelationshipTraversalHopFilters>;
  hops?: InputMaybe<Scalars['Int']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
};


/** A generic entity. */
export type GenericEntityRelationshipsArgs = {
  endTime?: InputMaybe<Scalars['EpochMilliseconds']['input']>;
  filter?: InputMaybe<EntityRelationshipFilter>;
};


/** A generic entity. */
export type GenericEntitySummaryMetricsArgs = {
  timeWindow?: InputMaybe<TimeWindowInput>;
};


/** A generic entity. */
export type GenericEntityTracingSummaryArgs = {
  timeWindow?: InputMaybe<TimeWindowInput>;
};

/** A generic entity outline. */
export type GenericEntityOutline = AlertableEntityOutline & EntityOutline & {
  __typename?: 'GenericEntityOutline';
  account?: Maybe<AccountOutline>;
  /** The New Relic account ID associated with this entity. */
  accountId?: Maybe<Scalars['Int']['output']>;
  /** The current alerting severity of the entity. */
  alertSeverity?: Maybe<EntityAlertSeverity>;
  /**
   * The alert status of the entity.
   * @deprecated Please use `alertSeverity` and `reporting`
   */
  alertStatus?: Maybe<EntityAlertStatus>;
  /** The entity's domain */
  domain?: Maybe<Scalars['String']['output']>;
  /** A value representing the combination of the entity's domain and type. */
  entityType?: Maybe<EntityType>;
  /** The date of last time the entity has updated any of its fields. */
  firstIndexedAt?: Maybe<Scalars['EpochMilliseconds']['output']>;
  /** The list of golden metrics for a specific entity */
  goldenMetrics?: Maybe<EntityGoldenContextScopedGoldenMetrics>;
  /**
   * For the golden signal on this entity, show correlated signals from related entities.
   * Well inspect the golden signals for all related entities and return a sorted list.
   * You can also filter the results.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  goldenSignalCorrelations?: Maybe<GoldenSignalCorrelationResult>;
  /**
   * The deviation from normal of golden signal(s) for the given entity.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  goldenSignalDeviations?: Maybe<Array<Maybe<GoldenSignalSignalDeviation>>>;
  /**
   * The stored golden signal(s) for the given entity.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  goldenSignalValues?: Maybe<GoldenSignalValues>;
  /**
   * The stored golden signal(s) for the given entity. To be removed, use goldenSignalValues instead.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  goldenSignalValuesV2?: Maybe<GoldenSignalValues>;
  /** The list of golden tags for a specific entityType. */
  goldenTags?: Maybe<EntityGoldenContextScopedGoldenTags>;
  /** A unique entity identifier. */
  guid?: Maybe<Scalars['EntityGuid']['output']>;
  /** The time the entity was indexed. */
  indexedAt?: Maybe<Scalars['EpochMilliseconds']['output']>;
  /** The last time the entity's reporting status changed. */
  lastReportingChangeAt?: Maybe<Scalars['EpochMilliseconds']['output']>;
  /** The name of this entity. */
  name?: Maybe<Scalars['String']['output']>;
  /** The url to the entity. */
  permalink?: Maybe<Scalars['String']['output']>;
  /** The recommended service levels for the entity. */
  recommendedServiceLevel?: Maybe<ServiceLevelRecommendation>;
  /** Related dashboards results */
  relatedDashboards: RelatedDashboardsRelatedDashboardResult;
  /** The reporting status of the entity. If New Relic is successfully collecting data from your application, this will be true. */
  reporting?: Maybe<Scalars['Boolean']['output']>;
  /** The service level defined for the entity. */
  serviceLevel?: Maybe<ServiceLevelDefinition>;
  /** The list of summary metrics. */
  summaryMetrics?: Maybe<Array<Maybe<EntitySummaryMetric>>>;
  /**
   * The tags applied to the entity.
   *
   * For details on tags, as well as query and mutation examples, visit [our docs](https://docs.newrelic.com/docs/apis/graphql-api/tutorials/graphql-tagging-api-tutorial).
   */
  tags?: Maybe<Array<Maybe<EntityTag>>>;
  /** The entity's type */
  type?: Maybe<Scalars['String']['output']>;
  /** List of templates availables for this entity. */
  uiTemplates?: Maybe<Array<EntityDashboardTemplatesUi>>;
};


/** A generic entity outline. */
export type GenericEntityOutlineGoldenMetricsArgs = {
  context?: InputMaybe<EntityGoldenContextInput>;
  timeWindow?: InputMaybe<EntityGoldenNrqlTimeWindowInput>;
};


/** A generic entity outline. */
export type GenericEntityOutlineGoldenSignalCorrelationsArgs = {
  filter?: InputMaybe<GoldenSignalCorrelationsEntityFilter>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  timeWindow?: InputMaybe<TimeWindowInput>;
};


/** A generic entity outline. */
export type GenericEntityOutlineGoldenSignalDeviationsArgs = {
  comparisonTimeWindow?: InputMaybe<TimeWindowInput>;
  evaluationTimeWindow?: InputMaybe<TimeWindowInput>;
};


/** A generic entity outline. */
export type GenericEntityOutlineGoldenSignalValuesArgs = {
  timeWindow?: InputMaybe<TimeWindowInput>;
};


/** A generic entity outline. */
export type GenericEntityOutlineGoldenSignalValuesV2Args = {
  timeWindow?: InputMaybe<TimeWindowInput>;
};


/** A generic entity outline. */
export type GenericEntityOutlineGoldenTagsArgs = {
  context?: InputMaybe<EntityGoldenContextInput>;
};


/** A generic entity outline. */
export type GenericEntityOutlineSummaryMetricsArgs = {
  timeWindow?: InputMaybe<TimeWindowInput>;
};

/** An Infrastructure entity. */
export type GenericInfrastructureEntity = AlertableEntity & Entity & InfrastructureIntegrationEntity & {
  __typename?: 'GenericInfrastructureEntity';
  account?: Maybe<AccountOutline>;
  /** The New Relic account ID associated with this entity. */
  accountId?: Maybe<Scalars['Int']['output']>;
  /** The current alerting severity of the entity. */
  alertSeverity?: Maybe<EntityAlertSeverity>;
  /**
   * The alert status of the entity.
   * @deprecated Please use `alertSeverity` and `reporting`
   */
  alertStatus?: Maybe<EntityAlertStatus>;
  /** Violations on the entity that were open during the specified time window. This will return up to 500 violations - if there are more in the time window selected, you must narrow the time window or look at fewer entities. */
  alertViolations?: Maybe<Array<Maybe<EntityAlertViolation>>>;
  /** Retrieve the deployment event(s). Ordered by timestamp DESC. */
  deploymentSearch?: Maybe<ChangeTrackingDeploymentSearchResult>;
  /** The entity's domain */
  domain?: Maybe<Scalars['String']['output']>;
  /** A value representing the combination of the entity's domain and type. */
  entityType?: Maybe<EntityType>;
  /** The date of last time the entity has updated any of its fields. */
  firstIndexedAt?: Maybe<Scalars['EpochMilliseconds']['output']>;
  /** The list of golden metrics for a specific entity */
  goldenMetrics?: Maybe<EntityGoldenContextScopedGoldenMetrics>;
  /**
   * For the golden signal on this entity, show correlated signals from related entities.
   * Well inspect the golden signals for all related entities and return a sorted list.
   * You can also filter the results.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  goldenSignalCorrelations?: Maybe<GoldenSignalCorrelationResult>;
  /**
   * The deviation from normal of golden signal(s) for the given entity.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  goldenSignalDeviations?: Maybe<Array<Maybe<GoldenSignalSignalDeviation>>>;
  /**
   * The stored golden signal(s) for the given entity.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  goldenSignalValues?: Maybe<GoldenSignalValues>;
  /**
   * The stored golden signal(s) for the given entity. To be removed, use goldenSignalValues instead.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  goldenSignalValuesV2?: Maybe<GoldenSignalValues>;
  /** The list of golden tags for a specific entityType. */
  goldenTags?: Maybe<EntityGoldenContextScopedGoldenTags>;
  /** A unique entity identifier. */
  guid?: Maybe<Scalars['EntityGuid']['output']>;
  /** The time the entity was indexed. */
  indexedAt?: Maybe<Scalars['EpochMilliseconds']['output']>;
  integrationTypeCode?: Maybe<Scalars['String']['output']>;
  /** The last time the entity's reporting status changed. */
  lastReportingChangeAt?: Maybe<Scalars['EpochMilliseconds']['output']>;
  /** The name of this entity. */
  name?: Maybe<Scalars['String']['output']>;
  nerdStorage?: Maybe<NerdStorageEntityScope>;
  nerdStoreCollection?: Maybe<Array<Maybe<NerdStoreCollectionMember>>>;
  nerdStoreDocument?: Maybe<Scalars['NerdStoreDocument']['output']>;
  /**
   * Make an `Entity` scoped query to NRDB with a NRQL string.
   *
   * A relevant `WHERE` clause will be added to your query to scope data to the entity in question.
   *
   * See the [NRQL Docs](https://docs.newrelic.com/docs/insights/nrql-new-relic-query-language/nrql-resources/nrql-syntax-components-functions) for more information about generating a query string.
   */
  nrdbQuery?: Maybe<NrdbResultContainer>;
  /**
   * Poll for the results of a previously-executed asychronous NRDB query.
   *
   * The `queryId` is available in the `queryProgress` data returned by the original asynchronous query.
   *
   * See [this page](https://docs.newrelic.com/docs/apis/nerdgraph/examples/async-queries-nrql-tutorial) for additional asynchronous query documentation.
   * @deprecated This field is experimental! It may change at any time.
   *
   */
  nrdbQueryProgress?: Maybe<NrdbResultContainer>;
  /** The url to the entity. */
  permalink?: Maybe<Scalars['String']['output']>;
  /** Recent violations on the entity. */
  recentAlertViolations?: Maybe<Array<Maybe<EntityAlertViolation>>>;
  /** The recommended service levels for the entity. */
  recommendedServiceLevel?: Maybe<ServiceLevelRecommendation>;
  /** Related dashboards results */
  relatedDashboards: RelatedDashboardsRelatedDashboardResult;
  /** Related entities result with optional filtering. */
  relatedEntities?: Maybe<EntityRelationshipRelatedEntitiesResult>;
  /** Relationship traversal results with optional filtering. WARNING: this query is still experimental, and subject to breaking changes. */
  relationshipTraversal?: Maybe<EntityRelationshipTraversalResult>;
  /**
   * A list of the entities' relationships.
   *
   * For more information, visit [our docs](https://docs.newrelic.com/docs/apis/graphql-api/tutorials/graphql-relationships-api-tutorial).
   * @deprecated This field is deprecated! Please use `relatedEntities`.
   */
  relationships?: Maybe<Array<Maybe<EntityRelationship>>>;
  /** The reporting status of the entity. If New Relic is successfully collecting data from your application, this will be true. */
  reporting?: Maybe<Scalars['Boolean']['output']>;
  /** The service level defined for the entity. */
  serviceLevel?: Maybe<ServiceLevelDefinition>;
  /** The list of summary metrics. */
  summaryMetrics?: Maybe<Array<Maybe<EntitySummaryMetric>>>;
  /**
   * The tags applied to the entity.
   *
   * For details on tags, as well as query and mutation examples, visit [our docs](https://docs.newrelic.com/docs/apis/graphql-api/tutorials/graphql-tagging-api-tutorial).
   */
  tags?: Maybe<Array<Maybe<EntityTag>>>;
  /** The tags applied to the entity with their metadata. */
  tagsWithMetadata?: Maybe<Array<Maybe<EntityTagWithMetadata>>>;
  /** Look up Distributed Tracing summary data for the selected `EntityGuid` */
  tracingSummary?: Maybe<DistributedTracingEntityTracingSummary>;
  /** The entity's type */
  type?: Maybe<Scalars['String']['output']>;
  /** List of templates availables for this entity. */
  uiTemplates?: Maybe<Array<EntityDashboardTemplatesUi>>;
};


/** An Infrastructure entity. */
export type GenericInfrastructureEntityAlertViolationsArgs = {
  endTime: Scalars['EpochMilliseconds']['input'];
  startTime: Scalars['EpochMilliseconds']['input'];
};


/** An Infrastructure entity. */
export type GenericInfrastructureEntityDeploymentSearchArgs = {
  filter?: InputMaybe<ChangeTrackingSearchFilter>;
};


/** An Infrastructure entity. */
export type GenericInfrastructureEntityGoldenMetricsArgs = {
  context?: InputMaybe<EntityGoldenContextInput>;
  timeWindow?: InputMaybe<EntityGoldenNrqlTimeWindowInput>;
};


/** An Infrastructure entity. */
export type GenericInfrastructureEntityGoldenSignalCorrelationsArgs = {
  filter?: InputMaybe<GoldenSignalCorrelationsEntityFilter>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  timeWindow?: InputMaybe<TimeWindowInput>;
};


/** An Infrastructure entity. */
export type GenericInfrastructureEntityGoldenSignalDeviationsArgs = {
  comparisonTimeWindow?: InputMaybe<TimeWindowInput>;
  evaluationTimeWindow?: InputMaybe<TimeWindowInput>;
};


/** An Infrastructure entity. */
export type GenericInfrastructureEntityGoldenSignalValuesArgs = {
  timeWindow?: InputMaybe<TimeWindowInput>;
};


/** An Infrastructure entity. */
export type GenericInfrastructureEntityGoldenSignalValuesV2Args = {
  timeWindow?: InputMaybe<TimeWindowInput>;
};


/** An Infrastructure entity. */
export type GenericInfrastructureEntityGoldenTagsArgs = {
  context?: InputMaybe<EntityGoldenContextInput>;
};


/** An Infrastructure entity. */
export type GenericInfrastructureEntityNerdStoreCollectionArgs = {
  collection: Scalars['String']['input'];
  scopeByActor?: InputMaybe<Scalars['Boolean']['input']>;
};


/** An Infrastructure entity. */
export type GenericInfrastructureEntityNerdStoreDocumentArgs = {
  collection: Scalars['String']['input'];
  documentId: Scalars['String']['input'];
  scopeByActor?: InputMaybe<Scalars['Boolean']['input']>;
};


/** An Infrastructure entity. */
export type GenericInfrastructureEntityNrdbQueryArgs = {
  async?: InputMaybe<Scalars['Boolean']['input']>;
  nrql: Scalars['Nrql']['input'];
  options?: InputMaybe<NrqlQueryOptions>;
  timeout?: InputMaybe<Scalars['Seconds']['input']>;
};


/** An Infrastructure entity. */
export type GenericInfrastructureEntityNrdbQueryProgressArgs = {
  queryId: Scalars['ID']['input'];
};


/** An Infrastructure entity. */
export type GenericInfrastructureEntityRecentAlertViolationsArgs = {
  count?: InputMaybe<Scalars['Int']['input']>;
};


/** An Infrastructure entity. */
export type GenericInfrastructureEntityRelatedEntitiesArgs = {
  cursor?: InputMaybe<Scalars['String']['input']>;
  filter?: InputMaybe<EntityRelationshipEdgeFilter>;
  limit?: InputMaybe<Scalars['Int']['input']>;
};


/** An Infrastructure entity. */
export type GenericInfrastructureEntityRelationshipTraversalArgs = {
  cursor?: InputMaybe<Scalars['String']['input']>;
  hopFilters?: InputMaybe<EntityRelationshipTraversalHopFilters>;
  hops?: InputMaybe<Scalars['Int']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
};


/** An Infrastructure entity. */
export type GenericInfrastructureEntityRelationshipsArgs = {
  endTime?: InputMaybe<Scalars['EpochMilliseconds']['input']>;
  filter?: InputMaybe<EntityRelationshipFilter>;
};


/** An Infrastructure entity. */
export type GenericInfrastructureEntitySummaryMetricsArgs = {
  timeWindow?: InputMaybe<TimeWindowInput>;
};


/** An Infrastructure entity. */
export type GenericInfrastructureEntityTracingSummaryArgs = {
  timeWindow?: InputMaybe<TimeWindowInput>;
};

/** An Infrastructure entity outline. */
export type GenericInfrastructureEntityOutline = AlertableEntityOutline & EntityOutline & InfrastructureIntegrationEntityOutline & {
  __typename?: 'GenericInfrastructureEntityOutline';
  account?: Maybe<AccountOutline>;
  /** The New Relic account ID associated with this entity. */
  accountId?: Maybe<Scalars['Int']['output']>;
  /** The current alerting severity of the entity. */
  alertSeverity?: Maybe<EntityAlertSeverity>;
  /**
   * The alert status of the entity.
   * @deprecated Please use `alertSeverity` and `reporting`
   */
  alertStatus?: Maybe<EntityAlertStatus>;
  /** The entity's domain */
  domain?: Maybe<Scalars['String']['output']>;
  /** A value representing the combination of the entity's domain and type. */
  entityType?: Maybe<EntityType>;
  /** The date of last time the entity has updated any of its fields. */
  firstIndexedAt?: Maybe<Scalars['EpochMilliseconds']['output']>;
  /** The list of golden metrics for a specific entity */
  goldenMetrics?: Maybe<EntityGoldenContextScopedGoldenMetrics>;
  /**
   * For the golden signal on this entity, show correlated signals from related entities.
   * Well inspect the golden signals for all related entities and return a sorted list.
   * You can also filter the results.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  goldenSignalCorrelations?: Maybe<GoldenSignalCorrelationResult>;
  /**
   * The deviation from normal of golden signal(s) for the given entity.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  goldenSignalDeviations?: Maybe<Array<Maybe<GoldenSignalSignalDeviation>>>;
  /**
   * The stored golden signal(s) for the given entity.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  goldenSignalValues?: Maybe<GoldenSignalValues>;
  /**
   * The stored golden signal(s) for the given entity. To be removed, use goldenSignalValues instead.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  goldenSignalValuesV2?: Maybe<GoldenSignalValues>;
  /** The list of golden tags for a specific entityType. */
  goldenTags?: Maybe<EntityGoldenContextScopedGoldenTags>;
  /** A unique entity identifier. */
  guid?: Maybe<Scalars['EntityGuid']['output']>;
  /** The time the entity was indexed. */
  indexedAt?: Maybe<Scalars['EpochMilliseconds']['output']>;
  integrationTypeCode?: Maybe<Scalars['String']['output']>;
  /** The last time the entity's reporting status changed. */
  lastReportingChangeAt?: Maybe<Scalars['EpochMilliseconds']['output']>;
  /** The name of this entity. */
  name?: Maybe<Scalars['String']['output']>;
  /** The url to the entity. */
  permalink?: Maybe<Scalars['String']['output']>;
  /** The recommended service levels for the entity. */
  recommendedServiceLevel?: Maybe<ServiceLevelRecommendation>;
  /** Related dashboards results */
  relatedDashboards: RelatedDashboardsRelatedDashboardResult;
  /** The reporting status of the entity. If New Relic is successfully collecting data from your application, this will be true. */
  reporting?: Maybe<Scalars['Boolean']['output']>;
  /** The service level defined for the entity. */
  serviceLevel?: Maybe<ServiceLevelDefinition>;
  /** The list of summary metrics. */
  summaryMetrics?: Maybe<Array<Maybe<EntitySummaryMetric>>>;
  /**
   * The tags applied to the entity.
   *
   * For details on tags, as well as query and mutation examples, visit [our docs](https://docs.newrelic.com/docs/apis/graphql-api/tutorials/graphql-tagging-api-tutorial).
   */
  tags?: Maybe<Array<Maybe<EntityTag>>>;
  /** The entity's type */
  type?: Maybe<Scalars['String']['output']>;
  /** List of templates availables for this entity. */
  uiTemplates?: Maybe<Array<EntityDashboardTemplatesUi>>;
};


/** An Infrastructure entity outline. */
export type GenericInfrastructureEntityOutlineGoldenMetricsArgs = {
  context?: InputMaybe<EntityGoldenContextInput>;
  timeWindow?: InputMaybe<EntityGoldenNrqlTimeWindowInput>;
};


/** An Infrastructure entity outline. */
export type GenericInfrastructureEntityOutlineGoldenSignalCorrelationsArgs = {
  filter?: InputMaybe<GoldenSignalCorrelationsEntityFilter>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  timeWindow?: InputMaybe<TimeWindowInput>;
};


/** An Infrastructure entity outline. */
export type GenericInfrastructureEntityOutlineGoldenSignalDeviationsArgs = {
  comparisonTimeWindow?: InputMaybe<TimeWindowInput>;
  evaluationTimeWindow?: InputMaybe<TimeWindowInput>;
};


/** An Infrastructure entity outline. */
export type GenericInfrastructureEntityOutlineGoldenSignalValuesArgs = {
  timeWindow?: InputMaybe<TimeWindowInput>;
};


/** An Infrastructure entity outline. */
export type GenericInfrastructureEntityOutlineGoldenSignalValuesV2Args = {
  timeWindow?: InputMaybe<TimeWindowInput>;
};


/** An Infrastructure entity outline. */
export type GenericInfrastructureEntityOutlineGoldenTagsArgs = {
  context?: InputMaybe<EntityGoldenContextInput>;
};


/** An Infrastructure entity outline. */
export type GenericInfrastructureEntityOutlineSummaryMetricsArgs = {
  timeWindow?: InputMaybe<TimeWindowInput>;
};

/** A type that encapsulates what is stitched into the actor */
export type GoldenMetricsSearchActorStitchedFields = {
  __typename?: 'GoldenMetricsSearchActorStitchedFields';
  /**
   * Filters and sorts entities based on a golden metric index
   * @deprecated This field is experimental and subject to breaking changes.
   */
  entitiesWithMetricsSearch: GoldenMetricsSearchResult;
};


/** A type that encapsulates what is stitched into the actor */
export type GoldenMetricsSearchActorStitchedFieldsEntitiesWithMetricsSearchArgs = {
  cursor?: InputMaybe<Scalars['String']['input']>;
  entityType: DomainTypeInput;
  filters: Array<GoldenMetricsSearchFilterInput>;
  query: Scalars['EntitySearchQuery']['input'];
  sortBy: GoldenMetricsSearchSortInput;
  timeWindow: TimeWindowInput;
};

/** An entity matching golden index query with corresponding metrics */
export type GoldenMetricsSearchEntityWithMetricValues = {
  __typename?: 'GoldenMetricsSearchEntityWithMetricValues';
  /**
   * The entity matching the golden index query
   * @deprecated This field is experimental and subject to breaking changes.
   */
  entity: EntityOutline;
  /**
   * A list of metrics, with their values, corresponding to the metric filter
   * @deprecated This field is experimental and subject to breaking changes.
   */
  metricValues: Array<GoldenMetricsSearchGoldenMetricValue>;
};

/** Filter to apply to the entity golden index query */
export type GoldenMetricsSearchFilterInput = {
  /** Golden metric aggregation */
  aggregation: Scalars['String']['input'];
  /** Golden metric name */
  name: Scalars['String']['input'];
  /** Filter operator */
  operator: GoldenMetricsSearchFilterOperator;
  /** Golden metric value */
  value: Scalars['Float']['input'];
};

/** Operator to apply to a golden index filter */
export enum GoldenMetricsSearchFilterOperator {
  /**
   * Greater than
   * @deprecated This field is experimental and subject to breaking changes.
   */
  Gt = 'GT',
  /**
   * Greater than or equal
   * @deprecated This field is experimental and subject to breaking changes.
   */
  Gte = 'GTE',
  /**
   * Less than
   * @deprecated This field is experimental and subject to breaking changes.
   */
  Lt = 'LT',
  /**
   * Less than or equal
   * @deprecated This field is experimental and subject to breaking changes.
   */
  Lte = 'LTE'
}

/** Matching metric returned by golden index */
export type GoldenMetricsSearchGoldenMetricValue = {
  __typename?: 'GoldenMetricsSearchGoldenMetricValue';
  /**
   * Golden index metric name
   * @deprecated This field is experimental and subject to breaking changes.
   */
  name: Scalars['String']['output'];
  /**
   * Golden index metric value
   * @deprecated This field is experimental and subject to breaking changes.
   */
  value: Scalars['Float']['output'];
};

/** Result of the golden index query */
export type GoldenMetricsSearchResult = {
  __typename?: 'GoldenMetricsSearchResult';
  /**
   * Pagination cursor
   * @deprecated This field is experimental and subject to breaking changes.
   */
  nextCursor?: Maybe<Scalars['String']['output']>;
  /**
   * Golden index results
   * @deprecated This field is experimental and subject to breaking changes.
   */
  results: Array<Maybe<GoldenMetricsSearchEntityWithMetricValues>>;
  /**
   * Total count of query results
   * @deprecated This field is experimental and subject to breaking changes.
   */
  totalCount: Scalars['Int']['output'];
};

/** Sort to apply to entity golden index query */
export type GoldenMetricsSearchSortInput = {
  /** Sort direction, either ascending or descending */
  direction: SortBy;
  /** Golden metric name to sort by */
  name: Scalars['String']['input'];
};

/** The result of a golden signal correlation computation. */
export type GoldenSignalCorrelationResult = {
  __typename?: 'GoldenSignalCorrelationResult';
  /**
   * The permalink to view these correlations in Lookout Go Fish
   * @deprecated This field is experimental and subject to breaking changes.
   */
  goFishPermalink?: Maybe<Scalars['String']['output']>;
  /**
   * The list of correlation results.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  results?: Maybe<Array<Maybe<GoldenSignalCorrelationResultEntry>>>;
  /**
   * The status of the correlation computation.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  status?: Maybe<GoldenSignalCorrelationResultStatus>;
};

/**
 * A single correlation result. It identifies the pair of entities, the golden signals,
 * and the correlation score between them.
 */
export type GoldenSignalCorrelationResultEntry = {
  __typename?: 'GoldenSignalCorrelationResultEntry';
  /**
   * The normalized correlation score.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  correlationScore?: Maybe<Scalars['Float']['output']>;
  /**
   * The relationship between the source and target entities.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  relationship?: Maybe<GoldenSignalEntityRelationshipDescriptor>;
  /**
   * The source entity of the relationship. This is always the entity driving the computation.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  source?: Maybe<GoldenSignalGoldenSignalSource>;
  /**
   * The target entity of the relationship. This is always a different entity.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  target?: Maybe<GoldenSignalGoldenSignalSource>;
};

/** The status of a correlation computation. */
export enum GoldenSignalCorrelationResultStatus {
  /**
   * We couldn't complete the computation because there are no related entities.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  NoEntities = 'NO_ENTITIES',
  /**
   * We executed the computation successfully.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  Ok = 'OK'
}

/** How we filter the data. */
export type GoldenSignalCorrelationsEntityFilter = {
  /** Filter by the absolute value of the correlation score (example: 0.8). */
  correlationScore?: InputMaybe<Scalars['Float']['input']>;
  /** Filter by the name of the golden metric (example: "responseTimeMs"). Case-insensitive. */
  metricName?: InputMaybe<Scalars['String']['input']>;
  /** Filter by the type of entity relationship (example: "HOSTS"). Case-insensitive. */
  relationshipType?: InputMaybe<Scalars['String']['input']>;
};

/** A Golden Metric for an entity. */
export type GoldenSignalEntityGoldenMetric = {
  __typename?: 'GoldenSignalEntityGoldenMetric';
  /**
   * The fully qualified signal name.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  fullyQualifiedSignalName?: Maybe<Scalars['String']['output']>;
  /**
   * The synthesised metric name. i.e: newrelic.goldenmetrics.apm.application.throughput.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  metricName?: Maybe<Scalars['String']['output']>;
  /**
   * The name of the golden metric.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  name?: Maybe<Scalars['String']['output']>;
  /**
   * The title of the golden metric.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  title?: Maybe<Scalars['String']['output']>;
  /**
   * The unit used to represent the golden metric.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  unit?: Maybe<Scalars['String']['output']>;
};

/** Describes the nature of a relationship between entities. */
export type GoldenSignalEntityRelationshipDescriptor = {
  __typename?: 'GoldenSignalEntityRelationshipDescriptor';
  /**
   * The direction of the relationship.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  direction?: Maybe<GoldenSignalEntityRelationshipDirection>;
  /**
   * The type of the relationship.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  type?: Maybe<Scalars['String']['output']>;
};

/** Describes the direction of a relationship between entities. */
export enum GoldenSignalEntityRelationshipDirection {
  /**
   * The relationship is from the source entity to the target entity.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  SourceToTarget = 'SOURCE_TO_TARGET',
  /**
   * The relationship is from the target entity to the source entity.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  TargetToSource = 'TARGET_TO_SOURCE'
}

/** Identifies the Golden Signal source, i.e. the entity plus the Golden Metric. */
export type GoldenSignalGoldenSignalSource = {
  __typename?: 'GoldenSignalGoldenSignalSource';
  /**
   * The entity producing the Golden Signal.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  entity?: Maybe<EntityOutline>;
  /**
   * The Golden Metric being produced.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  goldenMetric?: Maybe<GoldenSignalEntityGoldenMetric>;
  /**
   * The golden metric NRQL query.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  query?: Maybe<Scalars['String']['output']>;
};

/** The deviation from normal of golden signal(s) for the given entity, along with some supplimental calculations. */
export type GoldenSignalSignalDeviation = {
  __typename?: 'GoldenSignalSignalDeviation';
  /**
   * The Lookout anomaly score. Currently, close to the normalized deviation of the evaluation window against the comparison window.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  anomalyScore?: Maybe<Scalars['Float']['output']>;
  /**
   * Mean value of the golden signal during the comparison time window.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  comparisonMean?: Maybe<Scalars['Float']['output']>;
  /**
   * Standard deviation of the golden signal during the comparison time window.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  comparisonStandardDeviation?: Maybe<Scalars['Float']['output']>;
  /**
   * Mean value of the golden signal during the evaluation time window.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  evaluationMean?: Maybe<Scalars['Float']['output']>;
  /**
   * The fully qualified signal name.
   * @deprecated Use `goldenMetric` instead
   */
  fullyQualifiedSignalName?: Maybe<Scalars['String']['output']>;
  /**
   * The Golden Metric being produced.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  goldenMetric?: Maybe<GoldenSignalEntityGoldenMetric>;
  /**
   * The name of the golden signal.
   * @deprecated Use `goldenMetric` instead
   */
  name?: Maybe<Scalars['String']['output']>;
  /**
   * Percent change from the comparison to the evaluation window. The value is a percentage and will always be positive.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  percentChange?: Maybe<Scalars['Float']['output']>;
  /**
   * Whether or not this deviation is conclusive. In either case an analysis was successfully executed, but the results
   * may have been deemed meaningless due the nature of the data, calculation, or for other reasons.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  status?: Maybe<GoldenSignalSignalDeviationStatus>;
  /**
   * Units of the values, when applicable.
   * @deprecated Use `goldenMetric` instead
   */
  units?: Maybe<Scalars['String']['output']>;
};

/** The status of a SignalDeviation computation. */
export enum GoldenSignalSignalDeviationStatus {
  /**
   * The result is conclusive, and MAY be used
   * @deprecated This field is experimental and subject to breaking changes.
   */
  Conclusive = 'CONCLUSIVE',
  /**
   * The result is inconclusive, and SHOULD NOT be used. There may still be associated values with the SignalDeviation,
   * but the analysis has deemed any result have been deemed meaningless due the nature of the data, calculation, or for
   * other reasons.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  Inconclusive = 'INCONCLUSIVE',
  /**
   * The result could not be calculated or has partial results due to a lack of underlying data.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  MissingData = 'MISSING_DATA'
}

/** Individual signal data. Contains a timeseries, summary over the query, and metadata. */
export type GoldenSignalSignalValues = {
  __typename?: 'GoldenSignalSignalValues';
  /**
   * The fully qualified signal name.
   * @deprecated Use `goldenMetric` instead
   */
  fullyQualifiedSignalName?: Maybe<Scalars['String']['output']>;
  /**
   * The Golden Metric being produced.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  goldenMetric?: Maybe<GoldenSignalEntityGoldenMetric>;
  /**
   * The name of the golden signal.
   * @deprecated Use `goldenMetric` instead
   */
  name?: Maybe<Scalars['String']['output']>;
  /**
   * The aggregate value of the Golden Signal over the entire requested time window.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  summaryValue?: Maybe<Scalars['Float']['output']>;
  /**
   * Units of the values.
   * @deprecated Use `goldenMetric` instead
   */
  units?: Maybe<Scalars['String']['output']>;
  /**
   * The signal timeseries values. They correspond to the timeIndex.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  values?: Maybe<Array<Maybe<Scalars['Float']['output']>>>;
};

/** Response type for Golden Signal Service (buffer) data. */
export type GoldenSignalValues = {
  __typename?: 'GoldenSignalValues';
  /**
   * The list of signals which have data for the requested entity.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  signalValues?: Maybe<Array<GoldenSignalSignalValues>>;
  /**
   * The list of timestamps corresponding to all signal timeseries values.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  timeIndex?: Maybe<Array<Scalars['EpochMilliseconds']['output']>>;
};

/** Fields related to Grok feedbacks for a specific actor */
export type GrokActorStitchedFields = {
  __typename?: 'GrokActorStitchedFields';
  /**
   * Find Grok feedbacks by conversation IDs
   * @deprecated This field is experimental and subject to breaking changes.
   */
  feedbackByConversationId?: Maybe<GrokFeedbacks>;
  /**
   * Find Grok feedbacks by message IDs
   * @deprecated This field is experimental and subject to breaking changes.
   */
  feedbackByMessageIds?: Maybe<Array<Maybe<GrokFeedback>>>;
};


/** Fields related to Grok feedbacks for a specific actor */
export type GrokActorStitchedFieldsFeedbackByConversationIdArgs = {
  conversationId: Scalars['ID']['input'];
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  nextCursor?: InputMaybe<Scalars['String']['input']>;
  prevCursor?: InputMaybe<Scalars['String']['input']>;
};


/** Fields related to Grok feedbacks for a specific actor */
export type GrokActorStitchedFieldsFeedbackByMessageIdsArgs = {
  messageIds: Array<InputMaybe<Scalars['ID']['input']>>;
};

/** Assistant configuration options */
export type GrokAssistantConfigInput = {
  /** Name of the configuration */
  name: Scalars['String']['input'];
  /** Configuration value */
  value: Scalars['String']['input'];
};

/** Represents user feedback on Grok platform */
export type GrokFeedback = {
  __typename?: 'GrokFeedback';
  /**
   * Account ID of the user providing feedback
   * @deprecated This field is experimental and subject to breaking changes.
   */
  accountId: Scalars['Int']['output'];
  /**
   * Capability ID where the user was providing feedback
   * @deprecated This field is experimental and subject to breaking changes.
   */
  capabilityId?: Maybe<Scalars['ID']['output']>;
  /**
   * Conversation ID receiving the feedback
   * @deprecated This field is experimental and subject to breaking changes.
   */
  conversationId: Scalars['ID']['output'];
  /**
   * Timestamp when the feedback was created
   * @deprecated This field is experimental and subject to breaking changes.
   */
  createdAt: Scalars['EpochMilliseconds']['output'];
  /**
   * Creator ID of the user providing feedback
   * @deprecated This field is experimental and subject to breaking changes.
   */
  creatorId: Scalars['ID']['output'];
  /**
   * Unique identifier of the feedback
   * @deprecated This field is experimental and subject to breaking changes.
   */
  id: Scalars['ID']['output'];
  /**
   * Message ID receiving the feedback
   * @deprecated This field is experimental and subject to breaking changes.
   */
  messageId: Scalars['ID']['output'];
  /**
   * Nerdlet ID the user was using
   * @deprecated This field is experimental and subject to breaking changes.
   */
  nerdletId?: Maybe<Scalars['String']['output']>;
  /**
   * Organization ID of the user providing feedback
   * @deprecated This field is experimental and subject to breaking changes.
   */
  organizationId: Scalars['ID']['output'];
  /**
   * Sentiment of the feedback (positive or negative)
   * @deprecated This field is experimental and subject to breaking changes.
   */
  sentiment: Scalars['Boolean']['output'];
  /**
   * Categories representing the reasons for the feedback
   * @deprecated This field is experimental and subject to breaking changes.
   */
  sentimentCategories?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
  /**
   * Additional details provided with the feedback
   * @deprecated This field is experimental and subject to breaking changes.
   */
  sentimentDetail?: Maybe<Scalars['String']['output']>;
};

/** Paginated result object for Grok feedbacks */
export type GrokFeedbacks = {
  __typename?: 'GrokFeedbacks';
  /**
   * Indicates if there is a next page available
   * @deprecated This field is experimental and subject to breaking changes.
   */
  hasNextPage?: Maybe<Scalars['Boolean']['output']>;
  /**
   * Indicates if there is a previous page available
   * @deprecated This field is experimental and subject to breaking changes.
   */
  hasPreviousPage?: Maybe<Scalars['Boolean']['output']>;
  /**
   * Next cursor to paginate by
   * @deprecated This field is experimental and subject to breaking changes.
   */
  nextCursor?: Maybe<Scalars['String']['output']>;
  /**
   * Previous cursor to paginate by
   * @deprecated This field is experimental and subject to breaking changes.
   */
  prevCursor?: Maybe<Scalars['String']['output']>;
  /**
   * Array of feedbacks
   * @deprecated This field is experimental and subject to breaking changes.
   */
  results?: Maybe<Array<Maybe<GrokFeedback>>>;
  /**
   * Total amount of results
   * @deprecated This field is experimental and subject to breaking changes.
   */
  totalCount?: Maybe<Scalars['Int']['output']>;
};

/** Prompt creating return type */
export type GrokGrokPrompt = {
  __typename?: 'GrokGrokPrompt';
  /**
   * Prompt creation id
   * @deprecated This field is experimental and subject to breaking changes.
   */
  id: Scalars['ID']['output'];
};

export type HistoricalDataExportAccountStitchedFields = {
  __typename?: 'HistoricalDataExportAccountStitchedFields';
  /** Retrieve a single export by export id */
  export?: Maybe<HistoricalDataExportCustomerExportResponse>;
  /** Retrieve all exports for an account */
  exports?: Maybe<Array<HistoricalDataExportCustomerExportResponse>>;
};


export type HistoricalDataExportAccountStitchedFieldsExportArgs = {
  id: Scalars['ID']['input'];
};

/** A Historic Export. Contains information about the request and the current status of that request. */
export type HistoricalDataExportCustomerExportResponse = {
  __typename?: 'HistoricalDataExportCustomerExportResponse';
  /** The id of the account whose data the Export will run against */
  account?: Maybe<AccountReference>;
  /** The time at which the results of this Export expire and are no longer available. Null values indicate that the export is not ready and does not have an expiration time yet */
  availableUntil?: Maybe<Scalars['EpochMilliseconds']['output']>;
  /** The beginning of the time range of this Export. Determined from the Query String */
  beginTime: Scalars['EpochMilliseconds']['output'];
  /** The time at which the Export Request was created */
  createdAt: Scalars['EpochMilliseconds']['output'];
  /** The end of the time range of this Export. Determined from the Query String */
  endTime: Scalars['EpochMilliseconds']['output'];
  /** The number of events returned by this Export */
  eventCount: Scalars['Int']['output'];
  /** The event types that the Export will run against. Determined from the Query String */
  eventTypes: Array<Scalars['String']['output']>;
  /** The autogenerated query to get the created export */
  exportStatusQuery: Scalars['String']['output'];
  /** The number of files retrieved for this Export */
  fileCount: Scalars['Int']['output'];
  /** Unique Identifier for the Export */
  id: Scalars['ID']['output'];
  /** The more specific internal status, intended only for internal use */
  internalStatus: HistoricalDataExportInternalStatus;
  /** If relevant, an error message about the status of the current export */
  message?: Maybe<Scalars['String']['output']>;
  /** The NRQL query for which this Export will run */
  nrql: Scalars['Nrql']['output'];
  /** The current completion percentage of this Export */
  percentComplete: Scalars['Float']['output'];
  /** A list of urls to download the resulting files. Null values indicate that result files are not yet ready for download */
  results?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
  /** The current status of this Export */
  status: HistoricalDataExportStatus;
  /**
   * The time at which the Export Request was submitted
   * @deprecated submittedAt is deprecated. Use createdAt instead.
   */
  submittedAt: Scalars['EpochMilliseconds']['output'];
  /** The last time the status of the export was updated */
  updatedAt: Scalars['EpochMilliseconds']['output'];
  /** The ID of the user who submitted this Export Request */
  user?: Maybe<UserReference>;
};

/** The internal status of an export, for engineering team use only */
export enum HistoricalDataExportInternalStatus {
  /** Waiting for response from bundle query worker */
  AwaitingInterimResults = 'AWAITING_INTERIM_RESULTS',
  /** Export Canceled */
  Canceled = 'CANCELED',
  /** Export completed successfully */
  Complete = 'COMPLETE',
  /** Export Request Successful, export created */
  Created = 'CREATED',
  /** Export failed */
  Failed = 'FAILED',
  /** Determined which cells are part of this export */
  FetchedCells = 'FETCHED_CELLS',
  /** File Bundling Complete */
  FilesBundled = 'FILES_BUNDLED',
  /** Currently in File Bundling Step */
  FilesBundling = 'FILES_BUNDLING',
  /** Waiting on finalizer to complete the export */
  FinalizingResults = 'FINALIZING_RESULTS',
  /** Received response from bundle query worker */
  ReceivedInterimResults = 'RECEIVED_INTERIM_RESULTS'
}

/** Customer-facing status of an export */
export enum HistoricalDataExportStatus {
  /** Export Canceled */
  Canceled = 'CANCELED',
  /** Export Failed */
  CompleteFailed = 'COMPLETE_FAILED',
  /** Export Successful */
  CompleteSuccess = 'COMPLETE_SUCCESS',
  /** Export in progress */
  InProgress = 'IN_PROGRESS',
  /** Unknown Status of this Export */
  Unknown = 'UNKNOWN',
  /** Export waiting to start */
  Waiting = 'WAITING'
}

export type IncidentIntelligenceEnvironmentAccountStitchedFields = {
  __typename?: 'IncidentIntelligenceEnvironmentAccountStitchedFields';
  /** Retrieves the incident intelligence environment based on the user's authentication and product entitlement */
  currentEnvironment?: Maybe<IncidentIntelligenceEnvironmentCurrentEnvironmentResult>;
};


export type IncidentIntelligenceEnvironmentAccountStitchedFieldsCurrentEnvironmentArgs = {
  kind?: InputMaybe<IncidentIntelligenceEnvironmentSupportedEnvironmentKind>;
};

export type IncidentIntelligenceEnvironmentActorStitchedFields = {
  __typename?: 'IncidentIntelligenceEnvironmentActorStitchedFields';
  /** A list of potential environments is returned based on the authorized accounts list */
  authorizedEnvironments?: Maybe<Array<IncidentIntelligenceEnvironmentIncidentIntelligenceEnvironment>>;
  /** Retrieves a list of authorized accounts the user is authorized for that have been marked with consent by an admin of that account. */
  consentedAccounts?: Maybe<Array<IncidentIntelligenceEnvironmentConsentedAccount>>;
  /** Retrieves the incident intelligence environment based on the user's authentication and product entitlement, if an account id is not provided, the environment is detected based on the authorized accounts.In cases where a user have more then one potential environment, the account must be provided. */
  currentEnvironment?: Maybe<IncidentIntelligenceEnvironmentCurrentEnvironmentResult>;
};


export type IncidentIntelligenceEnvironmentActorStitchedFieldsAuthorizedEnvironmentsArgs = {
  kind?: InputMaybe<IncidentIntelligenceEnvironmentSupportedEnvironmentKind>;
};


export type IncidentIntelligenceEnvironmentActorStitchedFieldsCurrentEnvironmentArgs = {
  kind?: InputMaybe<IncidentIntelligenceEnvironmentSupportedEnvironmentKind>;
};

/** Consent accounts to usage of the Incident Intelligence product for EU or FedRAMP */
export type IncidentIntelligenceEnvironmentConsentAccounts = {
  __typename?: 'IncidentIntelligenceEnvironmentConsentAccounts';
  /** The list of accounts marked with consent */
  consentedAccounts?: Maybe<Array<IncidentIntelligenceEnvironmentConsentedAccount>>;
  /** The outcome of the consent marking */
  result: IncidentIntelligenceEnvironmentConsentAccountsResult;
};

/** Result options for account consent marking */
export enum IncidentIntelligenceEnvironmentConsentAccountsResult {
  /** All of the accounts have been already marked with consent */
  AlreadyConsented = 'ALREADY_CONSENTED',
  /** Accounts were consented */
  Consented = 'CONSENTED',
  /** The user is not authorized to consent due to a missing capability */
  UserNotAuthorizedMissingCapability = 'USER_NOT_AUTHORIZED_MISSING_CAPABILITY'
}

/** Consent all the user's authorized accounts for the Incident Intelligence product for EU or FedRAMP */
export type IncidentIntelligenceEnvironmentConsentAuthorizedAccounts = {
  __typename?: 'IncidentIntelligenceEnvironmentConsentAuthorizedAccounts';
  /** The list of accounts marked with consent */
  consentedAccounts?: Maybe<Array<IncidentIntelligenceEnvironmentConsentedAccount>>;
  /** The outcome of the consent marking */
  result: IncidentIntelligenceEnvironmentConsentAccountsResult;
};

/** Represent an account that is mark with consent for Incident Intelligence usage */
export type IncidentIntelligenceEnvironmentConsentedAccount = {
  __typename?: 'IncidentIntelligenceEnvironmentConsentedAccount';
  /** The account marked with consent */
  account?: Maybe<AccountReference>;
};

/**
 * Creates a new Incident Intelligence Environment,
 * will fail if an environment is already attached to the same parent account
 */
export type IncidentIntelligenceEnvironmentCreateEnvironment = {
  __typename?: 'IncidentIntelligenceEnvironmentCreateEnvironment';
  /**
   * The created environment
   * @deprecated Environment moved to the result details field
   */
  environment?: Maybe<IncidentIntelligenceEnvironmentIncidentIntelligenceEnvironment>;
  /** The outcome of the creation */
  result: IncidentIntelligenceEnvironmentCreateEnvironmentResult;
  /** Additional result details */
  resultDetails?: Maybe<IncidentIntelligenceEnvironmentCreateEnvironmentResultDetails>;
};

/** Result options for environment creation */
export enum IncidentIntelligenceEnvironmentCreateEnvironmentResult {
  /** The specified associated accounts are already associated to other environments */
  AccountsAlreadyAssociated = 'ACCOUNTS_ALREADY_ASSOCIATED',
  /** The account is not marked with consent for environment creation */
  AccountNotConsented = 'ACCOUNT_NOT_CONSENTED',
  /** The account is not entitled to incident intelligence */
  AccountNotEntitled = 'ACCOUNT_NOT_ENTITLED',
  /** Action not allowed, please contact support */
  ActionUnauthorized = 'ACTION_UNAUTHORIZED',
  /** The environment already exists and cannot be created again for the same parent account id tree */
  AlreadyExists = 'ALREADY_EXISTS',
  /** The specified associated accounts are not authorized to the user */
  AssociatedAccountsNotAuthorized = 'ASSOCIATED_ACCOUNTS_NOT_AUTHORIZED',
  /** The environment was created successfully */
  Created = 'CREATED',
  /** The user is not authorized to create an environment */
  UserNotAuthorized = 'USER_NOT_AUTHORIZED',
  /** The user is not authorized to create the environment due to a missing capability */
  UserNotAuthorizedMissingCapability = 'USER_NOT_AUTHORIZED_MISSING_CAPABILITY'
}

/** Result details union */
export type IncidentIntelligenceEnvironmentCreateEnvironmentResultDetails = IncidentIntelligenceEnvironmentEnvironmentAlreadyExists | IncidentIntelligenceEnvironmentEnvironmentCreated;

/** An environment will be populated only if the user is attached to a single environment. */
export type IncidentIntelligenceEnvironmentCurrentEnvironmentResult = {
  __typename?: 'IncidentIntelligenceEnvironmentCurrentEnvironmentResult';
  /** The current environment attached to the user */
  environment?: Maybe<IncidentIntelligenceEnvironmentIncidentIntelligenceEnvironment>;
  /** The explanation for the environment field result */
  reason?: Maybe<IncidentIntelligenceEnvironmentCurrentEnvironmentResultReason>;
  /** The current environment result details */
  reasonDetails?: Maybe<IncidentIntelligenceEnvironmentCurrentEnvironmentResultReasonDetails>;
};

/** Current environment result reasoning */
export enum IncidentIntelligenceEnvironmentCurrentEnvironmentResultReason {
  /** The current account is not entitled for incident intelligence */
  CurrentAccountNotEntitled = 'CURRENT_ACCOUNT_NOT_ENTITLED',
  /** The user is attached to an environment */
  EnvironmentFound = 'ENVIRONMENT_FOUND',
  /** The user is attached to more than one environment, hence the user is authorized to more then one parent account that has an environment. To get a list of possible environments, query authorizedEnvironment and select one of the accounts. */
  MultipleEnvironments = 'MULTIPLE_ENVIRONMENTS',
  /** The user is not attached to any environment */
  NoEnvironment = 'NO_ENVIRONMENT',
  /** The user is not authorized to access environments from the current account */
  UserNotAuthorizedForAccount = 'USER_NOT_AUTHORIZED_FOR_ACCOUNT'
}

/** Reason details union */
export type IncidentIntelligenceEnvironmentCurrentEnvironmentResultReasonDetails = IncidentIntelligenceEnvironmentMultipleEnvironmentsAvailable | IncidentIntelligenceEnvironmentUserNotAuthorizedForAccount | IncidentIntelligenceEnvironmentUserNotCapableToOperateOnAccount;

/** Deletes an existing environment */
export type IncidentIntelligenceEnvironmentDeleteEnvironment = {
  __typename?: 'IncidentIntelligenceEnvironmentDeleteEnvironment';
  /** The deletion outcome */
  result: IncidentIntelligenceEnvironmentDeleteEnvironmentResult;
};

/** Result options for environment deletion */
export enum IncidentIntelligenceEnvironmentDeleteEnvironmentResult {
  /** The account is not entitled to incident intelligence */
  AccountNotEntitled = 'ACCOUNT_NOT_ENTITLED',
  /** The environment was deleted successfully */
  Deleted = 'DELETED',
  /** The environment does not exists and cannot be deleted */
  DoesNotExist = 'DOES_NOT_EXIST',
  /** The user is not authorized to delete an environment */
  UserNotAuthorized = 'USER_NOT_AUTHORIZED',
  /** The user is not authorized to delete the environment due to a missing capability */
  UserNotAuthorizedMissingCapability = 'USER_NOT_AUTHORIZED_MISSING_CAPABILITY'
}

/** Dissent accounts to usage of the Incident Intelligence product in the EU/FedRAMP (removes the consent marking). */
export type IncidentIntelligenceEnvironmentDissentAccounts = {
  __typename?: 'IncidentIntelligenceEnvironmentDissentAccounts';
  /** The list of previously consented accounts, now dissented */
  dissentedAccounts?: Maybe<Array<IncidentIntelligenceEnvironmentConsentedAccount>>;
  /** The outcome of the dissent marking */
  result: IncidentIntelligenceEnvironmentDissentAccountsResult;
};

/** Result options for account consent marking */
export enum IncidentIntelligenceEnvironmentDissentAccountsResult {
  /** There are no accounts authorized by the user that are consented for Incident Intelligence usage */
  ConsentedAccountsNotFound = 'CONSENTED_ACCOUNTS_NOT_FOUND',
  /** Accounts were dissented */
  Dissented = 'DISSENTED',
  /** The user is not authorized to dissent due to a missing capability */
  UserNotAuthorizedMissingCapability = 'USER_NOT_AUTHORIZED_MISSING_CAPABILITY'
}

/** Environment already exists detailed result */
export type IncidentIntelligenceEnvironmentEnvironmentAlreadyExists = {
  __typename?: 'IncidentIntelligenceEnvironmentEnvironmentAlreadyExists';
  /** The account id of the already exists environment */
  accountId: Scalars['Int']['output'];
  /** The already exists environment */
  environment: IncidentIntelligenceEnvironmentIncidentIntelligenceEnvironment;
  /** The parent account id of the already exists environment */
  masterAccountId: Scalars['Int']['output'];
};

/** Environment created detailed result */
export type IncidentIntelligenceEnvironmentEnvironmentCreated = {
  __typename?: 'IncidentIntelligenceEnvironmentEnvironmentCreated';
  /** The created environment */
  environment: IncidentIntelligenceEnvironmentIncidentIntelligenceEnvironment;
};

/** Incident Intelligence environment kinds */
export enum IncidentIntelligenceEnvironmentEnvironmentKind {
  /** The environment can contain more than one account so that cross-account correlation between accounts is supported */
  CrossAccountEnvironment = 'CROSS_ACCOUNT_ENVIRONMENT',
  /** The environment only contains a single account */
  SingleAccountEnvironment = 'SINGLE_ACCOUNT_ENVIRONMENT'
}

/**
 * Represents an AI Incident Intelligence environment. An environment crosses the account boundary and allows
 * correlating data as long as the data's accounts are attached to the same environment.
 */
export type IncidentIntelligenceEnvironmentIncidentIntelligenceEnvironment = {
  __typename?: 'IncidentIntelligenceEnvironmentIncidentIntelligenceEnvironment';
  /** Authorized accounts associated with the environment. Events from these accounts can be correlated with one another (across the account boundary). The resulting correlated issue will be stored in the Incident Intelligence account */
  associatedAuthorizedAccounts: Array<Maybe<AccountReference>>;
  /** The assigned quota on the current billing cycle */
  billingCycleQuota?: Maybe<Scalars['Int']['output']>;
  /** When the environment was created */
  createdAt?: Maybe<Scalars['EpochMilliseconds']['output']>;
  /** The user that created the environment */
  createdBy?: Maybe<UserReference>;
  /** The account attached to the environment */
  incidentIntelligenceAccount?: Maybe<AccountReference>;
  /** True indicates that a consent has to be asked when an environment is created. The consent is to acknowledge that if the account is overaging an additional usage charge may be charged based on extra usage */
  isConsentRequired: Scalars['Boolean']['output'];
  /** Whether the environment is entitled for AI */
  isEntitledForAi?: Maybe<Scalars['Boolean']['output']>;
  /** True if the environment is part of the free-tier package */
  isFreeTier: Scalars['Boolean']['output'];
  /** The environment kind */
  kind?: Maybe<IncidentIntelligenceEnvironmentEnvironmentKind>;
  /** The parent account related to the environment */
  masterAccount?: Maybe<AccountReference>;
  /** The environment name */
  name?: Maybe<Scalars['String']['output']>;
  /** True if the environment was consented, false otherwise */
  wasConsented: Scalars['Boolean']['output'];
};

/** The user has access to more than one environment from the context of this account (only one is allowed) */
export type IncidentIntelligenceEnvironmentMultipleEnvironmentsAvailable = {
  __typename?: 'IncidentIntelligenceEnvironmentMultipleEnvironmentsAvailable';
  /** The multiple accounts the user has access to in this context */
  accountIds?: Maybe<Array<Maybe<Scalars['Int']['output']>>>;
};

/** Which environment kinds the request will provide */
export enum IncidentIntelligenceEnvironmentSupportedEnvironmentKind {
  /** Will return environments that are cross account (based on the parent-account and sub-account) */
  CrossAccount = 'CROSS_ACCOUNT',
  /** Will return environments that are cross account (based on the parent-account and sub-account) and single accounts */
  SingleAndCrossAccount = 'SINGLE_AND_CROSS_ACCOUNT'
}

/** The user is not authorized for this account */
export type IncidentIntelligenceEnvironmentUserNotAuthorizedForAccount = {
  __typename?: 'IncidentIntelligenceEnvironmentUserNotAuthorizedForAccount';
  /** The account id the user is not authorized to receive an environment for */
  accountId: Scalars['Int']['output'];
};

/** The user is not capable to perform an operation on this account */
export type IncidentIntelligenceEnvironmentUserNotCapableToOperateOnAccount = {
  __typename?: 'IncidentIntelligenceEnvironmentUserNotCapableToOperateOnAccount';
  /** The account id the user is not capable to perform the operation on */
  accountId?: Maybe<Scalars['Int']['output']>;
  /** The capability the user is missing */
  capability: Scalars['String']['output'];
};

export type IncidentIntelligenceIssueAccountStitchedFields = {
  __typename?: 'IncidentIntelligenceIssueAccountStitchedFields';
  /**
   * Incident query response
   * @deprecated This field is experimental and subject to breaking changes.
   */
  incidents?: Maybe<IncidentIntelligenceIssueIncidentsResponse>;
  /**
   * Issue query response
   * @deprecated This field is experimental and subject to breaking changes.
   */
  issues?: Maybe<IncidentIntelligenceIssueIssuesResponse>;
};


export type IncidentIntelligenceIssueAccountStitchedFieldsIncidentsArgs = {
  cursor?: InputMaybe<Scalars['String']['input']>;
  filters?: InputMaybe<Array<InputMaybe<IncidentIntelligenceIssueIncidentFilter>>>;
  incidentId?: InputMaybe<Scalars['String']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  numberOfEvents?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Scalars['String']['input']>;
  viewKind?: InputMaybe<IncidentIntelligenceIssueIncidentViewKind>;
};


export type IncidentIntelligenceIssueAccountStitchedFieldsIssuesArgs = {
  cursor?: InputMaybe<Scalars['String']['input']>;
  filters?: InputMaybe<Array<InputMaybe<IncidentIntelligenceIssueIssueFilter>>>;
  issueId?: InputMaybe<Scalars['String']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Scalars['String']['input']>;
};

/** The accumulation name & value pair for an Incident */
export type IncidentIntelligenceIssueAccumulationPair = {
  __typename?: 'IncidentIntelligenceIssueAccumulationPair';
  /**
   * Accumulation name
   * @deprecated This field is experimental and subject to breaking changes.
   */
  accumulationName: Scalars['String']['output'];
  /**
   * Accumulation value
   * @deprecated This field is experimental and subject to breaking changes.
   */
  value?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
};

/** An attribute name and value pair */
export type IncidentIntelligenceIssueAttributesPair = {
  __typename?: 'IncidentIntelligenceIssueAttributesPair';
  /**
   * Name of the attribute
   * @deprecated This field is experimental and subject to breaking changes.
   */
  attributeName: Scalars['String']['output'];
  /**
   * The attribute's value
   * @deprecated This field is experimental and subject to breaking changes.
   */
  value?: Maybe<Scalars['String']['output']>;
};

/** Filter rule operators */
export enum IncidentIntelligenceIssueFilterOperators {
  /**
   * Equals
   * @deprecated This field is experimental and subject to breaking changes.
   */
  Equals = 'EQUALS',
  /**
   * Greater than
   * @deprecated This field is experimental and subject to breaking changes.
   */
  GreaterThan = 'GREATER_THAN',
  /**
   * Greater than or equal
   * @deprecated This field is experimental and subject to breaking changes.
   */
  GreaterThanEquals = 'GREATER_THAN_EQUALS',
  /**
   * Check if the string is contained within a json list
   * @deprecated This field is experimental and subject to breaking changes.
   */
  JsonContains = 'JSON_CONTAINS',
  /**
   * Less than
   * @deprecated This field is experimental and subject to breaking changes.
   */
  LessThan = 'LESS_THAN',
  /**
   * Less than or equal
   * @deprecated This field is experimental and subject to breaking changes.
   */
  LessThanEquals = 'LESS_THAN_EQUALS',
  /**
   * Not equals
   * @deprecated This field is experimental and subject to breaking changes.
   */
  NotEquals = 'NOT_EQUALS'
}

/** An NRAI Incident */
export type IncidentIntelligenceIssueIncident = {
  __typename?: 'IncidentIntelligenceIssueIncident';
  /**
   * The account the Incident is related to
   * @deprecated This field is experimental and subject to breaking changes.
   */
  accountId: Scalars['Int']['output'];
  /**
   * The Incident's accumulations
   * @deprecated This field is experimental and subject to breaking changes.
   */
  accumulations?: Maybe<Array<Maybe<IncidentIntelligenceIssueAccumulationPair>>>;
  /**
   * The Incident's annotations
   * @deprecated This field is experimental and subject to breaking changes.
   */
  annotations?: Maybe<IncidentIntelligenceIssueIncidentAnnotations>;
  /**
   * The date the Incident was closed (null if the Incident is still open
   * @deprecated This field is experimental and subject to breaking changes.
   */
  closedOn?: Maybe<Scalars['DateTime']['output']>;
  /**
   * The date the Incident was created
   * @deprecated This field is experimental and subject to breaking changes.
   */
  createdOn: Scalars['DateTime']['output'];
  /**
   * The Incident's description
   * @deprecated This field is experimental and subject to breaking changes.
   */
  description?: Maybe<Scalars['String']['output']>;
  /**
   * A list of the Incident's events (length can be configured with numberOfEvents)
   * @deprecated This field is experimental and subject to breaking changes.
   */
  events?: Maybe<Array<Maybe<IncidentIntelligenceIssueIncidentEvent>>>;
  /**
   * The Incident's id
   * @deprecated This field is experimental and subject to breaking changes.
   */
  id: Scalars['ID']['output'];
  /**
   * True if the issue regarding the Incident is correlated, otherwise False
   * @deprecated This field is experimental and subject to breaking changes.
   */
  isCorrelated?: Maybe<Scalars['Boolean']['output']>;
  /**
   * A list of the Incident's labels
   * @deprecated This field is experimental and subject to breaking changes.
   */
  labels?: Maybe<Array<Maybe<IncidentIntelligenceIssueIncidentLabelPair>>>;
  /**
   * The id of the latest issue the Incident is related to
   * @deprecated This field is experimental and subject to breaking changes.
   */
  latestIssueId?: Maybe<Scalars['ID']['output']>;
  /**
   * The name of the latest issue the Incident is related to
   * @deprecated This field is experimental and subject to breaking changes.
   */
  latestIssueName?: Maybe<Scalars['String']['output']>;
  /**
   * The progress report of the latest issue the Incident is related to
   * @deprecated This field is experimental and subject to breaking changes.
   */
  latestIssueProgressReport?: Maybe<Array<Maybe<IncidentIntelligenceIssueIssueProgressReportAction>>>;
  /**
   * The state of the latest issue the Incident is related to
   * @deprecated This field is experimental and subject to breaking changes.
   */
  latestIssueState?: Maybe<IncidentIntelligenceIssueIssueState>;
  /**
   * The date the Incident was last modified
   * @deprecated This field is experimental and subject to breaking changes.
   */
  modifiedOn: Scalars['DateTime']['output'];
  /**
   * The Incident's name
   * @deprecated This field is experimental and subject to breaking changes.
   */
  name?: Maybe<Scalars['String']['output']>;
  /**
   * The Incident's priority
   * @deprecated This field is experimental and subject to breaking changes.
   */
  priority: IncidentIntelligenceIssuePriority;
  /**
   * The id of the rule from which the Incident was created
   * @deprecated This field is experimental and subject to breaking changes.
   */
  ruleId: Scalars['String']['output'];
  /**
   * The state of the Incident
   * @deprecated This field is experimental and subject to breaking changes.
   */
  state: IncidentIntelligenceIssueIncidentState;
  /**
   * A list of the Incident's tags
   * @deprecated This field is experimental and subject to breaking changes.
   */
  tags?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
  /**
   * The total number of events an Incident has
   * @deprecated This field is experimental and subject to breaking changes.
   */
  totalEvents: Scalars['Int']['output'];
};

/** The annotations of an Incident */
export type IncidentIntelligenceIssueIncidentAnnotations = {
  __typename?: 'IncidentIntelligenceIssueIncidentAnnotations';
  /**
   * The Incidents' description
   * @deprecated This field is experimental and subject to breaking changes.
   */
  description: Scalars['String']['output'];
  /**
   * The Incidents' title
   * @deprecated This field is experimental and subject to breaking changes.
   */
  title: Scalars['String']['output'];
};

/** An event of an Incident */
export type IncidentIntelligenceIssueIncidentEvent = {
  __typename?: 'IncidentIntelligenceIssueIncidentEvent';
  /**
   * Event attributes
   * @deprecated This field is experimental and subject to breaking changes.
   */
  attributes: Array<Maybe<IncidentIntelligenceIssueAttributesPair>>;
  /**
   * Name of event
   * @deprecated This field is experimental and subject to breaking changes.
   */
  name: Scalars['String']['output'];
  /**
   * Event text
   * @deprecated This field is experimental and subject to breaking changes.
   */
  text: Scalars['String']['output'];
  /**
   * Event timestamp
   * @deprecated This field is experimental and subject to breaking changes.
   */
  timestamp: Scalars['Float']['output'];
  /**
   * Event type
   * @deprecated This field is experimental and subject to breaking changes.
   */
  type: Scalars['String']['output'];
};

/** A filter for the Incidents query */
export type IncidentIntelligenceIssueIncidentFilter = {
  /** Incident field to filter by */
  field: IncidentIntelligenceIssueIncidentFilterFields;
  /** Comparison operator to match field type */
  operator: IncidentIntelligenceIssueFilterOperators;
  /** A single value for the operator to match */
  value?: InputMaybe<Scalars['IncidentIntelligenceIssueFilterValue']['input']>;
  /** A list of values for the operator to match */
  values?: InputMaybe<Array<InputMaybe<Scalars['IncidentIntelligenceIssueFilterValue']['input']>>>;
};

/** The fields a user can use as a filter */
export enum IncidentIntelligenceIssueIncidentFilterFields {
  /**
   * The id of the account that the Incident is related to
   * @deprecated This field is experimental and subject to breaking changes.
   */
  AccountId = 'ACCOUNT_ID',
  /**
   * The time the Incident was closed
   * @deprecated This field is experimental and subject to breaking changes.
   */
  ClosedOn = 'CLOSED_ON',
  /**
   * The time the Incident was created
   * @deprecated This field is experimental and subject to breaking changes.
   */
  CreatedOn = 'CREATED_ON',
  /**
   * The time the Incident was last modified
   * @deprecated This field is experimental and subject to breaking changes.
   */
  ModifiedOn = 'MODIFIED_ON',
  /**
   * The priority of the Incident
   * @deprecated This field is experimental and subject to breaking changes.
   */
  Priority = 'PRIORITY',
  /**
   * The id of the rule from which the Incident was created
   * @deprecated This field is experimental and subject to breaking changes.
   */
  RuleId = 'RULE_ID',
  /**
   * The state of the Incident
   * @deprecated This field is experimental and subject to breaking changes.
   */
  State = 'STATE'
}

/** The labels name & value pair for an Incident */
export type IncidentIntelligenceIssueIncidentLabelPair = {
  __typename?: 'IncidentIntelligenceIssueIncidentLabelPair';
  /**
   * Name of the label
   * @deprecated This field is experimental and subject to breaking changes.
   */
  labelName: Scalars['String']['output'];
  /**
   * The label's value
   * @deprecated This field is experimental and subject to breaking changes.
   */
  value?: Maybe<Scalars['String']['output']>;
};

/** Options for the state of an Incident */
export enum IncidentIntelligenceIssueIncidentState {
  /**
   * The incident was closed
   * @deprecated This field is experimental and subject to breaking changes.
   */
  Closed = 'CLOSED',
  /**
   * The incident is currently open
   * @deprecated This field is experimental and subject to breaking changes.
   */
  Open = 'OPEN'
}

/** The format type of the Incident */
export enum IncidentIntelligenceIssueIncidentViewKind {
  /**
   * Extended view (includes fields relating the issue)
   * @deprecated This field is experimental and subject to breaking changes.
   */
  Extended = 'EXTENDED',
  /**
   * Regular view
   * @deprecated This field is experimental and subject to breaking changes.
   */
  Regular = 'REGULAR'
}

/** Result options for fetching an Incident */
export enum IncidentIntelligenceIssueIncidentsReason {
  /**
   * An invalid Filter was given
   * @deprecated This field is experimental and subject to breaking changes.
   */
  InvalidFilter = 'INVALID_FILTER',
  /**
   * Invalid UUID string in id
   * @deprecated This field is experimental and subject to breaking changes.
   */
  InvalidId = 'INVALID_ID',
  /**
   * Limit can not be less than 1
   * @deprecated This field is experimental and subject to breaking changes.
   */
  LimitIsLessThanOne = 'LIMIT_IS_LESS_THAN_ONE',
  /**
   * The user is missing some capabilities
   * @deprecated This field is experimental and subject to breaking changes.
   */
  MissingCapabilities = 'MISSING_CAPABILITIES',
  /**
   * Did not find any incidents that match the query
   * @deprecated This field is experimental and subject to breaking changes.
   */
  NoIncidentsFound = 'NO_INCIDENTS_FOUND',
  /**
   * NumberOfEvents can not be less than 1
   * @deprecated This field is experimental and subject to breaking changes.
   */
  NumberOfEventsIsLessThanOne = 'NUMBER_OF_EVENTS_IS_LESS_THAN_ONE',
  /**
   * Query successfully retrieved
   * @deprecated This field is experimental and subject to breaking changes.
   */
  Success = 'SUCCESS'
}

/** Incident query response */
export type IncidentIntelligenceIssueIncidentsResponse = {
  __typename?: 'IncidentIntelligenceIssueIncidentsResponse';
  /**
   * The number of incidents returned
   * @deprecated This field is experimental and subject to breaking changes.
   */
  count?: Maybe<Scalars['Int']['output']>;
  /**
   * The cursor returned from the pagination
   * @deprecated This field is experimental and subject to breaking changes.
   */
  cursor?: Maybe<Scalars['String']['output']>;
  /**
   * Result of Incidents fetch
   * @deprecated This field is experimental and subject to breaking changes.
   */
  reason: IncidentIntelligenceIssueIncidentsReason;
  /**
   * The list of Incidents queried
   * @deprecated This field is experimental and subject to breaking changes.
   */
  results?: Maybe<Array<Maybe<IncidentIntelligenceIssueIncident>>>;
  /**
   * A list of the required capabilities that the user is missing
   * @deprecated This field is experimental and subject to breaking changes.
   */
  userMissingCapabilities?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
};

/** A New Relic AI Issue */
export type IncidentIntelligenceIssueIssue = {
  __typename?: 'IncidentIntelligenceIssueIssue';
  /**
   * The id of the account that the Issue is related to
   * @deprecated This field is experimental and subject to breaking changes.
   */
  accountId: Scalars['Int']['output'];
  /**
   * A list of the Issue's accumulations
   * @deprecated This field is experimental and subject to breaking changes.
   */
  accumulations?: Maybe<Array<Maybe<IncidentIntelligenceIssueAccumulationPair>>>;
  /**
   * The time the Issue was activated
   * @deprecated This field is experimental and subject to breaking changes.
   */
  activeSince?: Maybe<Scalars['DateTime']['output']>;
  /**
   * The annotations of the Issue
   * @deprecated This field is experimental and subject to breaking changes.
   */
  annotations?: Maybe<IncidentIntelligenceIssueIssueAnnotation>;
  /**
   * The time the Issue was closed
   * @deprecated This field is experimental and subject to breaking changes.
   */
  closedOn?: Maybe<Scalars['DateTime']['output']>;
  /**
   * The reason the the Issue was closed
   * @deprecated This field is experimental and subject to breaking changes.
   */
  closingReason?: Maybe<IncidentIntelligenceIssueIssueClosingReason>;
  /**
   * The AI that the correlated incidents are related
   * @deprecated This field is experimental and subject to breaking changes.
   */
  confidence?: Maybe<Scalars['Float']['output']>;
  /**
   * The time the Issue was created
   * @deprecated This field is experimental and subject to breaking changes.
   */
  createdOn: Scalars['DateTime']['output'];
  /**
   * The description of the Issue
   * @deprecated This field is experimental and subject to breaking changes.
   */
  description?: Maybe<Scalars['String']['output']>;
  /**
   * The id of the Issue
   * @deprecated This field is experimental and subject to breaking changes.
   */
  id: Scalars['ID']['output'];
  /**
   * The number of Incidents related to this Issue
   * @deprecated This field is experimental and subject to breaking changes.
   */
  incidentCount?: Maybe<Scalars['Int']['output']>;
  /**
   * The IDs of the Incidents related to the Issue
   * @deprecated This field is experimental and subject to breaking changes.
   */
  incidentIds: Array<Maybe<Scalars['String']['output']>>;
  /**
   * True if the Issue was correlated
   * @deprecated This field is experimental and subject to breaking changes.
   */
  isCorrelated?: Maybe<Scalars['Boolean']['output']>;
  /**
   * The labels of the Issues' Incidents
   * @deprecated This field is experimental and subject to breaking changes.
   */
  labelsSet?: Maybe<Array<Maybe<Array<Maybe<IncidentIntelligenceIssueIncidentLabelPair>>>>>;
  /**
   * The time the Issue was last modified
   * @deprecated This field is experimental and subject to breaking changes.
   */
  modifiedOn: Scalars['DateTime']['output'];
  /**
   * The IDs of the pathways this Issue matched
   * @deprecated This field is experimental and subject to breaking changes.
   */
  pathways?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
  /**
   * The previous state of the Issue
   * @deprecated This field is experimental and subject to breaking changes.
   */
  previousState?: Maybe<IncidentIntelligenceIssueIssueState>;
  /**
   * The priority of the Issue
   * @deprecated This field is experimental and subject to breaking changes.
   */
  priority?: Maybe<IncidentIntelligenceIssuePriority>;
  /**
   * A list creating the Issues' progress report
   * @deprecated This field is experimental and subject to breaking changes.
   */
  progressReport?: Maybe<Array<Maybe<IncidentIntelligenceIssueIssueProgressReportAction>>>;
  /**
   * The id of the rule from which the Issue was created
   * @deprecated This field is experimental and subject to breaking changes.
   */
  ruleId?: Maybe<Scalars['String']['output']>;
  /**
   * All the sources of all the Incidents in this Issue
   * @deprecated This field is experimental and subject to breaking changes.
   */
  sources?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
  /**
   * The state of the issue
   * @deprecated This field is experimental and subject to breaking changes.
   */
  state: IncidentIntelligenceIssueIssueState;
  /**
   * A list of the Issue's tags
   * @deprecated This field is experimental and subject to breaking changes.
   */
  tags?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
};

/** The origin of the action */
export enum IncidentIntelligenceIssueIssueActionOriginType {
  /**
   * system
   * @deprecated This field is experimental and subject to breaking changes.
   */
  System = 'SYSTEM',
  /**
   * user
   * @deprecated This field is experimental and subject to breaking changes.
   */
  User = 'USER'
}

/** The annotations of an Issue */
export type IncidentIntelligenceIssueIssueAnnotation = {
  __typename?: 'IncidentIntelligenceIssueIssueAnnotation';
  /**
   * A description of the Issue
   * @deprecated This field is experimental and subject to breaking changes.
   */
  description: Scalars['String']['output'];
  /**
   * The latest date on of the Incidents related to the Issue was modified
   * @deprecated This field is experimental and subject to breaking changes.
   */
  incidentsMaxModifiedOn?: Maybe<Scalars['DateTime']['output']>;
  /**
   * False if this Issue is a child of a different Issue
   * @deprecated This field is experimental and subject to breaking changes.
   */
  isRootIssue?: Maybe<Scalars['Boolean']['output']>;
  /**
   * The title of the Issue
   * @deprecated This field is experimental and subject to breaking changes.
   */
  title: Scalars['String']['output'];
};

/** The closing reason of an Issue */
export enum IncidentIntelligenceIssueIssueClosingReason {
  /**
   * The issue wasn't acknowledged
   * @deprecated This field is experimental and subject to breaking changes.
   */
  NotAcked = 'NOT_ACKED',
  /**
   * The issue is resolved
   * @deprecated This field is experimental and subject to breaking changes.
   */
  Resolved = 'RESOLVED',
  /**
   * The issue was automatically closed by the system
   * @deprecated This field is experimental and subject to breaking changes.
   */
  System = 'SYSTEM'
}

/** A filter for the Issues query */
export type IncidentIntelligenceIssueIssueFilter = {
  /** Issue field to filter by */
  field: IncidentIntelligenceIssueIssueFilterFields;
  /** comparison operator to match field type */
  operator: IncidentIntelligenceIssueFilterOperators;
  /** A single value for the operator to match */
  value?: InputMaybe<Scalars['IncidentIntelligenceIssueFilterValue']['input']>;
  /** A list of values for the operator to match */
  values?: InputMaybe<Array<InputMaybe<Scalars['IncidentIntelligenceIssueFilterValue']['input']>>>;
};

/** The fields a user can use as a filter */
export enum IncidentIntelligenceIssueIssueFilterFields {
  /**
   * The id of the account that the Issue is related to
   * @deprecated This field is experimental and subject to breaking changes.
   */
  AccountId = 'ACCOUNT_ID',
  /**
   * The time the Issue was activated
   * @deprecated This field is experimental and subject to breaking changes.
   */
  ActiveSince = 'ACTIVE_SINCE',
  /**
   * The time the Issue was closed
   * @deprecated This field is experimental and subject to breaking changes.
   */
  ClosedOn = 'CLOSED_ON',
  /**
   * The reason the the Issue was closed
   * @deprecated This field is experimental and subject to breaking changes.
   */
  ClosingReason = 'CLOSING_REASON',
  /**
   * The time the Issue was created
   * @deprecated This field is experimental and subject to breaking changes.
   */
  CreatedOn = 'CREATED_ON',
  /**
   * The time the Issue was last modified
   * @deprecated This field is experimental and subject to breaking changes.
   */
  ModifiedOn = 'MODIFIED_ON',
  /**
   * The previous state of the Issue
   * @deprecated This field is experimental and subject to breaking changes.
   */
  PreviousState = 'PREVIOUS_STATE',
  /**
   * The priority of the Issue
   * @deprecated This field is experimental and subject to breaking changes.
   */
  Priority = 'PRIORITY',
  /**
   * The id of the rule from which the Issue was created
   * @deprecated This field is experimental and subject to breaking changes.
   */
  RuleId = 'RULE_ID',
  /**
   * The state of the issue
   * @deprecated This field is experimental and subject to breaking changes.
   */
  State = 'STATE'
}

/** An action in the Progress Report of an Issue */
export type IncidentIntelligenceIssueIssueProgressReportAction = {
  __typename?: 'IncidentIntelligenceIssueIssueProgressReportAction';
  /**
   * Timestamp for when the action invoked
   * @deprecated This field is experimental and subject to breaking changes.
   */
  actionTimestamp: Scalars['Float']['output'];
  /**
   * Attributes for the action
   * @deprecated This field is experimental and subject to breaking changes.
   */
  attributes?: Maybe<Array<Maybe<IncidentIntelligenceIssueAttributesPair>>>;
  /**
   * The type of event
   * @deprecated This field is experimental and subject to breaking changes.
   */
  eventType: Scalars['String']['output'];
  /**
   * The ID of the entity that performed the action
   * @deprecated This field is experimental and subject to breaking changes.
   */
  originId?: Maybe<Scalars['String']['output']>;
  /**
   * The entity type performing the operation
   * @deprecated This field is experimental and subject to breaking changes.
   */
  originType: IncidentIntelligenceIssueIssueActionOriginType;
  /**
   * The id of the pathway the action occurred on
   * @deprecated This field is experimental and subject to breaking changes.
   */
  pathwayId?: Maybe<Scalars['String']['output']>;
  /**
   * Timestamp of the action
   * @deprecated This field is experimental and subject to breaking changes.
   */
  timestamp: Scalars['Float']['output'];
};

/** Options for the state of an Issue */
export enum IncidentIntelligenceIssueIssueState {
  /**
   * The issue was acknowledged
   * @deprecated This field is experimental and subject to breaking changes.
   */
  Acknowledged = 'ACKNOWLEDGED',
  /**
   * The issue is currently active
   * @deprecated This field is experimental and subject to breaking changes.
   */
  Active = 'ACTIVE',
  /**
   * The issue is closed
   * @deprecated This field is experimental and subject to breaking changes.
   */
  Closed = 'CLOSED',
  /**
   * The issue was created
   * @deprecated This field is experimental and subject to breaking changes.
   */
  Created = 'CREATED'
}

/** Result options for fetching an Incident */
export enum IncidentIntelligenceIssueIssuesReason {
  /**
   * An invalid Filter was given
   * @deprecated This field is experimental and subject to breaking changes.
   */
  InvalidFilter = 'INVALID_FILTER',
  /**
   * Invalid UUID string in id
   * @deprecated This field is experimental and subject to breaking changes.
   */
  InvalidId = 'INVALID_ID',
  /**
   * Limit can not be less than 1
   * @deprecated This field is experimental and subject to breaking changes.
   */
  LimitIsLessThanOne = 'LIMIT_IS_LESS_THAN_ONE',
  /**
   * The user is missing some capabilities
   * @deprecated This field is experimental and subject to breaking changes.
   */
  MissingCapabilities = 'MISSING_CAPABILITIES',
  /**
   * Did not find any issues that match the query
   * @deprecated This field is experimental and subject to breaking changes.
   */
  NoIssuesFound = 'NO_ISSUES_FOUND',
  /**
   * Query successfully retrieved
   * @deprecated This field is experimental and subject to breaking changes.
   */
  Success = 'SUCCESS'
}

/** Issue query response */
export type IncidentIntelligenceIssueIssuesResponse = {
  __typename?: 'IncidentIntelligenceIssueIssuesResponse';
  /**
   * The number of issues returned
   * @deprecated This field is experimental and subject to breaking changes.
   */
  count?: Maybe<Scalars['Int']['output']>;
  /**
   * The cursor returned from the pagination
   * @deprecated This field is experimental and subject to breaking changes.
   */
  cursor?: Maybe<Scalars['String']['output']>;
  /**
   * Result of Issue fetch
   * @deprecated This field is experimental and subject to breaking changes.
   */
  reason: IncidentIntelligenceIssueIssuesReason;
  /**
   * The list of Issues queried
   * @deprecated This field is experimental and subject to breaking changes.
   */
  results?: Maybe<Array<Maybe<IncidentIntelligenceIssueIssue>>>;
  /**
   * A list of the required capabilities that the user is missing
   * @deprecated This field is experimental and subject to breaking changes.
   */
  userMissingCapabilities?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
};

/** Priority */
export enum IncidentIntelligenceIssuePriority {
  /**
   * critical priority
   * @deprecated This field is experimental and subject to breaking changes.
   */
  Critical = 'CRITICAL',
  /**
   * high priority
   * @deprecated This field is experimental and subject to breaking changes.
   */
  High = 'HIGH',
  /**
   * low priority
   * @deprecated This field is experimental and subject to breaking changes.
   */
  Low = 'LOW',
  /**
   * medium priority
   * @deprecated This field is experimental and subject to breaking changes.
   */
  Medium = 'MEDIUM'
}

export type IncidentIntelligencePlatformAccountStitchedFields = {
  __typename?: 'IncidentIntelligencePlatformAccountStitchedFields';
  /**
   * PagerDuty users response
   * @deprecated This field is experimental and subject to breaking changes.
   */
  pagerdutyUsers?: Maybe<IncidentIntelligencePlatformPagerDutyUsersResponse>;
  /**
   * Map between filters and destinations
   * @deprecated This field is experimental and subject to breaking changes.
   */
  pathway?: Maybe<IncidentIntelligencePlatformPathwayResponse>;
  /**
   * Third party platform
   * @deprecated This field is experimental and subject to breaking changes.
   */
  platform?: Maybe<IncidentIntelligencePlatformPlatformResponse>;
};


export type IncidentIntelligencePlatformAccountStitchedFieldsPathwayArgs = {
  pathwayId: Scalars['String']['input'];
};


export type IncidentIntelligencePlatformAccountStitchedFieldsPlatformArgs = {
  platformType: IncidentIntelligencePlatformPlatforms;
};

/** Rule Combinations */
export enum IncidentIntelligencePlatformCombination {
  /**
   * Combination.AND
   * @deprecated This field is experimental and subject to breaking changes.
   */
  And = 'AND',
  /**
   * Combination.OR
   * @deprecated This field is experimental and subject to breaking changes.
   */
  Or = 'OR'
}

/** Describes filter rules combination */
export type IncidentIntelligencePlatformCombinator = {
  __typename?: 'IncidentIntelligencePlatformCombinator';
  /**
   * Combination type
   * @deprecated This field is experimental and subject to breaking changes.
   */
  combinator?: Maybe<IncidentIntelligencePlatformCombination>;
  /**
   * Filter rules
   * @deprecated This field is experimental and subject to breaking changes.
   */
  filterRules?: Maybe<Array<Maybe<IncidentIntelligencePlatformFilterRules>>>;
};

/** Describes a combination of filter rules */
export type IncidentIntelligencePlatformCombinatorInput = {
  /** Combination type */
  combinator?: InputMaybe<IncidentIntelligencePlatformCombination>;
  /** Filter rules to combine */
  rules?: InputMaybe<Array<InputMaybe<IncidentIntelligencePlatformFilterRulesInput>>>;
};

/** Adds a pathway */
export type IncidentIntelligencePlatformCreatePathway = {
  __typename?: 'IncidentIntelligencePlatformCreatePathway';
  /**
   * Map between filters and destinations
   * @deprecated This field is experimental and subject to breaking changes.
   */
  pathway?: Maybe<IncidentIntelligencePlatformPathway>;
  /**
   * Result of pathway creation
   * @deprecated This field is experimental and subject to breaking changes.
   */
  reason?: Maybe<IncidentIntelligencePlatformCreatePathwayResult>;
  /**
   * A list of the required capabilities that the user is missing
   * @deprecated This field is experimental and subject to breaking changes.
   */
  userMissingCapabilities?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
};

/** Result options for setting user as admin */
export enum IncidentIntelligencePlatformCreatePathwayResult {
  /**
   * Destination was updated successfully
   * @deprecated This field is experimental and subject to breaking changes.
   */
  Created = 'CREATED',
  /**
   * Failed destination in pathway was not found
   * @deprecated This field is experimental and subject to breaking changes.
   */
  DestinationNotFound = 'DESTINATION_NOT_FOUND',
  /**
   * The user is missing some capabilities
   * @deprecated This field is experimental and subject to breaking changes.
   */
  MissingCapabilities = 'MISSING_CAPABILITIES',
  /**
   * Failed to add team to destination
   * @deprecated This field is experimental and subject to breaking changes.
   */
  TeamAdditionFailed = 'TEAM_ADDITION_FAILED',
  /**
   * Failed to create team with specified filtering rules
   * @deprecated This field is experimental and subject to breaking changes.
   */
  TeamCreationFailed = 'TEAM_CREATION_FAILED'
}

/** Describes a pagerduty platform to create */
export type IncidentIntelligencePlatformCreatePlatformPagerDuty = {
  __typename?: 'IncidentIntelligencePlatformCreatePlatformPagerDuty';
  /**
   * Platform to be used as source/destination
   * @deprecated This field is experimental and subject to breaking changes.
   */
  platform?: Maybe<IncidentIntelligencePlatformPlatform>;
  /**
   * Result of platform fetch
   * @deprecated This field is experimental and subject to breaking changes.
   */
  reason?: Maybe<IncidentIntelligencePlatformPlatformResult>;
  /**
   * A list of the required capabilities that the user is missing
   * @deprecated This field is experimental and subject to breaking changes.
   */
  userMissingCapabilities?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
};

/** Deletes a pathway */
export type IncidentIntelligencePlatformDeletePathway = {
  __typename?: 'IncidentIntelligencePlatformDeletePathway';
  /**
   * Result of pathway deletion
   * @deprecated This field is experimental and subject to breaking changes.
   */
  reason?: Maybe<IncidentIntelligencePlatformDeletePathwayResult>;
  /**
   * A list of the required capabilities that the user is missing
   * @deprecated This field is experimental and subject to breaking changes.
   */
  userMissingCapabilities?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
};

/** Result options for setting user as admin */
export enum IncidentIntelligencePlatformDeletePathwayResult {
  /**
   * Pathway was deleted successfully
   * @deprecated This field is experimental and subject to breaking changes.
   */
  Deleted = 'DELETED',
  /**
   * The user is missing some capabilities
   * @deprecated This field is experimental and subject to breaking changes.
   */
  MissingCapabilities = 'MISSING_CAPABILITIES',
  /**
   * Pathway with id given was not found
   * @deprecated This field is experimental and subject to breaking changes.
   */
  PathwayNotFound = 'PATHWAY_NOT_FOUND',
  /**
   * Failed to remove team from pathway destinations
   * @deprecated This field is experimental and subject to breaking changes.
   */
  TeamRemovalFailed = 'TEAM_REMOVAL_FAILED'
}

/** Delete a platform */
export type IncidentIntelligencePlatformDeletePlatform = {
  __typename?: 'IncidentIntelligencePlatformDeletePlatform';
  /**
   * Result of platform deletion
   * @deprecated This field is experimental and subject to breaking changes.
   */
  reason?: Maybe<IncidentIntelligencePlatformDeletePlatformResult>;
  /**
   * A list of the required capabilities that the user is missing
   * @deprecated This field is experimental and subject to breaking changes.
   */
  userMissingCapabilities?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
};

/** Result of deleting a platform */
export enum IncidentIntelligencePlatformDeletePlatformResult {
  /**
   * Successfully deleted platform
   * @deprecated This field is experimental and subject to breaking changes.
   */
  Deleted = 'DELETED',
  /**
   * The user is missing some capabilities
   * @deprecated This field is experimental and subject to breaking changes.
   */
  MissingCapabilities = 'MISSING_CAPABILITIES',
  /**
   * Platform does not exist for origin given
   * @deprecated This field is experimental and subject to breaking changes.
   */
  PlatformNotFound = 'PLATFORM_NOT_FOUND'
}

/** Deprovision a destination */
export type IncidentIntelligencePlatformDeprovisionDestination = {
  __typename?: 'IncidentIntelligencePlatformDeprovisionDestination';
  /**
   * Result of destination deprovisioning
   * @deprecated This field is experimental and subject to breaking changes.
   */
  reason?: Maybe<IncidentIntelligencePlatformDeprovisionDestinationResult>;
  /**
   * A list of the required capabilities that the user is missing
   * @deprecated This field is experimental and subject to breaking changes.
   */
  userMissingCapabilities?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
};

/** Result options for setting user as admin */
export enum IncidentIntelligencePlatformDeprovisionDestinationResult {
  /**
   * Destination was deprovisioned successfully
   * @deprecated This field is experimental and subject to breaking changes.
   */
  Deprovisioned = 'DEPROVISIONED',
  /**
   * Destination does not exist, could not deprovision
   * @deprecated This field is experimental and subject to breaking changes.
   */
  DestinationDoesNotExist = 'DESTINATION_DOES_NOT_EXIST',
  /**
   * The user is missing some capabilities
   * @deprecated This field is experimental and subject to breaking changes.
   */
  MissingCapabilities = 'MISSING_CAPABILITIES'
}

/** Deprovision a source */
export type IncidentIntelligencePlatformDeprovisionSource = {
  __typename?: 'IncidentIntelligencePlatformDeprovisionSource';
  /**
   * Result of source deprovisioning
   * @deprecated This field is experimental and subject to breaking changes.
   */
  reason?: Maybe<IncidentIntelligencePlatformDeprovisionSourceResult>;
  /**
   * A list of the required capabilities that the user is missing
   * @deprecated This field is experimental and subject to breaking changes.
   */
  userMissingCapabilities?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
};

/** Result of deprovisioning a source */
export enum IncidentIntelligencePlatformDeprovisionSourceResult {
  /**
   * Destination was successfully deprovisioned
   * @deprecated This field is experimental and subject to breaking changes.
   */
  Deprovisioned = 'DEPROVISIONED',
  /**
   * The user is missing some capabilities
   * @deprecated This field is experimental and subject to breaking changes.
   */
  MissingCapabilities = 'MISSING_CAPABILITIES',
  /**
   * Destination with given id was not found
   * @deprecated This field is experimental and subject to breaking changes.
   */
  PlatformNotFound = 'PLATFORM_NOT_FOUND',
  /**
   * Source with given id was not found
   * @deprecated This field is experimental and subject to breaking changes.
   */
  SourceNotFound = 'SOURCE_NOT_FOUND'
}

/** Result options for setting user as admin */
export enum IncidentIntelligencePlatformDestinationPagerDutyResult {
  /**
   * Destination with given id was not found
   * @deprecated This field is experimental and subject to breaking changes.
   */
  DestinationNotFound = 'DESTINATION_NOT_FOUND',
  /**
   * The user is missing some capabilities
   * @deprecated This field is experimental and subject to breaking changes.
   */
  MissingCapabilities = 'MISSING_CAPABILITIES',
  /**
   * Failed provision operation in PagerDuty
   * @deprecated This field is experimental and subject to breaking changes.
   */
  PagerdutyError = 'PAGERDUTY_ERROR',
  /**
   * Platform was not found, could not provision destination
   * @deprecated This field is experimental and subject to breaking changes.
   */
  PlatformNotFound = 'PLATFORM_NOT_FOUND',
  /**
   * Destination was provisioned successfully
   * @deprecated This field is experimental and subject to breaking changes.
   */
  Provisioned = 'PROVISIONED',
  /**
   * Destination was updated successfully
   * @deprecated This field is experimental and subject to breaking changes.
   */
  Updated = 'UPDATED'
}

/** Result of webhook destination actions */
export enum IncidentIntelligencePlatformDestinationWebhookResult {
  /**
   * Destination with given id was not found
   * @deprecated This field is experimental and subject to breaking changes.
   */
  DestinationNotFound = 'DESTINATION_NOT_FOUND',
  /**
   * The user is missing some capabilities
   * @deprecated This field is experimental and subject to breaking changes.
   */
  MissingCapabilities = 'MISSING_CAPABILITIES',
  /**
   * Destination was provisioned successfully
   * @deprecated This field is experimental and subject to breaking changes.
   */
  Provisioned = 'PROVISIONED',
  /**
   * Destination was updated successfully
   * @deprecated This field is experimental and subject to breaking changes.
   */
  Updated = 'UPDATED'
}

/** Describes a PagerDuty extension */
export type IncidentIntelligencePlatformExtension = {
  __typename?: 'IncidentIntelligencePlatformExtension';
  /**
   * Extension endpoint url
   * @deprecated This field is experimental and subject to breaking changes.
   */
  endpointUrl: Scalars['String']['output'];
  /**
   * Id of extension in PagerDuty
   * @deprecated This field is experimental and subject to breaking changes.
   */
  id: Scalars['String']['output'];
};

/** Filter rule operators */
export enum IncidentIntelligencePlatformFilterOperators {
  /**
   * FilterOperators.CONTAINS
   * @deprecated This field is experimental and subject to breaking changes.
   */
  Contains = 'CONTAINS',
  /**
   * FilterOperators.ENDS_WITH
   * @deprecated This field is experimental and subject to breaking changes.
   */
  EndsWith = 'ENDS_WITH',
  /**
   * FilterOperators.EQUALS
   * @deprecated This field is experimental and subject to breaking changes.
   */
  Equals = 'EQUALS',
  /**
   * FilterOperators.GT
   * @deprecated This field is experimental and subject to breaking changes.
   */
  Gt = 'GT',
  /**
   * FilterOperators.GTE
   * @deprecated This field is experimental and subject to breaking changes.
   */
  Gte = 'GTE',
  /**
   * FilterOperators.LT
   * @deprecated This field is experimental and subject to breaking changes.
   */
  Lt = 'LT',
  /**
   * FilterOperators.LTE
   * @deprecated This field is experimental and subject to breaking changes.
   */
  Lte = 'LTE',
  /**
   * FilterOperators.NOT_CONTAINS
   * @deprecated This field is experimental and subject to breaking changes.
   */
  NotContains = 'NOT_CONTAINS',
  /**
   * FilterOperators.NOT_EQUALS
   * @deprecated This field is experimental and subject to breaking changes.
   */
  NotEquals = 'NOT_EQUALS',
  /**
   * FilterOperators.STARTS_WITH
   * @deprecated This field is experimental and subject to breaking changes.
   */
  StartsWith = 'STARTS_WITH'
}

/** Describes rules to filter by */
export type IncidentIntelligencePlatformFilterRules = {
  __typename?: 'IncidentIntelligencePlatformFilterRules';
  /**
   * Combination of filter rules
   * @deprecated This field is experimental and subject to breaking changes.
   */
  combinator?: Maybe<IncidentIntelligencePlatformCombinator>;
  /**
   * Filter rule by value
   * @deprecated This field is experimental and subject to breaking changes.
   */
  valueRule?: Maybe<IncidentIntelligencePlatformFilterValueRule>;
  /**
   * Filter rule by values
   * @deprecated This field is experimental and subject to breaking changes.
   */
  valuesRule?: Maybe<IncidentIntelligencePlatformFilterValuesRule>;
};

/** Describes the filter rules */
export type IncidentIntelligencePlatformFilterRulesInput = {
  /** Combination of filter rules */
  combinatorRule?: InputMaybe<IncidentIntelligencePlatformCombinatorInput>;
  /** Filter rule by value */
  valueRule?: InputMaybe<IncidentIntelligencePlatformFilterValueInput>;
  /** Filter rule by values */
  valuesRule?: InputMaybe<IncidentIntelligencePlatformFilterValuesRuleInput>;
};

/** Describes a rule based on single value */
export type IncidentIntelligencePlatformFilterValueInput = {
  /** Filter rule field */
  field: Scalars['String']['input'];
  /** Filter rule operator */
  operator?: InputMaybe<IncidentIntelligencePlatformFilterOperators>;
  /** Filter value */
  value: Scalars['IncidentIntelligencePlatformFilterValue']['input'];
};

/** Describes a rule based on single value */
export type IncidentIntelligencePlatformFilterValueRule = {
  __typename?: 'IncidentIntelligencePlatformFilterValueRule';
  /**
   * Filter rule field
   * @deprecated This field is experimental and subject to breaking changes.
   */
  field: Scalars['String']['output'];
  /**
   * Filter rule operator
   * @deprecated This field is experimental and subject to breaking changes.
   */
  operator?: Maybe<IncidentIntelligencePlatformFilterOperators>;
  /**
   * Filter rule value
   * @deprecated This field is experimental and subject to breaking changes.
   */
  value: Scalars['IncidentIntelligencePlatformFilterValue']['output'];
};

/** Describes a rule based on multiple values */
export type IncidentIntelligencePlatformFilterValuesRule = {
  __typename?: 'IncidentIntelligencePlatformFilterValuesRule';
  /**
   * Filter rule field
   * @deprecated This field is experimental and subject to breaking changes.
   */
  field: Scalars['String']['output'];
  /**
   * Filter rule operator
   * @deprecated This field is experimental and subject to breaking changes.
   */
  operator?: Maybe<IncidentIntelligencePlatformFilterOperators>;
  /**
   * Filter rule values
   * @deprecated This field is experimental and subject to breaking changes.
   */
  values?: Maybe<Array<Maybe<Scalars['IncidentIntelligencePlatformFilterValue']['output']>>>;
};

/** Describes a rule based on multiple values */
export type IncidentIntelligencePlatformFilterValuesRuleInput = {
  /** Filter rule field */
  field: Scalars['String']['input'];
  /** Filter rule operator */
  operator?: InputMaybe<IncidentIntelligencePlatformFilterOperators>;
  /** Values of filter */
  values?: InputMaybe<Array<InputMaybe<Scalars['IncidentIntelligencePlatformFilterValue']['input']>>>;
};

/** Header name and value */
export type IncidentIntelligencePlatformHeaderInput = {
  /** Header name */
  name: Scalars['String']['input'];
  /** Header value */
  value: Scalars['String']['input'];
};

/** Header name and value */
export type IncidentIntelligencePlatformHeaderOutput = {
  __typename?: 'IncidentIntelligencePlatformHeaderOutput';
  /**
   * Header name
   * @deprecated This field is experimental and subject to breaking changes.
   */
  name: Scalars['String']['output'];
  /**
   * Header value
   * @deprecated This field is experimental and subject to breaking changes.
   */
  value: Scalars['String']['output'];
};

/** Describes PagerDuty Integration */
export type IncidentIntelligencePlatformIntegration = {
  __typename?: 'IncidentIntelligencePlatformIntegration';
  /**
   * Integration id in pagerduty
   * @deprecated This field is experimental and subject to breaking changes.
   */
  id: Scalars['String']['output'];
  /**
   * Integration summary
   * @deprecated This field is experimental and subject to breaking changes.
   */
  summary: Scalars['String']['output'];
};

/** Configuration of a PagerDuty destination */
export type IncidentIntelligencePlatformPagerDutyDestinationConfigurationInput = {
  /** Propogate incident acknowledgement to source service */
  autoAckOriginalIncident: Scalars['Boolean']['input'];
  /** Propogate incident closing to source service */
  autoCloseOriginalIncident: Scalars['Boolean']['input'];
  /** Should create a new user if it does not exist in PagerDuty */
  shouldCreateNewUser: Scalars['Boolean']['input'];
  /** Use source service escalation policy */
  useOriginalServiceEscalationPolicy: Scalars['Boolean']['input'];
  /** User email */
  userEmail: Scalars['String']['input'];
};

/** Describes the configuration of a PagerDuty destination */
export type IncidentIntelligencePlatformPagerDutyDestinationConfigurationOutput = {
  __typename?: 'IncidentIntelligencePlatformPagerDutyDestinationConfigurationOutput';
  /**
   * Propogate incident acknowledgement to source service
   * @deprecated This field is experimental and subject to breaking changes.
   */
  autoAckOriginalIncident: Scalars['Boolean']['output'];
  /**
   * Propogate incident closing to source service
   * @deprecated This field is experimental and subject to breaking changes.
   */
  autoCloseOriginalIncident: Scalars['Boolean']['output'];
  /**
   * Should create a new user if it does not exist in PagerDuty
   * @deprecated This field is experimental and subject to breaking changes.
   */
  shouldCreateNewUser: Scalars['Boolean']['output'];
  /**
   * Use source service escalation policy
   * @deprecated This field is experimental and subject to breaking changes.
   */
  useOriginalServiceEscalationPolicy: Scalars['Boolean']['output'];
  /**
   * User email
   * @deprecated This field is experimental and subject to breaking changes.
   */
  userEmail: Scalars['String']['output'];
};

/** Describes the PagerDuty destination */
export type IncidentIntelligencePlatformPagerDutyDestinationOutput = {
  __typename?: 'IncidentIntelligencePlatformPagerDutyDestinationOutput';
  /**
   * Destination behaviour configuration
   * @deprecated This field is experimental and subject to breaking changes.
   */
  configuration: IncidentIntelligencePlatformPagerDutyDestinationConfigurationOutput;
  /**
   * Destination unique identifier
   * @deprecated This field is experimental and subject to breaking changes.
   */
  id: Scalars['String']['output'];
  /**
   * PagerDuty integration
   * @deprecated This field is experimental and subject to breaking changes.
   */
  integration: IncidentIntelligencePlatformIntegration;
  /**
   * PagerDuty service id
   * @deprecated This field is experimental and subject to breaking changes.
   */
  serviceId: Scalars['String']['output'];
};

/** Output configuration argument, currently used only for PagerDuty configuration */
export type IncidentIntelligencePlatformPagerDutyPlatformConfiguration = {
  __typename?: 'IncidentIntelligencePlatformPagerDutyPlatformConfiguration';
  /**
   * PagerDuty admin user to use for operations requiring a user
   * @deprecated This field is experimental and subject to breaking changes.
   */
  adminUser?: Maybe<Scalars['String']['output']>;
};

/** Input configuration argument, currently used only for PagerDuty configuration */
export type IncidentIntelligencePlatformPagerDutyPlatformConfigurationInput = {
  /** PagerDuty admin user to use for operations requiring a user */
  adminUser?: InputMaybe<Scalars['String']['input']>;
  /** PagerDuty api key */
  apiKey: Scalars['String']['input'];
};

/** Set user as admin in PagerDuty */
export type IncidentIntelligencePlatformPagerDutySetAdmin = {
  __typename?: 'IncidentIntelligencePlatformPagerDutySetAdmin';
  /**
   * Result of setting user as admin
   * @deprecated This field is experimental and subject to breaking changes.
   */
  reason?: Maybe<IncidentIntelligencePlatformUserSetAsAdminResult>;
  /**
   * A list of the required capabilities that the user is missing
   * @deprecated This field is experimental and subject to breaking changes.
   */
  userMissingCapabilities?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
};

/** Describes a PagerDuty source */
export type IncidentIntelligencePlatformPagerDutySourceOutput = {
  __typename?: 'IncidentIntelligencePlatformPagerDutySourceOutput';
  /**
   * Pagerduty extension
   * @deprecated This field is experimental and subject to breaking changes.
   */
  extension: IncidentIntelligencePlatformExtension;
  /**
   * Source unique identifier
   * @deprecated This field is experimental and subject to breaking changes.
   */
  id: Scalars['String']['output'];
  /**
   * Source type
   * @deprecated This field is experimental and subject to breaking changes.
   */
  kind: IncidentIntelligencePlatformSourceKind;
};

/** Fetch PagerDuty users response */
export type IncidentIntelligencePlatformPagerDutyUsersResponse = {
  __typename?: 'IncidentIntelligencePlatformPagerDutyUsersResponse';
  /**
   * PagerDuty users
   * @deprecated This field is experimental and subject to breaking changes.
   */
  pagerdutyUsers?: Maybe<Array<Maybe<IncidentIntelligencePlatformPagerdutyUserOutput>>>;
  /**
   * Result of fetching users from PagerDuty
   * @deprecated This field is experimental and subject to breaking changes.
   */
  reason?: Maybe<IncidentIntelligencePlatformPagerDutyUsersResult>;
  /**
   * A list of the required capabilities that the user is missing
   * @deprecated This field is experimental and subject to breaking changes.
   */
  userMissingCapabilities?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
};

/** Result of fetching PagerDuty users */
export enum IncidentIntelligencePlatformPagerDutyUsersResult {
  /**
   * Failed to fetch users from PagerDuty
   * @deprecated This field is experimental and subject to breaking changes.
   */
  Failed = 'FAILED',
  /**
   * The user is missing some capabilities
   * @deprecated This field is experimental and subject to breaking changes.
   */
  MissingCapabilities = 'MISSING_CAPABILITIES',
  /**
   * Platform does not exist for origin given
   * @deprecated This field is experimental and subject to breaking changes.
   */
  PlatformNotFound = 'PLATFORM_NOT_FOUND',
  /**
   * Pagerduty users retrieved successfully
   * @deprecated This field is experimental and subject to breaking changes.
   */
  Success = 'SUCCESS'
}

/** Describes a PagerDuty user */
export type IncidentIntelligencePlatformPagerdutyUserOutput = {
  __typename?: 'IncidentIntelligencePlatformPagerdutyUserOutput';
  /**
   * User email
   * @deprecated This field is experimental and subject to breaking changes.
   */
  email?: Maybe<Scalars['String']['output']>;
  /**
   * User unique identifier in pagerduty
   * @deprecated This field is experimental and subject to breaking changes.
   */
  id?: Maybe<Scalars['String']['output']>;
  /**
   * User name
   * @deprecated This field is experimental and subject to breaking changes.
   */
  name?: Maybe<Scalars['String']['output']>;
  /**
   * User role in pagerduty
   * @deprecated This field is experimental and subject to breaking changes.
   */
  role?: Maybe<IncidentIntelligencePlatformRole>;
};

/** Map between filters and destinations */
export type IncidentIntelligencePlatformPathway = {
  __typename?: 'IncidentIntelligencePlatformPathway';
  /**
   * Pathway deletion datetime
   * @deprecated This field is experimental and subject to breaking changes.
   */
  deletedOn?: Maybe<Scalars['DateTime']['output']>;
  /**
   * Pathway description
   * @deprecated This field is experimental and subject to breaking changes.
   */
  description?: Maybe<Scalars['String']['output']>;
  /**
   * Connected destinations ids
   * @deprecated This field is experimental and subject to breaking changes.
   */
  destinationIds?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
  /**
   * Pathway enabled/disabled
   * @deprecated This field is experimental and subject to breaking changes.
   */
  enabled?: Maybe<Scalars['Boolean']['output']>;
  /**
   * Pathway unique identifier
   * @deprecated This field is experimental and subject to breaking changes.
   */
  id?: Maybe<Scalars['String']['output']>;
  /**
   * Pathway name
   * @deprecated This field is experimental and subject to breaking changes.
   */
  name?: Maybe<Scalars['String']['output']>;
  /**
   * Pathway filter
   * @deprecated This field is experimental and subject to breaking changes.
   */
  pathwayFilter?: Maybe<IncidentIntelligencePlatformPathwayFilter>;
};

/** Describes a pathway filter */
export type IncidentIntelligencePlatformPathwayFilter = {
  __typename?: 'IncidentIntelligencePlatformPathwayFilter';
  /**
   * Filter unique identifier
   * @deprecated This field is experimental and subject to breaking changes.
   */
  filterId?: Maybe<Scalars['String']['output']>;
  /**
   * Filter rules
   * @deprecated This field is experimental and subject to breaking changes.
   */
  filterRules?: Maybe<IncidentIntelligencePlatformFilterRules>;
};

/** Describes a pathway filter */
export type IncidentIntelligencePlatformPathwayFilterInput = {
  /** Pathway filters */
  filterRules: IncidentIntelligencePlatformFilterRulesInput;
};

/** Describes a pathway to create */
export type IncidentIntelligencePlatformPathwayInput = {
  /** Pathway deletion datetime */
  deletedOn?: InputMaybe<Scalars['DateTime']['input']>;
  /** Pathway description */
  description: Scalars['String']['input'];
  /** Connected destinations ids */
  destinationIds?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  /** Pathway enabled/disabled */
  enabled?: InputMaybe<Scalars['Boolean']['input']>;
  /** Pathway name */
  name: Scalars['String']['input'];
  /** Pathway filter */
  pathwayFilter: IncidentIntelligencePlatformPathwayFilterInput;
};

/** Pathway request response */
export type IncidentIntelligencePlatformPathwayResponse = {
  __typename?: 'IncidentIntelligencePlatformPathwayResponse';
  /**
   * Map between filters and destinations
   * @deprecated This field is experimental and subject to breaking changes.
   */
  pathway?: Maybe<IncidentIntelligencePlatformPathway>;
  /**
   * Result of pathway fetch
   * @deprecated This field is experimental and subject to breaking changes.
   */
  reason?: Maybe<IncidentIntelligencePlatformPathwayResult>;
  /**
   * A list of the required capabilities that the user is missing
   * @deprecated This field is experimental and subject to breaking changes.
   */
  userMissingCapabilities?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
};

/** Result of fetching a pathway */
export enum IncidentIntelligencePlatformPathwayResult {
  /**
   * The user is missing some capabilities
   * @deprecated This field is experimental and subject to breaking changes.
   */
  MissingCapabilities = 'MISSING_CAPABILITIES',
  /**
   * Pathway with given id was not found
   * @deprecated This field is experimental and subject to breaking changes.
   */
  PathwayNotFound = 'PATHWAY_NOT_FOUND',
  /**
   * Pathway was retreived successfully
   * @deprecated This field is experimental and subject to breaking changes.
   */
  Success = 'SUCCESS'
}

/** Describes a platform */
export type IncidentIntelligencePlatformPlatform = {
  __typename?: 'IncidentIntelligencePlatformPlatform';
  /**
   * Platform configuration
   * @deprecated This field is experimental and subject to breaking changes.
   */
  endpointConfiguration: IncidentIntelligencePlatformPagerDutyPlatformConfiguration;
  /**
   * Platform enabled/disabled
   * @deprecated This field is experimental and subject to breaking changes.
   */
  endpointEnabled: Scalars['Boolean']['output'];
};

/** Platform request response */
export type IncidentIntelligencePlatformPlatformResponse = {
  __typename?: 'IncidentIntelligencePlatformPlatformResponse';
  /**
   * Platform to be used as source/destination
   * @deprecated This field is experimental and subject to breaking changes.
   */
  platform?: Maybe<IncidentIntelligencePlatformPlatform>;
  /**
   * Result of platform fetch
   * @deprecated This field is experimental and subject to breaking changes.
   */
  reason?: Maybe<IncidentIntelligencePlatformPlatformResult>;
  /**
   * A list of the required capabilities that the user is missing
   * @deprecated This field is experimental and subject to breaking changes.
   */
  userMissingCapabilities?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
};

/** Result of platform actions */
export enum IncidentIntelligencePlatformPlatformResult {
  /**
   * Successfully created platform
   * @deprecated This field is experimental and subject to breaking changes.
   */
  Created = 'CREATED',
  /**
   * At least on update arguments given
   * @deprecated This field is experimental and subject to breaking changes.
   */
  MissingArguments = 'MISSING_ARGUMENTS',
  /**
   * The user is missing some capabilities
   * @deprecated This field is experimental and subject to breaking changes.
   */
  MissingCapabilities = 'MISSING_CAPABILITIES',
  /**
   * Platform does not exist for origin given
   * @deprecated This field is experimental and subject to breaking changes.
   */
  PlatformNotFound = 'PLATFORM_NOT_FOUND',
  /**
   * Platform retrieved successfully
   * @deprecated This field is experimental and subject to breaking changes.
   */
  Success = 'SUCCESS',
  /**
   * Successfully updated platform
   * @deprecated This field is experimental and subject to breaking changes.
   */
  Updated = 'UPDATED'
}

/** Platform types */
export enum IncidentIntelligencePlatformPlatforms {
  /**
   * Platforms.PAGERDUTY
   * @deprecated This field is experimental and subject to breaking changes.
   */
  Pagerduty = 'PAGERDUTY',
  /**
   * Platforms.WEBHOOK
   * @deprecated This field is experimental and subject to breaking changes.
   */
  Webhook = 'WEBHOOK'
}

/** Priority */
export enum IncidentIntelligencePlatformPriority {
  /**
   * critical priority
   * @deprecated This field is experimental and subject to breaking changes.
   */
  Critical = 'CRITICAL',
  /**
   * high priority
   * @deprecated This field is experimental and subject to breaking changes.
   */
  High = 'HIGH',
  /**
   * low priority
   * @deprecated This field is experimental and subject to breaking changes.
   */
  Low = 'LOW',
  /**
   * medium priority
   * @deprecated This field is experimental and subject to breaking changes.
   */
  Medium = 'MEDIUM'
}

/** Mapping from NRAI issue priorities to destination priorities */
export type IncidentIntelligencePlatformPriorityMappingInput = {
  /** System priority */
  fromPriority: IncidentIntelligencePlatformPriority;
  /** Destination priority */
  toPriority: Scalars['String']['input'];
};

/** Mapping from NRAI issue priorities to destination priorities */
export type IncidentIntelligencePlatformPriorityMappingOutput = {
  __typename?: 'IncidentIntelligencePlatformPriorityMappingOutput';
  /**
   * System priority
   * @deprecated This field is experimental and subject to breaking changes.
   */
  fromPriority: IncidentIntelligencePlatformPriority;
  /**
   * Destination priority
   * @deprecated This field is experimental and subject to breaking changes.
   */
  toPriority: Scalars['String']['output'];
};

/** Provision a destination in PagerDuty */
export type IncidentIntelligencePlatformProvisionDestinationPagerDuty = {
  __typename?: 'IncidentIntelligencePlatformProvisionDestinationPagerDuty';
  /**
   * Map between a notification channel and an endpoint
   * @deprecated This field is experimental and subject to breaking changes.
   */
  destination?: Maybe<IncidentIntelligencePlatformPagerDutyDestinationOutput>;
  /**
   * Result of pagerduty destination provision/update
   * @deprecated This field is experimental and subject to breaking changes.
   */
  reason?: Maybe<IncidentIntelligencePlatformDestinationPagerDutyResult>;
  /**
   * A list of the required capabilities that the user is missing
   * @deprecated This field is experimental and subject to breaking changes.
   */
  userMissingCapabilities?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
};

/** Provision a webhook destination */
export type IncidentIntelligencePlatformProvisionDestinationWebhook = {
  __typename?: 'IncidentIntelligencePlatformProvisionDestinationWebhook';
  /**
   * Map between a notification channel and an endpoint
   * @deprecated This field is experimental and subject to breaking changes.
   */
  destination?: Maybe<IncidentIntelligencePlatformWebhookDestinationOutput>;
  /**
   * Result of webhook destination provision/update
   * @deprecated This field is experimental and subject to breaking changes.
   */
  reason?: Maybe<IncidentIntelligencePlatformDestinationWebhookResult>;
  /**
   * A list of the required capabilities that the user is missing
   * @deprecated This field is experimental and subject to breaking changes.
   */
  userMissingCapabilities?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
};

/** Adds a source to PagerDuty */
export type IncidentIntelligencePlatformProvisionSourcePagerDuty = {
  __typename?: 'IncidentIntelligencePlatformProvisionSourcePagerDuty';
  /**
   * Reult of pagerduty source provisioning
   * @deprecated This field is experimental and subject to breaking changes.
   */
  reason?: Maybe<IncidentIntelligencePlatformProvisionSourcePagerDutyResult>;
  /**
   * Map between an integration point in our system to a data source in the platform
   * @deprecated This field is experimental and subject to breaking changes.
   */
  source?: Maybe<IncidentIntelligencePlatformPagerDutySourceOutput>;
  /**
   * A list of the required capabilities that the user is missing
   * @deprecated This field is experimental and subject to breaking changes.
   */
  userMissingCapabilities?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
};

/** Result of provisioning a PagerDuty source */
export enum IncidentIntelligencePlatformProvisionSourcePagerDutyResult {
  /**
   * The user is missing some capabilities
   * @deprecated This field is experimental and subject to breaking changes.
   */
  MissingCapabilities = 'MISSING_CAPABILITIES',
  /**
   * Failed provision operation in PagerDuty
   * @deprecated This field is experimental and subject to breaking changes.
   */
  PagerdutyError = 'PAGERDUTY_ERROR',
  /**
   * Destination with given id was not found
   * @deprecated This field is experimental and subject to breaking changes.
   */
  PlatformNotFound = 'PLATFORM_NOT_FOUND',
  /**
   * Destination was provisioned successfully
   * @deprecated This field is experimental and subject to breaking changes.
   */
  Provisioned = 'PROVISIONED'
}

/** PagerDuty roles */
export enum IncidentIntelligencePlatformRole {
  /**
   * Role.ADMIN
   * @deprecated This field is experimental and subject to breaking changes.
   */
  Admin = 'ADMIN',
  /**
   * Role.LIMITED_USER
   * @deprecated This field is experimental and subject to breaking changes.
   */
  LimitedUser = 'LIMITED_USER',
  /**
   * Role.OBSERVER
   * @deprecated This field is experimental and subject to breaking changes.
   */
  Observer = 'OBSERVER',
  /**
   * Role.OWNER
   * @deprecated This field is experimental and subject to breaking changes.
   */
  Owner = 'OWNER',
  /**
   * Role.READ_ONLY_LIMITED_USER
   * @deprecated This field is experimental and subject to breaking changes.
   */
  ReadOnlyLimitedUser = 'READ_ONLY_LIMITED_USER',
  /**
   * Role.READ_ONLY_USER
   * @deprecated This field is experimental and subject to breaking changes.
   */
  ReadOnlyUser = 'READ_ONLY_USER',
  /**
   * Role.RESTRICTED_ACCESS
   * @deprecated This field is experimental and subject to breaking changes.
   */
  RestrictedAccess = 'RESTRICTED_ACCESS',
  /**
   * Role.USER
   * @deprecated This field is experimental and subject to breaking changes.
   */
  User = 'USER'
}

/** Source kind */
export enum IncidentIntelligencePlatformSourceKind {
  /**
   * SourceKind.SYSTEM
   * @deprecated This field is experimental and subject to breaking changes.
   */
  System = 'SYSTEM',
  /**
   * SourceKind.USER
   * @deprecated This field is experimental and subject to breaking changes.
   */
  User = 'USER'
}

/** Sync all services from PagerDuty account */
export type IncidentIntelligencePlatformSyncServicesPagerDuty = {
  __typename?: 'IncidentIntelligencePlatformSyncServicesPagerDuty';
  /**
   * Result of performing PagerDuty services sync
   * @deprecated This field is experimental and subject to breaking changes.
   */
  reason?: Maybe<IncidentIntelligencePlatformSyncServicesPagerDutyResult>;
  /**
   * A list of the required capabilities that the user is missing
   * @deprecated This field is experimental and subject to breaking changes.
   */
  userMissingCapabilities?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
};

/** Result of syncing (retrieving) PagerDuty services */
export enum IncidentIntelligencePlatformSyncServicesPagerDutyResult {
  /**
   * The user is missing some capabilities
   * @deprecated This field is experimental and subject to breaking changes.
   */
  MissingCapabilities = 'MISSING_CAPABILITIES',
  /**
   * A sync was recently done, pass force_sync argument to force one
   * @deprecated This field is experimental and subject to breaking changes.
   */
  NoNeedToSync = 'NO_NEED_TO_SYNC',
  /**
   * No PagerDuty platform configured for this account
   * @deprecated This field is experimental and subject to breaking changes.
   */
  PlatformNotFound = 'PLATFORM_NOT_FOUND',
  /**
   * PagerDuty services were synced
   * @deprecated This field is experimental and subject to breaking changes.
   */
  Synced = 'SYNCED'
}

/** Update a destination in PagerDuty */
export type IncidentIntelligencePlatformUpdateDestinationPagerDuty = {
  __typename?: 'IncidentIntelligencePlatformUpdateDestinationPagerDuty';
  /**
   * Map between a notification channel and an endpoint
   * @deprecated This field is experimental and subject to breaking changes.
   */
  destination?: Maybe<IncidentIntelligencePlatformPagerDutyDestinationOutput>;
  /**
   * Result of pagerduty destination provision/update
   * @deprecated This field is experimental and subject to breaking changes.
   */
  reason?: Maybe<IncidentIntelligencePlatformDestinationPagerDutyResult>;
  /**
   * A list of the required capabilities that the user is missing
   * @deprecated This field is experimental and subject to breaking changes.
   */
  userMissingCapabilities?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
};

/** Update destination of type webhook */
export type IncidentIntelligencePlatformUpdateDestinationWebhook = {
  __typename?: 'IncidentIntelligencePlatformUpdateDestinationWebhook';
  /**
   * Map between a notification channel and an endpoint
   * @deprecated This field is experimental and subject to breaking changes.
   */
  destination?: Maybe<IncidentIntelligencePlatformWebhookDestinationOutput>;
  /**
   * Result of webhook destination provision/update
   * @deprecated This field is experimental and subject to breaking changes.
   */
  reason?: Maybe<IncidentIntelligencePlatformDestinationWebhookResult>;
  /**
   * A list of the required capabilities that the user is missing
   * @deprecated This field is experimental and subject to breaking changes.
   */
  userMissingCapabilities?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
};

/** Updates a pathway */
export type IncidentIntelligencePlatformUpdatePathway = {
  __typename?: 'IncidentIntelligencePlatformUpdatePathway';
  /**
   * Map between filters and destinations
   * @deprecated This field is experimental and subject to breaking changes.
   */
  pathway?: Maybe<IncidentIntelligencePlatformPathway>;
  /**
   * Result of update
   * @deprecated This field is experimental and subject to breaking changes.
   */
  reason?: Maybe<IncidentIntelligencePlatformUpdatePathwayResult>;
  /**
   * A list of the required capabilities that the user is missing
   * @deprecated This field is experimental and subject to breaking changes.
   */
  userMissingCapabilities?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
};

/** Describes a pathway filter to be updated */
export type IncidentIntelligencePlatformUpdatePathwayFilterInput = {
  /** Filter unique identifier */
  filterId: Scalars['String']['input'];
  /** Pathway filters */
  filterRules: IncidentIntelligencePlatformFilterRulesInput;
};

/** Describes an updated pathway */
export type IncidentIntelligencePlatformUpdatePathwayInput = {
  /** Pathway deletion datetime */
  deletedOn?: InputMaybe<Scalars['DateTime']['input']>;
  /** Pathway description */
  description: Scalars['String']['input'];
  /** Connected destinations ids */
  destinationIds?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  /** Pathway enabled/disabled */
  enabled?: InputMaybe<Scalars['Boolean']['input']>;
  /** Pathway unique identifier */
  id: Scalars['String']['input'];
  /** Pathway name */
  name: Scalars['String']['input'];
  /** Pathway filter */
  pathwayFilter: IncidentIntelligencePlatformUpdatePathwayFilterInput;
};

/** Result options for setting user as admin */
export enum IncidentIntelligencePlatformUpdatePathwayResult {
  /**
   * The user is missing some capabilities
   * @deprecated This field is experimental and subject to breaking changes.
   */
  MissingCapabilities = 'MISSING_CAPABILITIES',
  /**
   * Pathway with given id was not found
   * @deprecated This field is experimental and subject to breaking changes.
   */
  PathwayNotFound = 'PATHWAY_NOT_FOUND',
  /**
   * Failed to add team to new destinations
   * @deprecated This field is experimental and subject to breaking changes.
   */
  TeamAdditionFailed = 'TEAM_ADDITION_FAILED',
  /**
   * Failed to remove team from removed destinations
   * @deprecated This field is experimental and subject to breaking changes.
   */
  TeamRemovalFailed = 'TEAM_REMOVAL_FAILED',
  /**
   * Failed to update team with new filters
   * @deprecated This field is experimental and subject to breaking changes.
   */
  TeamUpdateFailed = 'TEAM_UPDATE_FAILED',
  /**
   * Pathway was updated successfully
   * @deprecated This field is experimental and subject to breaking changes.
   */
  Updated = 'UPDATED'
}

/** Update the PagerDuty platform */
export type IncidentIntelligencePlatformUpdatePlatformPagerDuty = {
  __typename?: 'IncidentIntelligencePlatformUpdatePlatformPagerDuty';
  /**
   * Platform to be used as source/destination
   * @deprecated This field is experimental and subject to breaking changes.
   */
  platform?: Maybe<IncidentIntelligencePlatformPlatform>;
  /**
   * Result of platform fetch
   * @deprecated This field is experimental and subject to breaking changes.
   */
  reason?: Maybe<IncidentIntelligencePlatformPlatformResult>;
  /**
   * A list of the required capabilities that the user is missing
   * @deprecated This field is experimental and subject to breaking changes.
   */
  userMissingCapabilities?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
};

/** Result of setting a user as admin in platform */
export enum IncidentIntelligencePlatformUserSetAsAdminResult {
  /**
   * The user is missing some capabilities
   * @deprecated This field is experimental and subject to breaking changes.
   */
  MissingCapabilities = 'MISSING_CAPABILITIES',
  /**
   * Platform does not exist for origin given
   * @deprecated This field is experimental and subject to breaking changes.
   */
  PlatformNotFound = 'PLATFORM_NOT_FOUND',
  /**
   * User was set as pagerduty account admin
   * @deprecated This field is experimental and subject to breaking changes.
   */
  SetAsAdmin = 'SET_AS_ADMIN'
}

/** Describes the configuration of a webhook destination */
export type IncidentIntelligencePlatformWebHookDestinationConfigurationInput = {
  /** Headers to add to webhook request */
  headers: Array<InputMaybe<IncidentIntelligencePlatformHeaderInput>>;
  /** Destination name */
  name: Scalars['String']['input'];
  /** Priority mapping between NRAI issue priority and webhook destination priority */
  priorityMapping: Array<InputMaybe<IncidentIntelligencePlatformPriorityMappingInput>>;
  /** Webhook request schema */
  requestSchema: Scalars['String']['input'];
  /** Webhook url */
  url: Scalars['String']['input'];
};

/** Describes the configuration of a webhook destination */
export type IncidentIntelligencePlatformWebHookDestinationConfigurationOutput = {
  __typename?: 'IncidentIntelligencePlatformWebHookDestinationConfigurationOutput';
  /**
   * Headers to add to webhook request
   * @deprecated This field is experimental and subject to breaking changes.
   */
  headers: Array<Maybe<IncidentIntelligencePlatformHeaderOutput>>;
  /**
   * Destination name
   * @deprecated This field is experimental and subject to breaking changes.
   */
  name: Scalars['String']['output'];
  /**
   * Priority mapping to match webhook known priorities
   * @deprecated This field is experimental and subject to breaking changes.
   */
  priorityMapping: Array<Maybe<IncidentIntelligencePlatformPriorityMappingOutput>>;
  /**
   * Webhook request schema
   * @deprecated This field is experimental and subject to breaking changes.
   */
  requestSchema: Scalars['String']['output'];
  /**
   * Webhook url
   * @deprecated This field is experimental and subject to breaking changes.
   */
  url: Scalars['String']['output'];
};

/** Describes a webhook destination */
export type IncidentIntelligencePlatformWebhookDestinationOutput = {
  __typename?: 'IncidentIntelligencePlatformWebhookDestinationOutput';
  /**
   * Destination behaviour configuration
   * @deprecated This field is experimental and subject to breaking changes.
   */
  configuration: IncidentIntelligencePlatformWebHookDestinationConfigurationOutput;
  /**
   * Reason webhook was disabled
   * @deprecated This field is experimental and subject to breaking changes.
   */
  disableReason?: Maybe<Scalars['String']['output']>;
  /**
   * Destination unique identifier
   * @deprecated This field is experimental and subject to breaking changes.
   */
  id: Scalars['String']['output'];
};

export type IncidentIntelligenceSearchAccountStitchedFields = {
  __typename?: 'IncidentIntelligenceSearchAccountStitchedFields';
  /**
   * Fetch incidents
   * @deprecated This field is experimental and subject to breaking changes.
   */
  incidents?: Maybe<IncidentIntelligenceSearchIncidentsResponse>;
  /**
   * Fetch issues
   * @deprecated This field is experimental and subject to breaking changes.
   */
  issues?: Maybe<IncidentIntelligenceSearchIssuesResponse>;
};


export type IncidentIntelligenceSearchAccountStitchedFieldsIncidentsArgs = {
  cursor?: InputMaybe<Scalars['String']['input']>;
  filters?: InputMaybe<Array<InputMaybe<IncidentIntelligenceSearchIncidentsFilterInput>>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  numberOfEvents?: InputMaybe<Scalars['Int']['input']>;
  optionalWords?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  orderBy?: InputMaybe<IncidentIntelligenceSearchIncidentsOrderByOptions>;
  query?: InputMaybe<IncidentIntelligenceSearchIncidentsQueryInput>;
};


export type IncidentIntelligenceSearchAccountStitchedFieldsIssuesArgs = {
  cursor?: InputMaybe<Scalars['String']['input']>;
  filters?: InputMaybe<Array<InputMaybe<IncidentIntelligenceSearchIssuesFilterInput>>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  optionalWords?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  orderBy?: InputMaybe<IncidentIntelligenceSearchIssuesOrderByOptions>;
  query?: InputMaybe<IncidentIntelligenceSearchIssuesQueryInput>;
};

/** The accumulation name & value pair for an Incident */
export type IncidentIntelligenceSearchAccumulationPair = {
  __typename?: 'IncidentIntelligenceSearchAccumulationPair';
  /**
   * Accumulation name
   * @deprecated This field is experimental and subject to breaking changes.
   */
  accumulationName: Scalars['String']['output'];
  /**
   * Accumulation value
   * @deprecated This field is experimental and subject to breaking changes.
   */
  value?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
};

/** An attribute name and value pair */
export type IncidentIntelligenceSearchAttributesPair = {
  __typename?: 'IncidentIntelligenceSearchAttributesPair';
  /**
   * Name of the attribute
   * @deprecated This field is experimental and subject to breaking changes.
   */
  attributeName: Scalars['String']['output'];
  /**
   * The attribute's value
   * @deprecated This field is experimental and subject to breaking changes.
   */
  value?: Maybe<Scalars['String']['output']>;
};

/** Possible comparison operators */
export enum IncidentIntelligenceSearchComparisonOperators {
  /**
   * Equals
   * @deprecated This field is experimental and subject to breaking changes.
   */
  Equals = 'EQUALS',
  /**
   * Greater than
   * @deprecated This field is experimental and subject to breaking changes.
   */
  GreaterThan = 'GREATER_THAN',
  /**
   * Greater than or equals
   * @deprecated This field is experimental and subject to breaking changes.
   */
  GreaterThanEquals = 'GREATER_THAN_EQUALS',
  /**
   * Less than
   * @deprecated This field is experimental and subject to breaking changes.
   */
  LessThan = 'LESS_THAN',
  /**
   * Less than or equals
   * @deprecated This field is experimental and subject to breaking changes.
   */
  LessThanEquals = 'LESS_THAN_EQUALS',
  /**
   * Not equals
   * @deprecated This field is experimental and subject to breaking changes.
   */
  NotEquals = 'NOT_EQUALS'
}

/** An Incident Intelligence Incident */
export type IncidentIntelligenceSearchIncident = {
  __typename?: 'IncidentIntelligenceSearchIncident';
  /**
   * The account the Incident is related to
   * @deprecated This field is experimental and subject to breaking changes.
   */
  accountId: Scalars['Int']['output'];
  /**
   * The Incident's accumulations
   * @deprecated This field is experimental and subject to breaking changes.
   */
  accumulations?: Maybe<Array<Maybe<IncidentIntelligenceSearchAccumulationPair>>>;
  /**
   * The Incident's annotations
   * @deprecated This field is experimental and subject to breaking changes.
   */
  annotations?: Maybe<IncidentIntelligenceSearchIncidentAnnotations>;
  /**
   * The date the Incident was closed (null if the Incident is still open
   * @deprecated This field is experimental and subject to breaking changes.
   */
  closedOn?: Maybe<Scalars['DateTime']['output']>;
  /**
   * The date the Incident was created
   * @deprecated This field is experimental and subject to breaking changes.
   */
  createdOn: Scalars['DateTime']['output'];
  /**
   * The Incident's description
   * @deprecated This field is experimental and subject to breaking changes.
   */
  description?: Maybe<Scalars['String']['output']>;
  /**
   * A list of the Incident's events (length can be configured with numberOfEvents)
   * @deprecated This field is experimental and subject to breaking changes.
   */
  events?: Maybe<Array<Maybe<IncidentIntelligenceSearchIncidentEvent>>>;
  /**
   * The Incident's id
   * @deprecated This field is experimental and subject to breaking changes.
   */
  id: Scalars['ID']['output'];
  /**
   * True if the issue regarding the Incident is correlated, otherwise False
   * @deprecated This field is experimental and subject to breaking changes.
   */
  isCorrelated?: Maybe<Scalars['Boolean']['output']>;
  /**
   * A list of the Incident's labels
   * @deprecated This field is experimental and subject to breaking changes.
   */
  labels?: Maybe<Array<Maybe<IncidentIntelligenceSearchIncidentLabelPair>>>;
  /**
   * The id of the latest issue the Incident is related to
   * @deprecated This field is experimental and subject to breaking changes.
   */
  latestIssueId?: Maybe<Scalars['ID']['output']>;
  /**
   * The name of the latest issue the Incident is related to
   * @deprecated This field is experimental and subject to breaking changes.
   */
  latestIssueName?: Maybe<Scalars['String']['output']>;
  /**
   * The progress report of the latest issue the Incident is related to
   * @deprecated This field is experimental and subject to breaking changes.
   */
  latestIssueProgressReport?: Maybe<Array<Maybe<IncidentIntelligenceSearchIssueProgressReportAction>>>;
  /**
   * The state of the latest issue the Incident is related to
   * @deprecated This field is experimental and subject to breaking changes.
   */
  latestIssueState?: Maybe<IncidentIntelligenceSearchIssueState>;
  /**
   * The date the Incident was last modified
   * @deprecated This field is experimental and subject to breaking changes.
   */
  modifiedOn: Scalars['DateTime']['output'];
  /**
   * The Incident's name
   * @deprecated This field is experimental and subject to breaking changes.
   */
  name?: Maybe<Scalars['String']['output']>;
  /**
   * The Incident's priority
   * @deprecated This field is experimental and subject to breaking changes.
   */
  priority: IncidentIntelligenceSearchPriority;
  /**
   * The id of the rule from which the Incident was created
   * @deprecated This field is experimental and subject to breaking changes.
   */
  ruleId: Scalars['String']['output'];
  /**
   * The state of the Incident
   * @deprecated This field is experimental and subject to breaking changes.
   */
  state: IncidentIntelligenceSearchIncidentState;
  /**
   * A list of the Incident's tags
   * @deprecated This field is experimental and subject to breaking changes.
   */
  tags?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
  /**
   * The total number of events an Incident has
   * @deprecated This field is experimental and subject to breaking changes.
   */
  totalEvents: Scalars['Int']['output'];
};

/** The annotations of an Incident */
export type IncidentIntelligenceSearchIncidentAnnotations = {
  __typename?: 'IncidentIntelligenceSearchIncidentAnnotations';
  /**
   * The Incidents' description
   * @deprecated This field is experimental and subject to breaking changes.
   */
  description: Scalars['String']['output'];
  /**
   * The Incidents' title
   * @deprecated This field is experimental and subject to breaking changes.
   */
  title: Scalars['String']['output'];
};

/** An event of an Incident */
export type IncidentIntelligenceSearchIncidentEvent = {
  __typename?: 'IncidentIntelligenceSearchIncidentEvent';
  /**
   * Event attributes
   * @deprecated This field is experimental and subject to breaking changes.
   */
  attributes: Array<Maybe<IncidentIntelligenceSearchAttributesPair>>;
  /**
   * Name of event
   * @deprecated This field is experimental and subject to breaking changes.
   */
  name: Scalars['String']['output'];
  /**
   * Event text
   * @deprecated This field is experimental and subject to breaking changes.
   */
  text: Scalars['String']['output'];
  /**
   * Event timestamp
   * @deprecated This field is experimental and subject to breaking changes.
   */
  timestamp: Scalars['Float']['output'];
  /**
   * Event type
   * @deprecated This field is experimental and subject to breaking changes.
   */
  type: Scalars['String']['output'];
};

/** The labels name & value pair for an Incident */
export type IncidentIntelligenceSearchIncidentLabelPair = {
  __typename?: 'IncidentIntelligenceSearchIncidentLabelPair';
  /**
   * Name of the label
   * @deprecated This field is experimental and subject to breaking changes.
   */
  labelName: Scalars['String']['output'];
  /**
   * The label's value
   * @deprecated This field is experimental and subject to breaking changes.
   */
  value?: Maybe<Scalars['String']['output']>;
};

/** Options for the state of an Incident */
export enum IncidentIntelligenceSearchIncidentState {
  /**
   * The incident was closed
   * @deprecated This field is experimental and subject to breaking changes.
   */
  Closed = 'CLOSED',
  /**
   * The incident is currently open
   * @deprecated This field is experimental and subject to breaking changes.
   */
  Open = 'OPEN'
}

/** Possible filters fields */
export enum IncidentIntelligenceSearchIncidentsFilterFields {
  /**
   * Filter on the "modified_on" field (DateTime) , format must be "YYYY-MM-DD"
   * @deprecated This field is experimental and subject to breaking changes.
   */
  ModifiedOn = 'MODIFIED_ON',
  /**
   * Filter on the "sources" field (String)
   * @deprecated This field is experimental and subject to breaking changes.
   */
  Sources = 'SOURCES',
  /**
   * Filter on the "state" field (String)
   * @deprecated This field is experimental and subject to breaking changes.
   */
  State = 'STATE'
}

/** A filter for the Incidents query */
export type IncidentIntelligenceSearchIncidentsFilterInput = {
  /** Incident field to filter by */
  field: IncidentIntelligenceSearchIncidentsFilterFields;
  /** Comparison operator to match field type */
  operator: IncidentIntelligenceSearchComparisonOperators;
  /** Value for matching */
  value: Scalars['IncidentIntelligenceSearchFilterValue']['input'];
};

/** Possible fields to order by */
export enum IncidentIntelligenceSearchIncidentsOrderByOptions {
  /**
   * Order results by modified_on field
   * @deprecated This field is experimental and subject to breaking changes.
   */
  ModifiedOn = 'MODIFIED_ON'
}

/** The text to search for in incidents */
export type IncidentIntelligenceSearchIncidentsQueryInput = {
  /** Restrict search to title attribute only */
  restrictToTitle?: InputMaybe<Scalars['Boolean']['input']>;
  /** Free text search of issue's description or title */
  text?: InputMaybe<Scalars['String']['input']>;
};

/** Incidents fetch response */
export type IncidentIntelligenceSearchIncidentsResponse = {
  __typename?: 'IncidentIntelligenceSearchIncidentsResponse';
  /**
   * Cursor for next subsequent query
   * @deprecated This field is experimental and subject to breaking changes.
   */
  nextCursor?: Maybe<Scalars['String']['output']>;
  /**
   * Result of fetching incidents
   * @deprecated This field is experimental and subject to breaking changes.
   */
  reason?: Maybe<IncidentIntelligenceSearchIncidentsResult>;
  /**
   * Retrieved incidents
   * @deprecated This field is experimental and subject to breaking changes.
   */
  results?: Maybe<Array<Maybe<IncidentIntelligenceSearchIncident>>>;
  /**
   * A list of the required capabilities that the user is missing
   * @deprecated This field is experimental and subject to breaking changes.
   */
  userMissingCapabilities?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
};

/** Result of fetching issues */
export enum IncidentIntelligenceSearchIncidentsResult {
  /**
   * Filters were not defined correctly
   * @deprecated This field is experimental and subject to breaking changes.
   */
  BadFiltersDefinition = 'BAD_FILTERS_DEFINITION',
  /**
   * The user is missing some capabilities
   * @deprecated This field is experimental and subject to breaking changes.
   */
  MissingCapabilities = 'MISSING_CAPABILITIES',
  /**
   * No incidents were found with given parameters
   * @deprecated This field is experimental and subject to breaking changes.
   */
  NoIncidentsFound = 'NO_INCIDENTS_FOUND',
  /**
   * Requested events can only be a positive non-zero integer
   * @deprecated This field is experimental and subject to breaking changes.
   */
  NumberOfEventsIsLessThanOne = 'NUMBER_OF_EVENTS_IS_LESS_THAN_ONE',
  /**
   * Incidents were retrieved successfully
   * @deprecated This field is experimental and subject to breaking changes.
   */
  Success = 'SUCCESS'
}

/** A New Relic AI Issue */
export type IncidentIntelligenceSearchIssue = {
  __typename?: 'IncidentIntelligenceSearchIssue';
  /**
   * The id of the account that the Issue is related to
   * @deprecated This field is experimental and subject to breaking changes.
   */
  accountId: Scalars['Int']['output'];
  /**
   * A list of the Issue's accumulations
   * @deprecated This field is experimental and subject to breaking changes.
   */
  accumulations?: Maybe<Array<Maybe<IncidentIntelligenceSearchAccumulationPair>>>;
  /**
   * The time the Issue was activated
   * @deprecated This field is experimental and subject to breaking changes.
   */
  activeSince?: Maybe<Scalars['DateTime']['output']>;
  /**
   * The annotations of the Issue
   * @deprecated This field is experimental and subject to breaking changes.
   */
  annotations?: Maybe<IncidentIntelligenceSearchIssueAnnotation>;
  /**
   * The time the Issue was closed
   * @deprecated This field is experimental and subject to breaking changes.
   */
  closedOn?: Maybe<Scalars['DateTime']['output']>;
  /**
   * The reason the the Issue was closed
   * @deprecated This field is experimental and subject to breaking changes.
   */
  closingReason?: Maybe<IncidentIntelligenceSearchIssueClosingReason>;
  /**
   * The AI that the correlated incidents are related
   * @deprecated This field is experimental and subject to breaking changes.
   */
  confidence?: Maybe<Scalars['Float']['output']>;
  /**
   * The time the Issue was created
   * @deprecated This field is experimental and subject to breaking changes.
   */
  createdOn: Scalars['DateTime']['output'];
  /**
   * The description of the Issue
   * @deprecated This field is experimental and subject to breaking changes.
   */
  description?: Maybe<Scalars['String']['output']>;
  /**
   * The id of the Issue
   * @deprecated This field is experimental and subject to breaking changes.
   */
  id: Scalars['ID']['output'];
  /**
   * The number of Incidents related to this Issue
   * @deprecated This field is experimental and subject to breaking changes.
   */
  incidentCount?: Maybe<Scalars['Int']['output']>;
  /**
   * The IDs of the Incidents related to the Issue
   * @deprecated This field is experimental and subject to breaking changes.
   */
  incidentIds: Array<Maybe<Scalars['String']['output']>>;
  /**
   * True if the Issue was correlated
   * @deprecated This field is experimental and subject to breaking changes.
   */
  isCorrelated?: Maybe<Scalars['Boolean']['output']>;
  /**
   * The labels of the Issues' Incidents
   * @deprecated This field is experimental and subject to breaking changes.
   */
  labelsSet?: Maybe<Array<Maybe<Array<Maybe<IncidentIntelligenceSearchIncidentLabelPair>>>>>;
  /**
   * The time the Issue was last modified
   * @deprecated This field is experimental and subject to breaking changes.
   */
  modifiedOn: Scalars['DateTime']['output'];
  /**
   * The IDs of the pathways this Issue matched
   * @deprecated This field is experimental and subject to breaking changes.
   */
  pathways?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
  /**
   * The previous state of the Issue
   * @deprecated This field is experimental and subject to breaking changes.
   */
  previousState?: Maybe<IncidentIntelligenceSearchIssueState>;
  /**
   * The priority of the Issue
   * @deprecated This field is experimental and subject to breaking changes.
   */
  priority?: Maybe<IncidentIntelligenceSearchPriority>;
  /**
   * A list creating the Issues' progress report
   * @deprecated This field is experimental and subject to breaking changes.
   */
  progressReport?: Maybe<Array<Maybe<IncidentIntelligenceSearchIssueProgressReportAction>>>;
  /**
   * The id of the rule from which the Issue was created
   * @deprecated This field is experimental and subject to breaking changes.
   */
  ruleId?: Maybe<Scalars['String']['output']>;
  /**
   * All the sources of all the Incidents in this Issue
   * @deprecated This field is experimental and subject to breaking changes.
   */
  sources?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
  /**
   * The state of the issue
   * @deprecated This field is experimental and subject to breaking changes.
   */
  state: IncidentIntelligenceSearchIssueState;
  /**
   * A list of the Issue's tags
   * @deprecated This field is experimental and subject to breaking changes.
   */
  tags?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
};

/** The origin of the action */
export enum IncidentIntelligenceSearchIssueActionOriginType {
  /**
   * system
   * @deprecated This field is experimental and subject to breaking changes.
   */
  System = 'SYSTEM',
  /**
   * user
   * @deprecated This field is experimental and subject to breaking changes.
   */
  User = 'USER'
}

/** The annotations of an Issue */
export type IncidentIntelligenceSearchIssueAnnotation = {
  __typename?: 'IncidentIntelligenceSearchIssueAnnotation';
  /**
   * A description of the Issue
   * @deprecated This field is experimental and subject to breaking changes.
   */
  description: Scalars['String']['output'];
  /**
   * The latest date on of the Incidents related to the Issue was modified
   * @deprecated This field is experimental and subject to breaking changes.
   */
  incidentsMaxModifiedOn?: Maybe<Scalars['DateTime']['output']>;
  /**
   * False if this Issue is a child of a different Issue
   * @deprecated This field is experimental and subject to breaking changes.
   */
  isRootIssue?: Maybe<Scalars['Boolean']['output']>;
  /**
   * The title of the Issue
   * @deprecated This field is experimental and subject to breaking changes.
   */
  title: Scalars['String']['output'];
};

/** The closing reason of an Issue */
export enum IncidentIntelligenceSearchIssueClosingReason {
  /**
   * The issue wasn't acknowledged
   * @deprecated This field is experimental and subject to breaking changes.
   */
  NotAcked = 'NOT_ACKED',
  /**
   * The issue is resolved
   * @deprecated This field is experimental and subject to breaking changes.
   */
  Resolved = 'RESOLVED',
  /**
   * The issue was automatically closed by the system
   * @deprecated This field is experimental and subject to breaking changes.
   */
  System = 'SYSTEM'
}

/** An action in the Progress Report of an Issue */
export type IncidentIntelligenceSearchIssueProgressReportAction = {
  __typename?: 'IncidentIntelligenceSearchIssueProgressReportAction';
  /**
   * Timestamp for when the action invoked
   * @deprecated This field is experimental and subject to breaking changes.
   */
  actionTimestamp: Scalars['Float']['output'];
  /**
   * Attributes for the action
   * @deprecated This field is experimental and subject to breaking changes.
   */
  attributes?: Maybe<Array<Maybe<IncidentIntelligenceSearchAttributesPair>>>;
  /**
   * The type of event
   * @deprecated This field is experimental and subject to breaking changes.
   */
  eventType: Scalars['String']['output'];
  /**
   * The ID of the entity that performed the action
   * @deprecated This field is experimental and subject to breaking changes.
   */
  originId?: Maybe<Scalars['String']['output']>;
  /**
   * The entity type performing the operation
   * @deprecated This field is experimental and subject to breaking changes.
   */
  originType: IncidentIntelligenceSearchIssueActionOriginType;
  /**
   * The id of the pathway the action occurred on
   * @deprecated This field is experimental and subject to breaking changes.
   */
  pathwayId?: Maybe<Scalars['String']['output']>;
  /**
   * Timestamp of the action
   * @deprecated This field is experimental and subject to breaking changes.
   */
  timestamp: Scalars['Float']['output'];
};

/** Options for the state of an Issue */
export enum IncidentIntelligenceSearchIssueState {
  /**
   * The issue was acknowledged
   * @deprecated This field is experimental and subject to breaking changes.
   */
  Acknowledged = 'ACKNOWLEDGED',
  /**
   * The issue is currently active
   * @deprecated This field is experimental and subject to breaking changes.
   */
  Active = 'ACTIVE',
  /**
   * The issue is closed
   * @deprecated This field is experimental and subject to breaking changes.
   */
  Closed = 'CLOSED',
  /**
   * The issue was created
   * @deprecated This field is experimental and subject to breaking changes.
   */
  Created = 'CREATED'
}

/** Possible filter fields */
export enum IncidentIntelligenceSearchIssuesFilterFields {
  /**
   * Filter on the "categories" field (String)
   * @deprecated This field is experimental and subject to breaking changes.
   */
  Categories = 'CATEGORIES',
  /**
   * Filter on the "closing_reason" field (String)
   * @deprecated This field is experimental and subject to breaking changes.
   */
  ClosingReason = 'CLOSING_REASON',
  /**
   * Filter on the "correlation_rules" field (String)
   * @deprecated This field is experimental and subject to breaking changes.
   */
  CorrelationRules = 'CORRELATION_RULES',
  /**
   * Filter on the "has_feedback" field (Boolean)
   * @deprecated This field is experimental and subject to breaking changes.
   */
  HasFeedback = 'HAS_FEEDBACK',
  /**
   * Filter on the "incident_count" field (Integer)
   * @deprecated This field is experimental and subject to breaking changes.
   */
  IncidentCount = 'INCIDENT_COUNT',
  /**
   * Filter on the "is_correlated" field (String)
   * @deprecated This field is experimental and subject to breaking changes.
   */
  IsCorrelated = 'IS_CORRELATED',
  /**
   * Filter on the "is_followed" field (Boolean)
   * @deprecated This field is experimental and subject to breaking changes.
   */
  IsFollowed = 'IS_FOLLOWED',
  /**
   * Filter on the "is_snoozed" field (Boolean)
   * @deprecated This field is experimental and subject to breaking changes.
   */
  IsSnoozed = 'IS_SNOOZED',
  /**
   * Filter on the "modified_on" field (DateTime), format must be "YYYY-MM-DD"
   * @deprecated This field is experimental and subject to breaking changes.
   */
  ModifiedOn = 'MODIFIED_ON',
  /**
   * Filter on the "notification_endpoints" field (String)
   * @deprecated This field is experimental and subject to breaking changes.
   */
  NotificationEndpoints = 'NOTIFICATION_ENDPOINTS',
  /**
   * Filter on the "priority" field (String)
   * @deprecated This field is experimental and subject to breaking changes.
   */
  Priority = 'PRIORITY',
  /**
   * Filter on the "share_endpoints" field (String)
   * @deprecated This field is experimental and subject to breaking changes.
   */
  ShareEndpoints = 'SHARE_ENDPOINTS',
  /**
   * Filter on the "sources" field (String)
   * @deprecated This field is experimental and subject to breaking changes.
   */
  Sources = 'SOURCES',
  /**
   * Filter on the "state" field (String)
   * @deprecated This field is experimental and subject to breaking changes.
   */
  State = 'STATE',
  /**
   * Filter on the "teams" field (String)
   * @deprecated This field is experimental and subject to breaking changes.
   */
  Teams = 'TEAMS',
  /**
   * Filter on the "was_shared" field (Boolean)
   * @deprecated This field is experimental and subject to breaking changes.
   */
  WasShared = 'WAS_SHARED'
}

/** A filter for the Issues query */
export type IncidentIntelligenceSearchIssuesFilterInput = {
  /** Issue field to filter by */
  field: IncidentIntelligenceSearchIssuesFilterFields;
  /** Comparison operator to match field type */
  operator: IncidentIntelligenceSearchComparisonOperators;
  /** Value to be matched */
  value: Scalars['IncidentIntelligenceSearchFilterValue']['input'];
};

/** Possible fields to order by */
export enum IncidentIntelligenceSearchIssuesOrderByOptions {
  /**
   * Order results by the "modified_on" field
   * @deprecated This field is experimental and subject to breaking changes.
   */
  ModifiedOn = 'MODIFIED_ON'
}

/** The text to search for in issues */
export type IncidentIntelligenceSearchIssuesQueryInput = {
  /** Restrict search to title attribute only */
  restrictToTitle?: InputMaybe<Scalars['Boolean']['input']>;
  /** Free text search of issue's description or title */
  text?: InputMaybe<Scalars['String']['input']>;
};

/** Issues fetch response */
export type IncidentIntelligenceSearchIssuesResponse = {
  __typename?: 'IncidentIntelligenceSearchIssuesResponse';
  /**
   * Cursor for next subsequent query
   * @deprecated This field is experimental and subject to breaking changes.
   */
  nextCursor?: Maybe<Scalars['String']['output']>;
  /**
   * Result of fetching issues
   * @deprecated This field is experimental and subject to breaking changes.
   */
  reason?: Maybe<IncidentIntelligenceSearchIssuesResult>;
  /**
   * Retrieved issues
   * @deprecated This field is experimental and subject to breaking changes.
   */
  results?: Maybe<Array<Maybe<IncidentIntelligenceSearchIssue>>>;
  /**
   * A list of the required capabilities that the user is missing
   * @deprecated This field is experimental and subject to breaking changes.
   */
  userMissingCapabilities?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
};

/** Result of fetching issues */
export enum IncidentIntelligenceSearchIssuesResult {
  /**
   * Filters were not defined correctly
   * @deprecated This field is experimental and subject to breaking changes.
   */
  BadFiltersDefinition = 'BAD_FILTERS_DEFINITION',
  /**
   * The user is missing some capabilities
   * @deprecated This field is experimental and subject to breaking changes.
   */
  MissingCapabilities = 'MISSING_CAPABILITIES',
  /**
   * No issues were found with given parameters
   * @deprecated This field is experimental and subject to breaking changes.
   */
  NoIssuesFound = 'NO_ISSUES_FOUND',
  /**
   * Issues were retrieved successfully
   * @deprecated This field is experimental and subject to breaking changes.
   */
  Success = 'SUCCESS'
}

/** Priority */
export enum IncidentIntelligenceSearchPriority {
  /**
   * critical priority
   * @deprecated This field is experimental and subject to breaking changes.
   */
  Critical = 'CRITICAL',
  /**
   * high priority
   * @deprecated This field is experimental and subject to breaking changes.
   */
  High = 'HIGH',
  /**
   * low priority
   * @deprecated This field is experimental and subject to breaking changes.
   */
  Low = 'LOW',
  /**
   * medium priority
   * @deprecated This field is experimental and subject to breaking changes.
   */
  Medium = 'MEDIUM'
}

export type InfraFilterSet = {
  __typename?: 'InfraFilterSet';
  filter?: Maybe<Scalars['EncodedInfraFilterSet']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  queryFilter?: Maybe<Scalars['EncodedInfraFilterSet']['output']>;
};

export type InfraHost = {
  __typename?: 'InfraHost';
  /** @deprecated Please use `entitySearch` and `relationships` */
  apps?: Maybe<Array<Maybe<Agent>>>;
  entity?: Maybe<EntityGuidSegments>;
  entityId?: Maybe<Scalars['String']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  statuses?: Maybe<Array<Maybe<InfraStatus>>>;
  /** Summary values will be queried for the last `duration` minutes */
  summary?: Maybe<InfraHostSummary>;
};


export type InfraHostSummaryArgs = {
  duration: Scalars['Int']['input'];
};

export type InfraHostSummary = {
  __typename?: 'InfraHostSummary';
  cpuUsage?: Maybe<SummaryValue>;
  diskUsage?: Maybe<SummaryValue>;
  loadAverage?: Maybe<SummaryValue>;
  memoryUsage?: Maybe<SummaryValue>;
};

export type InfraSearch = {
  __typename?: 'InfraSearch';
  hosts?: Maybe<Array<Maybe<InfraHost>>>;
  total?: Maybe<Scalars['Int']['output']>;
};

export type InfraStatus = {
  __typename?: 'InfraStatus';
  alertStatus?: Maybe<AlertStatus>;
  label?: Maybe<Scalars['String']['output']>;
  level?: Maybe<Scalars['String']['output']>;
  openedAt?: Maybe<Scalars['Int']['output']>;
};

/** The strategy for how we can instrument this service */
export enum InfrastructureAgentInstrumentationStrategy {
  /** Instrumentation strategy: New Relic Java Agent. InfrastructureEvent strategy value: java_apm */
  Javaapm = 'JAVAAPM',
  /** Instrumentation strategy: Java Flight Recorder. InfrastructureEvent strategy value: jfr */
  Jfr = 'JFR',
  /** Instrumentation strategy: Jafa Flight Recorder-Daemon. InfrastructureEvent strategy value: jfrd */
  Jfrd = 'JFRD',
  /** Instrumentation strategy: Java Management Extensions. InfrastructureEvent strategy value: jmx */
  Jmx = 'JMX'
}

/** An error object for command channel send. */
export type InfrastructureAgentSendCommandError = {
  __typename?: 'InfrastructureAgentSendCommandError';
  /** A message explaining what the error is about. */
  message?: Maybe<Scalars['String']['output']>;
  /** The type of error. */
  type?: Maybe<InfrastructureAgentSendCommandErrorType>;
};

/** The errors that can be returned when sending a command */
export enum InfrastructureAgentSendCommandErrorType {
  /** Too many concurrent tasks for the same GUID are being sent and we cannot process. Please serialize your requests for the given GUID. */
  ConcurrentTaskException = 'CONCURRENT_TASK_EXCEPTION',
  /** Domain Type invalid. The decoded domain type from the provided GUID is not valid. Please provide a correct GUID. */
  InvalidDomainType = 'INVALID_DOMAIN_TYPE',
  /** We could not decode the provided GUID. Entity guid needs to be base64 encoded. */
  InvalidEntityGuid = 'INVALID_ENTITY_GUID',
  /** The given GUID or tag you're looking for does not exist. */
  NotFound = 'NOT_FOUND',
  /** You've attempted to do something your Domain/EntityType is not permitted to do. Its also possible that an api key is required. */
  NotPermitted = 'NOT_PERMITTED'
}

/** The result returned when sending a command */
export type InfrastructureAgentSendCommandResult = {
  __typename?: 'InfrastructureAgentSendCommandResult';
  /** An array containing errors, if any. These are expected errors listed in SendCommandErrorType which a request should be capable of handling appropriately. */
  errors?: Maybe<Array<Maybe<InfrastructureAgentSendCommandError>>>;
  /** Whether the command submission succeeded or not. Check the "errors" list for details about any possible error */
  success: Scalars['Boolean']['output'];
};

/** A service that can be instrumented on a host */
export type InfrastructureAgentServiceDetails = {
  __typename?: 'InfrastructureAgentServiceDetails';
  /** How the process should be displayed to the user */
  displayName: Scalars['String']['output'];
  /** The GUID of the infra agent that is (or could) manage this service */
  guid: Scalars['EntityGuid']['output'];
  /** The process ID */
  processId: Scalars['String']['output'];
  /** Status of the service */
  status: InfrastructureAgentServiceStatus;
  /** Instrumentation strategy for this service */
  strategy: InfrastructureAgentInstrumentationStrategy;
};

/** The status of an individual service */
export enum InfrastructureAgentServiceStatus {
  /** The service is being instrumented */
  Instrumented = 'INSTRUMENTED',
  /** Known service status */
  Known = 'KNOWN'
}

/** A service to be instrumented on a host */
export type InfrastructureAgentTargetDetails = {
  /** The process ID */
  processId: Scalars['String']['input'];
  /** Status of the service */
  status: InfrastructureAgentServiceStatus;
  /** Instrumentation strategy for this service */
  strategy: InfrastructureAgentInstrumentationStrategy;
};

/** An AWS Lambda Function entity. */
export type InfrastructureAwsLambdaFunctionEntity = AlertableEntity & Entity & InfrastructureIntegrationEntity & {
  __typename?: 'InfrastructureAwsLambdaFunctionEntity';
  account?: Maybe<AccountOutline>;
  /** The New Relic account ID associated with this entity. */
  accountId?: Maybe<Scalars['Int']['output']>;
  /** The current alerting severity of the entity. */
  alertSeverity?: Maybe<EntityAlertSeverity>;
  /**
   * The alert status of the entity.
   * @deprecated Please use `alertSeverity` and `reporting`
   */
  alertStatus?: Maybe<EntityAlertStatus>;
  /** Violations on the entity that were open during the specified time window. This will return up to 500 violations - if there are more in the time window selected, you must narrow the time window or look at fewer entities. */
  alertViolations?: Maybe<Array<Maybe<EntityAlertViolation>>>;
  /**
   * Query upstream and downstream dependencies for an entity
   * @deprecated This field is experimental and subject to breaking changes.
   */
  connections?: Maybe<RelatedExternalsEntityResult>;
  /** Retrieve the deployment event(s). Ordered by timestamp DESC. */
  deploymentSearch?: Maybe<ChangeTrackingDeploymentSearchResult>;
  /** The entity's domain */
  domain?: Maybe<Scalars['String']['output']>;
  /** A value representing the combination of the entity's domain and type. */
  entityType?: Maybe<EntityType>;
  /** The date of last time the entity has updated any of its fields. */
  firstIndexedAt?: Maybe<Scalars['EpochMilliseconds']['output']>;
  /** The list of golden metrics for a specific entity */
  goldenMetrics?: Maybe<EntityGoldenContextScopedGoldenMetrics>;
  /**
   * For the golden signal on this entity, show correlated signals from related entities.
   * Well inspect the golden signals for all related entities and return a sorted list.
   * You can also filter the results.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  goldenSignalCorrelations?: Maybe<GoldenSignalCorrelationResult>;
  /**
   * The deviation from normal of golden signal(s) for the given entity.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  goldenSignalDeviations?: Maybe<Array<Maybe<GoldenSignalSignalDeviation>>>;
  /**
   * The stored golden signal(s) for the given entity.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  goldenSignalValues?: Maybe<GoldenSignalValues>;
  /**
   * The stored golden signal(s) for the given entity. To be removed, use goldenSignalValues instead.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  goldenSignalValuesV2?: Maybe<GoldenSignalValues>;
  /** The list of golden tags for a specific entityType. */
  goldenTags?: Maybe<EntityGoldenContextScopedGoldenTags>;
  /** A unique entity identifier. */
  guid?: Maybe<Scalars['EntityGuid']['output']>;
  /** The time the entity was indexed. */
  indexedAt?: Maybe<Scalars['EpochMilliseconds']['output']>;
  integrationTypeCode?: Maybe<Scalars['String']['output']>;
  /** The last time the entity's reporting status changed. */
  lastReportingChangeAt?: Maybe<Scalars['EpochMilliseconds']['output']>;
  /** The name of this entity. */
  name?: Maybe<Scalars['String']['output']>;
  nerdStorage?: Maybe<NerdStorageEntityScope>;
  nerdStoreCollection?: Maybe<Array<Maybe<NerdStoreCollectionMember>>>;
  nerdStoreDocument?: Maybe<Scalars['NerdStoreDocument']['output']>;
  /**
   * Make an `Entity` scoped query to NRDB with a NRQL string.
   *
   * A relevant `WHERE` clause will be added to your query to scope data to the entity in question.
   *
   * See the [NRQL Docs](https://docs.newrelic.com/docs/insights/nrql-new-relic-query-language/nrql-resources/nrql-syntax-components-functions) for more information about generating a query string.
   */
  nrdbQuery?: Maybe<NrdbResultContainer>;
  /**
   * Poll for the results of a previously-executed asychronous NRDB query.
   *
   * The `queryId` is available in the `queryProgress` data returned by the original asynchronous query.
   *
   * See [this page](https://docs.newrelic.com/docs/apis/nerdgraph/examples/async-queries-nrql-tutorial) for additional asynchronous query documentation.
   * @deprecated This field is experimental! It may change at any time.
   *
   */
  nrdbQueryProgress?: Maybe<NrdbResultContainer>;
  /** The url to the entity. */
  permalink?: Maybe<Scalars['String']['output']>;
  /** Recent violations on the entity. */
  recentAlertViolations?: Maybe<Array<Maybe<EntityAlertViolation>>>;
  /** The recommended service levels for the entity. */
  recommendedServiceLevel?: Maybe<ServiceLevelRecommendation>;
  /** Related dashboards results */
  relatedDashboards: RelatedDashboardsRelatedDashboardResult;
  /** Related entities result with optional filtering. */
  relatedEntities?: Maybe<EntityRelationshipRelatedEntitiesResult>;
  /**
   * Query upstream and downstream transaction dependencies for an entity
   * @deprecated This field is experimental and subject to breaking changes.
   */
  relatedTransactions?: Maybe<RelatedExternalsTransactionResult>;
  /** Relationship traversal results with optional filtering. WARNING: this query is still experimental, and subject to breaking changes. */
  relationshipTraversal?: Maybe<EntityRelationshipTraversalResult>;
  /**
   * A list of the entities' relationships.
   *
   * For more information, visit [our docs](https://docs.newrelic.com/docs/apis/graphql-api/tutorials/graphql-relationships-api-tutorial).
   * @deprecated This field is deprecated! Please use `relatedEntities`.
   */
  relationships?: Maybe<Array<Maybe<EntityRelationship>>>;
  /** The reporting status of the entity. If New Relic is successfully collecting data from your application, this will be true. */
  reporting?: Maybe<Scalars['Boolean']['output']>;
  runtime?: Maybe<Scalars['String']['output']>;
  /** The service level defined for the entity. */
  serviceLevel?: Maybe<ServiceLevelDefinition>;
  /** The list of summary metrics. */
  summaryMetrics?: Maybe<Array<Maybe<EntitySummaryMetric>>>;
  /**
   * The tags applied to the entity.
   *
   * For details on tags, as well as query and mutation examples, visit [our docs](https://docs.newrelic.com/docs/apis/graphql-api/tutorials/graphql-tagging-api-tutorial).
   */
  tags?: Maybe<Array<Maybe<EntityTag>>>;
  /** The tags applied to the entity with their metadata. */
  tagsWithMetadata?: Maybe<Array<Maybe<EntityTagWithMetadata>>>;
  /** Look up Distributed Tracing summary data for the selected `EntityGuid` */
  tracingSummary?: Maybe<DistributedTracingEntityTracingSummary>;
  /** The entity's type */
  type?: Maybe<Scalars['String']['output']>;
  /** List of templates availables for this entity. */
  uiTemplates?: Maybe<Array<EntityDashboardTemplatesUi>>;
};


/** An AWS Lambda Function entity. */
export type InfrastructureAwsLambdaFunctionEntityAlertViolationsArgs = {
  endTime: Scalars['EpochMilliseconds']['input'];
  startTime: Scalars['EpochMilliseconds']['input'];
};


/** An AWS Lambda Function entity. */
export type InfrastructureAwsLambdaFunctionEntityConnectionsArgs = {
  timeWindow?: InputMaybe<TimeWindowInput>;
};


/** An AWS Lambda Function entity. */
export type InfrastructureAwsLambdaFunctionEntityDeploymentSearchArgs = {
  filter?: InputMaybe<ChangeTrackingSearchFilter>;
};


/** An AWS Lambda Function entity. */
export type InfrastructureAwsLambdaFunctionEntityGoldenMetricsArgs = {
  context?: InputMaybe<EntityGoldenContextInput>;
  timeWindow?: InputMaybe<EntityGoldenNrqlTimeWindowInput>;
};


/** An AWS Lambda Function entity. */
export type InfrastructureAwsLambdaFunctionEntityGoldenSignalCorrelationsArgs = {
  filter?: InputMaybe<GoldenSignalCorrelationsEntityFilter>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  timeWindow?: InputMaybe<TimeWindowInput>;
};


/** An AWS Lambda Function entity. */
export type InfrastructureAwsLambdaFunctionEntityGoldenSignalDeviationsArgs = {
  comparisonTimeWindow?: InputMaybe<TimeWindowInput>;
  evaluationTimeWindow?: InputMaybe<TimeWindowInput>;
};


/** An AWS Lambda Function entity. */
export type InfrastructureAwsLambdaFunctionEntityGoldenSignalValuesArgs = {
  timeWindow?: InputMaybe<TimeWindowInput>;
};


/** An AWS Lambda Function entity. */
export type InfrastructureAwsLambdaFunctionEntityGoldenSignalValuesV2Args = {
  timeWindow?: InputMaybe<TimeWindowInput>;
};


/** An AWS Lambda Function entity. */
export type InfrastructureAwsLambdaFunctionEntityGoldenTagsArgs = {
  context?: InputMaybe<EntityGoldenContextInput>;
};


/** An AWS Lambda Function entity. */
export type InfrastructureAwsLambdaFunctionEntityNerdStoreCollectionArgs = {
  collection: Scalars['String']['input'];
  scopeByActor?: InputMaybe<Scalars['Boolean']['input']>;
};


/** An AWS Lambda Function entity. */
export type InfrastructureAwsLambdaFunctionEntityNerdStoreDocumentArgs = {
  collection: Scalars['String']['input'];
  documentId: Scalars['String']['input'];
  scopeByActor?: InputMaybe<Scalars['Boolean']['input']>;
};


/** An AWS Lambda Function entity. */
export type InfrastructureAwsLambdaFunctionEntityNrdbQueryArgs = {
  async?: InputMaybe<Scalars['Boolean']['input']>;
  nrql: Scalars['Nrql']['input'];
  options?: InputMaybe<NrqlQueryOptions>;
  timeout?: InputMaybe<Scalars['Seconds']['input']>;
};


/** An AWS Lambda Function entity. */
export type InfrastructureAwsLambdaFunctionEntityNrdbQueryProgressArgs = {
  queryId: Scalars['ID']['input'];
};


/** An AWS Lambda Function entity. */
export type InfrastructureAwsLambdaFunctionEntityRecentAlertViolationsArgs = {
  count?: InputMaybe<Scalars['Int']['input']>;
};


/** An AWS Lambda Function entity. */
export type InfrastructureAwsLambdaFunctionEntityRelatedEntitiesArgs = {
  cursor?: InputMaybe<Scalars['String']['input']>;
  filter?: InputMaybe<EntityRelationshipEdgeFilter>;
  limit?: InputMaybe<Scalars['Int']['input']>;
};


/** An AWS Lambda Function entity. */
export type InfrastructureAwsLambdaFunctionEntityRelatedTransactionsArgs = {
  search: RelatedExternalsSearch;
  timeWindow?: InputMaybe<TimeWindowInput>;
};


/** An AWS Lambda Function entity. */
export type InfrastructureAwsLambdaFunctionEntityRelationshipTraversalArgs = {
  cursor?: InputMaybe<Scalars['String']['input']>;
  hopFilters?: InputMaybe<EntityRelationshipTraversalHopFilters>;
  hops?: InputMaybe<Scalars['Int']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
};


/** An AWS Lambda Function entity. */
export type InfrastructureAwsLambdaFunctionEntityRelationshipsArgs = {
  endTime?: InputMaybe<Scalars['EpochMilliseconds']['input']>;
  filter?: InputMaybe<EntityRelationshipFilter>;
};


/** An AWS Lambda Function entity. */
export type InfrastructureAwsLambdaFunctionEntitySummaryMetricsArgs = {
  timeWindow?: InputMaybe<TimeWindowInput>;
};


/** An AWS Lambda Function entity. */
export type InfrastructureAwsLambdaFunctionEntityTracingSummaryArgs = {
  timeWindow?: InputMaybe<TimeWindowInput>;
};

/** An AWS Lambda Function entity outline. */
export type InfrastructureAwsLambdaFunctionEntityOutline = AlertableEntityOutline & EntityOutline & InfrastructureIntegrationEntityOutline & {
  __typename?: 'InfrastructureAwsLambdaFunctionEntityOutline';
  account?: Maybe<AccountOutline>;
  /** The New Relic account ID associated with this entity. */
  accountId?: Maybe<Scalars['Int']['output']>;
  /** The current alerting severity of the entity. */
  alertSeverity?: Maybe<EntityAlertSeverity>;
  /**
   * The alert status of the entity.
   * @deprecated Please use `alertSeverity` and `reporting`
   */
  alertStatus?: Maybe<EntityAlertStatus>;
  /** The entity's domain */
  domain?: Maybe<Scalars['String']['output']>;
  /** A value representing the combination of the entity's domain and type. */
  entityType?: Maybe<EntityType>;
  /** The date of last time the entity has updated any of its fields. */
  firstIndexedAt?: Maybe<Scalars['EpochMilliseconds']['output']>;
  /** The list of golden metrics for a specific entity */
  goldenMetrics?: Maybe<EntityGoldenContextScopedGoldenMetrics>;
  /**
   * For the golden signal on this entity, show correlated signals from related entities.
   * Well inspect the golden signals for all related entities and return a sorted list.
   * You can also filter the results.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  goldenSignalCorrelations?: Maybe<GoldenSignalCorrelationResult>;
  /**
   * The deviation from normal of golden signal(s) for the given entity.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  goldenSignalDeviations?: Maybe<Array<Maybe<GoldenSignalSignalDeviation>>>;
  /**
   * The stored golden signal(s) for the given entity.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  goldenSignalValues?: Maybe<GoldenSignalValues>;
  /**
   * The stored golden signal(s) for the given entity. To be removed, use goldenSignalValues instead.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  goldenSignalValuesV2?: Maybe<GoldenSignalValues>;
  /** The list of golden tags for a specific entityType. */
  goldenTags?: Maybe<EntityGoldenContextScopedGoldenTags>;
  /** A unique entity identifier. */
  guid?: Maybe<Scalars['EntityGuid']['output']>;
  /** The time the entity was indexed. */
  indexedAt?: Maybe<Scalars['EpochMilliseconds']['output']>;
  integrationTypeCode?: Maybe<Scalars['String']['output']>;
  /** The last time the entity's reporting status changed. */
  lastReportingChangeAt?: Maybe<Scalars['EpochMilliseconds']['output']>;
  /** The name of this entity. */
  name?: Maybe<Scalars['String']['output']>;
  /** The url to the entity. */
  permalink?: Maybe<Scalars['String']['output']>;
  /** The recommended service levels for the entity. */
  recommendedServiceLevel?: Maybe<ServiceLevelRecommendation>;
  /** Related dashboards results */
  relatedDashboards: RelatedDashboardsRelatedDashboardResult;
  /** The reporting status of the entity. If New Relic is successfully collecting data from your application, this will be true. */
  reporting?: Maybe<Scalars['Boolean']['output']>;
  runtime?: Maybe<Scalars['String']['output']>;
  /** The service level defined for the entity. */
  serviceLevel?: Maybe<ServiceLevelDefinition>;
  /** The list of summary metrics. */
  summaryMetrics?: Maybe<Array<Maybe<EntitySummaryMetric>>>;
  /**
   * The tags applied to the entity.
   *
   * For details on tags, as well as query and mutation examples, visit [our docs](https://docs.newrelic.com/docs/apis/graphql-api/tutorials/graphql-tagging-api-tutorial).
   */
  tags?: Maybe<Array<Maybe<EntityTag>>>;
  /** The entity's type */
  type?: Maybe<Scalars['String']['output']>;
  /** List of templates availables for this entity. */
  uiTemplates?: Maybe<Array<EntityDashboardTemplatesUi>>;
};


/** An AWS Lambda Function entity outline. */
export type InfrastructureAwsLambdaFunctionEntityOutlineGoldenMetricsArgs = {
  context?: InputMaybe<EntityGoldenContextInput>;
  timeWindow?: InputMaybe<EntityGoldenNrqlTimeWindowInput>;
};


/** An AWS Lambda Function entity outline. */
export type InfrastructureAwsLambdaFunctionEntityOutlineGoldenSignalCorrelationsArgs = {
  filter?: InputMaybe<GoldenSignalCorrelationsEntityFilter>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  timeWindow?: InputMaybe<TimeWindowInput>;
};


/** An AWS Lambda Function entity outline. */
export type InfrastructureAwsLambdaFunctionEntityOutlineGoldenSignalDeviationsArgs = {
  comparisonTimeWindow?: InputMaybe<TimeWindowInput>;
  evaluationTimeWindow?: InputMaybe<TimeWindowInput>;
};


/** An AWS Lambda Function entity outline. */
export type InfrastructureAwsLambdaFunctionEntityOutlineGoldenSignalValuesArgs = {
  timeWindow?: InputMaybe<TimeWindowInput>;
};


/** An AWS Lambda Function entity outline. */
export type InfrastructureAwsLambdaFunctionEntityOutlineGoldenSignalValuesV2Args = {
  timeWindow?: InputMaybe<TimeWindowInput>;
};


/** An AWS Lambda Function entity outline. */
export type InfrastructureAwsLambdaFunctionEntityOutlineGoldenTagsArgs = {
  context?: InputMaybe<EntityGoldenContextInput>;
};


/** An AWS Lambda Function entity outline. */
export type InfrastructureAwsLambdaFunctionEntityOutlineSummaryMetricsArgs = {
  timeWindow?: InputMaybe<TimeWindowInput>;
};

/** An Infrastructure Host entity. */
export type InfrastructureHostEntity = AlertableEntity & Entity & {
  __typename?: 'InfrastructureHostEntity';
  account?: Maybe<AccountOutline>;
  /** The New Relic account ID associated with this entity. */
  accountId?: Maybe<Scalars['Int']['output']>;
  /** The current alerting severity of the entity. */
  alertSeverity?: Maybe<EntityAlertSeverity>;
  /**
   * The alert status of the entity.
   * @deprecated Please use `alertSeverity` and `reporting`
   */
  alertStatus?: Maybe<EntityAlertStatus>;
  /** Violations on the entity that were open during the specified time window. This will return up to 500 violations - if there are more in the time window selected, you must narrow the time window or look at fewer entities. */
  alertViolations?: Maybe<Array<Maybe<EntityAlertViolation>>>;
  /** Retrieves deployed instrumentation given a host GUID. */
  availableServices?: Maybe<Array<Maybe<InfrastructureAgentServiceDetails>>>;
  /** Retrieve the deployment event(s). Ordered by timestamp DESC. */
  deploymentSearch?: Maybe<ChangeTrackingDeploymentSearchResult>;
  /** The entity's domain */
  domain?: Maybe<Scalars['String']['output']>;
  /** A value representing the combination of the entity's domain and type. */
  entityType?: Maybe<EntityType>;
  /** The date of last time the entity has updated any of its fields. */
  firstIndexedAt?: Maybe<Scalars['EpochMilliseconds']['output']>;
  /** The list of golden metrics for a specific entity */
  goldenMetrics?: Maybe<EntityGoldenContextScopedGoldenMetrics>;
  /**
   * For the golden signal on this entity, show correlated signals from related entities.
   * Well inspect the golden signals for all related entities and return a sorted list.
   * You can also filter the results.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  goldenSignalCorrelations?: Maybe<GoldenSignalCorrelationResult>;
  /**
   * The deviation from normal of golden signal(s) for the given entity.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  goldenSignalDeviations?: Maybe<Array<Maybe<GoldenSignalSignalDeviation>>>;
  /**
   * The stored golden signal(s) for the given entity.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  goldenSignalValues?: Maybe<GoldenSignalValues>;
  /**
   * The stored golden signal(s) for the given entity. To be removed, use goldenSignalValues instead.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  goldenSignalValuesV2?: Maybe<GoldenSignalValues>;
  /** The list of golden tags for a specific entityType. */
  goldenTags?: Maybe<EntityGoldenContextScopedGoldenTags>;
  /** A unique entity identifier. */
  guid?: Maybe<Scalars['EntityGuid']['output']>;
  hostSummary?: Maybe<InfrastructureHostSummaryData>;
  /** The time the entity was indexed. */
  indexedAt?: Maybe<Scalars['EpochMilliseconds']['output']>;
  /** The last time the entity's reporting status changed. */
  lastReportingChangeAt?: Maybe<Scalars['EpochMilliseconds']['output']>;
  /** The name of this entity. */
  name?: Maybe<Scalars['String']['output']>;
  nerdStorage?: Maybe<NerdStorageEntityScope>;
  nerdStoreCollection?: Maybe<Array<Maybe<NerdStoreCollectionMember>>>;
  nerdStoreDocument?: Maybe<Scalars['NerdStoreDocument']['output']>;
  /**
   * Make an `Entity` scoped query to NRDB with a NRQL string.
   *
   * A relevant `WHERE` clause will be added to your query to scope data to the entity in question.
   *
   * See the [NRQL Docs](https://docs.newrelic.com/docs/insights/nrql-new-relic-query-language/nrql-resources/nrql-syntax-components-functions) for more information about generating a query string.
   */
  nrdbQuery?: Maybe<NrdbResultContainer>;
  /**
   * Poll for the results of a previously-executed asychronous NRDB query.
   *
   * The `queryId` is available in the `queryProgress` data returned by the original asynchronous query.
   *
   * See [this page](https://docs.newrelic.com/docs/apis/nerdgraph/examples/async-queries-nrql-tutorial) for additional asynchronous query documentation.
   * @deprecated This field is experimental! It may change at any time.
   *
   */
  nrdbQueryProgress?: Maybe<NrdbResultContainer>;
  /** The url to the entity. */
  permalink?: Maybe<Scalars['String']['output']>;
  /**
   * This endpoint attempts to find the root cause on a certain entity
   * @deprecated This field is experimental and subject to breaking changes.
   */
  rcairResults?: Maybe<RootCauseAnalysisResult>;
  /** Recent violations on the entity. */
  recentAlertViolations?: Maybe<Array<Maybe<EntityAlertViolation>>>;
  /** The recommended service levels for the entity. */
  recommendedServiceLevel?: Maybe<ServiceLevelRecommendation>;
  /** Related dashboards results */
  relatedDashboards: RelatedDashboardsRelatedDashboardResult;
  /** Related entities result with optional filtering. */
  relatedEntities?: Maybe<EntityRelationshipRelatedEntitiesResult>;
  /** Relationship traversal results with optional filtering. WARNING: this query is still experimental, and subject to breaking changes. */
  relationshipTraversal?: Maybe<EntityRelationshipTraversalResult>;
  /**
   * A list of the entities' relationships.
   *
   * For more information, visit [our docs](https://docs.newrelic.com/docs/apis/graphql-api/tutorials/graphql-relationships-api-tutorial).
   * @deprecated This field is deprecated! Please use `relatedEntities`.
   */
  relationships?: Maybe<Array<Maybe<EntityRelationship>>>;
  /** The reporting status of the entity. If New Relic is successfully collecting data from your application, this will be true. */
  reporting?: Maybe<Scalars['Boolean']['output']>;
  /** The service level defined for the entity. */
  serviceLevel?: Maybe<ServiceLevelDefinition>;
  /** The list of summary metrics. */
  summaryMetrics?: Maybe<Array<Maybe<EntitySummaryMetric>>>;
  /**
   * The tags applied to the entity.
   *
   * For details on tags, as well as query and mutation examples, visit [our docs](https://docs.newrelic.com/docs/apis/graphql-api/tutorials/graphql-tagging-api-tutorial).
   */
  tags?: Maybe<Array<Maybe<EntityTag>>>;
  /** The tags applied to the entity with their metadata. */
  tagsWithMetadata?: Maybe<Array<Maybe<EntityTagWithMetadata>>>;
  /** Look up Distributed Tracing summary data for the selected `EntityGuid` */
  tracingSummary?: Maybe<DistributedTracingEntityTracingSummary>;
  /** The entity's type */
  type?: Maybe<Scalars['String']['output']>;
  /** List of templates availables for this entity. */
  uiTemplates?: Maybe<Array<EntityDashboardTemplatesUi>>;
};


/** An Infrastructure Host entity. */
export type InfrastructureHostEntityAlertViolationsArgs = {
  endTime: Scalars['EpochMilliseconds']['input'];
  startTime: Scalars['EpochMilliseconds']['input'];
};


/** An Infrastructure Host entity. */
export type InfrastructureHostEntityDeploymentSearchArgs = {
  filter?: InputMaybe<ChangeTrackingSearchFilter>;
};


/** An Infrastructure Host entity. */
export type InfrastructureHostEntityGoldenMetricsArgs = {
  context?: InputMaybe<EntityGoldenContextInput>;
  timeWindow?: InputMaybe<EntityGoldenNrqlTimeWindowInput>;
};


/** An Infrastructure Host entity. */
export type InfrastructureHostEntityGoldenSignalCorrelationsArgs = {
  filter?: InputMaybe<GoldenSignalCorrelationsEntityFilter>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  timeWindow?: InputMaybe<TimeWindowInput>;
};


/** An Infrastructure Host entity. */
export type InfrastructureHostEntityGoldenSignalDeviationsArgs = {
  comparisonTimeWindow?: InputMaybe<TimeWindowInput>;
  evaluationTimeWindow?: InputMaybe<TimeWindowInput>;
};


/** An Infrastructure Host entity. */
export type InfrastructureHostEntityGoldenSignalValuesArgs = {
  timeWindow?: InputMaybe<TimeWindowInput>;
};


/** An Infrastructure Host entity. */
export type InfrastructureHostEntityGoldenSignalValuesV2Args = {
  timeWindow?: InputMaybe<TimeWindowInput>;
};


/** An Infrastructure Host entity. */
export type InfrastructureHostEntityGoldenTagsArgs = {
  context?: InputMaybe<EntityGoldenContextInput>;
};


/** An Infrastructure Host entity. */
export type InfrastructureHostEntityNerdStoreCollectionArgs = {
  collection: Scalars['String']['input'];
  scopeByActor?: InputMaybe<Scalars['Boolean']['input']>;
};


/** An Infrastructure Host entity. */
export type InfrastructureHostEntityNerdStoreDocumentArgs = {
  collection: Scalars['String']['input'];
  documentId: Scalars['String']['input'];
  scopeByActor?: InputMaybe<Scalars['Boolean']['input']>;
};


/** An Infrastructure Host entity. */
export type InfrastructureHostEntityNrdbQueryArgs = {
  async?: InputMaybe<Scalars['Boolean']['input']>;
  nrql: Scalars['Nrql']['input'];
  options?: InputMaybe<NrqlQueryOptions>;
  timeout?: InputMaybe<Scalars['Seconds']['input']>;
};


/** An Infrastructure Host entity. */
export type InfrastructureHostEntityNrdbQueryProgressArgs = {
  queryId: Scalars['ID']['input'];
};


/** An Infrastructure Host entity. */
export type InfrastructureHostEntityRcairResultsArgs = {
  requestId: Scalars['String']['input'];
};


/** An Infrastructure Host entity. */
export type InfrastructureHostEntityRecentAlertViolationsArgs = {
  count?: InputMaybe<Scalars['Int']['input']>;
};


/** An Infrastructure Host entity. */
export type InfrastructureHostEntityRelatedEntitiesArgs = {
  cursor?: InputMaybe<Scalars['String']['input']>;
  filter?: InputMaybe<EntityRelationshipEdgeFilter>;
  limit?: InputMaybe<Scalars['Int']['input']>;
};


/** An Infrastructure Host entity. */
export type InfrastructureHostEntityRelationshipTraversalArgs = {
  cursor?: InputMaybe<Scalars['String']['input']>;
  hopFilters?: InputMaybe<EntityRelationshipTraversalHopFilters>;
  hops?: InputMaybe<Scalars['Int']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
};


/** An Infrastructure Host entity. */
export type InfrastructureHostEntityRelationshipsArgs = {
  endTime?: InputMaybe<Scalars['EpochMilliseconds']['input']>;
  filter?: InputMaybe<EntityRelationshipFilter>;
};


/** An Infrastructure Host entity. */
export type InfrastructureHostEntitySummaryMetricsArgs = {
  timeWindow?: InputMaybe<TimeWindowInput>;
};


/** An Infrastructure Host entity. */
export type InfrastructureHostEntityTracingSummaryArgs = {
  timeWindow?: InputMaybe<TimeWindowInput>;
};

/** An Infrastructure Host entity outline. */
export type InfrastructureHostEntityOutline = AlertableEntityOutline & EntityOutline & {
  __typename?: 'InfrastructureHostEntityOutline';
  account?: Maybe<AccountOutline>;
  /** The New Relic account ID associated with this entity. */
  accountId?: Maybe<Scalars['Int']['output']>;
  /** The current alerting severity of the entity. */
  alertSeverity?: Maybe<EntityAlertSeverity>;
  /**
   * The alert status of the entity.
   * @deprecated Please use `alertSeverity` and `reporting`
   */
  alertStatus?: Maybe<EntityAlertStatus>;
  /** The entity's domain */
  domain?: Maybe<Scalars['String']['output']>;
  /** A value representing the combination of the entity's domain and type. */
  entityType?: Maybe<EntityType>;
  /** The date of last time the entity has updated any of its fields. */
  firstIndexedAt?: Maybe<Scalars['EpochMilliseconds']['output']>;
  /** The list of golden metrics for a specific entity */
  goldenMetrics?: Maybe<EntityGoldenContextScopedGoldenMetrics>;
  /**
   * For the golden signal on this entity, show correlated signals from related entities.
   * Well inspect the golden signals for all related entities and return a sorted list.
   * You can also filter the results.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  goldenSignalCorrelations?: Maybe<GoldenSignalCorrelationResult>;
  /**
   * The deviation from normal of golden signal(s) for the given entity.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  goldenSignalDeviations?: Maybe<Array<Maybe<GoldenSignalSignalDeviation>>>;
  /**
   * The stored golden signal(s) for the given entity.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  goldenSignalValues?: Maybe<GoldenSignalValues>;
  /**
   * The stored golden signal(s) for the given entity. To be removed, use goldenSignalValues instead.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  goldenSignalValuesV2?: Maybe<GoldenSignalValues>;
  /** The list of golden tags for a specific entityType. */
  goldenTags?: Maybe<EntityGoldenContextScopedGoldenTags>;
  /** A unique entity identifier. */
  guid?: Maybe<Scalars['EntityGuid']['output']>;
  hostSummary?: Maybe<InfrastructureHostSummaryData>;
  /** The time the entity was indexed. */
  indexedAt?: Maybe<Scalars['EpochMilliseconds']['output']>;
  /** The last time the entity's reporting status changed. */
  lastReportingChangeAt?: Maybe<Scalars['EpochMilliseconds']['output']>;
  /** The name of this entity. */
  name?: Maybe<Scalars['String']['output']>;
  /** The url to the entity. */
  permalink?: Maybe<Scalars['String']['output']>;
  /** The recommended service levels for the entity. */
  recommendedServiceLevel?: Maybe<ServiceLevelRecommendation>;
  /** Related dashboards results */
  relatedDashboards: RelatedDashboardsRelatedDashboardResult;
  /** The reporting status of the entity. If New Relic is successfully collecting data from your application, this will be true. */
  reporting?: Maybe<Scalars['Boolean']['output']>;
  /** The service level defined for the entity. */
  serviceLevel?: Maybe<ServiceLevelDefinition>;
  /** The list of summary metrics. */
  summaryMetrics?: Maybe<Array<Maybe<EntitySummaryMetric>>>;
  /**
   * The tags applied to the entity.
   *
   * For details on tags, as well as query and mutation examples, visit [our docs](https://docs.newrelic.com/docs/apis/graphql-api/tutorials/graphql-tagging-api-tutorial).
   */
  tags?: Maybe<Array<Maybe<EntityTag>>>;
  /** The entity's type */
  type?: Maybe<Scalars['String']['output']>;
  /** List of templates availables for this entity. */
  uiTemplates?: Maybe<Array<EntityDashboardTemplatesUi>>;
};


/** An Infrastructure Host entity outline. */
export type InfrastructureHostEntityOutlineGoldenMetricsArgs = {
  context?: InputMaybe<EntityGoldenContextInput>;
  timeWindow?: InputMaybe<EntityGoldenNrqlTimeWindowInput>;
};


/** An Infrastructure Host entity outline. */
export type InfrastructureHostEntityOutlineGoldenSignalCorrelationsArgs = {
  filter?: InputMaybe<GoldenSignalCorrelationsEntityFilter>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  timeWindow?: InputMaybe<TimeWindowInput>;
};


/** An Infrastructure Host entity outline. */
export type InfrastructureHostEntityOutlineGoldenSignalDeviationsArgs = {
  comparisonTimeWindow?: InputMaybe<TimeWindowInput>;
  evaluationTimeWindow?: InputMaybe<TimeWindowInput>;
};


/** An Infrastructure Host entity outline. */
export type InfrastructureHostEntityOutlineGoldenSignalValuesArgs = {
  timeWindow?: InputMaybe<TimeWindowInput>;
};


/** An Infrastructure Host entity outline. */
export type InfrastructureHostEntityOutlineGoldenSignalValuesV2Args = {
  timeWindow?: InputMaybe<TimeWindowInput>;
};


/** An Infrastructure Host entity outline. */
export type InfrastructureHostEntityOutlineGoldenTagsArgs = {
  context?: InputMaybe<EntityGoldenContextInput>;
};


/** An Infrastructure Host entity outline. */
export type InfrastructureHostEntityOutlineSummaryMetricsArgs = {
  timeWindow?: InputMaybe<TimeWindowInput>;
};

/** Summary statistics about the Infra Host. */
export type InfrastructureHostSummaryData = {
  __typename?: 'InfrastructureHostSummaryData';
  /** Total CPU utilization as a percentage. */
  cpuUtilizationPercent?: Maybe<Scalars['Float']['output']>;
  /** The cumulative disk fullness percentage. */
  diskUsedPercent?: Maybe<Scalars['Float']['output']>;
  /** Total memory utilization as a percentage. */
  memoryUsedPercent?: Maybe<Scalars['Float']['output']>;
  /** The number of bytes per second received during the sampling period. */
  networkReceiveRate?: Maybe<Scalars['Float']['output']>;
  /** The number of bytes sent per second during the sampling period. */
  networkTransmitRate?: Maybe<Scalars['Float']['output']>;
  /** Number of services running on the host. */
  servicesCount?: Maybe<Scalars['Int']['output']>;
};

export type InfrastructureIntegrationEntity = {
  integrationTypeCode?: Maybe<Scalars['String']['output']>;
};

export type InfrastructureIntegrationEntityOutline = {
  integrationTypeCode?: Maybe<Scalars['String']['output']>;
};

export type InstallationAccountStitchedFields = {
  __typename?: 'InstallationAccountStitchedFields';
  /**
   * Look up the install event for a given account.
   * - An install event is a representation for when the newrelic-cli has attempted an installation."
   */
  installStatus?: Maybe<InstallationInstallStatus>;
  /**
   * Look up all recipe events for a given account.
   * - Recipe events are stored in our cache for any given account.
   * - Recipe events are used in the nr1-install-newrelic nerdlet to provide an overview of all the attempted installation statuses.
   */
  recipeEvents?: Maybe<Array<InstallationRecipeEvent>>;
  /** Look up recipe events for a given account by installId. */
  recipes?: Maybe<InstallationRecipeEventResult>;
  /** Look up install statuses for a given account by installId. */
  statuses?: Maybe<InstallationInstallStatusResult>;
};


export type InstallationAccountStitchedFieldsRecipesArgs = {
  cursor?: InputMaybe<Scalars['String']['input']>;
  installId?: InputMaybe<Scalars['String']['input']>;
};


export type InstallationAccountStitchedFieldsStatusesArgs = {
  cursor?: InputMaybe<Scalars['String']['input']>;
  installId?: InputMaybe<Scalars['String']['input']>;
};

/** An enum that represent the installation state. */
export enum InstallationInstallStateType {
  /** Defines a completed installation. */
  Completed = 'COMPLETED',
  /** Defines an installation that has been started. */
  Started = 'STARTED'
}

/** An object that contains the overall installation status that is created from within the newrelic-cli. */
export type InstallationInstallStatus = {
  __typename?: 'InstallationInstallStatus';
  /** The version of the newrelic-cli that was used for a given installation attempt. */
  cliVersion: Scalars['SemVer']['output'];
  /** Refers to the source of the installation. */
  deployedBy: Scalars['String']['output'];
  /** Whether or not the installation is using a proxy. */
  enabledProxy: Scalars['Boolean']['output'];
  /** The error returned for a given installation attempt. */
  error: InstallationStatusError;
  /** The host name of the customer's machine. */
  hostName: Scalars['String']['output'];
  /** The unique ID that corresponds to an install status. */
  installId: Scalars['ID']['output'];
  /** The version of the open-install-library that is being used. */
  installLibraryVersion: Scalars['SemVer']['output'];
  /** Whether or not the installation is supported on the host machine. */
  isUnsupported: Scalars['Boolean']['output'];
  /** The kernel architecture of the customer's machine. */
  kernelArch: Scalars['String']['output'];
  /** The kernel version of the customer's machine. */
  kernelVersion: Scalars['SemVer']['output'];
  /** The path to the log file on the customer's host. */
  logFilePath: Scalars['String']['output'];
  /** The OS of the customer's machine. */
  os: Scalars['String']['output'];
  /** The platform name provided by the open-install-library. */
  platform: Scalars['String']['output'];
  /** The platform family name provided by the open-install-library. */
  platformFamily: Scalars['String']['output'];
  /** The platform version provided by the open-install-library. */
  platformVersion: Scalars['SemVer']['output'];
  /** A URL generated by the newrelic-cli that redirects to the appropriate entity once an installation is complete. */
  redirectUrl: Scalars['String']['output'];
  /** The state of the installation. */
  state: InstallationInstallStateType;
  /** Whether or not the installation is a targeted install. */
  targetedInstall: Scalars['Boolean']['output'];
  /** The timestamp for when the install event occurred. */
  timestamp?: Maybe<Scalars['EpochSeconds']['output']>;
};

/** An object that contains the overall installation status to be created. */
export type InstallationInstallStatusInput = {
  /** The version of the newrelic-cli that was used for a given installation attempt. */
  cliVersion: Scalars['SemVer']['input'];
  /** Refers to the source of the installation. */
  deployedBy?: InputMaybe<Scalars['String']['input']>;
  /** Whether or not the installation is using a proxy. */
  enabledProxy: Scalars['Boolean']['input'];
  /** The error for a given installation attempt. */
  error: InstallationStatusErrorInput;
  /** The host name of the customer's machine. */
  hostName: Scalars['String']['input'];
  /** The unique ID that corresponds to an install status. */
  installId: Scalars['ID']['input'];
  /** The version of the open-install-library that is being used. */
  installLibraryVersion: Scalars['SemVer']['input'];
  /** Whether or not the installation is supported on the host machine. */
  isUnsupported: Scalars['Boolean']['input'];
  /** The kernel architecture of the customer's machine. */
  kernelArch: Scalars['String']['input'];
  /** The kernel version of the customer's machine. */
  kernelVersion: Scalars['SemVer']['input'];
  /** The path to the log file on the customer's host. */
  logFilePath: Scalars['String']['input'];
  /** The OS of the customer's machine. */
  os: Scalars['String']['input'];
  /** The platform name provided by the open-install-library. */
  platform: Scalars['String']['input'];
  /** The platform family name provided by the open-install-library. */
  platformFamily: Scalars['String']['input'];
  /** The platform version provided by the open-install-library. */
  platformVersion: Scalars['SemVer']['input'];
  /** A URL generated by the newrelic-cli that redirects to the appropriate entity once an installation is complete. */
  redirectUrl: Scalars['String']['input'];
  /** The state of the installation. */
  state: InstallationInstallStateType;
  /** Whether or not the installation is a targeted install. */
  targetedInstall: Scalars['Boolean']['input'];
  /** The timestamp for when the install event occurred. */
  timestamp?: InputMaybe<Scalars['EpochSeconds']['input']>;
};

/** A wrapper object that contains paginated install statuses along with counts and a pagination cursor */
export type InstallationInstallStatusResult = {
  __typename?: 'InstallationInstallStatusResult';
  /** Cursor for fetching next page of results.  Results are ordered by descending timestamp (most recent first) */
  cursor?: Maybe<Scalars['String']['output']>;
  /** List of InstallStatus objects */
  installStatuses?: Maybe<Array<InstallationInstallStatus>>;
  /** Total number of InstallStatus results across all pages for a given query */
  totalCount?: Maybe<Scalars['Int']['output']>;
};

/** An object that contains an installation event created from within the newrelic-cli. */
export type InstallationRecipeEvent = {
  __typename?: 'InstallationRecipeEvent';
  /** The version of the newrelic-cli that was used for a given recipe. */
  cliVersion: Scalars['SemVer']['output'];
  /** Whether or not the recipe has been installed and all steps have been completed. */
  complete: Scalars['Boolean']['output'];
  /** The display name for a given recipe. */
  displayName: Scalars['String']['output'];
  /** The entity Guid for a given recipe. */
  entityGuid: Scalars['EntityGuid']['output'];
  /** The error returned for a given recipe. */
  error: InstallationStatusError;
  /** The host name of the customer's machine. */
  hostName: Scalars['String']['output'];
  /** The unique ID that corresponds to an install event. */
  installId?: Maybe<Scalars['ID']['output']>;
  /** The version of the open-install-library that is being used. */
  installLibraryVersion?: Maybe<Scalars['SemVer']['output']>;
  /** The kernel architecture of the customer's machine. */
  kernelArch: Scalars['String']['output'];
  /** The kernel version of the customer's machine. */
  kernelVersion: Scalars['SemVer']['output'];
  /** The path to the log file on the customer's host. */
  logFilePath: Scalars['String']['output'];
  /** Additional key:value data related to the environment where the installation occurred. */
  metadata?: Maybe<Scalars['InstallationRawMetadata']['output']>;
  /** The unique name for a given recipe. */
  name: Scalars['String']['output'];
  /** The OS of the customer's machine. */
  os: Scalars['String']['output'];
  /** The platform name provided by the open-install-library. */
  platform: Scalars['String']['output'];
  /** The platform family name provided by the open-install-library. */
  platformFamily: Scalars['String']['output'];
  /** The platform version provided by the open-install-library. */
  platformVersion: Scalars['SemVer']['output'];
  /** The redirect URL created by the CLI used for redirecting to a particular entity. */
  redirectUrl?: Maybe<Scalars['String']['output']>;
  /** The status for a given recipe. */
  status: InstallationRecipeStatusType;
  /** Whether or not the recipe being installed is a targeted install. */
  targetedInstall: Scalars['Boolean']['output'];
  /** The path to the installation task as defined in the open-install-library. */
  taskPath?: Maybe<Scalars['String']['output']>;
  /** The timestamp for when the recipe event occurred. */
  timestamp: Scalars['EpochSeconds']['output'];
  /** The number of milliseconds it took to validate the recipe. */
  validationDurationMilliseconds: Scalars['EpochMilliseconds']['output'];
};

/** A wrapper object that contains paginated recipe events along with counts and a pagination cursor */
export type InstallationRecipeEventResult = {
  __typename?: 'InstallationRecipeEventResult';
  /** Cursor for fetching next page of results.  Results are ordered by descending timestamp (most recent first) */
  cursor?: Maybe<Scalars['String']['output']>;
  /** List of RecipeEvent objects */
  recipeEvents?: Maybe<Array<InstallationRecipeEvent>>;
  /** Total number of RecipeEvent results across all pages for a given query */
  totalCount?: Maybe<Scalars['Int']['output']>;
};

/** An object that represents a recipe status. */
export type InstallationRecipeStatus = {
  /** The version of the newrelic-cli that was used for a given recipe. */
  cliVersion: Scalars['SemVer']['input'];
  /** Whether or not the recipe has been installed and all steps have been completed. */
  complete: Scalars['Boolean']['input'];
  /** The display name for a given recipe. */
  displayName: Scalars['String']['input'];
  /** The entity Guid for a given recipe. */
  entityGuid: Scalars['EntityGuid']['input'];
  /** The error returned for a given recipe. */
  error: InstallationStatusErrorInput;
  /** The host name of the customer's machine. */
  hostName: Scalars['String']['input'];
  /** The unique ID that corresponds to an install event. */
  installId?: InputMaybe<Scalars['ID']['input']>;
  /** The version of the open-install-library that is being used. */
  installLibraryVersion?: InputMaybe<Scalars['SemVer']['input']>;
  /** The kernel architecture of the customer's machine. */
  kernelArch: Scalars['String']['input'];
  /** The kernel version of the customer's machine. */
  kernelVersion: Scalars['SemVer']['input'];
  /** The path to the log file on the customer's host. */
  logFilePath: Scalars['String']['input'];
  /** Additional key:value data related to an error or related to the environment where the installation occurred. */
  metadata?: InputMaybe<Scalars['InstallationRawMetadata']['input']>;
  /** The unique name for a given recipe. */
  name: Scalars['String']['input'];
  /** The OS of the customer's machine. */
  os: Scalars['String']['input'];
  /** The platform name provided by the open-install-library. */
  platform: Scalars['String']['input'];
  /** The platform family name provided by the open-install-library. */
  platformFamily: Scalars['String']['input'];
  /** The platform version provided by the open-install-library. */
  platformVersion: Scalars['SemVer']['input'];
  /** The redirect URL created by the CLI used for redirecting to a particular entity. */
  redirectUrl?: InputMaybe<Scalars['String']['input']>;
  /** The status for a given recipe. */
  status: InstallationRecipeStatusType;
  /** Whether or not the recipe being installed is a targeted install. */
  targetedInstall: Scalars['Boolean']['input'];
  /** The path to the installation task as defined in the open-install-library. */
  taskPath?: InputMaybe<Scalars['String']['input']>;
  /** The number of milliseconds it took to validate the recipe. */
  validationDurationMilliseconds: Scalars['EpochMilliseconds']['input'];
};

/** An enum that represents the various recipe statuses. */
export enum InstallationRecipeStatusType {
  /** Defines an available recipe when attempting to install. */
  Available = 'AVAILABLE',
  /** Defines a canceled recipe when attempting to install. */
  Canceled = 'CANCELED',
  /** Defines when New Relic instrumentation compatibility is detected. */
  Detected = 'DETECTED',
  /** Defines a recipe that has failed during installation. */
  Failed = 'FAILED',
  /** Defines a recipe that has been installed. */
  Installed = 'INSTALLED',
  /** Defines a recipe currently being installed. */
  Installing = 'INSTALLING',
  /** Defines a recipe that has been recommended during installation. */
  Recommended = 'RECOMMENDED',
  /** Defines a recipe that has been skipped during installation. */
  Skipped = 'SKIPPED',
  /** Defines a recipe that is unsupported. */
  Unsupported = 'UNSUPPORTED'
}

/** An object that represents a status error whenever an recipe has failed to install. */
export type InstallationStatusError = {
  __typename?: 'InstallationStatusError';
  /** Error details, if any. */
  details?: Maybe<Scalars['String']['output']>;
  /** The actual error message. */
  message?: Maybe<Scalars['String']['output']>;
};

/** An object that represents a status error whenever an recipe has failed to install. */
export type InstallationStatusErrorInput = {
  /** Error details, if any. */
  details?: InputMaybe<Scalars['String']['input']>;
  /** The actual error message. */
  message?: InputMaybe<Scalars['String']['input']>;
};

export type InvitationsAccountStitchedFields = {
  __typename?: 'InvitationsAccountStitchedFields';
  /** Returns a list of pending UserUpgradeRequests */
  userUpgradeRequests?: Maybe<Array<Maybe<InvitationsUserUpgradeRequest>>>;
};


export type InvitationsAccountStitchedFieldsUserUpgradeRequestsArgs = {
  filter?: InputMaybe<InvitationsUserUpgradeRequestsFilterInput>;
};

/** The admins chosen response to a add user to organization request/s */
export enum InvitationsAddUserRequestAdminResponse {
  /** The user has been created */
  Created = 'CREATED',
  /** The user request has been denied */
  Denied = 'DENIED'
}

/** The details for a request to add a new user to organization */
export type InvitationsAddUserToOrganizationRequest = {
  __typename?: 'InvitationsAddUserToOrganizationRequest';
  /** The email address of the requester */
  email: Scalars['String']['output'];
  /** The organization add request id */
  id: Scalars['ID']['output'];
  /** The name of the requester */
  name: Scalars['String']['output'];
  /** The organization id the request belongs to */
  organizationId: Scalars['ID']['output'];
  /** The timestamp of when the request was received */
  timestamp: Scalars['DateTime']['output'];
};

/** The result of inviting a teammate via a mutation */
export type InvitationsInviteResponse = {
  __typename?: 'InvitationsInviteResponse';
  /** The account ID that the user is being invited to */
  accountId: Scalars['Int']['output'];
  /** ID of the invite, used for querying for existing records or updating the status later */
  id: Scalars['ID']['output'];
  /** The user being invited */
  invitee: InvitationsInvitee;
  /** The status of the invite */
  status: InvitationsInviteStatus;
};

/** The status of the mutation to invite a teammate */
export enum InvitationsInviteStatus {
  /** The invite request was successfully created. An invite request did not previously exist for the given account ID and invitee email */
  Created = 'CREATED',
  /** An invite request for the given account ID and invitee email already exists */
  Requested = 'REQUESTED',
  /** The requested invitee email already exists as a user on the account */
  UserExists = 'USER_EXISTS'
}

/** The details for a users request to invite a new user to organization */
export type InvitationsInviteUserToOrganizationRequest = {
  __typename?: 'InvitationsInviteUserToOrganizationRequest';
  /** comment of the inviter */
  comment?: Maybe<Scalars['String']['output']>;
  /** The organization invite request id */
  id: Scalars['ID']['output'];
  /** The email address of the invitee */
  inviteeEmail: Scalars['String']['output'];
  /** The name of the invitee */
  inviteeName: Scalars['String']['output'];
  /** The organization id the request belongs to */
  organizationId: Scalars['ID']['output'];
  /** Type of the request */
  requestType?: Maybe<Scalars['String']['output']>;
  /** The user id for the user that initiated the invitation */
  requesterId: Scalars['Int']['output'];
  /** The timestamp of when the request was received */
  timestamp: Scalars['DateTime']['output'];
};

/** Used to filter what requests are returned */
export type InvitationsInviteUserToOrganizationRequestsFilterInput = {
  /** The userIds to return results for */
  userIds?: InputMaybe<Array<InputMaybe<Scalars['Int']['input']>>>;
};

/** The result of inviting a teammate to organization via a mutation */
export type InvitationsInviteUserToOrganizationResponse = {
  __typename?: 'InvitationsInviteUserToOrganizationResponse';
  /** ID of the invite, used for querying for existing records or updating the status later */
  id: Scalars['ID']['output'];
  /** The status of the invite */
  status: InvitationsInviteStatus;
};

/** Details of the invited user */
export type InvitationsInvitee = {
  __typename?: 'InvitationsInvitee';
  /** Email address of the invitee */
  email: Scalars['String']['output'];
};

/** Details of the user to invite */
export type InvitationsInviteeInput = {
  /** Email address of the user */
  email: Scalars['String']['input'];
};

/** Response returned when an admin responds to AddUserToOrganizationRequests */
export type InvitationsManageAddUserToOrganizationRequestsResponse = {
  __typename?: 'InvitationsManageAddUserToOrganizationRequestsResponse';
  /** The status of the mutation call */
  status?: Maybe<Scalars['String']['output']>;
};

/** Response returned when an admin responds to InviteUserToOrganizationRequests */
export type InvitationsManageInviteUserToOrganizationRequestsResponse = {
  __typename?: 'InvitationsManageInviteUserToOrganizationRequestsResponse';
  /** The status of the mutation call */
  status?: Maybe<Scalars['String']['output']>;
};

/** Response returned when an admin responds to UserUpgradeRequests */
export type InvitationsManageUserUpgradeRequestsResponse = {
  __typename?: 'InvitationsManageUserUpgradeRequestsResponse';
  /** The status of the mutation call */
  status?: Maybe<Scalars['String']['output']>;
};

export type InvitationsOrganizationStitchedFields = {
  __typename?: 'InvitationsOrganizationStitchedFields';
  /** Returns a list of pending add user requests to organization */
  addUserToOrganizationRequests?: Maybe<Array<Maybe<InvitationsAddUserToOrganizationRequest>>>;
  /** Returns a list of pending user invite requests to organization */
  inviteUserToOrganizationRequests?: Maybe<Array<Maybe<InvitationsInviteUserToOrganizationRequest>>>;
  /** Returns count of pending invite requests to organization */
  pendingRequestsCount?: Maybe<InvitationsPendingRequestsCount>;
};


export type InvitationsOrganizationStitchedFieldsInviteUserToOrganizationRequestsArgs = {
  filter?: InputMaybe<InvitationsInviteUserToOrganizationRequestsFilterInput>;
};

/** Count of pending invite requests for the account */
export type InvitationsPendingRequestsCount = {
  __typename?: 'InvitationsPendingRequestsCount';
  /** The count of the pending invites */
  domainCapturePendingRequestCount: Scalars['Int']['output'];
  /** The count of the pending invites */
  inviteATeammatePendingRequestCount: Scalars['Int']['output'];
  /** The count of the pending invites */
  selfInvitePendingRequestCount: Scalars['Int']['output'];
  /** The count of the pending invites */
  totalPendingRequestCount: Scalars['Int']['output'];
};

/** Response returned when a user requests Full User access */
export type InvitationsRequestAccessResponse = {
  __typename?: 'InvitationsRequestAccessResponse';
  /** ID of the account to request access within */
  accountId: Scalars['Int']['output'];
  /** ID of the user that needs elevated access */
  userId: Scalars['Int']['output'];
};

/** Possible user types that a user can request access for */
export enum InvitationsRequestableUserType {
  /** basic user */
  Basic = 'BASIC',
  /** core user */
  Core = 'CORE',
  /** full platform user */
  FullPlatform = 'FULL_PLATFORM'
}

/** Information of the source */
export type InvitationsSourceInfoInput = {
  /** Channel of the request */
  channel?: InputMaybe<Scalars['String']['input']>;
  /** SubChannel of the request */
  subchannel?: InputMaybe<Scalars['String']['input']>;
};

/** The admins chosen response to a invite request/s */
export enum InvitationsUserInviteRequestAdminResponse {
  /** The user has been created */
  Created = 'CREATED',
  /** The user request has been denied */
  Denied = 'DENIED'
}

/** The details for a users request to be upgraded */
export type InvitationsUserUpgradeRequest = {
  __typename?: 'InvitationsUserUpgradeRequest';
  /** The account id the request belongs to */
  accountId: Scalars['Int']['output'];
  /** The user's tier at the time of the request */
  currentUserTier: Scalars['String']['output'];
  /** The upgrade request id */
  id: Scalars['Int']['output'];
  /** The users reason for requesting an upgrade */
  requestReason?: Maybe<Scalars['String']['output']>;
  /** The tier that the user is requesting an upgrade to */
  requestedUserTier: Scalars['String']['output'];
  /** The timestamp of when the request was received */
  timestamp: Scalars['DateTime']['output'];
  /** The users email address */
  userEmailAddress: Scalars['String']['output'];
  /** The user id for the user requesting the upgrade */
  userId: Scalars['Int']['output'];
};

/** The admins chosen response to a request/s */
export enum InvitationsUserUpgradeRequestAdminResponse {
  /** The request has been approved */
  Approved = 'APPROVED',
  /** The request has been denied */
  Denied = 'DENIED'
}

/** Used to filter what requests are returned */
export type InvitationsUserUpgradeRequestsFilterInput = {
  /** The userIds to return results for */
  userIds?: InputMaybe<Array<InputMaybe<Scalars['Int']['input']>>>;
};

/** The flamegraph built from the strack trace samples */
export type JavaFlightRecorderFlamegraph = {
  __typename?: 'JavaFlightRecorderFlamegraph';
  /** List of stack frames for the flamegraph */
  allFrames: Array<Maybe<JavaFlightRecorderStackFrame>>;
};

/** A method within the flamegraph */
export type JavaFlightRecorderStackFrame = {
  __typename?: 'JavaFlightRecorderStackFrame';
  /** The number of stack traces that this frame is in */
  count: Scalars['Int']['output'];
  /** This stackframe's id */
  id: Scalars['ID']['output'];
  /** The stackframe's class and method name */
  name: Scalars['String']['output'];
  /** This stackframe's parent id */
  parentId?: Maybe<Scalars['ID']['output']>;
};

/** The application wrapper. */
export type KeyTransactionApplication = {
  __typename?: 'KeyTransactionApplication';
  /** The application outline. */
  entity?: Maybe<EntityOutline>;
  /** The guid of the application. */
  guid: Scalars['EntityGuid']['output'];
};

/** The result of creating a key transaction. */
export type KeyTransactionCreateResult = {
  __typename?: 'KeyTransactionCreateResult';
  /** The acceptable amount of time spent in the backend before customers get frustrated (Apdex target). */
  apdexTarget?: Maybe<Scalars['Float']['output']>;
  /** The application associated with this key transaction */
  application: KeyTransactionApplication;
  /** The acceptable amount of time for rendering a page in a browser before customers get frustrated (browser Apdex target). */
  browserApdexTarget?: Maybe<Scalars['Float']['output']>;
  /** The GUID for the new key transaction. */
  guid?: Maybe<Scalars['EntityGuid']['output']>;
  /** The name of the metric underlying this key transaction. */
  metricName?: Maybe<Scalars['String']['output']>;
  /** The name of the key transaction. */
  name?: Maybe<Scalars['String']['output']>;
};

/** The result of deleting a key transaction. */
export type KeyTransactionDeleteResult = {
  __typename?: 'KeyTransactionDeleteResult';
  /** If the delete request succeeded. */
  success?: Maybe<Scalars['Boolean']['output']>;
};

/** A Key Transaction entity. */
export type KeyTransactionEntity = AlertableEntity & Entity & {
  __typename?: 'KeyTransactionEntity';
  account?: Maybe<AccountOutline>;
  /** The New Relic account ID associated with this entity. */
  accountId?: Maybe<Scalars['Int']['output']>;
  /** The current alerting severity of the entity. */
  alertSeverity?: Maybe<EntityAlertSeverity>;
  /**
   * The alert status of the entity.
   * @deprecated Please use `alertSeverity` and `reporting`
   */
  alertStatus?: Maybe<EntityAlertStatus>;
  /** Violations on the entity that were open during the specified time window. This will return up to 500 violations - if there are more in the time window selected, you must narrow the time window or look at fewer entities. */
  alertViolations?: Maybe<Array<Maybe<EntityAlertViolation>>>;
  /** The acceptable amount of time spent in the backend before customers get frustrated (Apdex target). */
  apdexTarget: Scalars['Float']['output'];
  /** The application associated with this key transaction */
  application: KeyTransactionApplication;
  /** The acceptable amount of time for rendering a page in a browser before customers get frustrated (browser Apdex target). */
  browserApdexTarget?: Maybe<Scalars['Float']['output']>;
  /** Retrieve the deployment event(s). Ordered by timestamp DESC. */
  deploymentSearch?: Maybe<ChangeTrackingDeploymentSearchResult>;
  /** The entity's domain */
  domain?: Maybe<Scalars['String']['output']>;
  /** A value representing the combination of the entity's domain and type. */
  entityType?: Maybe<EntityType>;
  /** The date of last time the entity has updated any of its fields. */
  firstIndexedAt?: Maybe<Scalars['EpochMilliseconds']['output']>;
  /** The list of golden metrics for a specific entity */
  goldenMetrics?: Maybe<EntityGoldenContextScopedGoldenMetrics>;
  /**
   * For the golden signal on this entity, show correlated signals from related entities.
   * Well inspect the golden signals for all related entities and return a sorted list.
   * You can also filter the results.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  goldenSignalCorrelations?: Maybe<GoldenSignalCorrelationResult>;
  /**
   * The deviation from normal of golden signal(s) for the given entity.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  goldenSignalDeviations?: Maybe<Array<Maybe<GoldenSignalSignalDeviation>>>;
  /**
   * The stored golden signal(s) for the given entity.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  goldenSignalValues?: Maybe<GoldenSignalValues>;
  /**
   * The stored golden signal(s) for the given entity. To be removed, use goldenSignalValues instead.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  goldenSignalValuesV2?: Maybe<GoldenSignalValues>;
  /** The list of golden tags for a specific entityType. */
  goldenTags?: Maybe<EntityGoldenContextScopedGoldenTags>;
  /** A unique entity identifier. */
  guid?: Maybe<Scalars['EntityGuid']['output']>;
  /** The time the entity was indexed. */
  indexedAt?: Maybe<Scalars['EpochMilliseconds']['output']>;
  /** The last time the entity's reporting status changed. */
  lastReportingChangeAt?: Maybe<Scalars['EpochMilliseconds']['output']>;
  /** The name of the metric underlying this key transaction. */
  metricName: Scalars['String']['output'];
  /** The name of this entity. */
  name?: Maybe<Scalars['String']['output']>;
  nerdStorage?: Maybe<NerdStorageEntityScope>;
  nerdStoreCollection?: Maybe<Array<Maybe<NerdStoreCollectionMember>>>;
  nerdStoreDocument?: Maybe<Scalars['NerdStoreDocument']['output']>;
  /**
   * Make an `Entity` scoped query to NRDB with a NRQL string.
   *
   * A relevant `WHERE` clause will be added to your query to scope data to the entity in question.
   *
   * See the [NRQL Docs](https://docs.newrelic.com/docs/insights/nrql-new-relic-query-language/nrql-resources/nrql-syntax-components-functions) for more information about generating a query string.
   */
  nrdbQuery?: Maybe<NrdbResultContainer>;
  /**
   * Poll for the results of a previously-executed asychronous NRDB query.
   *
   * The `queryId` is available in the `queryProgress` data returned by the original asynchronous query.
   *
   * See [this page](https://docs.newrelic.com/docs/apis/nerdgraph/examples/async-queries-nrql-tutorial) for additional asynchronous query documentation.
   * @deprecated This field is experimental! It may change at any time.
   *
   */
  nrdbQueryProgress?: Maybe<NrdbResultContainer>;
  /** The url to the entity. */
  permalink?: Maybe<Scalars['String']['output']>;
  /** Recent violations on the entity. */
  recentAlertViolations?: Maybe<Array<Maybe<EntityAlertViolation>>>;
  /** The recommended service levels for the entity. */
  recommendedServiceLevel?: Maybe<ServiceLevelRecommendation>;
  /** Related dashboards results */
  relatedDashboards: RelatedDashboardsRelatedDashboardResult;
  /** Related entities result with optional filtering. */
  relatedEntities?: Maybe<EntityRelationshipRelatedEntitiesResult>;
  /** Relationship traversal results with optional filtering. WARNING: this query is still experimental, and subject to breaking changes. */
  relationshipTraversal?: Maybe<EntityRelationshipTraversalResult>;
  /**
   * A list of the entities' relationships.
   *
   * For more information, visit [our docs](https://docs.newrelic.com/docs/apis/graphql-api/tutorials/graphql-relationships-api-tutorial).
   * @deprecated This field is deprecated! Please use `relatedEntities`.
   */
  relationships?: Maybe<Array<Maybe<EntityRelationship>>>;
  /** The reporting status of the entity. If New Relic is successfully collecting data from your application, this will be true. */
  reporting?: Maybe<Scalars['Boolean']['output']>;
  /** The service level defined for the entity. */
  serviceLevel?: Maybe<ServiceLevelDefinition>;
  /** The list of summary metrics. */
  summaryMetrics?: Maybe<Array<Maybe<EntitySummaryMetric>>>;
  /**
   * The tags applied to the entity.
   *
   * For details on tags, as well as query and mutation examples, visit [our docs](https://docs.newrelic.com/docs/apis/graphql-api/tutorials/graphql-tagging-api-tutorial).
   */
  tags?: Maybe<Array<Maybe<EntityTag>>>;
  /** The tags applied to the entity with their metadata. */
  tagsWithMetadata?: Maybe<Array<Maybe<EntityTagWithMetadata>>>;
  /** Look up Distributed Tracing summary data for the selected `EntityGuid` */
  tracingSummary?: Maybe<DistributedTracingEntityTracingSummary>;
  /** The entity's type */
  type?: Maybe<Scalars['String']['output']>;
  /** List of templates availables for this entity. */
  uiTemplates?: Maybe<Array<EntityDashboardTemplatesUi>>;
};


/** A Key Transaction entity. */
export type KeyTransactionEntityAlertViolationsArgs = {
  endTime: Scalars['EpochMilliseconds']['input'];
  startTime: Scalars['EpochMilliseconds']['input'];
};


/** A Key Transaction entity. */
export type KeyTransactionEntityDeploymentSearchArgs = {
  filter?: InputMaybe<ChangeTrackingSearchFilter>;
};


/** A Key Transaction entity. */
export type KeyTransactionEntityGoldenMetricsArgs = {
  context?: InputMaybe<EntityGoldenContextInput>;
  timeWindow?: InputMaybe<EntityGoldenNrqlTimeWindowInput>;
};


/** A Key Transaction entity. */
export type KeyTransactionEntityGoldenSignalCorrelationsArgs = {
  filter?: InputMaybe<GoldenSignalCorrelationsEntityFilter>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  timeWindow?: InputMaybe<TimeWindowInput>;
};


/** A Key Transaction entity. */
export type KeyTransactionEntityGoldenSignalDeviationsArgs = {
  comparisonTimeWindow?: InputMaybe<TimeWindowInput>;
  evaluationTimeWindow?: InputMaybe<TimeWindowInput>;
};


/** A Key Transaction entity. */
export type KeyTransactionEntityGoldenSignalValuesArgs = {
  timeWindow?: InputMaybe<TimeWindowInput>;
};


/** A Key Transaction entity. */
export type KeyTransactionEntityGoldenSignalValuesV2Args = {
  timeWindow?: InputMaybe<TimeWindowInput>;
};


/** A Key Transaction entity. */
export type KeyTransactionEntityGoldenTagsArgs = {
  context?: InputMaybe<EntityGoldenContextInput>;
};


/** A Key Transaction entity. */
export type KeyTransactionEntityNerdStoreCollectionArgs = {
  collection: Scalars['String']['input'];
  scopeByActor?: InputMaybe<Scalars['Boolean']['input']>;
};


/** A Key Transaction entity. */
export type KeyTransactionEntityNerdStoreDocumentArgs = {
  collection: Scalars['String']['input'];
  documentId: Scalars['String']['input'];
  scopeByActor?: InputMaybe<Scalars['Boolean']['input']>;
};


/** A Key Transaction entity. */
export type KeyTransactionEntityNrdbQueryArgs = {
  async?: InputMaybe<Scalars['Boolean']['input']>;
  nrql: Scalars['Nrql']['input'];
  options?: InputMaybe<NrqlQueryOptions>;
  timeout?: InputMaybe<Scalars['Seconds']['input']>;
};


/** A Key Transaction entity. */
export type KeyTransactionEntityNrdbQueryProgressArgs = {
  queryId: Scalars['ID']['input'];
};


/** A Key Transaction entity. */
export type KeyTransactionEntityRecentAlertViolationsArgs = {
  count?: InputMaybe<Scalars['Int']['input']>;
};


/** A Key Transaction entity. */
export type KeyTransactionEntityRelatedEntitiesArgs = {
  cursor?: InputMaybe<Scalars['String']['input']>;
  filter?: InputMaybe<EntityRelationshipEdgeFilter>;
  limit?: InputMaybe<Scalars['Int']['input']>;
};


/** A Key Transaction entity. */
export type KeyTransactionEntityRelationshipTraversalArgs = {
  cursor?: InputMaybe<Scalars['String']['input']>;
  hopFilters?: InputMaybe<EntityRelationshipTraversalHopFilters>;
  hops?: InputMaybe<Scalars['Int']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
};


/** A Key Transaction entity. */
export type KeyTransactionEntityRelationshipsArgs = {
  endTime?: InputMaybe<Scalars['EpochMilliseconds']['input']>;
  filter?: InputMaybe<EntityRelationshipFilter>;
};


/** A Key Transaction entity. */
export type KeyTransactionEntitySummaryMetricsArgs = {
  timeWindow?: InputMaybe<TimeWindowInput>;
};


/** A Key Transaction entity. */
export type KeyTransactionEntityTracingSummaryArgs = {
  timeWindow?: InputMaybe<TimeWindowInput>;
};

/** A Key Transaction entity outline. */
export type KeyTransactionEntityOutline = AlertableEntityOutline & EntityOutline & {
  __typename?: 'KeyTransactionEntityOutline';
  account?: Maybe<AccountOutline>;
  /** The New Relic account ID associated with this entity. */
  accountId?: Maybe<Scalars['Int']['output']>;
  /** The current alerting severity of the entity. */
  alertSeverity?: Maybe<EntityAlertSeverity>;
  /**
   * The alert status of the entity.
   * @deprecated Please use `alertSeverity` and `reporting`
   */
  alertStatus?: Maybe<EntityAlertStatus>;
  /** The entity's domain */
  domain?: Maybe<Scalars['String']['output']>;
  /** A value representing the combination of the entity's domain and type. */
  entityType?: Maybe<EntityType>;
  /** The date of last time the entity has updated any of its fields. */
  firstIndexedAt?: Maybe<Scalars['EpochMilliseconds']['output']>;
  /** The list of golden metrics for a specific entity */
  goldenMetrics?: Maybe<EntityGoldenContextScopedGoldenMetrics>;
  /**
   * For the golden signal on this entity, show correlated signals from related entities.
   * Well inspect the golden signals for all related entities and return a sorted list.
   * You can also filter the results.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  goldenSignalCorrelations?: Maybe<GoldenSignalCorrelationResult>;
  /**
   * The deviation from normal of golden signal(s) for the given entity.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  goldenSignalDeviations?: Maybe<Array<Maybe<GoldenSignalSignalDeviation>>>;
  /**
   * The stored golden signal(s) for the given entity.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  goldenSignalValues?: Maybe<GoldenSignalValues>;
  /**
   * The stored golden signal(s) for the given entity. To be removed, use goldenSignalValues instead.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  goldenSignalValuesV2?: Maybe<GoldenSignalValues>;
  /** The list of golden tags for a specific entityType. */
  goldenTags?: Maybe<EntityGoldenContextScopedGoldenTags>;
  /** A unique entity identifier. */
  guid?: Maybe<Scalars['EntityGuid']['output']>;
  /** The time the entity was indexed. */
  indexedAt?: Maybe<Scalars['EpochMilliseconds']['output']>;
  /** The last time the entity's reporting status changed. */
  lastReportingChangeAt?: Maybe<Scalars['EpochMilliseconds']['output']>;
  /** The name of this entity. */
  name?: Maybe<Scalars['String']['output']>;
  /** The url to the entity. */
  permalink?: Maybe<Scalars['String']['output']>;
  /** The recommended service levels for the entity. */
  recommendedServiceLevel?: Maybe<ServiceLevelRecommendation>;
  /** Related dashboards results */
  relatedDashboards: RelatedDashboardsRelatedDashboardResult;
  /** The reporting status of the entity. If New Relic is successfully collecting data from your application, this will be true. */
  reporting?: Maybe<Scalars['Boolean']['output']>;
  /** The service level defined for the entity. */
  serviceLevel?: Maybe<ServiceLevelDefinition>;
  /** The list of summary metrics. */
  summaryMetrics?: Maybe<Array<Maybe<EntitySummaryMetric>>>;
  /**
   * The tags applied to the entity.
   *
   * For details on tags, as well as query and mutation examples, visit [our docs](https://docs.newrelic.com/docs/apis/graphql-api/tutorials/graphql-tagging-api-tutorial).
   */
  tags?: Maybe<Array<Maybe<EntityTag>>>;
  /** The entity's type */
  type?: Maybe<Scalars['String']['output']>;
  /** List of templates availables for this entity. */
  uiTemplates?: Maybe<Array<EntityDashboardTemplatesUi>>;
};


/** A Key Transaction entity outline. */
export type KeyTransactionEntityOutlineGoldenMetricsArgs = {
  context?: InputMaybe<EntityGoldenContextInput>;
  timeWindow?: InputMaybe<EntityGoldenNrqlTimeWindowInput>;
};


/** A Key Transaction entity outline. */
export type KeyTransactionEntityOutlineGoldenSignalCorrelationsArgs = {
  filter?: InputMaybe<GoldenSignalCorrelationsEntityFilter>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  timeWindow?: InputMaybe<TimeWindowInput>;
};


/** A Key Transaction entity outline. */
export type KeyTransactionEntityOutlineGoldenSignalDeviationsArgs = {
  comparisonTimeWindow?: InputMaybe<TimeWindowInput>;
  evaluationTimeWindow?: InputMaybe<TimeWindowInput>;
};


/** A Key Transaction entity outline. */
export type KeyTransactionEntityOutlineGoldenSignalValuesArgs = {
  timeWindow?: InputMaybe<TimeWindowInput>;
};


/** A Key Transaction entity outline. */
export type KeyTransactionEntityOutlineGoldenSignalValuesV2Args = {
  timeWindow?: InputMaybe<TimeWindowInput>;
};


/** A Key Transaction entity outline. */
export type KeyTransactionEntityOutlineGoldenTagsArgs = {
  context?: InputMaybe<EntityGoldenContextInput>;
};


/** A Key Transaction entity outline. */
export type KeyTransactionEntityOutlineSummaryMetricsArgs = {
  timeWindow?: InputMaybe<TimeWindowInput>;
};

/** The result of updating a key transaction. */
export type KeyTransactionUpdateResult = {
  __typename?: 'KeyTransactionUpdateResult';
  /** The acceptable amount of time spent in the backend before customers get frustrated (Apdex target). */
  apdexTarget?: Maybe<Scalars['Float']['output']>;
  /** The application associated with this key transaction */
  application: KeyTransactionApplication;
  /** The acceptable amount of time for rendering a page in a browser before customers get frustrated (browser Apdex target). */
  browserApdexTarget?: Maybe<Scalars['Float']['output']>;
  /** The name of the key transaction. */
  name?: Maybe<Scalars['String']['output']>;
};

export type Label = {
  __typename?: 'Label';
  type?: Maybe<Scalars['String']['output']>;
  value?: Maybe<Scalars['String']['output']>;
};

export type LabelSearchInput = {
  type: Scalars['String']['input'];
  value?: InputMaybe<Scalars['String']['input']>;
};

export type LogConfigurationsAccountStitchedFields = {
  __typename?: 'LogConfigurationsAccountStitchedFields';
  /** Look up for all data partition rules for a given account. */
  dataPartitionRules?: Maybe<Array<LogConfigurationsDataPartitionRule>>;
  /** Look up for all Live Archive configurations for a given account. */
  liveArchiveConfigurations?: Maybe<Array<LogConfigurationsLiveArchiveConfiguration>>;
  /** Look up for all obfuscation expressions for a given account */
  obfuscationExpressions?: Maybe<Array<LogConfigurationsObfuscationExpression>>;
  /** Look up for all obfuscation rules for a given account. */
  obfuscationRules?: Maybe<Array<LogConfigurationsObfuscationRule>>;
  /** Look up for all parsing rules for a given account. */
  parsingRules?: Maybe<Array<LogConfigurationsParsingRule>>;
  /** Look up pipeline configuration for a given account. */
  pipelineConfiguration?: Maybe<LogConfigurationsPipelineConfiguration>;
  /** Test a Grok pattern against a list of log lines. */
  testGrok?: Maybe<Array<LogConfigurationsGrokTestResult>>;
};


export type LogConfigurationsAccountStitchedFieldsTestGrokArgs = {
  grok: Scalars['String']['input'];
  logLines: Array<Scalars['String']['input']>;
};

/** Expected errors as a result of creating a new data partition rule. */
export type LogConfigurationsCreateDataPartitionRuleError = {
  __typename?: 'LogConfigurationsCreateDataPartitionRuleError';
  /** The message with the error cause. */
  message?: Maybe<Scalars['String']['output']>;
  /** Type of error. */
  type?: Maybe<LogConfigurationsCreateDataPartitionRuleErrorType>;
};

/** Expected error types as result of creating a new data partition rule. */
export enum LogConfigurationsCreateDataPartitionRuleErrorType {
  /** A data partition rule with the provided name already exists. */
  DuplicateDataPartitionRuleName = 'DUPLICATE_DATA_PARTITION_RULE_NAME',
  /** The provided data partition does not match the validation requirements */
  InvalidDataPartitionInput = 'INVALID_DATA_PARTITION_INPUT',
  /** Customer has reached the maximum number of allowed data partition rules. */
  MaxDataPartitionRules = 'MAX_DATA_PARTITION_RULES'
}

/** A new data partition rule. */
export type LogConfigurationsCreateDataPartitionRuleInput = {
  /** The description of the data partition rule. */
  description?: InputMaybe<Scalars['String']['input']>;
  /** Whether or not this data partition rule is enabled. */
  enabled: Scalars['Boolean']['input'];
  /** The matching criteria of the data partition rule. */
  matchingCriteria?: InputMaybe<LogConfigurationsDataPartitionRuleMatchingCriteriaInput>;
  /** The NRQL to match events for this data partition rule. Logs matching this criteria will be routed to the specified data partition. */
  nrql?: InputMaybe<Scalars['Nrql']['input']>;
  /** The retention policy of the data partition data. */
  retentionPolicy: LogConfigurationsDataPartitionRuleRetentionPolicyType;
  /** The name of the data partition where logs will be allocated once the rule is enabled. */
  targetDataPartition: Scalars['LogConfigurationsLogDataPartitionName']['input'];
};

/** The result after creating a new data partition rule. */
export type LogConfigurationsCreateDataPartitionRuleResponse = {
  __typename?: 'LogConfigurationsCreateDataPartitionRuleResponse';
  /** List of errors, if any. */
  errors?: Maybe<Array<Maybe<LogConfigurationsCreateDataPartitionRuleError>>>;
  /** The created data partition rule. */
  rule?: Maybe<LogConfigurationsDataPartitionRule>;
};

/** Input for creating an obfuscation action on a rule being created. */
export type LogConfigurationsCreateObfuscationActionInput = {
  /** Attribute names for action. An empty list applies the action to all the attributes. */
  attributes: Array<Scalars['String']['input']>;
  /** Expression Id for action. */
  expressionId: Scalars['ID']['input'];
  /** Obfuscation method to use. */
  method: LogConfigurationsObfuscationMethod;
};

/** Input for creating an obfuscation expression. */
export type LogConfigurationsCreateObfuscationExpressionInput = {
  /** Description of expression. */
  description?: InputMaybe<Scalars['String']['input']>;
  /** Name of expression. */
  name: Scalars['String']['input'];
  /** Regex of expression. */
  regex: Scalars['String']['input'];
};

/** Input for creating an obfuscation rule. */
export type LogConfigurationsCreateObfuscationRuleInput = {
  /** Actions for the rule. The actions will be applied in the order specified by this list. */
  actions: Array<LogConfigurationsCreateObfuscationActionInput>;
  /** Description of rule. */
  description?: InputMaybe<Scalars['String']['input']>;
  /** Whether the rule should be applied or not to incoming data. */
  enabled: Scalars['Boolean']['input'];
  /** NRQL for determining whether a given log record should have obfuscation actions applied. */
  filter: Scalars['Nrql']['input'];
  /** Name of rule. */
  name: Scalars['String']['input'];
};

/** The result after creating a new parsing rule. */
export type LogConfigurationsCreateParsingRuleResponse = {
  __typename?: 'LogConfigurationsCreateParsingRuleResponse';
  /** List of errors, if any. */
  errors?: Maybe<Array<Maybe<LogConfigurationsParsingRuleMutationError>>>;
  /** The created parsing rule. */
  rule?: Maybe<LogConfigurationsParsingRule>;
};

/** The data partition rule for an account. */
export type LogConfigurationsDataPartitionRule = {
  __typename?: 'LogConfigurationsDataPartitionRule';
  /** Identifies the date and time when the rule was created. */
  createdAt: Scalars['DateTime']['output'];
  /** Identifies the user who has created the rule. */
  createdBy?: Maybe<UserReference>;
  /** Whether or not this data partition rule is deleted. Deleting a data partition rule does not delete the already persisted data. This data will be retained for a given period of time specified in the retention policy field. */
  deleted: Scalars['Boolean']['output'];
  /** A description of what this data partition rule represents. */
  description?: Maybe<Scalars['String']['output']>;
  /** Whether or not this data partition rule is enabled. */
  enabled: Scalars['Boolean']['output'];
  /** Unique data partition rule identifier. */
  id: Scalars['ID']['output'];
  /**
   * The matching criteria for this data partition rule. Logs matching this criteria will be routed to the specified data partition once the rule is enabled.
   * @deprecated matchingCriteria is deprecated and will eventually be replaced with a new field named nrql which will allow for greater flexibility in defining rules
   */
  matchingCriteria?: Maybe<LogConfigurationsDataPartitionRuleMatchingCriteria>;
  /** The NRQL to match events for this data partition rule. Logs matching this criteria will be routed to the specified data partition once the rule is enabled. */
  nrql?: Maybe<Scalars['Nrql']['output']>;
  /** The retention policy of the data partition data. */
  retentionPolicy: LogConfigurationsDataPartitionRuleRetentionPolicyType;
  /** The name of the data partition. */
  targetDataPartition: Scalars['LogConfigurationsLogDataPartitionName']['output'];
  /** Identifies the date and time when the rule was last updated. */
  updatedAt?: Maybe<Scalars['DateTime']['output']>;
  /** Identifies the user who has last updated the rule. */
  updatedBy?: Maybe<UserReference>;
};

/** The data partition rule matching criteria. */
export type LogConfigurationsDataPartitionRuleMatchingCriteria = {
  __typename?: 'LogConfigurationsDataPartitionRuleMatchingCriteria';
  /** The attribute name against which this matching condition will be evaluated. */
  attributeName: Scalars['String']['output'];
  /** The matching expression of the data partition rule definition. */
  matchingExpression: Scalars['String']['output'];
  /** The matching method of the data partition rule definition. */
  matchingOperator: LogConfigurationsDataPartitionRuleMatchingOperator;
};

/** The data partition rule matching criteria. */
export type LogConfigurationsDataPartitionRuleMatchingCriteriaInput = {
  /** The attribute name against which this matching condition will be evaluated. */
  attributeName: Scalars['String']['input'];
  /** The matching expression of the data partition rule definition. */
  matchingExpression: Scalars['String']['input'];
  /** The matching method of the data partition rule definition. */
  matchingMethod: LogConfigurationsDataPartitionRuleMatchingOperator;
};

/**
 * The matching method for the rule to allocate the data partition data.
 * Select EQUALS to target logs that match your criteria exactly, or select LIKE to apply a fuzzy match.
 */
export enum LogConfigurationsDataPartitionRuleMatchingOperator {
  /** When applying the rule will allocate data for those attributes that are an exact match with the provided value. */
  Equals = 'EQUALS',
  /** When applying the rule will allocate data for those attributes that contain the provided value. */
  Like = 'LIKE'
}

/** An object that contains expected errors as a result of mutating an existing data partition rule. */
export type LogConfigurationsDataPartitionRuleMutationError = {
  __typename?: 'LogConfigurationsDataPartitionRuleMutationError';
  /** The message with the error cause. */
  message?: Maybe<Scalars['String']['output']>;
  /** Type of error. */
  type?: Maybe<LogConfigurationsDataPartitionRuleMutationErrorType>;
};

/** Expected default error types as result of mutating an existing data partition rule. */
export enum LogConfigurationsDataPartitionRuleMutationErrorType {
  /** Number format error. ID should be convertible to int. */
  InvalidId = 'INVALID_ID',
  /** Partition rule must be specified with a valid nrql where clause */
  InvalidRule = 'INVALID_RULE',
  /** Couldn't find the provided data partition rule. */
  NotFound = 'NOT_FOUND'
}

/** The retention policy for the data partition data. */
export enum LogConfigurationsDataPartitionRuleRetentionPolicyType {
  /** The alternative data retention policy, 30 days of data retention since the log data is ingested. */
  Secondary = 'SECONDARY',
  /** The maximum retention period associated with the account. This is determined by the customers subscription/contract with New Relic. */
  Standard = 'STANDARD'
}

/** The result after deleting a data partition rule. */
export type LogConfigurationsDeleteDataPartitionRuleResponse = {
  __typename?: 'LogConfigurationsDeleteDataPartitionRuleResponse';
  /** List of errors, if any. */
  errors?: Maybe<Array<Maybe<LogConfigurationsDataPartitionRuleMutationError>>>;
};

/** The result after deleting a parsing rule. */
export type LogConfigurationsDeleteParsingRuleResponse = {
  __typename?: 'LogConfigurationsDeleteParsingRuleResponse';
  /** List of errors, if any. */
  errors?: Maybe<Array<Maybe<LogConfigurationsParsingRuleMutationError>>>;
};

/** An attribute that was extracted from a Grok test. */
export type LogConfigurationsGrokTestExtractedAttribute = {
  __typename?: 'LogConfigurationsGrokTestExtractedAttribute';
  /** The attribute name. */
  name: Scalars['String']['output'];
  /** A string representation of the extracted value (which might not be a String). */
  value: Scalars['String']['output'];
};

/** The result of testing Grok on a log line. */
export type LogConfigurationsGrokTestResult = {
  __typename?: 'LogConfigurationsGrokTestResult';
  /** Any attributes that were extracted. */
  attributes?: Maybe<Array<LogConfigurationsGrokTestExtractedAttribute>>;
  /** The log line that was tested against. */
  logLine: Scalars['String']['output'];
  /** Whether the Grok pattern matched. */
  matched: Scalars['Boolean']['output'];
};

/** Live Archive configuration for an event type. */
export type LogConfigurationsLiveArchiveConfiguration = {
  __typename?: 'LogConfigurationsLiveArchiveConfiguration';
  /** Account Id */
  accountId: Scalars['Int']['output'];
  /** Identifies the date and time when the configuration was created. */
  createdAt: Scalars['DateTime']['output'];
  /** Identifies the user who has created the configuration. */
  createdBy?: Maybe<UserReference>;
  /** Indicates if the Live Archive configuration is enabled */
  enabled: Scalars['Boolean']['output'];
  /** EventType name that will be configured. */
  eventType: Scalars['String']['output'];
  /** Configuration Id */
  id: Scalars['ID']['output'];
  /** Retention policy for the EventType. */
  retentionPolicy: LogConfigurationsLiveArchiveRetentionPolicyType;
  /** Identifies the date and time when the configuration was last updated. */
  updatedAt?: Maybe<Scalars['DateTime']['output']>;
  /** Identifies the user who has last updated the configuration. */
  updatedBy?: Maybe<UserReference>;
};

/** Live Archive retention policies. */
export enum LogConfigurationsLiveArchiveRetentionPolicyType {
  /** Live Archive disabled */
  None = 'NONE',
  /** Live Archive enabled with configured retention policy */
  StandardArchive = 'STANDARD_ARCHIVE'
}

/** Application of an obfuscation expression with specific a replacement method. */
export type LogConfigurationsObfuscationAction = {
  __typename?: 'LogConfigurationsObfuscationAction';
  /** Log record attributes to apply this expression to. An empty list applies the action to all the attributes. */
  attributes: Array<Scalars['String']['output']>;
  /** Obfuscation expression applied by this action. */
  expression: LogConfigurationsObfuscationExpression;
  /** The id of the obfuscation action. */
  id: Scalars['ID']['output'];
  /** How to obfuscate matches for the applied expression. */
  method: LogConfigurationsObfuscationMethod;
};

/** Reusable obfuscation expression. */
export type LogConfigurationsObfuscationExpression = {
  __typename?: 'LogConfigurationsObfuscationExpression';
  /** Identifies the date and time when the expression was created. */
  createdAt: Scalars['DateTime']['output'];
  /** Identifies the user who has created the expression. */
  createdBy?: Maybe<UserReference>;
  /** Description of the expression. */
  description?: Maybe<Scalars['String']['output']>;
  /** The id of the obfuscation expression. */
  id: Scalars['ID']['output'];
  /** Name of the expression. */
  name: Scalars['String']['output'];
  /** Regular expression for this obfuscation expression. Capture groups will be obscured on matching. */
  regex: Scalars['String']['output'];
  /** Identifies the date and time when the expression was last updated. */
  updatedAt: Scalars['DateTime']['output'];
  /** Identifies the user who has last updated the expression. */
  updatedBy?: Maybe<UserReference>;
};

/** Methods for replacing obfuscated values. */
export enum LogConfigurationsObfuscationMethod {
  /** Replace the matched data with a SHA256 hash. */
  HashSha256 = 'HASH_SHA256',
  /** Replace the matched data with a static value. */
  Mask = 'MASK'
}

/** Rule for identifying a set of log data to apply specific obfuscation actions to. */
export type LogConfigurationsObfuscationRule = {
  __typename?: 'LogConfigurationsObfuscationRule';
  /** Obfuscation actions to take if a record passes the matching criteria. */
  actions?: Maybe<Array<LogConfigurationsObfuscationAction>>;
  /** Identifies the date and time when the rule was created. */
  createdAt: Scalars['DateTime']['output'];
  /** Identifies the user who has created the rule. */
  createdBy?: Maybe<UserReference>;
  /** Description of the obfuscation rule. */
  description?: Maybe<Scalars['String']['output']>;
  /** Whether the rule should be applied to incoming logs */
  enabled: Scalars['Boolean']['output'];
  /** NRQL filter to determine if a log record should have obfuscation actions applied. */
  filter: Scalars['Nrql']['output'];
  /** The id of the obfuscation rule. */
  id: Scalars['ID']['output'];
  /** Name of the obfuscation rule. */
  name: Scalars['String']['output'];
  /** Identifies the date and time when the rule was last updated. */
  updatedAt: Scalars['DateTime']['output'];
  /** Identifies the user who has last updated the rule. */
  updatedBy?: Maybe<UserReference>;
};

/** A parsing rule for an account. */
export type LogConfigurationsParsingRule = {
  __typename?: 'LogConfigurationsParsingRule';
  /** The account id associated with the rule. */
  accountId: Scalars['Int']['output'];
  /** The parsing rule will apply to value of this attribute. */
  attribute: Scalars['String']['output'];
  /** Identifies the user who has created the rule. */
  createdBy?: Maybe<UserReference>;
  /** Whether or not this rule is deleted. */
  deleted: Scalars['Boolean']['output'];
  /** A description of what this parsing rule represents. */
  description: Scalars['String']['output'];
  /** Whether or not this rule is enabled. */
  enabled: Scalars['Boolean']['output'];
  /** The Grok of what to parse. */
  grok: Scalars['String']['output'];
  /** Unique parsing rule identifier. */
  id: Scalars['ID']['output'];
  /** The Lucene to match events to the parsing rule. */
  lucene: Scalars['String']['output'];
  /** The NRQL to match events to the parsing rule. */
  nrql: Scalars['Nrql']['output'];
  /** Identifies the date and time when the rule was last updated. */
  updatedAt?: Maybe<Scalars['DateTime']['output']>;
  /** Identifies the user who has last updated the rule. */
  updatedBy?: Maybe<UserReference>;
};

/** A new parsing rule. */
export type LogConfigurationsParsingRuleConfiguration = {
  /** The parsing rule will apply to value of this attribute. If field is not provided, value will default to message. */
  attribute?: InputMaybe<Scalars['String']['input']>;
  /** A description of what this parsing rule represents. */
  description: Scalars['String']['input'];
  /** Whether or not this rule is enabled. */
  enabled: Scalars['Boolean']['input'];
  /** The Grok of what to parse. */
  grok: Scalars['String']['input'];
  /** The Lucene to match events to the parsing rule. */
  lucene: Scalars['String']['input'];
  /** The NRQL to match events to the parsing rule. */
  nrql: Scalars['Nrql']['input'];
};

/** Expected errors as a result of mutating a parsing rule. */
export type LogConfigurationsParsingRuleMutationError = {
  __typename?: 'LogConfigurationsParsingRuleMutationError';
  /** The message with the error cause. */
  message?: Maybe<Scalars['String']['output']>;
  /** Type of error. */
  type?: Maybe<LogConfigurationsParsingRuleMutationErrorType>;
};

/** Expected default error types as result of mutating an existing parsing rule. */
export enum LogConfigurationsParsingRuleMutationErrorType {
  /** Invalid Grok */
  InvalidGrok = 'INVALID_GROK',
  /** Number format error. ID should be convertible to int. */
  InvalidId = 'INVALID_ID',
  /** Invalid NRQL */
  InvalidNrql = 'INVALID_NRQL',
  /** Couldn't find the specified parsing rule. */
  NotFound = 'NOT_FOUND'
}

/** The pipeline configuration for an account, with metadata. */
export type LogConfigurationsPipelineConfiguration = {
  __typename?: 'LogConfigurationsPipelineConfiguration';
  /** The account id. */
  accountId: Scalars['Int']['output'];
  /** Whether or not enrichment is disabled. */
  enrichmentDisabled: Scalars['Boolean']['output'];
  /** Whether or not New Relic Entity Synthesis is disabled. */
  entitySynthesisDisabled: Scalars['Boolean']['output'];
  /** Whether or not NRIA attributes should be dropped. */
  infraAgentAttributesCleanupEnabled: Scalars['Boolean']['output'];
  /** Whether or not JSON parsing is disabled. */
  jsonParsingDisabled: Scalars['Boolean']['output'];
  /** Whether or not New Relic APM linking data extraction is disabled. */
  nrLinkingExtractionDisabled: Scalars['Boolean']['output'];
  /** Whether or not New Relic unmarshalling fields are disabled. */
  nrUnmarshallingFieldsDisabled: Scalars['Boolean']['output'];
  /** Whether or not obfuscation is disabled. */
  obfuscationDisabled: Scalars['Boolean']['output'];
  /** Whether or not parsing is disabled. */
  parsingDisabled: Scalars['Boolean']['output'];
  /** Whether or not patterns are enabled. */
  patternsEnabled: Scalars['Boolean']['output'];
  /** Whether or not plugin.* attributes should be dropped. */
  pluginAttributesCleanupEnabled: Scalars['Boolean']['output'];
  /** Whether or not recursive JSON parsing is disabled. */
  recursiveJsonParsingDisabled: Scalars['Boolean']['output'];
  /** Whether or not Json Parsing is disabled for Syslog. */
  syslogJsonParsingDisabled: Scalars['Boolean']['output'];
  /** Whether or not transformation is disabled. */
  transformationDisabled: Scalars['Boolean']['output'];
  /** Identifies the date and time when the configuration was last updated, or null if this has never been changed from the defaults. */
  updatedAt?: Maybe<Scalars['DateTime']['output']>;
  /** Identifies the user who has updated the configuration, or null if this has never been changed from the defaults. */
  updatedBy?: Maybe<UserReference>;
};

/** The pipeline configuration for an account. */
export type LogConfigurationsPipelineConfigurationInput = {
  /** Whether or not enrichment is disabled. */
  enrichmentDisabled?: InputMaybe<Scalars['Boolean']['input']>;
  /** Whether or not New Relic Entity Synthesis is disabled. */
  entitySynthesisDisabled?: InputMaybe<Scalars['Boolean']['input']>;
  /** Whether or not NRIA attributes should be dropped. */
  infraAgentAttributesCleanupEnabled?: InputMaybe<Scalars['Boolean']['input']>;
  /** Whether or not JSON parsing is disabled. */
  jsonParsingDisabled?: InputMaybe<Scalars['Boolean']['input']>;
  /** Whether or not New Relic APM linking data extraction is disabled. */
  nrLinkingExtractionDisabled?: InputMaybe<Scalars['Boolean']['input']>;
  /** Whether or not New Relic unmarshalling fields are disabled. */
  nrUnmarshallingFieldsDisabled?: InputMaybe<Scalars['Boolean']['input']>;
  /** Whether or not obfuscation is disabled. */
  obfuscationDisabled?: InputMaybe<Scalars['Boolean']['input']>;
  /** Whether or not parsing is disabled. */
  parsingDisabled?: InputMaybe<Scalars['Boolean']['input']>;
  /** Whether or not patterns are enabled. */
  patternsEnabled?: InputMaybe<Scalars['Boolean']['input']>;
  /** Whether or not plugin.* attributes should be dropped. */
  pluginAttributesCleanupEnabled?: InputMaybe<Scalars['Boolean']['input']>;
  /** Whether or not recursive JSON parsing is disabled. */
  recursiveJsonParsingDisabled?: InputMaybe<Scalars['Boolean']['input']>;
  /** Whether or not Json Parsing is disabled for Syslog. */
  syslogJsonParsingDisabled?: InputMaybe<Scalars['Boolean']['input']>;
  /** Whether or not transformation is disabled. */
  transformationDisabled?: InputMaybe<Scalars['Boolean']['input']>;
};

/** An object for updating an existing data partition rule. */
export type LogConfigurationsUpdateDataPartitionRuleInput = {
  /** The description of the data partition rule. */
  description?: InputMaybe<Scalars['String']['input']>;
  /** Whether or not this data partition rule is enabled. */
  enabled?: InputMaybe<Scalars['Boolean']['input']>;
  /** Unique data partition rule identifier. */
  id: Scalars['ID']['input'];
  /** The criteria of the data partition rule. */
  matchingCriteria?: InputMaybe<LogConfigurationsDataPartitionRuleMatchingCriteriaInput>;
  /** The NRQL to match events for this data partition rule. Logs matching this criteria will be routed to the specified data partition. */
  nrql?: InputMaybe<Scalars['Nrql']['input']>;
};

/** An object that represents the result after updating a data partition rule. */
export type LogConfigurationsUpdateDataPartitionRuleResponse = {
  __typename?: 'LogConfigurationsUpdateDataPartitionRuleResponse';
  /** List of errors, if any. */
  errors?: Maybe<Array<Maybe<LogConfigurationsDataPartitionRuleMutationError>>>;
  /** The updated data partition rule. */
  rule?: Maybe<LogConfigurationsDataPartitionRule>;
};

/** Input for creating an obfuscation action on a rule being updated. */
export type LogConfigurationsUpdateObfuscationActionInput = {
  /** Attribute names for action. An empty list applies the action to all the attributes. */
  attributes: Array<Scalars['String']['input']>;
  /** Expression Id for action. */
  expressionId: Scalars['ID']['input'];
  /** Obfuscation method to use. */
  method: LogConfigurationsObfuscationMethod;
};

/**
 * Input for updating an obfuscation expression.
 * Null fields are left untouched by mutation.
 */
export type LogConfigurationsUpdateObfuscationExpressionInput = {
  /** Description of expression. */
  description?: InputMaybe<Scalars['String']['input']>;
  /** Expression Id. */
  id: Scalars['ID']['input'];
  /** Name of expression. */
  name?: InputMaybe<Scalars['String']['input']>;
  /** Regex of expression. */
  regex?: InputMaybe<Scalars['String']['input']>;
};

/**
 * Input for updating an obfuscation rule.
 * Null fields are left untouched by mutation.
 */
export type LogConfigurationsUpdateObfuscationRuleInput = {
  /**
   * Actions for the rule. When non-null, this list of actions is used to replace
   * the existing list of actions of the rule. The actions will be applied in the
   * order specified by this list.
   */
  actions?: InputMaybe<Array<LogConfigurationsUpdateObfuscationActionInput>>;
  /** Description of rule. */
  description?: InputMaybe<Scalars['String']['input']>;
  /** Whether the rule should be applied or not to incoming data. */
  enabled?: InputMaybe<Scalars['Boolean']['input']>;
  /** NRQL for determining whether a given log record should have obfuscation actions applied. */
  filter?: InputMaybe<Scalars['Nrql']['input']>;
  /** Rule Id. */
  id: Scalars['ID']['input'];
  /** Name of rule. */
  name?: InputMaybe<Scalars['String']['input']>;
};

/** The result after updating a parsing rule. */
export type LogConfigurationsUpdateParsingRuleResponse = {
  __typename?: 'LogConfigurationsUpdateParsingRuleResponse';
  /** List of errors, if any. */
  errors?: Maybe<Array<Maybe<LogConfigurationsParsingRuleMutationError>>>;
  /** The updated parsing rule. */
  rule?: Maybe<LogConfigurationsParsingRule>;
};

/** The result after upserting pipeline configuration for an account. */
export type LogConfigurationsUpsertPipelineConfigurationResponse = {
  __typename?: 'LogConfigurationsUpsertPipelineConfigurationResponse';
  /** The updated pipeline configuration. */
  pipelineConfiguration?: Maybe<LogConfigurationsPipelineConfiguration>;
};

export type LogsLiveTailResult = {
  __typename?: 'LogsLiveTailResult';
  count?: Maybe<Scalars['Int']['output']>;
  lines?: Maybe<Array<Maybe<Scalars['LogLine']['output']>>>;
};

export type Metric = {
  __typename?: 'Metric';
  name?: Maybe<Scalars['String']['output']>;
  scope?: Maybe<Scalars['String']['output']>;
};

/** Return type for queries given an account ID. */
export type MetricNormalizationAccountStitchedFields = {
  __typename?: 'MetricNormalizationAccountStitchedFields';
  /** Retrieves a rule. */
  metricNormalizationRule?: Maybe<MetricNormalizationRule>;
  /** Retrieves the rules for the account. */
  metricNormalizationRules?: Maybe<Array<MetricNormalizationRule>>;
};


/** Return type for queries given an account ID. */
export type MetricNormalizationAccountStitchedFieldsMetricNormalizationRuleArgs = {
  id: Scalars['Int']['input'];
};


/** Return type for queries given an account ID. */
export type MetricNormalizationAccountStitchedFieldsMetricNormalizationRulesArgs = {
  enabled?: InputMaybe<Scalars['Boolean']['input']>;
};

/** Input object used to represent the rule to be created */
export type MetricNormalizationCreateRuleInput = {
  /** Customer rule action. */
  action: MetricNormalizationCustomerRuleAction;
  /** Application GUID */
  applicationGuid?: InputMaybe<Scalars['EntityGuid']['input']>;
  /** Is rule enabled? */
  enabled: Scalars['Boolean']['input'];
  /** Rule evaluation order */
  evalOrder?: InputMaybe<Scalars['Int']['input']>;
  /** Metric Match Expression. */
  matchExpression: Scalars['String']['input'];
  /** Notes. */
  notes?: InputMaybe<Scalars['String']['input']>;
  /** Metric Replacement Expression. */
  replacement?: InputMaybe<Scalars['String']['input']>;
  /** Whether it terminates the evaluation chain or not */
  terminateChain?: InputMaybe<Scalars['Boolean']['input']>;
};

/** The different rule actions for customers. */
export enum MetricNormalizationCustomerRuleAction {
  /** Deny new metrics (only for NR Administrators) */
  DenyNewMetrics = 'DENY_NEW_METRICS',
  /** Ignore matching metrics. */
  Ignore = 'IGNORE',
  /** Replace metrics. */
  Replace = 'REPLACE'
}

/** Input object used to represent the rule to be created */
export type MetricNormalizationEditRuleInput = {
  /** Rule action. */
  action: MetricNormalizationCustomerRuleAction;
  /** Is rule enabled? */
  enabled: Scalars['Boolean']['input'];
  /** Rule evaluation order */
  evalOrder?: InputMaybe<Scalars['Int']['input']>;
  /** Rule Id. */
  id: Scalars['Int']['input'];
  /** Metric Match Expression. */
  matchExpression: Scalars['String']['input'];
  /** Notes. */
  notes?: InputMaybe<Scalars['String']['input']>;
  /** Metric Replacement Expression. */
  replacement?: InputMaybe<Scalars['String']['input']>;
  /** Whether it terminates the evaluation chain or not */
  terminateChain?: InputMaybe<Scalars['Boolean']['input']>;
};

/** An object that represents a metric rename rule. */
export type MetricNormalizationRule = {
  __typename?: 'MetricNormalizationRule';
  /** Rule action. */
  action?: Maybe<MetricNormalizationRuleAction>;
  /** Application GUID */
  applicationGuid?: Maybe<Scalars['EntityGuid']['output']>;
  /** Application Name */
  applicationName?: Maybe<Scalars['String']['output']>;
  /** Date of rule creation. */
  createdAt?: Maybe<Scalars['EpochMilliseconds']['output']>;
  /** Is rule enabled? */
  enabled: Scalars['Boolean']['output'];
  /** Rule evaluation order */
  evalOrder?: Maybe<Scalars['Int']['output']>;
  /** Rule Id */
  id: Scalars['Int']['output'];
  /** Metric Match Expression. */
  matchExpression: Scalars['String']['output'];
  /** Notes. */
  notes?: Maybe<Scalars['String']['output']>;
  /** Metric Replacement Expression. */
  replacement?: Maybe<Scalars['String']['output']>;
  /** Whether it terminates the evaluation chain or not */
  terminateChain?: Maybe<Scalars['Boolean']['output']>;
};

/** The different rule actions. */
export enum MetricNormalizationRuleAction {
  /** Deny new metrics. */
  DenyNewMetrics = 'DENY_NEW_METRICS',
  /** Ignore matching metrics. */
  Ignore = 'IGNORE',
  /** Replace metrics. */
  Replace = 'REPLACE'
}

/** The different types of errors the API can return. */
export enum MetricNormalizationRuleErrorType {
  /** Creation Error. */
  CreationError = 'CREATION_ERROR',
  /** Edition Error. */
  EditionError = 'EDITION_ERROR',
  /** Rule does not exist. */
  RuleNotFound = 'RULE_NOT_FOUND',
  /** Validation error */
  ValidationError = 'VALIDATION_ERROR'
}

/** An object that represents a metric grouping issue. */
export type MetricNormalizationRuleMetricGroupingIssue = {
  __typename?: 'MetricNormalizationRuleMetricGroupingIssue';
  /** Total number of received and denied new metrics. */
  deniedMetricsCount?: Maybe<Scalars['Int']['output']>;
  /** Rate of received and denied new metrics per minute. */
  deniedMetricsRatePerMinute?: Maybe<Scalars['Float']['output']>;
  /** Metric normalization rule id */
  metricNormalizationRuleId: Scalars['Int']['output'];
  /** Whether the issue is mitigated or still active */
  mitigated?: Maybe<Scalars['Boolean']['output']>;
  /** The new metrics rate threshold to consider the issue mitigated. */
  mitigationRateThreshold?: Maybe<Scalars['Float']['output']>;
  /** The minute time window to calculate if the issue was mitigated. */
  mitigationRateWindowSize?: Maybe<Scalars['Int']['output']>;
};

/** Error for mutation results */
export type MetricNormalizationRuleMutationError = {
  __typename?: 'MetricNormalizationRuleMutationError';
  /** Details of error */
  message?: Maybe<Scalars['String']['output']>;
  /** Type of error */
  type?: Maybe<MetricNormalizationRuleErrorType>;
};

/** The result of a metric rename rule mutation */
export type MetricNormalizationRuleMutationResponse = {
  __typename?: 'MetricNormalizationRuleMutationResponse';
  /** An array containing errors, if any. */
  errors?: Maybe<Array<Maybe<MetricNormalizationRuleMutationError>>>;
  /** The created rule */
  rule?: Maybe<MetricNormalizationRule>;
};

/** Mobile application summary data */
export type MobileAppSummaryData = {
  __typename?: 'MobileAppSummaryData';
  /** The number of times the app has been launched. */
  appLaunchCount?: Maybe<Scalars['Int']['output']>;
  /** The number of crashes. */
  crashCount?: Maybe<Scalars['Int']['output']>;
  /** Crash rate is percentage of crashes per sessions. */
  crashRate?: Maybe<Scalars['Float']['output']>;
  /** Error rate is the percentage of http errors per successful requests. */
  httpErrorRate?: Maybe<Scalars['Float']['output']>;
  /** The number of http requests. */
  httpRequestCount?: Maybe<Scalars['Int']['output']>;
  /** The rate of http requests per minute. */
  httpRequestRate?: Maybe<Scalars['Float']['output']>;
  /** The average response time for all http calls. */
  httpResponseTimeAverage?: Maybe<Scalars['Seconds']['output']>;
  /** The number of mobile sessions. */
  mobileSessionCount?: Maybe<Scalars['Int']['output']>;
  /** Network failure rate is the percentage of network failures per successful requests. */
  networkFailureRate?: Maybe<Scalars['Float']['output']>;
  /** The number of users affected by crashes. */
  usersAffectedCount?: Maybe<Scalars['Int']['output']>;
};

/** A Mobile Application entity. */
export type MobileApplicationEntity = AlertableEntity & Entity & {
  __typename?: 'MobileApplicationEntity';
  account?: Maybe<AccountOutline>;
  /** The New Relic account ID associated with this entity. */
  accountId?: Maybe<Scalars['Int']['output']>;
  /** The current alerting severity of the entity. */
  alertSeverity?: Maybe<EntityAlertSeverity>;
  /**
   * The alert status of the entity.
   * @deprecated Please use `alertSeverity` and `reporting`
   */
  alertStatus?: Maybe<EntityAlertStatus>;
  /** Violations on the entity that were open during the specified time window. This will return up to 500 violations - if there are more in the time window selected, you must narrow the time window or look at fewer entities. */
  alertViolations?: Maybe<Array<Maybe<EntityAlertViolation>>>;
  /** The ID of the Mobile App. */
  applicationId?: Maybe<Scalars['Int']['output']>;
  /**
   * Query upstream and downstream dependencies for an entity
   * @deprecated This field is experimental and subject to breaking changes.
   */
  connections?: Maybe<RelatedExternalsEntityResult>;
  /** A Crash that occurred in your Mobile Application. */
  crash?: Maybe<StackTraceMobileCrash>;
  /** Retrieve the deployment event(s). Ordered by timestamp DESC. */
  deploymentSearch?: Maybe<ChangeTrackingDeploymentSearchResult>;
  /** The entity's domain */
  domain?: Maybe<Scalars['String']['output']>;
  /** A value representing the combination of the entity's domain and type. */
  entityType?: Maybe<EntityType>;
  /** A Handled Exception that occurred in your Mobile Application. */
  exception?: Maybe<StackTraceMobileException>;
  /** The date of last time the entity has updated any of its fields. */
  firstIndexedAt?: Maybe<Scalars['EpochMilliseconds']['output']>;
  /** The list of golden metrics for a specific entity */
  goldenMetrics?: Maybe<EntityGoldenContextScopedGoldenMetrics>;
  /**
   * For the golden signal on this entity, show correlated signals from related entities.
   * Well inspect the golden signals for all related entities and return a sorted list.
   * You can also filter the results.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  goldenSignalCorrelations?: Maybe<GoldenSignalCorrelationResult>;
  /**
   * The deviation from normal of golden signal(s) for the given entity.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  goldenSignalDeviations?: Maybe<Array<Maybe<GoldenSignalSignalDeviation>>>;
  /**
   * The stored golden signal(s) for the given entity.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  goldenSignalValues?: Maybe<GoldenSignalValues>;
  /**
   * The stored golden signal(s) for the given entity. To be removed, use goldenSignalValues instead.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  goldenSignalValuesV2?: Maybe<GoldenSignalValues>;
  /** The list of golden tags for a specific entityType. */
  goldenTags?: Maybe<EntityGoldenContextScopedGoldenTags>;
  /** A unique entity identifier. */
  guid?: Maybe<Scalars['EntityGuid']['output']>;
  /** The time the entity was indexed. */
  indexedAt?: Maybe<Scalars['EpochMilliseconds']['output']>;
  /** The last time the entity's reporting status changed. */
  lastReportingChangeAt?: Maybe<Scalars['EpochMilliseconds']['output']>;
  /** Retrieves the entity metric grouping issues. */
  metricGroupingIssues?: Maybe<Array<MetricNormalizationRuleMetricGroupingIssue>>;
  /** Retrieves a rule. */
  metricNormalizationRule?: Maybe<MetricNormalizationRule>;
  /** Retrieves the rules for the application. */
  metricNormalizationRules?: Maybe<Array<MetricNormalizationRule>>;
  /** Access general properties for the application. */
  mobileProperties?: Maybe<AgentApplicationSettingsMobileProperties>;
  /** Settings that are common across mobile applications. */
  mobileSettings?: Maybe<AgentApplicationSettingsMobileBase>;
  /** Summary statistics about the Mobile App. */
  mobileSummary?: Maybe<MobileAppSummaryData>;
  /** The name of this entity. */
  name?: Maybe<Scalars['String']['output']>;
  nerdStorage?: Maybe<NerdStorageEntityScope>;
  nerdStoreCollection?: Maybe<Array<Maybe<NerdStoreCollectionMember>>>;
  nerdStoreDocument?: Maybe<Scalars['NerdStoreDocument']['output']>;
  /**
   * Make an `Entity` scoped query to NRDB with a NRQL string.
   *
   * A relevant `WHERE` clause will be added to your query to scope data to the entity in question.
   *
   * See the [NRQL Docs](https://docs.newrelic.com/docs/insights/nrql-new-relic-query-language/nrql-resources/nrql-syntax-components-functions) for more information about generating a query string.
   */
  nrdbQuery?: Maybe<NrdbResultContainer>;
  /**
   * Poll for the results of a previously-executed asychronous NRDB query.
   *
   * The `queryId` is available in the `queryProgress` data returned by the original asynchronous query.
   *
   * See [this page](https://docs.newrelic.com/docs/apis/nerdgraph/examples/async-queries-nrql-tutorial) for additional asynchronous query documentation.
   * @deprecated This field is experimental! It may change at any time.
   *
   */
  nrdbQueryProgress?: Maybe<NrdbResultContainer>;
  /** The url to the entity. */
  permalink?: Maybe<Scalars['String']['output']>;
  /** Recent violations on the entity. */
  recentAlertViolations?: Maybe<Array<Maybe<EntityAlertViolation>>>;
  /** The recommended service levels for the entity. */
  recommendedServiceLevel?: Maybe<ServiceLevelRecommendation>;
  /** Related dashboards results */
  relatedDashboards: RelatedDashboardsRelatedDashboardResult;
  /** Related entities result with optional filtering. */
  relatedEntities?: Maybe<EntityRelationshipRelatedEntitiesResult>;
  /**
   * Query upstream and downstream transaction dependencies for an entity
   * @deprecated This field is experimental and subject to breaking changes.
   */
  relatedTransactions?: Maybe<RelatedExternalsTransactionResult>;
  /** Relationship traversal results with optional filtering. WARNING: this query is still experimental, and subject to breaking changes. */
  relationshipTraversal?: Maybe<EntityRelationshipTraversalResult>;
  /**
   * A list of the entities' relationships.
   *
   * For more information, visit [our docs](https://docs.newrelic.com/docs/apis/graphql-api/tutorials/graphql-relationships-api-tutorial).
   * @deprecated This field is deprecated! Please use `relatedEntities`.
   */
  relationships?: Maybe<Array<Maybe<EntityRelationship>>>;
  /** The reporting status of the entity. If New Relic is successfully collecting data from your application, this will be true. */
  reporting?: Maybe<Scalars['Boolean']['output']>;
  /** The service level defined for the entity. */
  serviceLevel?: Maybe<ServiceLevelDefinition>;
  /** The list of summary metrics. */
  summaryMetrics?: Maybe<Array<Maybe<EntitySummaryMetric>>>;
  /**
   * The tags applied to the entity.
   *
   * For details on tags, as well as query and mutation examples, visit [our docs](https://docs.newrelic.com/docs/apis/graphql-api/tutorials/graphql-tagging-api-tutorial).
   */
  tags?: Maybe<Array<Maybe<EntityTag>>>;
  /** The tags applied to the entity with their metadata. */
  tagsWithMetadata?: Maybe<Array<Maybe<EntityTagWithMetadata>>>;
  /** Look up Distributed Tracing summary data for the selected `EntityGuid` */
  tracingSummary?: Maybe<DistributedTracingEntityTracingSummary>;
  /** The entity's type */
  type?: Maybe<Scalars['String']['output']>;
  /** List of templates availables for this entity. */
  uiTemplates?: Maybe<Array<EntityDashboardTemplatesUi>>;
};


/** A Mobile Application entity. */
export type MobileApplicationEntityAlertViolationsArgs = {
  endTime: Scalars['EpochMilliseconds']['input'];
  startTime: Scalars['EpochMilliseconds']['input'];
};


/** A Mobile Application entity. */
export type MobileApplicationEntityConnectionsArgs = {
  timeWindow?: InputMaybe<TimeWindowInput>;
};


/** A Mobile Application entity. */
export type MobileApplicationEntityCrashArgs = {
  occurrenceId: Scalars['String']['input'];
  timeWindow?: InputMaybe<TimeWindowInput>;
};


/** A Mobile Application entity. */
export type MobileApplicationEntityDeploymentSearchArgs = {
  filter?: InputMaybe<ChangeTrackingSearchFilter>;
};


/** A Mobile Application entity. */
export type MobileApplicationEntityExceptionArgs = {
  fingerprint?: InputMaybe<Scalars['String']['input']>;
  occurrenceId?: InputMaybe<Scalars['String']['input']>;
  timeWindow?: InputMaybe<TimeWindowInput>;
};


/** A Mobile Application entity. */
export type MobileApplicationEntityGoldenMetricsArgs = {
  context?: InputMaybe<EntityGoldenContextInput>;
  timeWindow?: InputMaybe<EntityGoldenNrqlTimeWindowInput>;
};


/** A Mobile Application entity. */
export type MobileApplicationEntityGoldenSignalCorrelationsArgs = {
  filter?: InputMaybe<GoldenSignalCorrelationsEntityFilter>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  timeWindow?: InputMaybe<TimeWindowInput>;
};


/** A Mobile Application entity. */
export type MobileApplicationEntityGoldenSignalDeviationsArgs = {
  comparisonTimeWindow?: InputMaybe<TimeWindowInput>;
  evaluationTimeWindow?: InputMaybe<TimeWindowInput>;
};


/** A Mobile Application entity. */
export type MobileApplicationEntityGoldenSignalValuesArgs = {
  timeWindow?: InputMaybe<TimeWindowInput>;
};


/** A Mobile Application entity. */
export type MobileApplicationEntityGoldenSignalValuesV2Args = {
  timeWindow?: InputMaybe<TimeWindowInput>;
};


/** A Mobile Application entity. */
export type MobileApplicationEntityGoldenTagsArgs = {
  context?: InputMaybe<EntityGoldenContextInput>;
};


/** A Mobile Application entity. */
export type MobileApplicationEntityMetricGroupingIssuesArgs = {
  endTime?: InputMaybe<Scalars['EpochMilliseconds']['input']>;
  metricNormalizationRuleIds?: InputMaybe<Array<InputMaybe<Scalars['Int']['input']>>>;
  startTime?: InputMaybe<Scalars['EpochMilliseconds']['input']>;
};


/** A Mobile Application entity. */
export type MobileApplicationEntityMetricNormalizationRuleArgs = {
  id: Scalars['Int']['input'];
};


/** A Mobile Application entity. */
export type MobileApplicationEntityMetricNormalizationRulesArgs = {
  enabled?: InputMaybe<Scalars['Boolean']['input']>;
};


/** A Mobile Application entity. */
export type MobileApplicationEntityNerdStoreCollectionArgs = {
  collection: Scalars['String']['input'];
  scopeByActor?: InputMaybe<Scalars['Boolean']['input']>;
};


/** A Mobile Application entity. */
export type MobileApplicationEntityNerdStoreDocumentArgs = {
  collection: Scalars['String']['input'];
  documentId: Scalars['String']['input'];
  scopeByActor?: InputMaybe<Scalars['Boolean']['input']>;
};


/** A Mobile Application entity. */
export type MobileApplicationEntityNrdbQueryArgs = {
  async?: InputMaybe<Scalars['Boolean']['input']>;
  nrql: Scalars['Nrql']['input'];
  options?: InputMaybe<NrqlQueryOptions>;
  timeout?: InputMaybe<Scalars['Seconds']['input']>;
};


/** A Mobile Application entity. */
export type MobileApplicationEntityNrdbQueryProgressArgs = {
  queryId: Scalars['ID']['input'];
};


/** A Mobile Application entity. */
export type MobileApplicationEntityRecentAlertViolationsArgs = {
  count?: InputMaybe<Scalars['Int']['input']>;
};


/** A Mobile Application entity. */
export type MobileApplicationEntityRelatedEntitiesArgs = {
  cursor?: InputMaybe<Scalars['String']['input']>;
  filter?: InputMaybe<EntityRelationshipEdgeFilter>;
  limit?: InputMaybe<Scalars['Int']['input']>;
};


/** A Mobile Application entity. */
export type MobileApplicationEntityRelatedTransactionsArgs = {
  search: RelatedExternalsSearch;
  timeWindow?: InputMaybe<TimeWindowInput>;
};


/** A Mobile Application entity. */
export type MobileApplicationEntityRelationshipTraversalArgs = {
  cursor?: InputMaybe<Scalars['String']['input']>;
  hopFilters?: InputMaybe<EntityRelationshipTraversalHopFilters>;
  hops?: InputMaybe<Scalars['Int']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
};


/** A Mobile Application entity. */
export type MobileApplicationEntityRelationshipsArgs = {
  endTime?: InputMaybe<Scalars['EpochMilliseconds']['input']>;
  filter?: InputMaybe<EntityRelationshipFilter>;
};


/** A Mobile Application entity. */
export type MobileApplicationEntitySummaryMetricsArgs = {
  timeWindow?: InputMaybe<TimeWindowInput>;
};


/** A Mobile Application entity. */
export type MobileApplicationEntityTracingSummaryArgs = {
  timeWindow?: InputMaybe<TimeWindowInput>;
};

/** A Mobile Application entity outline. */
export type MobileApplicationEntityOutline = AlertableEntityOutline & EntityOutline & {
  __typename?: 'MobileApplicationEntityOutline';
  account?: Maybe<AccountOutline>;
  /** The New Relic account ID associated with this entity. */
  accountId?: Maybe<Scalars['Int']['output']>;
  /** The current alerting severity of the entity. */
  alertSeverity?: Maybe<EntityAlertSeverity>;
  /**
   * The alert status of the entity.
   * @deprecated Please use `alertSeverity` and `reporting`
   */
  alertStatus?: Maybe<EntityAlertStatus>;
  /** The ID of the Mobile App. */
  applicationId?: Maybe<Scalars['Int']['output']>;
  /** The entity's domain */
  domain?: Maybe<Scalars['String']['output']>;
  /** A value representing the combination of the entity's domain and type. */
  entityType?: Maybe<EntityType>;
  /** The date of last time the entity has updated any of its fields. */
  firstIndexedAt?: Maybe<Scalars['EpochMilliseconds']['output']>;
  /** The list of golden metrics for a specific entity */
  goldenMetrics?: Maybe<EntityGoldenContextScopedGoldenMetrics>;
  /**
   * For the golden signal on this entity, show correlated signals from related entities.
   * Well inspect the golden signals for all related entities and return a sorted list.
   * You can also filter the results.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  goldenSignalCorrelations?: Maybe<GoldenSignalCorrelationResult>;
  /**
   * The deviation from normal of golden signal(s) for the given entity.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  goldenSignalDeviations?: Maybe<Array<Maybe<GoldenSignalSignalDeviation>>>;
  /**
   * The stored golden signal(s) for the given entity.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  goldenSignalValues?: Maybe<GoldenSignalValues>;
  /**
   * The stored golden signal(s) for the given entity. To be removed, use goldenSignalValues instead.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  goldenSignalValuesV2?: Maybe<GoldenSignalValues>;
  /** The list of golden tags for a specific entityType. */
  goldenTags?: Maybe<EntityGoldenContextScopedGoldenTags>;
  /** A unique entity identifier. */
  guid?: Maybe<Scalars['EntityGuid']['output']>;
  /** The time the entity was indexed. */
  indexedAt?: Maybe<Scalars['EpochMilliseconds']['output']>;
  /** The last time the entity's reporting status changed. */
  lastReportingChangeAt?: Maybe<Scalars['EpochMilliseconds']['output']>;
  /** Summary statistics about the Mobile App. */
  mobileSummary?: Maybe<MobileAppSummaryData>;
  /** The name of this entity. */
  name?: Maybe<Scalars['String']['output']>;
  /** The url to the entity. */
  permalink?: Maybe<Scalars['String']['output']>;
  /** The recommended service levels for the entity. */
  recommendedServiceLevel?: Maybe<ServiceLevelRecommendation>;
  /** Related dashboards results */
  relatedDashboards: RelatedDashboardsRelatedDashboardResult;
  /** The reporting status of the entity. If New Relic is successfully collecting data from your application, this will be true. */
  reporting?: Maybe<Scalars['Boolean']['output']>;
  /** The service level defined for the entity. */
  serviceLevel?: Maybe<ServiceLevelDefinition>;
  /** The list of summary metrics. */
  summaryMetrics?: Maybe<Array<Maybe<EntitySummaryMetric>>>;
  /**
   * The tags applied to the entity.
   *
   * For details on tags, as well as query and mutation examples, visit [our docs](https://docs.newrelic.com/docs/apis/graphql-api/tutorials/graphql-tagging-api-tutorial).
   */
  tags?: Maybe<Array<Maybe<EntityTag>>>;
  /** The entity's type */
  type?: Maybe<Scalars['String']['output']>;
  /** List of templates availables for this entity. */
  uiTemplates?: Maybe<Array<EntityDashboardTemplatesUi>>;
};


/** A Mobile Application entity outline. */
export type MobileApplicationEntityOutlineGoldenMetricsArgs = {
  context?: InputMaybe<EntityGoldenContextInput>;
  timeWindow?: InputMaybe<EntityGoldenNrqlTimeWindowInput>;
};


/** A Mobile Application entity outline. */
export type MobileApplicationEntityOutlineGoldenSignalCorrelationsArgs = {
  filter?: InputMaybe<GoldenSignalCorrelationsEntityFilter>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  timeWindow?: InputMaybe<TimeWindowInput>;
};


/** A Mobile Application entity outline. */
export type MobileApplicationEntityOutlineGoldenSignalDeviationsArgs = {
  comparisonTimeWindow?: InputMaybe<TimeWindowInput>;
  evaluationTimeWindow?: InputMaybe<TimeWindowInput>;
};


/** A Mobile Application entity outline. */
export type MobileApplicationEntityOutlineGoldenSignalValuesArgs = {
  timeWindow?: InputMaybe<TimeWindowInput>;
};


/** A Mobile Application entity outline. */
export type MobileApplicationEntityOutlineGoldenSignalValuesV2Args = {
  timeWindow?: InputMaybe<TimeWindowInput>;
};


/** A Mobile Application entity outline. */
export type MobileApplicationEntityOutlineGoldenTagsArgs = {
  context?: InputMaybe<EntityGoldenContextInput>;
};


/** A Mobile Application entity outline. */
export type MobileApplicationEntityOutlineSummaryMetricsArgs = {
  timeWindow?: InputMaybe<TimeWindowInput>;
};

export type MobilePushNotificationActorStitchedFields = {
  __typename?: 'MobilePushNotificationActorStitchedFields';
  /** A list of mobile devices the user has registered for push notifications. */
  devices?: Maybe<Array<Maybe<MobilePushNotificationDevice>>>;
};

/** Device info used for push notifications. */
export type MobilePushNotificationDevice = {
  __typename?: 'MobilePushNotificationDevice';
  /** The version of the app. */
  appVersion: Scalars['SemVer']['output'];
  /** The uuid of the device. */
  deviceId: Scalars['String']['output'];
  /** The name of the device. */
  deviceName: Scalars['String']['output'];
  /** The push notification token. */
  deviceToken: Scalars['SecureValue']['output'];
  /** The OS this device is running (android/ios). */
  operatingSystem: Scalars['String']['output'];
  /** The id of the user this device belongs to. */
  userId: Scalars['Int']['output'];
};

/** Result from removing a device. */
export type MobilePushNotificationRemoveDeviceResult = {
  __typename?: 'MobilePushNotificationRemoveDeviceResult';
  /** The uuid of the device that was removed. */
  deviceId?: Maybe<Scalars['String']['output']>;
  /** The success or failure message from the attempted remove. */
  message?: Maybe<Scalars['String']['output']>;
};

/** Result from sending a test push notification. */
export type MobilePushNotificationSendPushResult = {
  __typename?: 'MobilePushNotificationSendPushResult';
  /** The success or failure message from the attempted test push. */
  message?: Maybe<Scalars['String']['output']>;
};

/** A grant within the system */
export type MultiTenantAuthorizationGrant = {
  __typename?: 'MultiTenantAuthorizationGrant';
  /** The group associated to the grant */
  group: MultiTenantAuthorizationGrantGroup;
  /** The id of the grant */
  id: Scalars['Int']['output'];
  /** The role associated to the grant */
  role: MultiTenantAuthorizationGrantRole;
  /** The scope associated to the grant */
  scope: MultiTenantAuthorizationGrantScope;
};

/** Filters grants by authentication domain id */
export type MultiTenantAuthorizationGrantAuthenticationDomainIdInputFilter = {
  /** Performs an equals operation */
  eq?: InputMaybe<Scalars['ID']['input']>;
  /** Performs an in operation */
  in?: InputMaybe<Array<Scalars['ID']['input']>>;
};

/** A list of grants */
export type MultiTenantAuthorizationGrantCollection = {
  __typename?: 'MultiTenantAuthorizationGrantCollection';
  /** List of grants */
  items: Array<MultiTenantAuthorizationGrant>;
  /** an opaque cursor to supply with subsequent   requests to get the next page of results, null if there are no more pages */
  nextCursor?: Maybe<Scalars['String']['output']>;
};

/** Provides all the available filters on a grant */
export type MultiTenantAuthorizationGrantFilterInputExpression = {
  /** The authentication domain id of the grant */
  authenticationDomainId?: InputMaybe<MultiTenantAuthorizationGrantAuthenticationDomainIdInputFilter>;
  /** The group id of the grant */
  groupId?: InputMaybe<MultiTenantAuthorizationGrantGroupIdInputFilter>;
  /** The id of the grant */
  id?: InputMaybe<MultiTenantAuthorizationGrantIdInputFilter>;
  /** The organization id the grant belongs to */
  organizationId: MultiTenantAuthorizationGrantOrganizationIdInputFilter;
  /** The role id of the grant */
  roleId?: InputMaybe<MultiTenantAuthorizationGrantRoleIdInputFilter>;
  /** the scope id of the grant */
  scopeId?: InputMaybe<MultiTenantAuthorizationGrantScopeIdInputFilter>;
  /** The scope type of the grant */
  scopeType?: InputMaybe<MultiTenantAuthorizationGrantScopeTypeInputFilter>;
};

/** The group associated to the grant */
export type MultiTenantAuthorizationGrantGroup = {
  __typename?: 'MultiTenantAuthorizationGrantGroup';
  /** The id of the group */
  id: Scalars['ID']['output'];
};

/** Filters on grants group id */
export type MultiTenantAuthorizationGrantGroupIdInputFilter = {
  /** Performs an equals operation */
  eq?: InputMaybe<Scalars['ID']['input']>;
  /** Performs an in operation */
  in?: InputMaybe<Array<Scalars['ID']['input']>>;
};

/** Fitlers on grants id */
export type MultiTenantAuthorizationGrantIdInputFilter = {
  /** Performs an equals operation */
  eq: Scalars['Int']['input'];
};

/** Filters on the grants organization id */
export type MultiTenantAuthorizationGrantOrganizationIdInputFilter = {
  /** Performs an equals operation */
  eq: Scalars['ID']['input'];
};

/** The role associated to the grant */
export type MultiTenantAuthorizationGrantRole = {
  __typename?: 'MultiTenantAuthorizationGrantRole';
  /** The id of the role */
  id: Scalars['Int']['output'];
  /** The name of the role */
  name: Scalars['String']['output'];
};

/** Filters on the grants role id */
export type MultiTenantAuthorizationGrantRoleIdInputFilter = {
  /** Performs an equals operation */
  eq?: InputMaybe<Scalars['Int']['input']>;
  /** Performs an in operation */
  in?: InputMaybe<Array<Scalars['Int']['input']>>;
};

/** The scope associated to the grant */
export type MultiTenantAuthorizationGrantScope = {
  __typename?: 'MultiTenantAuthorizationGrantScope';
  /** The id of the resource in scope */
  id: Scalars['String']['output'];
  /** The type of the resource in scope */
  type: MultiTenantAuthorizationGrantScopeEnum;
};

/** Provides the types of grant scopes available */
export enum MultiTenantAuthorizationGrantScopeEnum {
  /** Grant scoped to an account */
  Account = 'ACCOUNT',
  /** Grant scoped to a group */
  Group = 'GROUP',
  /** Grant scoped to an organization */
  Organization = 'ORGANIZATION'
}

/** Filters on the grants scope id */
export type MultiTenantAuthorizationGrantScopeIdInputFilter = {
  /** Performs an equals operation */
  eq?: InputMaybe<Scalars['String']['input']>;
  /** Performs an in operation */
  in?: InputMaybe<Array<Scalars['String']['input']>>;
};

/** Filters on the grants scope type */
export type MultiTenantAuthorizationGrantScopeTypeInputFilter = {
  /** Performs an equals operation */
  eq: MultiTenantAuthorizationGrantScopeEnum;
};

/** The possible fields a grant can be sorted on */
export enum MultiTenantAuthorizationGrantSortEnum {
  /** Id of the grant */
  Id = 'ID'
}

/** Provides the sorting options for grants */
export type MultiTenantAuthorizationGrantSortInput = {
  /** The direction which the field should be sorted */
  direction?: InputMaybe<MultiTenantAuthorizationSortDirectionEnum>;
  /** The field to be sorted */
  key: MultiTenantAuthorizationGrantSortEnum;
};

/** An allowed action */
export type MultiTenantAuthorizationPermission = {
  __typename?: 'MultiTenantAuthorizationPermission';
  /** The kind of access */
  category?: Maybe<MultiTenantAuthorizationPermissionCategoryEnum>;
  /** The feature the permission controls access to */
  feature?: Maybe<Scalars['String']['output']>;
  /** a value that uniquely identifies this object */
  id: Scalars['ID']['output'];
  /** Name of the permission if category is OTHER */
  name?: Maybe<Scalars['String']['output']>;
  /** The product the permission controls access to */
  product?: Maybe<Scalars['String']['output']>;
  /** batches that are a sub-set of this batch */
  subsetIds?: Maybe<Array<Scalars['ID']['output']>>;
};

/** The kind of access granted by permissions */
export enum MultiTenantAuthorizationPermissionCategoryEnum {
  /** Delete access */
  Delete = 'DELETE',
  /** Create and update access */
  Manage = 'MANAGE',
  /** Create and update access */
  Modify = 'MODIFY',
  /** Other access */
  Other = 'OTHER',
  /** View access */
  Read = 'READ',
  /** View access */
  View = 'VIEW'
}

/** A collection of permissions */
export type MultiTenantAuthorizationPermissionCollection = {
  __typename?: 'MultiTenantAuthorizationPermissionCollection';
  /** collection of permissions */
  items: Array<MultiTenantAuthorizationPermission>;
  /** an opaque cursor to supply with subsequent   requests to get the next page of results, null if there are no more pages */
  nextCursor?: Maybe<Scalars['String']['output']>;
};

/** Provides all the available filters on permissions */
export type MultiTenantAuthorizationPermissionFilter = {
  /** Filter permissions by role id */
  roleId?: InputMaybe<MultiTenantAuthorizationPermissionFilterRoleIdInput>;
};

/** Filter permissions by role id */
export type MultiTenantAuthorizationPermissionFilterRoleIdInput = {
  /** performs an equals operation */
  eq: Scalars['ID']['input'];
};

/** Describes a role within the system */
export type MultiTenantAuthorizationRole = {
  __typename?: 'MultiTenantAuthorizationRole';
  /** a value that uniquely identifies this object */
  id: Scalars['Int']['output'];
  /** internal snake_case name */
  internalName: Scalars['String']['output'];
  /** the name of the object */
  name: Scalars['String']['output'];
  /** The scope the role applies to */
  scope: Scalars['String']['output'];
  /** The type of role */
  type: Scalars['String']['output'];
};

/** An iterable collection of roles */
export type MultiTenantAuthorizationRoleCollection = {
  __typename?: 'MultiTenantAuthorizationRoleCollection';
  /** collection of roles */
  items: Array<MultiTenantAuthorizationRole>;
  /** an opaque cursor to supply with subsequent   requests to get the next page of results, null if there are no more pages */
  nextCursor?: Maybe<Scalars['String']['output']>;
  /** the total number of results */
  totalCount: Scalars['Int']['output'];
};

/** Provides all the available filters on a role */
export type MultiTenantAuthorizationRoleFilterInputExpression = {
  /** The group id the role has been granted to */
  groupId?: InputMaybe<MultiTenantAuthorizationRoleGroupIdInputFilter>;
  /** The id of the role */
  id?: InputMaybe<MultiTenantAuthorizationRoleIdInputFilter>;
  /** The name of the role */
  name?: InputMaybe<MultiTenantAuthorizationRoleNameInputFilter>;
  /** The organization id the role belongs to */
  organizationId: MultiTenantAuthorizationRoleOrganizationIdInputFilter;
  /** The scope of the role */
  scope?: InputMaybe<MultiTenantAuthorizationRoleScopeInputFilter>;
  /** The type of the role */
  type?: InputMaybe<MultiTenantAuthorizationRoleTypeInputFilter>;
};

/** Provides all the available filters on the group id */
export type MultiTenantAuthorizationRoleGroupIdInputFilter = {
  /** performs an equals operation */
  eq?: InputMaybe<Scalars['ID']['input']>;
  /** A list of group IDs */
  in?: InputMaybe<Array<Scalars['ID']['input']>>;
};

/** Provides all the available filters on the role id */
export type MultiTenantAuthorizationRoleIdInputFilter = {
  /** performs an equals operation */
  eq: Scalars['Int']['input'];
};

/** Provides all the available filters on the role name */
export type MultiTenantAuthorizationRoleNameInputFilter = {
  /** performs a contains operation */
  contains?: InputMaybe<Scalars['String']['input']>;
  /** performs an equals operation */
  eq?: InputMaybe<Scalars['String']['input']>;
};

/** Provides all the available filters on the organization id */
export type MultiTenantAuthorizationRoleOrganizationIdInputFilter = {
  /** performs an equals operation */
  eq: Scalars['ID']['input'];
};

/** Enumerations of role scopes */
export enum MultiTenantAuthorizationRoleScopeEnum {
  /** Account scoped role */
  Account = 'ACCOUNT',
  /** Group scoped role */
  Group = 'GROUP',
  /** Organization scoped role */
  Organization = 'ORGANIZATION'
}

/** Provides all the available filters on the role scope */
export type MultiTenantAuthorizationRoleScopeInputFilter = {
  /** performs an equals operation */
  eq: MultiTenantAuthorizationRoleScopeEnum;
};

/** The list of sortable fields */
export enum MultiTenantAuthorizationRoleSortEnum {
  /** Id of the role */
  Id = 'ID',
  /** Name of the role */
  Name = 'NAME',
  /** Scope of the role */
  Scope = 'SCOPE',
  /** Type of the role */
  Type = 'TYPE'
}

/** Provides the field and direction the result should be sorted */
export type MultiTenantAuthorizationRoleSortInput = {
  /** The direction the field should be sorted */
  direction?: InputMaybe<MultiTenantAuthorizationSortDirectionEnum>;
  /** The field which should be sorted */
  key: MultiTenantAuthorizationRoleSortEnum;
};

/** Enumerations of role types */
export enum MultiTenantAuthorizationRoleTypeEnum {
  /** Custom role */
  Custom = 'CUSTOM',
  /** Standard role */
  Standard = 'STANDARD'
}

/** Provides all the available filters on the role type */
export type MultiTenantAuthorizationRoleTypeInputFilter = {
  /** performs an equals operation */
  eq: MultiTenantAuthorizationRoleTypeEnum;
};

/** Provides the directions data can be sorted */
export enum MultiTenantAuthorizationSortDirectionEnum {
  /** Sort in ascending order */
  Ascending = 'ASCENDING',
  /** Sort in descending order */
  Descending = 'DESCENDING'
}

/** The input object representing parameters for the allowed capability filter */
export type MultiTenantIdentityAllowsCapabilityInput = {
  /** A list of capabilities. If set, groups with atleast one of the given capabilities granted on them for the user will be returned. Otherwise, only groups with read access granted are returned. */
  in?: InputMaybe<Array<MultiTenantIdentityCapability>>;
};

/** The input object representing parameters for the authentication domain ID filter */
export type MultiTenantIdentityAuthenticationDomainIdInput = {
  /** An authentication domain ID */
  eq: Scalars['ID']['input'];
};

/** Provides the types of group capabilities available */
export enum MultiTenantIdentityCapability {
  /** The capability to delete a group */
  DeleteGroup = 'DELETE_GROUP',
  /** The capability to grant membership to a group */
  GrantGroupMembership = 'GRANT_GROUP_MEMBERSHIP',
  /** The capability to revoke membership from a group */
  RevokeGroupMembership = 'REVOKE_GROUP_MEMBERSHIP',
  /** The capability to update a group's display name */
  UpdateGroupName = 'UPDATE_GROUP_NAME'
}

/** Email verification validates that a user's email address exists and can receive email. One of: "Not Verifiable", "Verified", and "Pending". */
export enum MultiTenantIdentityEmailVerificationState {
  /** The user's email does not require verification. */
  NotVerifiable = 'NOT_VERIFIABLE',
  /** The user's email requires verification and has not been verified. */
  Pending = 'PENDING',
  /** The user's email requires verification and has been verified. */
  Verified = 'VERIFIED'
}

/** Available filtering types for email verification states */
export type MultiTenantIdentityEmailVerificationStateInput = {
  /** An email verification state */
  pending: Scalars['Boolean']['input'];
};

/** A Granted Role represents the access given to a group. */
export type MultiTenantIdentityGrantRole = {
  __typename?: 'MultiTenantIdentityGrantRole';
  /** a value that uniquely identifies this object */
  id: Scalars['ID']['output'];
  /** the name of the object */
  name: Scalars['String']['output'];
  /** the type of the role */
  type: Scalars['String']['output'];
};

/** The resource on which access was granted */
export type MultiTenantIdentityGrantScope = {
  __typename?: 'MultiTenantIdentityGrantScope';
  /** The ID of the resource on which access was granted. */
  id: Scalars['ID']['output'];
  /** The type of resource on which access was granted. */
  type: Scalars['String']['output'];
};

/** For users on our New Relic One user model, a "group" represents a group of users. Putting users in a group allows the managing of permissions for multiple users at the same time. */
export type MultiTenantIdentityGroup = {
  __typename?: 'MultiTenantIdentityGroup';
  /** The authentication domain the group belongs to */
  authenticationDomainId: Scalars['ID']['output'];
  /** Access grants that have been granted to a group */
  grants?: Maybe<MultiTenantIdentityGroupGrants>;
  /** a value that uniquely identifies this object */
  id: Scalars['ID']['output'];
  /** the name of the object */
  name: Scalars['String']['output'];
  /** Active users belonging to a group */
  users?: Maybe<MultiTenantIdentityGroupUsers>;
};


/** For users on our New Relic One user model, a "group" represents a group of users. Putting users in a group allows the managing of permissions for multiple users at the same time. */
export type MultiTenantIdentityGroupGrantsArgs = {
  cursor?: InputMaybe<Scalars['String']['input']>;
};


/** For users on our New Relic One user model, a "group" represents a group of users. Putting users in a group allows the managing of permissions for multiple users at the same time. */
export type MultiTenantIdentityGroupUsersArgs = {
  cursor?: InputMaybe<Scalars['String']['input']>;
  filter?: InputMaybe<MultiTenantIdentityGroupUserFilterInput>;
};

/** List of groups representing named sets of New Relic users within an authentication domain */
export type MultiTenantIdentityGroupCollection = {
  __typename?: 'MultiTenantIdentityGroupCollection';
  /** groups */
  items: Array<MultiTenantIdentityGroup>;
  /** an opaque cursor to supply with subsequent     requests to get the next page of results, null if there are no more pages */
  nextCursor?: Maybe<Scalars['String']['output']>;
  /** the total number of results */
  totalCount: Scalars['Int']['output'];
};

/** The input object representing the filter parameters for groups */
export type MultiTenantIdentityGroupFilterInput = {
  /** Filter groups by capabilities */
  allowsCapability?: InputMaybe<MultiTenantIdentityAllowsCapabilityInput>;
  /** Filter groups by authentication domain */
  authenticationDomainId?: InputMaybe<MultiTenantIdentityAuthenticationDomainIdInput>;
  /** Filter groups by ID */
  id?: InputMaybe<MultiTenantIdentityGroupIdInput>;
  /** Filter groups that contain specific members */
  members?: InputMaybe<MultiTenantIdentityGroupMemberIdInput>;
  /** Filter groups by display name */
  name?: InputMaybe<MultiTenantIdentityGroupNameInput>;
  /** An organization ID to filter groups by */
  organizationId: MultiTenantIdentityOrganizationIdInput;
};

/** An Access Grant that has been granted to a group */
export type MultiTenantIdentityGroupGrant = {
  __typename?: 'MultiTenantIdentityGroupGrant';
  /** a value that uniquely identifies this object */
  id: Scalars['ID']['output'];
  /** The Role that represents the access given. */
  role?: Maybe<MultiTenantIdentityGrantRole>;
  /** The resource on which access was granted */
  scope: MultiTenantIdentityGrantScope;
};

/** List of access grants that have been granted to a group */
export type MultiTenantIdentityGroupGrants = {
  __typename?: 'MultiTenantIdentityGroupGrants';
  /** Access grants that have been granted to a group */
  items: Array<MultiTenantIdentityGroupGrant>;
  /** an opaque cursor to supply with subsequent     requests to get the next page of results, null if there are no more pages */
  nextCursor?: Maybe<Scalars['String']['output']>;
};

/** The input object representing parameters for the ID input filter */
export type MultiTenantIdentityGroupIdInput = {
  /** A group ID */
  eq: Scalars['ID']['input'];
};

/** The input object representing parameters for the Members filter */
export type MultiTenantIdentityGroupMemberIdInput = {
  /** A list of user IDs. A group will be returned if all listed users are members. */
  contains: Array<Scalars['ID']['input']>;
};

/** The input object representing parameters for the name filter */
export type MultiTenantIdentityGroupNameInput = {
  /** Part of a group name */
  contains?: InputMaybe<Scalars['String']['input']>;
  /** A group name */
  eq?: InputMaybe<Scalars['String']['input']>;
};

/** The input object representing the sort parameters for groups */
export type MultiTenantIdentityGroupSortInput = {
  /** Order by which to sort groups */
  direction?: InputMaybe<MultiTenantIdentitySortDirection>;
  /** Group attribute to sort on */
  key?: InputMaybe<MultiTenantIdentitySortKeyEnum>;
};

/** Active user within group */
export type MultiTenantIdentityGroupUser = {
  __typename?: 'MultiTenantIdentityGroupUser';
  /** The email of the user. */
  email: Scalars['String']['output'];
  /** a value that uniquely identifies this object */
  id: Scalars['ID']['output'];
  /** The full name of the user. */
  name: Scalars['String']['output'];
  /** The configured time zone of the user. */
  timeZone?: Maybe<Scalars['String']['output']>;
};

/** The input object representing the filter parameters for user groups */
export type MultiTenantIdentityGroupUserFilterInput = {
  /** Filter users by IDs */
  id?: InputMaybe<MultiTenantIdentityUserIdInput>;
};

/** List of active users belonging to a group */
export type MultiTenantIdentityGroupUsers = {
  __typename?: 'MultiTenantIdentityGroupUsers';
  /** Active users within group */
  items: Array<MultiTenantIdentityGroupUser>;
  /** an opaque cursor to supply with subsequent     requests to get the next page of results, null if there are no more pages */
  nextCursor?: Maybe<Scalars['String']['output']>;
  /** the total number of results */
  totalCount: Scalars['Int']['output'];
};

/** The input object representing parameters for the organization ID filter */
export type MultiTenantIdentityOrganizationIdInput = {
  /** An organization ID */
  eq: Scalars['ID']['input'];
};

/** Exists only if a user has a pending upgrade request. */
export type MultiTenantIdentityPendingUpgradeRequest = {
  __typename?: 'MultiTenantIdentityPendingUpgradeRequest';
  /** a value that uniquely identifies this object */
  id: Scalars['ID']['output'];
  /** Requester message, why the user believes they require the upgrade. */
  message?: Maybe<Scalars['String']['output']>;
  /** Requested user type for the user. */
  requestedUserType?: Maybe<MultiTenantIdentityUserType>;
};

/** Available filtering types for pending upgrade requests */
export type MultiTenantIdentityPendingUpgradeRequestInput = {
  /** Whether a request exists or not */
  exists: Scalars['Boolean']['input'];
};

/** Available directions for sorting */
export enum MultiTenantIdentitySortDirection {
  /** Sort in ascending order */
  Ascending = 'ASCENDING',
  /** Sort in descending order */
  Descending = 'DESCENDING'
}

/** Available keys for sorting groups */
export enum MultiTenantIdentitySortKeyEnum {
  /** Authentication domain ID */
  AuthenticationDomainId = 'AUTHENTICATION_DOMAIN_ID',
  /** Group ID */
  Id = 'ID',
  /** Group name */
  Name = 'NAME'
}

/** A New Relic user */
export type MultiTenantIdentityUser = {
  __typename?: 'MultiTenantIdentityUser';
  /** The authentication domain the user belongs to. */
  authenticationDomainId: Scalars['ID']['output'];
  /** Email address of the user. */
  email?: Maybe<Scalars['String']['output']>;
  /**
   * One of: "Not Verifiable", "Verified", and "Pending".
   *
   * Not Verifiable: the user's email does not require verification.
   *
   * Verified: the user's email requires verification and has been.
   *
   * Pending: the user's email requires verification and has not been.
   */
  emailVerificationState: MultiTenantIdentityEmailVerificationState;
  /** container for groups enabling cursor based pagination */
  groups?: Maybe<MultiTenantIdentityUserGroups>;
  /** The user id. */
  id: Scalars['ID']['output'];
  /** The last active date of the user. */
  lastActive?: Maybe<Scalars['DateTime']['output']>;
  /** The full name of the user. */
  name?: Maybe<Scalars['String']['output']>;
  /** The pending upgrade request for the user (if any). */
  pendingUpgradeRequest?: Maybe<MultiTenantIdentityPendingUpgradeRequest>;
  /** Time zone of the user in IANA Time Zone database format, also known as the "Olson" time zone database format (for exmaple, "America/Los_Angeles"). */
  timeZone?: Maybe<Scalars['String']['output']>;
  /** A "user type" is what determines the set of New Relic capabilities a user can theoretically access. */
  type: MultiTenantIdentityUserType;
};


/** A New Relic user */
export type MultiTenantIdentityUserGroupsArgs = {
  cursor?: InputMaybe<Scalars['String']['input']>;
};

/** A collection of New Relic users */
export type MultiTenantIdentityUserCollection = {
  __typename?: 'MultiTenantIdentityUserCollection';
  /** Users */
  items: Array<MultiTenantIdentityUser>;
  /** an opaque cursor to supply with subsequent     requests to get the next page of results, null if there are no more pages */
  nextCursor?: Maybe<Scalars['String']['output']>;
  /**
   * The total number of users found.
   *  Note: Not necessarily the same as number of users returned, due to pagination.
   */
  totalCount: Scalars['Int']['output'];
};

/** Filters by user email address */
export type MultiTenantIdentityUserEmailInput = {
  /** Part of an email address */
  contains?: InputMaybe<Scalars['String']['input']>;
  /** An email address */
  eq?: InputMaybe<Scalars['String']['input']>;
};

/** Filter users */
export type MultiTenantIdentityUserFilterInput = {
  /** Filter users by authentication domain */
  authenticationDomainId: MultiTenantIdentityAuthenticationDomainIdInput;
  /** Filter users by email address */
  email?: InputMaybe<MultiTenantIdentityUserEmailInput>;
  /** Filter users by email verification state */
  emailVerificationState?: InputMaybe<MultiTenantIdentityEmailVerificationStateInput>;
  /** Filter users by group id */
  groupId?: InputMaybe<MultiTenantIdentityUserGroupIdInput>;
  /** Filter users by id */
  id?: InputMaybe<MultiTenantIdentityUserIdInput>;
  /** Filter users by name */
  name?: InputMaybe<MultiTenantIdentityUserNameInput>;
  /** Filter users by pending upgrade request */
  pendingUpgradeRequest?: InputMaybe<MultiTenantIdentityPendingUpgradeRequestInput>;
};

/** A group of users. */
export type MultiTenantIdentityUserGroup = {
  __typename?: 'MultiTenantIdentityUserGroup';
  /** a value that uniquely identifies this object */
  id: Scalars['ID']['output'];
  /** the name of the object */
  name: Scalars['String']['output'];
};

/** Filters by group id */
export type MultiTenantIdentityUserGroupIdInput = {
  /** A group id */
  eq?: InputMaybe<Scalars['ID']['input']>;
  /** A list of group IDs */
  in?: InputMaybe<Array<Scalars['ID']['input']>>;
};

/** List of groups representing named sets of New Relic users within an authentication domain */
export type MultiTenantIdentityUserGroups = {
  __typename?: 'MultiTenantIdentityUserGroups';
  /** User groups */
  items: Array<MultiTenantIdentityUserGroup>;
  /** an opaque cursor to supply with subsequent     requests to get the next page of results, null if there are no more pages */
  nextCursor?: Maybe<Scalars['String']['output']>;
  /** the total number of results */
  totalCount: Scalars['Int']['output'];
};

/** Filters by user id */
export type MultiTenantIdentityUserIdInput = {
  /** A user id */
  eq?: InputMaybe<Scalars['ID']['input']>;
  /** A list of user IDs */
  in?: InputMaybe<Array<Scalars['ID']['input']>>;
};

/** Filters by user name */
export type MultiTenantIdentityUserNameInput = {
  /** Part of a user name */
  contains?: InputMaybe<Scalars['String']['input']>;
  /** A user name */
  eq?: InputMaybe<Scalars['String']['input']>;
};

/** Sort users */
export type MultiTenantIdentityUserSortInput = {
  /** Direction to sort in */
  direction?: InputMaybe<MultiTenantIdentitySortDirection>;
  /** User attribute to sort on */
  key?: InputMaybe<MultiTenantIdentityUserSortKey>;
};

/** Available keys for sorting users */
export enum MultiTenantIdentityUserSortKey {
  /** User email address */
  Email = 'EMAIL',
  /** User id */
  Id = 'ID',
  /** User last active date */
  LastActive = 'LAST_ACTIVE',
  /** User name */
  Name = 'NAME',
  /** User type */
  Type = 'TYPE'
}

/** A "user type" is what determines the set of New Relic capabilities a user can theoretically access. */
export type MultiTenantIdentityUserType = {
  __typename?: 'MultiTenantIdentityUserType';
  /** The id of the user type. */
  id: Scalars['ID']['output'];
  /** The name of the user type. */
  name: Scalars['String']['output'];
};

export type NerdGraph = {
  __typename?: 'NerdGraph';
  experimentalNamespaces?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
  mutationGroupings?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
};

export type NerdGraphContext = {
  __typename?: 'NerdGraphContext';
  accountId?: Maybe<Scalars['Int']['output']>;
  actualUser?: Maybe<UserObject>;
  actualUserId?: Maybe<Scalars['Int']['output']>;
  currentAccount?: Maybe<AccountInfo>;
  hardFail?: Maybe<Scalars['String']['output']>;
  impersonatedUser?: Maybe<UserInfo>;
  impersonatedUserId?: Maybe<Scalars['Int']['output']>;
  internal?: Maybe<Scalars['Boolean']['output']>;
  isImpersonating?: Maybe<Scalars['Boolean']['output']>;
  isNewrelicAdmin?: Maybe<Scalars['Boolean']['output']>;
  nerdGraphKey?: Maybe<Scalars['String']['output']>;
  referrer?: Maybe<Scalars['String']['output']>;
  userId?: Maybe<Scalars['Int']['output']>;
  visibility?: Maybe<NerdGraphVisibility>;
};

export enum NerdGraphVisibility {
  Custome = 'CUSTOME',
  Product = 'PRODUCT'
}

export type NerdStorageAccountScope = {
  __typename?: 'NerdStorageAccountScope';
  /** The collection to be retrieved. */
  collection?: Maybe<Array<Maybe<NerdStorageCollectionMember>>>;
  /** A Nerdpack document is formed by an identifier (called documentId) and a set of data associated with it. */
  document?: Maybe<Scalars['NerdStorageDocument']['output']>;
};


export type NerdStorageAccountScopeCollectionArgs = {
  collection: Scalars['String']['input'];
};


export type NerdStorageAccountScopeDocumentArgs = {
  collection: Scalars['String']['input'];
  documentId: Scalars['String']['input'];
};

export type NerdStorageActorScope = {
  __typename?: 'NerdStorageActorScope';
  /**
   * Nerdpack documents are stored inside a collection.
   * A collection can be thought of as a key-value storage where each document is one of these key-value pairs.
   *
   * To use the NerdStorage schema you must specify a Nerdpack ID using the NewRelic-Package-Id header in your request.
   */
  collection?: Maybe<Array<Maybe<NerdStorageCollectionMember>>>;
  /**
   * A Nerdpack document is formed by an identifier (called documentId) and a set of data associated with it.
   *
   * To use the NerdStorage schema you must specify a Nerdpack ID using the NewRelic-Package-Id header in your request.
   */
  document?: Maybe<Scalars['NerdStorageDocument']['output']>;
};


export type NerdStorageActorScopeCollectionArgs = {
  collection: Scalars['String']['input'];
};


export type NerdStorageActorScopeDocumentArgs = {
  collection: Scalars['String']['input'];
  documentId: Scalars['String']['input'];
};

export type NerdStorageCollectionMember = {
  __typename?: 'NerdStorageCollectionMember';
  /** The NerdStorage document. */
  document?: Maybe<Scalars['NerdStorageDocument']['output']>;
  /** The documentId. */
  id?: Maybe<Scalars['String']['output']>;
};

export type NerdStorageDeleteResult = {
  __typename?: 'NerdStorageDeleteResult';
  deleted?: Maybe<Scalars['Int']['output']>;
};

export type NerdStorageEntityScope = {
  __typename?: 'NerdStorageEntityScope';
  collection?: Maybe<Array<Maybe<NerdStorageCollectionMember>>>;
  document?: Maybe<Scalars['NerdStorageDocument']['output']>;
};


export type NerdStorageEntityScopeCollectionArgs = {
  collection: Scalars['String']['input'];
  scopeByActor?: InputMaybe<Scalars['Boolean']['input']>;
};


export type NerdStorageEntityScopeDocumentArgs = {
  collection: Scalars['String']['input'];
  documentId: Scalars['String']['input'];
  scopeByActor?: InputMaybe<Scalars['Boolean']['input']>;
};

/** The access level of the NerdStorage data. */
export enum NerdStorageScope {
  /** Account-level storage. */
  Account = 'ACCOUNT',
  /** Actor-level storage. */
  Actor = 'ACTOR',
  /** Entity-level storage. */
  Entity = 'ENTITY'
}

/** The data access level and ID for the selected scope. */
export type NerdStorageScopeInput = {
  /** The ID for the selected scope. */
  id: Scalars['String']['input'];
  /** The NerdStorage data access level. */
  name: NerdStorageScope;
};

/** NerdStorageVault data will only be visible to the User that created them. */
export enum NerdStorageVaultActorScope {
  /** Store and retrieve NerdStorageVault data for the current user. */
  CurrentUser = 'CURRENT_USER'
}

export type NerdStorageVaultActorStitchedFields = {
  __typename?: 'NerdStorageVaultActorStitchedFields';
  /** Fetch a single secret by key. */
  secret?: Maybe<NerdStorageVaultSecret>;
  /**
   * List the keys and values of all secrets
   * you have access to for the current scope and nerdpack.
   */
  secrets: Array<NerdStorageVaultSecret>;
};


export type NerdStorageVaultActorStitchedFieldsSecretArgs = {
  key: Scalars['String']['input'];
};

/** Result of a mutation. */
export type NerdStorageVaultDeleteSecretResult = {
  __typename?: 'NerdStorageVaultDeleteSecretResult';
  /** Any errors that happend during the mutation. */
  errors?: Maybe<Array<NerdStorageVaultResultError>>;
  /** The status of the mutation. */
  status: NerdStorageVaultResultStatus;
};

/** The possible types why an error may have occurred. */
export enum NerdStorageVaultErrorType {
  /**
   * Indicates the client performing the operation does not have sufficient
   * permission.
   */
  AccessDenied = 'ACCESS_DENIED',
  /**
   * Indicates the mutation has malformed input and needs to be corrected before
   * the mutation can be processed.
   */
  BadInput = 'BAD_INPUT',
  /** Indicates that the resource does not exist. */
  NotFound = 'NOT_FOUND',
  /** Indicates the mutation has failed validation. */
  ValidationFailed = 'VALIDATION_FAILED'
}

/** Mutation error information. */
export type NerdStorageVaultResultError = {
  __typename?: 'NerdStorageVaultResultError';
  /** The error message. */
  message?: Maybe<Scalars['String']['output']>;
  /** The type of error that occured when performing the mutation. */
  type: NerdStorageVaultErrorType;
};

/** Mutation result status. */
export enum NerdStorageVaultResultStatus {
  /** The mutation failed. */
  Failure = 'FAILURE',
  /** The mutation succeeded. */
  Success = 'SUCCESS'
}

/** The NerdStorageVault data access level. */
export type NerdStorageVaultScope = {
  /** A NerdStorageVault data access level for the current user. */
  actor?: InputMaybe<NerdStorageVaultActorScope>;
};

/** Secret key and value. */
export type NerdStorageVaultSecret = {
  __typename?: 'NerdStorageVaultSecret';
  /** The unique identifier of the secret. */
  key: Scalars['String']['output'];
  /** The value of the secret. */
  value: Scalars['SecureValue']['output'];
};

/** The data to be stored in NerdStorageVault. */
export type NerdStorageVaultWriteSecretInput = {
  /** The unique identifier of the secret. */
  key: Scalars['String']['input'];
  /** The value of the secret. */
  value: Scalars['SecureValue']['input'];
};

/** Information about the result of the write secret mutation */
export type NerdStorageVaultWriteSecretResult = {
  __typename?: 'NerdStorageVaultWriteSecretResult';
  /** Any errors that happend during the mutation. */
  errors?: Maybe<Array<NerdStorageVaultResultError>>;
  /** The status of the mutation. */
  status: NerdStorageVaultResultStatus;
};

export type NerdStoreCollectionMember = {
  __typename?: 'NerdStoreCollectionMember';
  document?: Maybe<Scalars['NerdStoreDocument']['output']>;
  id?: Maybe<Scalars['String']['output']>;
};

export type NerdStoreDeleteResult = {
  __typename?: 'NerdStoreDeleteResult';
  deleted?: Maybe<Scalars['Int']['output']>;
};

export enum NerdStoreScope {
  Accounts = 'ACCOUNTS',
  Entities = 'ENTITIES',
  Users = 'USERS'
}

export type NerdStoreScopeInput = {
  id: Scalars['String']['input'];
  name: NerdStoreScope;
};

/** Input data for allow list handling. */
export type NerdpackAllowListInput = {
  /** List of accounts that will be allow to subscribe. They must belong to the user's authorized account list. */
  accountIds: Array<InputMaybe<Scalars['Int']['input']>>;
};

/** Result of an allow list mutation. */
export type NerdpackAllowListResult = {
  __typename?: 'NerdpackAllowListResult';
  /** Nerdpack to allow to subscribe. */
  nerdpack: NerdpackData;
  /** Subscription allow list result per account. */
  resultsPerAccount?: Maybe<Array<Maybe<NerdpackMutationResultPerAccount>>>;
};

/** Information about an account present on the allow-list */
export type NerdpackAllowedAccount = {
  __typename?: 'NerdpackAllowedAccount';
  /** Allowed account id */
  accountId: Scalars['Int']['output'];
};

/** The Artifact object contains information and the location of the files that form an artifact. Only available for PRODUCT visibility */
export type NerdpackArtifact = {
  __typename?: 'NerdpackArtifact';
  /** The unique identifier of the artifact within the Nerdpack. */
  artifactId?: Maybe<Scalars['String']['output']>;
  /** List of css files associated with the artifact. */
  css?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
  /** A brief description of the artifact. */
  description?: Maybe<Scalars['String']['output']>;
  /** The name for the artifact in a human-readable format. */
  displayName?: Maybe<Scalars['String']['output']>;
  /** Entity type filters. Associate the artifact with matching entity type */
  entities?: Maybe<Array<Maybe<NerdpackEntityFilter>>>;
  /** Icon URL of Package */
  icon?: Maybe<Scalars['String']['output']>;
  /** Full ID of the Artifact: <nerdpackId>.<artifactId>. */
  id?: Maybe<Scalars['String']['output']>;
  /** List of javascript files associated with the artifact. */
  js?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
  /** List of other files associated with the artifact. */
  otherFiles?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
  /**
   * The artifact's metadata in raw JSON format.
   * It provides all the published information of the current artifact including the properties that are not provided
   * (flattened) on this Artifact object. This field is required to support platform changes on the NR1 artifact schema.
   */
  rawMetadata: Scalars['NerdpackRawMetadata']['output'];
  /** Indicates the type of artifact being defined, which affects how it is handled by New Relic (i.e., LAUNCHER, NERDLET, etc.). */
  schemaType?: Maybe<Scalars['String']['output']>;
};

/** The common artifact metadata. */
export type NerdpackArtifactMetadata = {
  /** The description of the artifact. */
  description?: Maybe<Scalars['String']['output']>;
  /** The name of the artifact implementation in a human-readable format. */
  displayName?: Maybe<Scalars['String']['output']>;
  /** The artifact id. */
  id: Scalars['NerdpackFullArtifactId']['output'];
};

/** The Artifact object contains information and the location of the files that form an artifact. Only available for PRODUCT visibility */
export type NerdpackArtifactOutput = {
  __typename?: 'NerdpackArtifactOutput';
  /** The artifact id. */
  id: Scalars['NerdpackFullArtifactId']['output'];
  /** The artifact metadata. */
  metadata: NerdpackArtifactMetadata;
};

/** Type of nerdpack artifact. */
export enum NerdpackArtifactSchemaType {
  /** Launcher. */
  Launcher = 'LAUNCHER',
  /** Nerdlet. */
  Nerdlet = 'NERDLET',
  /** Visualization. */
  Visualization = 'VISUALIZATION'
}

/** Info about Nerdpack assets. */
export type NerdpackAssetInfo = {
  __typename?: 'NerdpackAssetInfo';
  /** Name of the asset. */
  name?: Maybe<Scalars['String']['output']>;
  /** Size of the asset, in Bytes. */
  sizeInBytes?: Maybe<Scalars['Int']['output']>;
};

/** Defines the context on where an artifact will be displayed. */
export type NerdpackContext = {
  __typename?: 'NerdpackContext';
  /** An array of entities on which this artifact operates. */
  entities?: Maybe<Array<Maybe<NerdpackEntityContextFilter>>>;
};

/** Input data for creating a new nerdpack. */
export type NerdpackCreationInput = {
  /** Nerdpack owner account ID. If not provided it will use the account ID specified in the header. */
  ownerAccount?: InputMaybe<Scalars['Int']['input']>;
};

/** The Nerdpack root object. Contains the Nerdpack information including the list of versions and subscriptions. */
export type NerdpackData = {
  __typename?: 'NerdpackData';
  /** Unique identifier of the account that owns the Nerdpack. */
  accountId: Scalars['Int']['output'];
  /**
   * Get the list of accounts specified on the allow list.
   * If the user is authorized to the nerdpack owner account all the allowed accounts will be displayed,
   * otherwise, only the intersection of allowed accounts and user authorized accounts will be displayed.
   */
  allowedAccounts?: Maybe<Array<Maybe<NerdpackAllowedAccount>>>;
  /** Unique V5 uuid that identifies the Nerdpack. */
  id: Scalars['ID']['output'];
  /** Type that defines the rules for account subscription. */
  subscriptionModel?: Maybe<NerdpackSubscriptionModel>;
  /** List of subscriptions on versions of the given Nerdpack. */
  subscriptions?: Maybe<Array<Maybe<NerdpackSubscription>>>;
  /** Retrieve the versions for the given Nerdpack. */
  versions?: Maybe<NerdpackVersionsResult>;
};


/** The Nerdpack root object. Contains the Nerdpack information including the list of versions and subscriptions. */
export type NerdpackDataVersionsArgs = {
  cursor?: InputMaybe<Scalars['String']['input']>;
  filter?: InputMaybe<NerdpackVersionFilter>;
};

/** Data to filter subscribable nerdpack list. */
export type NerdpackDataFilter = {
  /** ID of the account to be subscribed. */
  accountId?: InputMaybe<Scalars['Int']['input']>;
  /** Nerdpack subscription model to filter. */
  subscriptionModel?: InputMaybe<NerdpackSubscriptionModel>;
  /** Tag the account may subscribe to. */
  tag?: InputMaybe<Scalars['NerdpackTagName']['input']>;
};

/** Defines the visualization scope on which an artifact operates */
export type NerdpackEntityContextFilter = {
  __typename?: 'NerdpackEntityContextFilter';
  /** The domain of the Entity */
  domain?: Maybe<Scalars['String']['output']>;
  /** List of tags of an entity */
  tags?: Maybe<Array<NerdpackEntityTag>>;
  /** The type of the Entity */
  type: Scalars['String']['output'];
};

/** Entity filter to match entity types that can be used by the nerdpack */
export type NerdpackEntityFilter = {
  __typename?: 'NerdpackEntityFilter';
  /** Entity domain */
  domain?: Maybe<Scalars['String']['output']>;
  /** Entity type */
  type?: Maybe<Scalars['String']['output']>;
};

/** Tag associated with an entity */
export type NerdpackEntityTag = {
  __typename?: 'NerdpackEntityTag';
  /** key */
  key: Scalars['String']['output'];
  /** list of values */
  values?: Maybe<Array<Scalars['String']['output']>>;
};

/** Launchers are a type of artifact that is used to build an application like experience. The user can launch these applications from the NR1 UI platform. */
export type NerdpackLauncherMetadata = NerdpackArtifactMetadata & {
  __typename?: 'NerdpackLauncherMetadata';
  /** Defines the context on where this launcher will be displayed. */
  context?: Maybe<NerdpackContext>;
  /** The description of the launcher. */
  description?: Maybe<Scalars['String']['output']>;
  /** The name of the artifact implementation in a human-readable format. */
  displayName?: Maybe<Scalars['String']['output']>;
  /** Indicates if the launcher will be hidden in the UI (Apps Overlay & Apps Dropdown) */
  hidden?: Maybe<Scalars['Boolean']['output']>;
  /** The icon to be used for this Launcher. */
  icon?: Maybe<Scalars['String']['output']>;
  /** The full artifact id for this launcher. */
  id: Scalars['NerdpackFullArtifactId']['output'];
};

/** Error reason for the mutation. */
export enum NerdpackMutationErrorType {
  /** The user does not have the required capability to execute the operation. */
  CapabilityNotGranted = 'CAPABILITY_NOT_GRANTED',
  /** Downstream service error. */
  DownstreamError = 'DOWNSTREAM_ERROR',
  /** Resource not found for given operation. */
  NotFound = 'NOT_FOUND',
  /** Terms and conditions have not been accepted by the operation account. */
  TncNotAccepted = 'TNC_NOT_ACCEPTED',
  /** Account is not authorized to execute the operation. */
  UnauthorizedAccount = 'UNAUTHORIZED_ACCOUNT'
}

/** Mutation result. */
export enum NerdpackMutationResult {
  /** Error executing mutation. */
  Error = 'ERROR',
  /** Successful mutation execution. */
  Ok = 'OK'
}

/** Mutation result for the given acccount. */
export type NerdpackMutationResultPerAccount = {
  __typename?: 'NerdpackMutationResultPerAccount';
  /** Given account ID. */
  accountId: Scalars['Int']['output'];
  /** Error type if mutation failed. */
  reason?: Maybe<NerdpackMutationErrorType>;
  /** Mutation result for the given acccount. */
  result: NerdpackMutationResult;
};

/** A React component the NR1 UI platform knows how to render. */
export type NerdpackNerdletMetadata = NerdpackArtifactMetadata & {
  __typename?: 'NerdpackNerdletMetadata';
  /** Defines the context on where this nerdlet will be displayed. */
  context?: Maybe<NerdpackContext>;
  /** The description of the nerdlet. */
  description?: Maybe<Scalars['String']['output']>;
  /** The name of the artifact implementation in a human-readable format. */
  displayName?: Maybe<Scalars['String']['output']>;
  /** The icon to be used for this Nerdlet. */
  icon?: Maybe<Scalars['String']['output']>;
  /** The full artifact id for this nerdlet. */
  id: Scalars['NerdpackFullArtifactId']['output'];
};

/** Provides fields to query nerdpacks by different conditions */
export type NerdpackNerdpacks = {
  __typename?: 'NerdpackNerdpacks';
  /** Returns the list of artifacts associated to the provided artifact ids or types. WARNING: This field is experimental and subject to breaking changes!. Please reach #help-nr-core before using it. */
  artifacts?: Maybe<Array<Maybe<NerdpackArtifactOutput>>>;
  /**
   * Get the list of stable core nerdpack versions together with nerdpack versions which the requesting user's account is subscribed.
   * This query allows for version or channel overrides by providing OverrideVersionRules objects.
   */
  effectiveSubscribedVersions?: Maybe<Array<Maybe<NerdpackVersion>>>;
  /** If a Nerdpack with the given uuid exists, retrieve the Nerdpack object. */
  nerdpack?: Maybe<NerdpackData>;
  /** Returns the list of subscribable Nerdpacks of the current user. */
  subscribable?: Maybe<Array<Maybe<NerdpackData>>>;
};


/** Provides fields to query nerdpacks by different conditions */
export type NerdpackNerdpacksArtifactsArgs = {
  ids?: InputMaybe<Array<Scalars['NerdpackFullArtifactId']['input']>>;
  nerdpackVersionOverrides?: InputMaybe<Array<InputMaybe<NerdpackOverrideVersionRules>>>;
  types?: InputMaybe<Array<NerdpackArtifactSchemaType>>;
};


/** Provides fields to query nerdpacks by different conditions */
export type NerdpackNerdpacksEffectiveSubscribedVersionsArgs = {
  overrides?: InputMaybe<Array<InputMaybe<NerdpackOverrideVersionRules>>>;
};


/** Provides fields to query nerdpacks by different conditions */
export type NerdpackNerdpacksNerdpackArgs = {
  id: Scalars['ID']['input'];
};


/** Provides fields to query nerdpacks by different conditions */
export type NerdpackNerdpacksSubscribableArgs = {
  nerdpackFilter?: InputMaybe<NerdpackDataFilter>;
};

/** Attributes to match a specific nerdpack versions. */
export type NerdpackOverrideVersionRules = {
  /** Nerdpack uuid. */
  nerdpackId: Scalars['ID']['input'];
  /** Nerdpack version tag. */
  tag?: InputMaybe<Scalars['NerdpackTagName']['input']>;
  /** Semver-compliant Nerdpack version. */
  version?: InputMaybe<Scalars['SemVer']['input']>;
};

/** Input data that identifies nerdpack tag. */
export type NerdpackRemoveVersionTagInput = {
  /** Tag name. */
  tag?: InputMaybe<Scalars['NerdpackTagName']['input']>;
};

/** Information about removed tag */
export type NerdpackRemovedTagInfo = {
  __typename?: 'NerdpackRemovedTagInfo';
  /** UUID of the nerdpack */
  nerdpackId?: Maybe<Scalars['ID']['output']>;
  /** Tag removed */
  tagName?: Maybe<Scalars['NerdpackTagName']['output']>;
  /** Version affected */
  version?: Maybe<Scalars['SemVer']['output']>;
};

/** Removed Tag response */
export type NerdpackRemovedTagResponse = {
  __typename?: 'NerdpackRemovedTagResponse';
  /** Optional removed tag information */
  removedTagInfo?: Maybe<NerdpackRemovedTagInfo>;
  /** The status of the response. Tells is the tag was deleted or not */
  status?: Maybe<NerdpackRemovedTagResponseType>;
};

/** Indicates if a tag has been removed for a nerdpack */
export enum NerdpackRemovedTagResponseType {
  /** Indicates the tag has not been removed */
  NothingToRemove = 'NOTHING_TO_REMOVE',
  /** Indicates the tag has been removed */
  Removed = 'REMOVED'
}

/** New subscriptions input. */
export type NerdpackSubscribeAccountsInput = {
  /** List of accounts to be subscribed. */
  accountIds: Array<Scalars['Int']['input']>;
  /** Tag of the Nerdpack version to be subscribed to. */
  tag: Scalars['NerdpackTagName']['input'];
};

/** Subscription result. */
export type NerdpackSubscribeResult = {
  __typename?: 'NerdpackSubscribeResult';
  /** Nerdpack to be subscribed to. */
  nerdpack: NerdpackData;
  /** Subscription result per account. */
  resultsPerAccount?: Maybe<Array<Maybe<NerdpackMutationResultPerAccount>>>;
  /** Tag associated with the version. */
  tag?: Maybe<Scalars['NerdpackTagName']['output']>;
};

/** Nerdpack subscription information. */
export type NerdpackSubscription = {
  __typename?: 'NerdpackSubscription';
  /** What type of access the user has over this subscription. Eg: direct or inherited. */
  accessType?: Maybe<Array<Maybe<NerdpackSubscriptionAccessType>>>;
  /** Unique identifier of the account that has subscribed to the Nerdpack. */
  accountId?: Maybe<Scalars['Int']['output']>;
  /** Nerdpack associated to the subscribed version. */
  nerdpackVersion?: Maybe<NerdpackVersion>;
  /** Tag associated with the version. */
  tag?: Maybe<Scalars['NerdpackTagName']['output']>;
};

/** Type of access to the subscribed Nerdpack. */
export enum NerdpackSubscriptionAccessType {
  /** Direct subscription with user account. */
  Direct = 'DIRECT',
  /** Master account subscription. */
  Inherited = 'INHERITED'
}

/** Type that define the rules for account subscription. */
export enum NerdpackSubscriptionModel {
  /** Product nerdpacks displayed to everybody, no subscription required . */
  Core = 'CORE',
  /** Any NR user can subscribe to the nerdpack. */
  Global = 'GLOBAL',
  /** Only owner, master and allowed accounts can subscribe to the nerdpack. */
  OwnerAndAllowed = 'OWNER_AND_ALLOWED'
}

/** Input data for nerdpack version tagging. */
export type NerdpackTagVersionInput = {
  /** Tag to be added to the version. */
  tag?: InputMaybe<Scalars['NerdpackTagName']['input']>;
  /** Nerdpack version. */
  version?: InputMaybe<Scalars['SemVer']['input']>;
};

/** Shows info on the team owning the nerdpack. */
export type NerdpackTeamInfo = {
  __typename?: 'NerdpackTeamInfo';
  /** Id of the team */
  id?: Maybe<Scalars['ID']['output']>;
  /** URL of the JIRA board */
  jiraUrl?: Maybe<Scalars['String']['output']>;
  /** Key identifier of the team */
  key?: Maybe<Scalars['String']['output']>;
  /** Name of the team */
  name?: Maybe<Scalars['String']['output']>;
  /** Slack channel of the team */
  slack?: Maybe<Scalars['String']['output']>;
  /** URL of the slack channel */
  slackUrl?: Maybe<Scalars['String']['output']>;
  /** URL of the team store page */
  teamstoreUrl?: Maybe<Scalars['String']['output']>;
};

/** Data of accounts to be unsubscribed. */
export type NerdpackUnsubscribeAccountsInput = {
  /** List of accounts to be unsubscribed. */
  accountIds: Array<Scalars['Int']['input']>;
};

/** Result of trying to remove the subscription. */
export type NerdpackUnsubscribeResult = {
  __typename?: 'NerdpackUnsubscribeResult';
  /** Nerdpack to be unsubscribed from. */
  nerdpack: NerdpackData;
  /** Unsubscribe result per account. */
  resultsPerAccount?: Maybe<Array<Maybe<NerdpackMutationResultPerAccount>>>;
};

/** Contains files and information associated with a specific version of a Nerdpack. */
export type NerdpackVersion = {
  __typename?: 'NerdpackVersion';
  /** List of Artifact objects. Only available for PRODUCT visibility */
  artifacts?: Maybe<Array<Maybe<NerdpackArtifact>>>;
  /** List of assets present on this Nerdpack version. */
  assets?: Maybe<Array<Maybe<NerdpackAssetInfo>>>;
  /** Version of the CLI used to generate the Nerdpack. */
  cliVersion?: Maybe<Scalars['SemVer']['output']>;
  /** Timestamp for the creation on the Nerdpack version. */
  createdAt: Scalars['DateTime']['output'];
  /** Unique identifier of the user who created the version. */
  createdByUser: Scalars['Int']['output'];
  /** A brief description of the artifact. */
  description?: Maybe<Scalars['String']['output']>;
  /** Human-readable Nerdpack's name. */
  displayName?: Maybe<Scalars['String']['output']>;
  /** Icon URL of Package */
  icon?: Maybe<Scalars['String']['output']>;
  /** Unique uuid V5 that identifies the Nerdpack. */
  nerdpackId?: Maybe<Scalars['ID']['output']>;
  /** URL to the repository with the Nerdpack source code. */
  repositoryUrl?: Maybe<Scalars['String']['output']>;
  /** Version of the SDK used to generate the Nerdpack. */
  sdkVersion?: Maybe<Scalars['String']['output']>;
  /** Nerdpack subscription model to filter. */
  subscriptionModel?: Maybe<NerdpackSubscriptionModel>;
  /** List of tags associated with the Nerdpack version. */
  tags: Array<Maybe<Scalars['NerdpackTagName']['output']>>;
  /** List of teams owning this nerdpack */
  teams?: Maybe<Array<Maybe<NerdpackTeamInfo>>>;
  /** Semver-compliant Nerdpack version. */
  version: Scalars['SemVer']['output'];
};

/** Attributes to filter a list of nerdpack versions. Restrictions: 'tags' attribute cannot combined with other attributes. */
export type NerdpackVersionFilter = {
  /** Fallback version to return if no version matches the given filters. No version is returned by default. */
  fallback?: InputMaybe<NerdpackVersionFilterFallback>;
  /** Get a version with the specified tag. */
  tag?: InputMaybe<Scalars['NerdpackTagName']['input']>;
  /** Get the versions with a tag from the tag list. */
  tags?: InputMaybe<Array<InputMaybe<Scalars['NerdpackTagName']['input']>>>;
  /** Nerdpack version. */
  version?: InputMaybe<Scalars['SemVer']['input']>;
};

/** Fallback version to return if no version matches with the given filters. */
export enum NerdpackVersionFilterFallback {
  /** Latest version (semver). */
  LatestSemver = 'LATEST_SEMVER'
}

/** Results of the nerdpack versions query. */
export type NerdpackVersionsResult = {
  __typename?: 'NerdpackVersionsResult';
  /** Cursor that can be used to retrieve the next results page. */
  nextCursor?: Maybe<Scalars['String']['output']>;
  /** List of nerdpack version objects. */
  results?: Maybe<Array<Maybe<NerdpackVersion>>>;
  /** Total amount of available version objects for the given nerdpack (including the ones not showed in the current page) */
  totalCount?: Maybe<Scalars['Int']['output']>;
};

/** Custom visualization. */
export type NerdpackVisualizationMetadata = NerdpackArtifactMetadata & {
  __typename?: 'NerdpackVisualizationMetadata';
  /** List of fields, collections or namespaces configurations. */
  configuration?: Maybe<Array<Scalars['NerdpackRawVisualizationMetadataConfiguration']['output']>>;
  /** The description of the visualization. */
  description?: Maybe<Scalars['String']['output']>;
  /** The name of the artifact implementation in a human-readable format. */
  displayName?: Maybe<Scalars['String']['output']>;
  /** The full artifact id for this visualization. */
  id: Scalars['NerdpackFullArtifactId']['output'];
};

/** Queries that are stitched into Nerdgraph. */
export type NetworkMonitoringActorStitchedFields = {
  __typename?: 'NetworkMonitoringActorStitchedFields';
  /** Returns a single unique agent's configuration and metadata */
  agentConfiguration?: Maybe<NetworkMonitoringAgentConfigurationWithData>;
  /** Returns metadata about a filtered set of configuration revisions */
  agentConfigurationRevisions?: Maybe<Array<NetworkMonitoringAgentConfigurationRevision>>;
  /** Returns filtered network agent configurations. */
  agentConfigurations?: Maybe<Array<Maybe<NetworkMonitoringAgentConfiguration>>>;
};


/** Queries that are stitched into Nerdgraph. */
export type NetworkMonitoringActorStitchedFieldsAgentConfigurationArgs = {
  configurationId: Scalars['ID']['input'];
  revisionId?: InputMaybe<Scalars['Int']['input']>;
};


/** Queries that are stitched into Nerdgraph. */
export type NetworkMonitoringActorStitchedFieldsAgentConfigurationRevisionsArgs = {
  filter: NetworkMonitoringAgentConfigurationRevisionFilterInput;
};


/** Queries that are stitched into Nerdgraph. */
export type NetworkMonitoringActorStitchedFieldsAgentConfigurationsArgs = {
  filters?: InputMaybe<NetworkMonitoringAgentConfigurationFilterInput>;
};

/** A network agent configuration without its full configuration blob */
export type NetworkMonitoringAgentConfiguration = {
  __typename?: 'NetworkMonitoringAgentConfiguration';
  /** The account to which network configuration belongs */
  accountId: Scalars['Int']['output'];
  /** The time the configuration was created. */
  createdAt: Scalars['EpochMilliseconds']['output'];
  /** The unique id for the configuration. */
  id: Scalars['ID']['output'];
  /** The name to describe configuration */
  name: Scalars['String']['output'];
  /** The revision number of the configuration */
  revisionId: Scalars['Int']['output'];
  /** The time any configuration settings were last changed. */
  updatedAt: Scalars['EpochMilliseconds']['output'];
};

/** An object with filters that can be applied to a list of network configurations. */
export type NetworkMonitoringAgentConfigurationFilterInput = {
  /** An account to which network configurations belong */
  accountId?: InputMaybe<Scalars['Int']['input']>;
  /** The list with ids of configurations to find. */
  ids?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** The name of configurations to find. */
  name?: InputMaybe<Scalars['String']['input']>;
};

/** Metadata about the revisions of a configuration */
export type NetworkMonitoringAgentConfigurationRevision = {
  __typename?: 'NetworkMonitoringAgentConfigurationRevision';
  /** The ID of the "parent" configuration */
  configId: Scalars['ID']['output'];
  /** A date for when the revision was created */
  createdAt: Scalars['EpochMilliseconds']['output'];
  /** An ID for the revision itself */
  revisionId: Scalars['Int']['output'];
  /** The ID of the user who made the change */
  userId: Scalars['Int']['output'];
};

/** A filter that determines which agent configuration revisions to fetch */
export type NetworkMonitoringAgentConfigurationRevisionFilterInput = {
  /** The ID of the configuration whose revisions will be fetched */
  configurationId: Scalars['ID']['input'];
  /** An optional list of revision numbers to fetch more information about. If not provided, the query will fetch all revisions */
  revisionIds?: InputMaybe<Array<Scalars['Int']['input']>>;
};

/** A network agent configuration with the potential to fetch the full configuration blob */
export type NetworkMonitoringAgentConfigurationWithData = {
  __typename?: 'NetworkMonitoringAgentConfigurationWithData';
  /** The account to which network configuration belongs */
  accountId: Scalars['Int']['output'];
  /** The time the configuration was created. */
  createdAt: Scalars['EpochMilliseconds']['output'];
  /** The unique id for the configuration. */
  id: Scalars['ID']['output'];
  /** The name to describe configuration */
  name: Scalars['String']['output'];
  /** The related SNMP configuration as raw json. */
  rawConfiguration: Scalars['NetworkMonitoringRawConfiguration']['output'];
  /** The revision number of the configuration */
  revisionId: Scalars['Int']['output'];
  /** The time any configuration settings were last changed. */
  updatedAt: Scalars['EpochMilliseconds']['output'];
};

/** Input to create a new network agent configuration. */
export type NetworkMonitoringCreateAgentConfigurationInput = {
  /** An account to which network configuration belong */
  accountId: Scalars['Int']['input'];
  /** A name for configuration. */
  name: Scalars['String']['input'];
  /** The related SNMP configuration as raw json. */
  rawConfiguration: Scalars['NetworkMonitoringRawConfiguration']['input'];
};

/** The details of an attempt to publish device configurations. */
export type NetworkMonitoringPublishAgentConfigurationResponse = {
  __typename?: 'NetworkMonitoringPublishAgentConfigurationResponse';
  /** A list of created device configuration's ids. */
  createdDeviceIds?: Maybe<Array<Scalars['ID']['output']>>;
  /** A list of deleted device configuration's ids. */
  deletedDeviceIds?: Maybe<Array<Scalars['ID']['output']>>;
  /** A list of not processed device configuration's keys. */
  skippedDeviceKeys?: Maybe<Array<Scalars['ID']['output']>>;
  /** A list of updated device configuration's ids. */
  updatedDeviceIds?: Maybe<Array<Scalars['ID']['output']>>;
};

/** Input to update an existing network agent configuration. */
export type NetworkMonitoringUpdateAgentConfigurationInput = {
  /** The unique id for the configuration. */
  id: Scalars['ID']['input'];
  /** The related SNMP configuration as raw json. */
  rawConfiguration: Scalars['NetworkMonitoringRawConfiguration']['input'];
};

export type NewRelicServiceHealthActorStitchedFields = {
  __typename?: 'NewRelicServiceHealthActorStitchedFields';
  /**
   * Determines any services and account IDs impacted by an ongoing New Relic incident or incidents.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  currentStatus?: Maybe<NewRelicServiceHealthCurrentStatus>;
  /**
   * Determines historical records for services and account IDs impacted by previous New Relic incidents within a date range.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  historicalStatus?: Maybe<Array<Maybe<NewRelicServiceHealthHistoricalStatus>>>;
  /**
   * Retrieves a list of status notification configurations set up for the current user
   * @deprecated This field is experimental and subject to breaking changes.
   */
  statusNotificationConfigurations?: Maybe<Array<Maybe<NewRelicServiceHealthNotificationConfiguration>>>;
};


export type NewRelicServiceHealthActorStitchedFieldsCurrentStatusArgs = {
  accountIds: Array<Scalars['Int']['input']>;
};


export type NewRelicServiceHealthActorStitchedFieldsHistoricalStatusArgs = {
  accountIds?: InputMaybe<Array<InputMaybe<Scalars['Int']['input']>>>;
  queryWindow?: InputMaybe<DateTimeWindowInput>;
};

/** Provides a list of NewRelic services that are currently impacted. */
export type NewRelicServiceHealthCurrentStatus = {
  __typename?: 'NewRelicServiceHealthCurrentStatus';
  /**
   * A list of Services that are impacted.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  services?: Maybe<Array<Maybe<NewRelicServiceHealthService>>>;
};

/** Provides a list of services */
export type NewRelicServiceHealthHistoricalImpact = {
  __typename?: 'NewRelicServiceHealthHistoricalImpact';
  /**
   * A list of services with various types of impact
   * @deprecated This field is experimental and subject to breaking changes.
   */
  services?: Maybe<Array<Maybe<NewRelicServiceHealthHistoricalService>>>;
};

/** Provides the name of impacted service and the service's impacted account ids status. */
export type NewRelicServiceHealthHistoricalService = {
  __typename?: 'NewRelicServiceHealthHistoricalService';
  /**
   * The name of the service.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  name: Scalars['String']['output'];
  /**
   * The service's account ids status.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  status?: Maybe<NewRelicServiceHealthHistoricalStatusEntry>;
};

/**
 * Provides a list of records representing services and accounts
 * reported to have been impacted at a given time.
 */
export type NewRelicServiceHealthHistoricalStatus = {
  __typename?: 'NewRelicServiceHealthHistoricalStatus';
  /**
   * A list of services with ongoing impact at the time of the included timestamp
   * @deprecated This field is experimental and subject to breaking changes.
   */
  endedImpact?: Maybe<NewRelicServiceHealthHistoricalImpact>;
  /**
   * A list of services with new impact at the time of the included timestamp
   * @deprecated This field is experimental and subject to breaking changes.
   */
  newImpact?: Maybe<NewRelicServiceHealthHistoricalImpact>;
  /**
   * A list of services with ongoing impact at the time of the included timestamp
   * @deprecated This field is experimental and subject to breaking changes.
   */
  ongoingImpact?: Maybe<NewRelicServiceHealthHistoricalImpact>;
  /**
   * When this history record was reported.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  timestamp: Scalars['String']['output'];
};

/** Provides details about impact that was recorded at a specific time. */
export type NewRelicServiceHealthHistoricalStatusEntry = {
  __typename?: 'NewRelicServiceHealthHistoricalStatusEntry';
  /**
   * The new, ongoing, and ended account ids.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  impactedAccounts?: Maybe<Array<Maybe<Scalars['Int']['output']>>>;
};

/** A custom message from New Relic Communication Managers to impacted customers. */
export type NewRelicServiceHealthMessage = {
  __typename?: 'NewRelicServiceHealthMessage';
  /**
   * The text of the message.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  text: Scalars['String']['output'];
  /**
   * When this message was sent.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  timestamp: Scalars['String']['output'];
};

/** Details regarding what a user will be notified on regarding New Relic service health */
export type NewRelicServiceHealthNotificationConfiguration = {
  __typename?: 'NewRelicServiceHealthNotificationConfiguration';
  /**
   * A list of accounts to be notified about
   * @deprecated This field is experimental and subject to breaking changes.
   */
  accounts: Array<Scalars['Int']['output']>;
  /**
   * Whether or not notifications for this configuration will be sent out
   * @deprecated This field is experimental and subject to breaking changes.
   */
  active: Scalars['Boolean']['output'];
  /**
   * The email address to send notifications to
   * @deprecated This field is experimental and subject to breaking changes.
   */
  email: Scalars['String']['output'];
  /**
   * A descriptive name to help delineate configurations
   * @deprecated This field is experimental and subject to breaking changes.
   */
  name: Scalars['String']['output'];
  /**
   * A list of services to be notified about
   * @deprecated This field is experimental and subject to breaking changes.
   */
  services: Array<Scalars['String']['output']>;
  /**
   * A reference ID for the configuration
   * @deprecated This field is experimental and subject to breaking changes.
   */
  uuid: Scalars['String']['output'];
};

/**
 * Provides the name of the impacted service as well as a list of
 * impacted account IDs.
 */
export type NewRelicServiceHealthService = {
  __typename?: 'NewRelicServiceHealthService';
  /**
   * The name of the service.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  name: Scalars['String']['output'];
  /**
   * A specific status of the current impact.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  status: NewRelicServiceHealthStatusEntry;
};

/**
 * Includes a list of impacted account IDs as well as (optionally)
 * a description of the impact and a message to our end users.
 */
export type NewRelicServiceHealthStatusEntry = {
  __typename?: 'NewRelicServiceHealthStatusEntry';
  /**
   * A description of the type or kind of impact being experienced.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  description?: Maybe<Scalars['String']['output']>;
  /**
   * The account IDs with that service currently impacted.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  impactedAccounts: Array<Maybe<Scalars['Int']['output']>>;
  /**
   * A list of custom messages sent to our end users.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  messages?: Maybe<Array<Maybe<NewRelicServiceHealthMessage>>>;
};

/** The response object for requesting an auth token */
export type NotificationAuthenticationGenerateTokenResponse = {
  __typename?: 'NotificationAuthenticationGenerateTokenResponse';
  /**
   * The auth token value
   * @deprecated This field is experimental and subject to breaking changes.
   */
  status: Scalars['SecureValue']['output'];
};

export type Nr1CatalogActorStitchedFields = {
  __typename?: 'Nr1CatalogActorStitchedFields';
  /** Information related to a alert policy template */
  alertPolicyTemplate?: Maybe<Nr1CatalogAlertPolicyTemplate>;
  /** List of alert policy templates in New Relic I/O */
  alertPolicyTemplates?: Maybe<Nr1CatalogAlertPolicyTemplatesListing>;
  /** List of available categories for filtering and searching */
  categories?: Maybe<Array<Nr1CatalogCategory>>;
  /** Information related to a dashboard template */
  dashboardTemplate?: Maybe<Nr1CatalogDashboardTemplate>;
  /** List of dashboard templates in New Relic I/O */
  dashboardTemplates?: Maybe<Nr1CatalogDashboardTemplatesListing>;
  /** Information related to a data source */
  dataSource?: Maybe<Nr1CatalogDataSource>;
  /** Information related to a deployed Nerdpack */
  nerdpack?: Maybe<Nr1CatalogNerdpack>;
  /** List of nerdpacks available in the catalog */
  nerdpacks?: Maybe<Array<Nr1CatalogNerdpack>>;
  /** Catalog information related to a quickstart */
  quickstart?: Maybe<Nr1CatalogQuickstart>;
  /** List of Quickstarts available in New Relic I/O */
  quickstarts?: Maybe<Nr1CatalogQuickstartsListing>;
  /** Search for items in the catalog */
  search?: Maybe<Nr1CatalogSearchResponse>;
};


export type Nr1CatalogActorStitchedFieldsAlertPolicyTemplateArgs = {
  id: Scalars['ID']['input'];
};


export type Nr1CatalogActorStitchedFieldsDashboardTemplateArgs = {
  id: Scalars['ID']['input'];
};


export type Nr1CatalogActorStitchedFieldsDataSourceArgs = {
  id: Scalars['ID']['input'];
};


export type Nr1CatalogActorStitchedFieldsNerdpackArgs = {
  id: Scalars['ID']['input'];
};


export type Nr1CatalogActorStitchedFieldsQuickstartArgs = {
  id: Scalars['ID']['input'];
};


export type Nr1CatalogActorStitchedFieldsQuickstartsArgs = {
  cursor?: InputMaybe<Scalars['String']['input']>;
};


export type Nr1CatalogActorStitchedFieldsSearchArgs = {
  cursor?: InputMaybe<Scalars['String']['input']>;
  filter?: InputMaybe<Nr1CatalogSearchFilter>;
  query?: InputMaybe<Scalars['String']['input']>;
  sortBy?: InputMaybe<Nr1CatalogSearchSortOption>;
};

/** An outline of a created alert condition */
export type Nr1CatalogAlertConditionOutline = {
  __typename?: 'Nr1CatalogAlertConditionOutline';
  /** The template id of the created alert condition */
  alertConditionTemplate: Nr1CatalogAlertConditionTemplate;
  /** The id of the created alert condition */
  id: Scalars['ID']['output'];
};

/** Information about an alert condition template */
export type Nr1CatalogAlertConditionTemplate = {
  __typename?: 'Nr1CatalogAlertConditionTemplate';
  /** The unique identifier for the alert condition template */
  id: Scalars['ID']['output'];
  /** Metadata associated with the alert condition template */
  metadata: Nr1CatalogAlertConditionTemplateMetadata;
  /** The source of the alert condition template configuration */
  sourceUrl?: Maybe<Scalars['String']['output']>;
};

/** Metadata associated with the alert condition template */
export type Nr1CatalogAlertConditionTemplateMetadata = {
  __typename?: 'Nr1CatalogAlertConditionTemplateMetadata';
  /** A short form description for the alert condition template */
  description?: Maybe<Scalars['String']['output']>;
  /** The human-readable name for the alert condition template */
  displayName?: Maybe<Scalars['String']['output']>;
  /** Determines the type of alert condition template that will be created */
  type: Nr1CatalogAlertConditionType;
};

/** Possible types of configured alert conditions */
export enum Nr1CatalogAlertConditionType {
  /** A baseline alert condition */
  Baseline = 'BASELINE',
  /** A static alert condition */
  Static = 'STATIC'
}

/** An outline of a created alert policy */
export type Nr1CatalogAlertPolicyOutline = {
  __typename?: 'Nr1CatalogAlertPolicyOutline';
  /** A list of created alert conditions under this policy */
  conditions?: Maybe<Array<Nr1CatalogAlertConditionOutline>>;
  /** The id of the created alert policy */
  id: Scalars['ID']['output'];
};

/** Information about an alert policy template */
export type Nr1CatalogAlertPolicyTemplate = {
  __typename?: 'Nr1CatalogAlertPolicyTemplate';
  /** The unique identifier for the alert policy template */
  id: Scalars['ID']['output'];
  /** Metadata associated with the alert policy template */
  metadata?: Maybe<Nr1CatalogAlertPolicyTemplateMetadata>;
  /** Level of support expected for the alert policy template */
  supportLevel: Nr1CatalogSupportLevel;
  /** A timestamp that indicates when the alert policy template was last updated */
  updatedAt: Scalars['DateTime']['output'];
};

/** Metadata associated with the alert policy template */
export type Nr1CatalogAlertPolicyTemplateMetadata = {
  __typename?: 'Nr1CatalogAlertPolicyTemplateMetadata';
  /** A list of authors that created the alert policy template */
  authors: Array<Nr1CatalogAuthor>;
  /** The list of categories for filtering, searching, and grouping associated with the alert policy template */
  categories: Array<Nr1CatalogCategory>;
  /** The list of category terms associated with the alert policy template */
  categoryTerms: Array<Scalars['String']['output']>;
  /** The list of alert condition templates attached to the alert policy template */
  conditions: Array<Nr1CatalogAlertConditionTemplate>;
  /** The human-readable name for the alert policy template */
  displayName?: Maybe<Scalars['String']['output']>;
  /** The corresponding icon for the alert policy template */
  icon?: Maybe<Nr1CatalogIcon>;
  /** A list of required data sources needed to populate data in the alert policy. */
  requiredDataSources: Array<Nr1CatalogDataSource>;
};

/** Paginated information about alert policy templates */
export type Nr1CatalogAlertPolicyTemplatesListing = {
  __typename?: 'Nr1CatalogAlertPolicyTemplatesListing';
  /** Cursor used to fetch the next set of results */
  nextCursor?: Maybe<Scalars['String']['output']>;
  /** The list of alert policy template results */
  results: Array<Nr1CatalogAlertPolicyTemplate>;
  /** The total number of alert policy template results */
  totalCount: Scalars['Int']['output'];
};

/** Specifies the supported entity types to be all entity types */
export type Nr1CatalogAllSupportedEntityTypes = Nr1CatalogSupportedEntityTypes & {
  __typename?: 'Nr1CatalogAllSupportedEntityTypes';
  /** The level of support entity types. Always set to ALL */
  mode: Nr1CatalogSupportedEntityTypesMode;
};

/** Information about an author */
export type Nr1CatalogAuthor = {
  __typename?: 'Nr1CatalogAuthor';
  /** The name of the author */
  name: Scalars['String']['output'];
};

/** Information about an author */
export type Nr1CatalogAuthorInput = {
  /** The name of the author */
  name: Scalars['String']['input'];
};

/** A thematic grouping for catalog items */
export type Nr1CatalogCategory = {
  __typename?: 'Nr1CatalogCategory';
  /** The human readable name of the category */
  displayName: Scalars['String']['output'];
  /** The url friendly name of the category */
  slug: Scalars['String']['output'];
  /** A list of terms that match catalog items to this category */
  terms: Array<Scalars['String']['output']>;
};

/** Information about a facet count on a category */
export type Nr1CatalogCategoryFacet = {
  __typename?: 'Nr1CatalogCategoryFacet';
  /** The count of results for this category */
  count: Scalars['Int']['output'];
  /** The category's display name */
  displayName: Scalars['String']['output'];
};

/** A contact channel where users can get support via the community */
export type Nr1CatalogCommunityContactChannel = {
  __typename?: 'Nr1CatalogCommunityContactChannel';
  /** The URL linking to a website for support */
  url: Scalars['String']['output'];
};

/** Details about the contact channel where users can get support via the web */
export type Nr1CatalogCommunityContactChannelInput = {
  /** The URL linking to the website where users can get web support */
  url: Scalars['String']['input'];
};

/** Information about a facet count on a component */
export type Nr1CatalogComponentFacet = {
  __typename?: 'Nr1CatalogComponentFacet';
  /** The type of component */
  component: Nr1CatalogSearchComponentType;
  /** The count of results for this component */
  count: Scalars['Int']['output'];
};

/** Information about the mutation result when creating quickstart metadata */
export type Nr1CatalogCreateQuickstartResult = {
  __typename?: 'Nr1CatalogCreateQuickstartResult';
  /** The quickstart created as a result of running the mutation */
  quickstart?: Maybe<Nr1CatalogQuickstart>;
};

/** An outline of a created dashboard */
export type Nr1CatalogDashboardOutline = {
  __typename?: 'Nr1CatalogDashboardOutline';
  /** The guid of the created dashboard */
  dashboardGuid: Scalars['EntityGuid']['output'];
};

/** Information about a dashboard template */
export type Nr1CatalogDashboardTemplate = {
  __typename?: 'Nr1CatalogDashboardTemplate';
  /** The unique identifier for the dashboard template */
  id: Scalars['ID']['output'];
  /** Metadata associated with the dashboard template */
  metadata: Nr1CatalogDashboardTemplateMetadata;
  /** The source of the dashboard template configuration */
  sourceUrl?: Maybe<Scalars['String']['output']>;
  /** Level of support expected for the dashboard template */
  supportLevel: Nr1CatalogSupportLevel;
  /** A timestamp that indicates when the dashboard template was last updated */
  updatedAt: Scalars['DateTime']['output'];
};

/** Metadata associated with a dashboard template */
export type Nr1CatalogDashboardTemplateMetadata = {
  __typename?: 'Nr1CatalogDashboardTemplateMetadata';
  /** A list of authors that created the dashboard template */
  authors: Array<Nr1CatalogAuthor>;
  /** The list of categories for filtering, searching, and grouping associated with the dashboard template */
  categories: Array<Nr1CatalogCategory>;
  /** The list of category terms associated with the dashboard template */
  categoryTerms: Array<Scalars['String']['output']>;
  /** A short form description for a dashboard template. */
  description?: Maybe<Scalars['String']['output']>;
  /** The human-readable name for a dashboard template. */
  displayName?: Maybe<Scalars['String']['output']>;
  /** A list of previews for a dashboard template, such as screenshots. */
  previews: Array<Nr1CatalogPreview>;
  /** A list of required data sources needed to populate data in the dashboard. */
  requiredDataSources: Array<Nr1CatalogDataSource>;
};

/** Paginated information about dashboard templates */
export type Nr1CatalogDashboardTemplatesListing = {
  __typename?: 'Nr1CatalogDashboardTemplatesListing';
  /** Cursor used to fetch the next set of results */
  nextCursor?: Maybe<Scalars['String']['output']>;
  /** The list of dashboard template results */
  results: Array<Nr1CatalogDashboardTemplate>;
  /** The total number of dashboard template results */
  totalCount: Scalars['Int']['output'];
};

/** Information about a data source */
export type Nr1CatalogDataSource = {
  __typename?: 'Nr1CatalogDataSource';
  /** The unique identifier for the data source */
  id: Scalars['ID']['output'];
  /** Metadata associated with the data source */
  metadata: Nr1CatalogDataSourceMetadata;
};

/** Information about a data source install */
export type Nr1CatalogDataSourceInstall = {
  __typename?: 'Nr1CatalogDataSourceInstall';
  /** Provides context about how the fallback install should proceed */
  fallback?: Maybe<Nr1CatalogDataSourceInstallDirective>;
  /** Provides context about how the primary install should proceed */
  primary: Nr1CatalogDataSourceInstallDirective;
};

/** Installation information for a data source */
export type Nr1CatalogDataSourceInstallDirective = Nr1CatalogLinkInstallDirective | Nr1CatalogNerdletInstallDirective;

/** Installation information for a data source */
export type Nr1CatalogDataSourceInstallInput = {
  /** Provides context about how the fallback install should proceed */
  fallback?: InputMaybe<Nr1CatalogInstallDirectiveInput>;
  /** Provides context about how the primary install should proceed */
  primary: Nr1CatalogInstallDirectiveInput;
};

/** Metadata associated with a data source */
export type Nr1CatalogDataSourceMetadata = {
  __typename?: 'Nr1CatalogDataSourceMetadata';
  /** A list of alert policy templates that are auto installed upon data source installation */
  autoInstallAlertPolicyTemplates: Array<Nr1CatalogAlertPolicyTemplate>;
  /** A list of dashboard templates that are auto installed upon data source installation */
  autoInstallDashboardTemplates: Array<Nr1CatalogDashboardTemplate>;
  /** The categories for the data source */
  categories: Array<Nr1CatalogCategory>;
  /** A short form description for the data source */
  description?: Maybe<Scalars['String']['output']>;
  /** The human-readable name for the data source */
  displayName?: Maybe<Scalars['String']['output']>;
  /** The corresponding icon for the data source */
  icon?: Maybe<Nr1CatalogIcon>;
  /**
   * Icon for data source
   * @deprecated This field is no longer supported. Please use icon instead.
   *
   * If using the icon name to map the icon for an icon library, consider
   * matching against the data source ID instead.
   *
   */
  iconName?: Maybe<Scalars['String']['output']>;
  /** Install information for the data source */
  install: Nr1CatalogDataSourceInstall;
  /**
   * Provides context on how the install should proceed
   * @deprecated This field is no longer supported. Please use install.primary instead
   */
  installDirective: Nr1CatalogInstallPlanDirective;
  /** A list of keywords for filtering and searching */
  keywords: Array<Scalars['String']['output']>;
};

/** Metadata associated with the data source that will be available in New Relic Instant Observability */
export type Nr1CatalogDataSourceMetadataInput = {
  /** The list of category terms associated with the data source */
  categoryTerms?: InputMaybe<Array<Scalars['String']['input']>>;
  /** A short form description for the data source. */
  description?: InputMaybe<Scalars['String']['input']>;
  /** The human-readable name for the data source. */
  displayName: Scalars['String']['input'];
  /** The public url of an icon for the data source */
  icon: Scalars['String']['input'];
  /** Installation information for the data source */
  install: Nr1CatalogDataSourceInstallInput;
  /** A list of keywords for filtering and searching */
  keywords?: InputMaybe<Array<Scalars['String']['input']>>;
};

/** A contact channel where users can get support via email */
export type Nr1CatalogEmailContactChannel = {
  __typename?: 'Nr1CatalogEmailContactChannel';
  /** The email address for email support */
  address: Scalars['String']['output'];
};

/** Details about the contact channel where users can get support via email */
export type Nr1CatalogEmailContactChannelInput = {
  /** The email address where users can get email support */
  address: Scalars['String']['input'];
};

/** Information about an icon */
export type Nr1CatalogIcon = {
  __typename?: 'Nr1CatalogIcon';
  /** The publicly accessible URL for the icon */
  url: Scalars['String']['output'];
};

/** Information about the mutation result when installing an alert policy template */
export type Nr1CatalogInstallAlertPolicyTemplateResult = {
  __typename?: 'Nr1CatalogInstallAlertPolicyTemplateResult';
  /** The template that was used for the installation */
  alertPolicyTemplate: Nr1CatalogAlertPolicyTemplate;
  /** An outline of the created alert policy */
  createdAlertPolicy: Nr1CatalogAlertPolicyOutline;
};

/** Information about the mutation result when installing a dashboard template */
export type Nr1CatalogInstallDashboardTemplateResult = {
  __typename?: 'Nr1CatalogInstallDashboardTemplateResult';
  /** An outline of the created dashboard */
  createdDashboard: Nr1CatalogDashboardOutline;
  /** The template that was used for the installation */
  dashboardTemplate: Nr1CatalogDashboardTemplate;
};

/** Set of attributes which represent how an install takes place */
export type Nr1CatalogInstallDirectiveInput = {
  /** Link information for this directive. Cannot be used with a nerdlet directive. */
  link?: InputMaybe<Nr1CatalogLinkInstallDirectiveInput>;
  /** Nerdlet information for this directive. Cannot be used with a link directive. */
  nerdlet?: InputMaybe<Nr1CatalogNerdletInstallDirectiveInput>;
};

/** An installer that uses install plan steps */
export type Nr1CatalogInstallPlan = Nr1CatalogInstaller & {
  __typename?: 'Nr1CatalogInstallPlan';
  /** The list of install plan steps necessary to execute the installation of the quickstart */
  steps: Array<Nr1CatalogInstallPlanStep>;
  /** The type of installer */
  type: Nr1CatalogInstallerType;
};

/** Possible destinations for the install plan target */
export enum Nr1CatalogInstallPlanDestination {
  /** Application (APM) install */
  Application = 'APPLICATION',
  /** Cloud provider install */
  Cloud = 'CLOUD',
  /** Host install */
  Host = 'HOST',
  /** Kubernetes install */
  Kubernetes = 'KUBERNETES',
  /** Unknown install - special case when the target where the install takes place is unknown (such as guided install) */
  Unknown = 'UNKNOWN'
}

/** Information about an install plan directive */
export type Nr1CatalogInstallPlanDirective = {
  /** The mode of the install plan directive */
  mode: Nr1CatalogInstallPlanDirectiveMode;
};

/** Set of attributes which represent how an install takes place */
export type Nr1CatalogInstallPlanDirectiveInput = {
  /** Value that pairs with the mode to enable the installation step. Supported values are a recipe_name, nerdlet_id, or a link */
  destination?: InputMaybe<Scalars['String']['input']>;
  /** Link information for this directive. Cannot be used with nerdlet or targeted directives. */
  link?: InputMaybe<Nr1CatalogLinkDirectiveInput>;
  /** The type of installation that will take place */
  mode?: InputMaybe<Nr1CatalogInstallPlanDirectiveMode>;
  /** Nerdlet information for this directive. Cannot be used with link or targeted directives. */
  nerdlet?: InputMaybe<Nr1CatalogNerdletDirectiveInput>;
  /** Targeted information for this directive. Cannot be used with link or nerdlet directives. */
  targeted?: InputMaybe<Nr1CatalogTargetedDirectiveInput>;
};

/** Possible modes for an install plan directive */
export enum Nr1CatalogInstallPlanDirectiveMode {
  /** Directs the installation toward an external link */
  Link = 'LINK',
  /** Directs the installation to open a stacked Nerdlet to perform the installation */
  Nerdlet = 'NERDLET',
  /** Directs the installation toward a specific target */
  Targeted = 'TARGETED'
}

/** Possible types for the install plan operating system */
export enum Nr1CatalogInstallPlanOperatingSystem {
  /** Mac operating system */
  Darwin = 'DARWIN',
  /** Linux operating system */
  Linux = 'LINUX',
  /** Windows operating system */
  Windows = 'WINDOWS'
}

/** Information pertaining to a specific step in the installation plan */
export type Nr1CatalogInstallPlanStep = {
  __typename?: 'Nr1CatalogInstallPlanStep';
  /** A short form description for the install plan step */
  description?: Maybe<Scalars['String']['output']>;
  /** The human-readable name for the install plan step */
  displayName: Scalars['String']['output'];
  /** Provides context about how the fallback install plan step should proceed */
  fallback?: Maybe<Nr1CatalogInstallPlanDirective>;
  /** Used as a heading for the install plan step */
  heading: Scalars['String']['output'];
  /** The unique identifier for the install plan step */
  id: Scalars['ID']['output'];
  /** Provides context about how the primary install plan step should proceed */
  primary: Nr1CatalogInstallPlanDirective;
  /** Provides context about where the install will occur */
  target: Nr1CatalogInstallPlanTarget;
};

/** Metadata associated with a specific step in the install plan */
export type Nr1CatalogInstallPlanStepInput = {
  /** A short form description for the install plan step */
  description: Scalars['String']['input'];
  /** The human-readable name for the install plan step */
  displayName: Scalars['String']['input'];
  /** Provides context about how the fallback install plan step should proceed */
  fallback?: InputMaybe<Nr1CatalogInstallPlanDirectiveInput>;
  /** Used as a heading for the install plan step */
  heading: Scalars['String']['input'];
  /** The unique identifier for the install plan step */
  id: Scalars['ID']['input'];
  /** Provides context about how the primary install plan step should proceed */
  primary: Nr1CatalogInstallPlanDirectiveInput;
  /** Provides context about where the install will occur */
  target: Nr1CatalogInstallPlanTargetInput;
};

/** Represents the location of an install */
export type Nr1CatalogInstallPlanTarget = {
  __typename?: 'Nr1CatalogInstallPlanTarget';
  /** Provides context on the location the install will take place */
  destination: Nr1CatalogInstallPlanDestination;
  /** Provides context for the operating system that will be targeted */
  os: Array<Nr1CatalogInstallPlanOperatingSystem>;
  /** Provides context for the type of installation that will take place */
  type: Nr1CatalogInstallPlanTargetType;
};

/** Represents the location of an install */
export type Nr1CatalogInstallPlanTargetInput = {
  /** Provides context on the location the install will take place */
  destination: Nr1CatalogInstallPlanDestination;
  /** Operating system for the install */
  os?: InputMaybe<Array<Nr1CatalogInstallPlanOperatingSystem>>;
  /** Provides context for the type of installation that will take place */
  type: Nr1CatalogInstallPlanTargetType;
};

/** Possible types for the install plan target */
export enum Nr1CatalogInstallPlanTargetType {
  /** Agent install */
  Agent = 'AGENT',
  /** Integration install */
  Integration = 'INTEGRATION',
  /** On host integration install */
  OnHostIntegration = 'ON_HOST_INTEGRATION',
  /** Unknown install - special case when the target where the install takes place is unknown (such as guided install) */
  Unknown = 'UNKNOWN'
}

/** Information about how a quickstart is installed */
export type Nr1CatalogInstaller = {
  /** The type of installer */
  type: Nr1CatalogInstallerType;
};

/** Type of installer */
export enum Nr1CatalogInstallerType {
  /** Install plan */
  InstallPlan = 'INSTALL_PLAN'
}

/** A contact channel where users can get support via the repository issues page */
export type Nr1CatalogIssuesContactChannel = {
  __typename?: 'Nr1CatalogIssuesContactChannel';
  /** The URL linking to the repository issues page */
  url: Scalars['String']['output'];
};

/** Details about the contact channel where users can get support via the repository issues page */
export type Nr1CatalogIssuesContactChannelInput = {
  /** The URL linking the repository issues page where users can get support */
  url: Scalars['String']['input'];
};

/** Information about a launcher in a Nerdpack */
export type Nr1CatalogLauncher = Nr1CatalogNerdpackItem & {
  __typename?: 'Nr1CatalogLauncher';
  /** The unique identifier for the launcher. */
  id: Scalars['ID']['output'];
  /** Metadata associated with the launcher */
  metadata?: Maybe<Nr1CatalogLauncherMetadata>;
};

/** Metadata information for a launcher */
export type Nr1CatalogLauncherMetadata = Nr1CatalogNerdpackItemMetadata & {
  __typename?: 'Nr1CatalogLauncherMetadata';
  /** A short form description for the launcher. */
  description?: Maybe<Scalars['String']['output']>;
  /** The human-readable name for the launcher. */
  displayName?: Maybe<Scalars['String']['output']>;
  /** The corresponding icon for the launcher. */
  icon?: Maybe<Nr1CatalogIcon>;
  /** A list of previews for the launcher, such as screenshots. */
  previews: Array<Nr1CatalogPreview>;
};

/** Link information for a directive */
export type Nr1CatalogLinkDirectiveInput = {
  /** The URL to use for this directive */
  url: Scalars['String']['input'];
};

/** Information about a link install directive */
export type Nr1CatalogLinkInstallDirective = {
  __typename?: 'Nr1CatalogLinkInstallDirective';
  /** The URL of the external link used to guide the user through installation */
  url: Scalars['String']['output'];
};

/** Link information for a directive */
export type Nr1CatalogLinkInstallDirectiveInput = {
  /** The URL to use for this directive */
  url: Scalars['String']['input'];
};

/** Information about a link install plan directive */
export type Nr1CatalogLinkInstallPlanDirective = Nr1CatalogInstallPlanDirective & {
  __typename?: 'Nr1CatalogLinkInstallPlanDirective';
  /** The mode of the install plan directive */
  mode: Nr1CatalogInstallPlanDirectiveMode;
  /** The URL of the external link used to guide the user through installation */
  url: Scalars['String']['output'];
};

/** Outcome of the mutation */
export enum Nr1CatalogMutationResult {
  /** The mutation failed */
  Error = 'ERROR',
  /** The mutation was processed successfully */
  Ok = 'OK'
}

/** Information about a Nerdlet in a Nerdpack */
export type Nr1CatalogNerdlet = Nr1CatalogNerdpackItem & {
  __typename?: 'Nr1CatalogNerdlet';
  /** The unique identifier for the Nerdlet. */
  id: Scalars['ID']['output'];
  /** Metadata associated with the Nerdlet */
  metadata?: Maybe<Nr1CatalogNerdletMetadata>;
};

/** Nerdlet information for a directive */
export type Nr1CatalogNerdletDirectiveInput = {
  /** The ID of the nerdlet to use for this directive */
  nerdletId: Scalars['String']['input'];
  /** The initial state to be passed to a nerdlet */
  nerdletState?: InputMaybe<Scalars['Nr1CatalogRawNerdletState']['input']>;
};

/** Information about a nerdlet install directive */
export type Nr1CatalogNerdletInstallDirective = {
  __typename?: 'Nr1CatalogNerdletInstallDirective';
  /** The nerdlet ID used to guide the user through installation */
  nerdletId: Scalars['ID']['output'];
  /** The nerdlet state used to intialize the nerdlet */
  nerdletState?: Maybe<Scalars['Nr1CatalogRawNerdletState']['output']>;
  /** Determines if an account selection needs to be made prior to installation */
  requiresAccount: Scalars['Boolean']['output'];
};

/** Nerdlet information for a directive */
export type Nr1CatalogNerdletInstallDirectiveInput = {
  /** The ID of the nerdlet to use for this directive */
  nerdletId: Scalars['String']['input'];
  /** The initial state to be passed to a nerdlet */
  nerdletState?: InputMaybe<Scalars['Nr1CatalogRawNerdletState']['input']>;
  /** Determines if an account selection needs to be made prior to installation */
  requiresAccount: Scalars['Boolean']['input'];
};

/** Information about a targeted install plan directive */
export type Nr1CatalogNerdletInstallPlanDirective = Nr1CatalogInstallPlanDirective & {
  __typename?: 'Nr1CatalogNerdletInstallPlanDirective';
  /** The mode of the install plan directive */
  mode: Nr1CatalogInstallPlanDirectiveMode;
  /** The nerdlet ID used to guide the user through installation */
  nerdletId: Scalars['ID']['output'];
  /** The nerdlet state used to intialize the nerdlet */
  nerdletState?: Maybe<Scalars['Nr1CatalogRawNerdletState']['output']>;
  /** Determines if an account selection needs to be made prior to installation */
  requiresAccount: Scalars['Boolean']['output'];
};

/** Metadata information for a Nerdlet */
export type Nr1CatalogNerdletMetadata = Nr1CatalogNerdpackItemMetadata & {
  __typename?: 'Nr1CatalogNerdletMetadata';
  /** A short form description for the Nerdlet. */
  description?: Maybe<Scalars['String']['output']>;
  /** The human-readable name for the Nerdlet. */
  displayName?: Maybe<Scalars['String']['output']>;
  /** A list of previews for the Nerdlet, such as screenshots. */
  previews: Array<Nr1CatalogPreview>;
  /** The supported entity types by the Nerdlet. */
  supportedEntityTypes?: Maybe<Nr1CatalogSupportedEntityTypes>;
};

/** Information about the Nerdpack */
export type Nr1CatalogNerdpack = {
  __typename?: 'Nr1CatalogNerdpack';
  /** The unique identifier for the Nerdpack */
  id: Scalars['ID']['output'];
  /** Metadata associated with the Nerdpack that is available in the New Relic One Catalog */
  metadata?: Maybe<Nr1CatalogNerdpackMetadata>;
  /** Indicates the visibility of the Nerdpack */
  visibility: Nr1CatalogNerdpackVisibility;
};

/** Information about an item in a Nerdpack */
export type Nr1CatalogNerdpackItem = {
  /** The unique identifier for the Nerdpack item. */
  id: Scalars['ID']['output'];
  /** Metadata associated with the Nerdpack item */
  metadata?: Maybe<Nr1CatalogNerdpackItemMetadata>;
};

/** Metadata information for an item in a Nerdpack */
export type Nr1CatalogNerdpackItemMetadata = {
  /** A short form description for the Nerdpack item. */
  description?: Maybe<Scalars['String']['output']>;
  /** The human-readable name for the Nerdpack item. */
  displayName?: Maybe<Scalars['String']['output']>;
  /** A list of previews for the Nerdpack item, such as screenshots. */
  previews: Array<Nr1CatalogPreview>;
};

/** Metadata associated with the Nerdpack that is available in the New Relic One Catalog */
export type Nr1CatalogNerdpackMetadata = {
  __typename?: 'Nr1CatalogNerdpackMetadata';
  /** Additional information about the Nerdpack */
  additionalInfo?: Maybe<Scalars['String']['output']>;
  /** The list of categories for filtering, searching, and grouping associated with the Nerdpack */
  categories: Array<Nr1CatalogCategory>;
  /** The list of category terms associated with the Nerdpack */
  categoryTerms: Array<Scalars['String']['output']>;
  /** A short form description for the New Relic One Nerdpack. Used throughout the platform when displaying the Nerdpack. */
  description?: Maybe<Scalars['String']['output']>;
  /** The long form description used in the catalog to detail the functionality of the Nerdpack */
  details?: Maybe<Scalars['String']['output']>;
  /** The human-readable name for the Nerdpack. Used throughout the New Relic One platform when displaying the Nerdpack. */
  displayName?: Maybe<Scalars['String']['output']>;
  /** Additional documentation for the Nerdpack */
  documentation?: Maybe<Scalars['String']['output']>;
  /** The corresponding icon for the Nerdpack */
  icon?: Maybe<Nr1CatalogIcon>;
  /** The types of artifacts (e.g. nerdlet, launcher, etc) contained in the nerdpack */
  includedArtifactTypes?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
  /** The list of keywords for filtering and searching */
  keywords: Array<Scalars['String']['output']>;
  /** Information related to items in the nerdpack */
  nerdpackItems: Array<Nr1CatalogNerdpackItem>;
  /** A list of previews for the Nerdpack, such as screenshots. */
  previews: Array<Nr1CatalogPreview>;
  /** The date the Nerdpack was published */
  publishDate?: Maybe<Scalars['DateTime']['output']>;
  /**
   * The date the Nerdpack was deployed
   * @deprecated This field is no longer supported. Please use publishDate instead.
   */
  releaseDate?: Maybe<Scalars['DateTime']['output']>;
  /** The URL to the repository where the source code for the Nerdpack can be found. */
  repository?: Maybe<Scalars['String']['output']>;
  /** Contact information to get support for the Nerdpack */
  support: Nr1CatalogSupportChannels;
  /** A tagline for the Nerdpack */
  tagline?: Maybe<Scalars['String']['output']>;
  /** The nerdpack version the metadata corresponds with */
  version: Scalars['SemVer']['output'];
  /** A description of changes for this version of the Nerdpack */
  whatsNew?: Maybe<Nr1CatalogReleaseNote>;
};


/** Metadata associated with the Nerdpack that is available in the New Relic One Catalog */
export type Nr1CatalogNerdpackMetadataAdditionalInfoArgs = {
  format?: InputMaybe<Nr1CatalogRenderFormat>;
};


/** Metadata associated with the Nerdpack that is available in the New Relic One Catalog */
export type Nr1CatalogNerdpackMetadataDocumentationArgs = {
  format?: InputMaybe<Nr1CatalogRenderFormat>;
};

/** Possible visibilities for the Nerdpack */
export enum Nr1CatalogNerdpackVisibility {
  /** Indicates the Nerdpack is available globally across all accounts */
  Global = 'GLOBAL',
  /** Indicates the Nerdpack is only available to the owning and allowed accounts */
  OwnerAndAllowed = 'OWNER_AND_ALLOWED'
}

/** Specifies the supported entity types to be no entity types */
export type Nr1CatalogNoSupportedEntityTypes = Nr1CatalogSupportedEntityTypes & {
  __typename?: 'Nr1CatalogNoSupportedEntityTypes';
  /** The level of support entity types. Always set to NONE */
  mode: Nr1CatalogSupportedEntityTypesMode;
};

/** Specifies fields required for types that implement the ability to display a media preview in the New Relic One Catalog */
export type Nr1CatalogPreview = {
  /** The publicly accessible URL for the preview */
  url: Scalars['String']['output'];
};

/** Information about the quickstart */
export type Nr1CatalogQuickstart = {
  __typename?: 'Nr1CatalogQuickstart';
  /** Determines if this is a featured quickstart */
  featured: Scalars['Boolean']['output'];
  /** The unique identifier for the quickstart */
  id: Scalars['ID']['output'];
  /** Metadata associated with the quickstart */
  metadata?: Maybe<Nr1CatalogQuickstartMetadata>;
  /** Specifies the URL where the source definition for the quickstart can be found */
  sourceUrl?: Maybe<Scalars['String']['output']>;
  /** Level of support expected for the quickstart */
  supportLevel: Nr1CatalogSupportLevel;
};

/** Information about an alert in a quickstart */
export type Nr1CatalogQuickstartAlert = Nr1CatalogQuickstartComponent & {
  __typename?: 'Nr1CatalogQuickstartAlert';
  /**
   * The unique identifier for the alert
   * @deprecated This field is no longer supported. Please use Nr1CatalogQuickstartAlertCondition instead.
   */
  id: Scalars['ID']['output'];
  /**
   * Metadata associated with the alert
   * @deprecated This field is no longer supported. Please use Nr1CatalogQuickstartAlertCondition instead.
   */
  metadata: Nr1CatalogQuickstartAlertMetadata;
};

/** Information about an alert condition in a quickstart */
export type Nr1CatalogQuickstartAlertCondition = Nr1CatalogQuickstartComponent & {
  __typename?: 'Nr1CatalogQuickstartAlertCondition';
  /** The unique identifier for the alert condition */
  id: Scalars['ID']['output'];
  /** Metadata associated with the alert condition */
  metadata: Nr1CatalogQuickstartAlertConditionMetadata;
  /** The source of the alert configuration */
  sourceUrl?: Maybe<Scalars['String']['output']>;
};

/** Metadata associated with the alert condition in a quickstart */
export type Nr1CatalogQuickstartAlertConditionMetadata = Nr1CatalogQuickstartComponentMetadata & {
  __typename?: 'Nr1CatalogQuickstartAlertConditionMetadata';
  /** A short form description for the alert condition */
  description?: Maybe<Scalars['String']['output']>;
  /** The human-readable name for the alert condition */
  displayName?: Maybe<Scalars['String']['output']>;
  /** Determines the type of alert condition that will be created */
  type: Nr1CatalogQuickstartAlertConditionType;
};

/** Possible types of configured alert conditions */
export enum Nr1CatalogQuickstartAlertConditionType {
  /** A baseline alert condition */
  Baseline = 'BASELINE',
  /**
   * An outlier alert condition
   * @deprecated Outlier alert conditions are no longer supported
   */
  Outlier = 'OUTLIER',
  /** A static alert condition */
  Static = 'STATIC'
}

/** Metadata associated with the alert in a quickstart */
export type Nr1CatalogQuickstartAlertMetadata = Nr1CatalogQuickstartComponentMetadata & {
  __typename?: 'Nr1CatalogQuickstartAlertMetadata';
  /**
   * A short form description for the alert.
   * @deprecated This field is no longer supported. Please use Nr1CatalogQuickstartAlertCondition instead.
   */
  description?: Maybe<Scalars['String']['output']>;
  /**
   * The human-readable name for the alert.
   * @deprecated This field is no longer supported. Please use Nr1CatalogQuickstartAlertCondition instead.
   */
  displayName?: Maybe<Scalars['String']['output']>;
};

/** Information about a component in a quickstart */
export type Nr1CatalogQuickstartComponent = {
  /** Metadata associated with the quickstart component */
  metadata: Nr1CatalogQuickstartComponentMetadata;
};

/** Information related to the metadata attached to a quickstart component */
export type Nr1CatalogQuickstartComponentMetadata = {
  /** A short form description for the quickstart component. */
  description?: Maybe<Scalars['String']['output']>;
  /** The human-readable name for the quickstart component. */
  displayName?: Maybe<Scalars['String']['output']>;
};

/** Information about a dashboard in a quickstart */
export type Nr1CatalogQuickstartDashboard = Nr1CatalogQuickstartComponent & {
  __typename?: 'Nr1CatalogQuickstartDashboard';
  /** The unique identifier for the dashboard */
  id: Scalars['ID']['output'];
  /** Metadata associated with the dashboard */
  metadata: Nr1CatalogQuickstartDashboardMetadata;
  /** The source of the dashboard configuration */
  sourceUrl?: Maybe<Scalars['String']['output']>;
};

/** Metadata associated with the dashboard in a quickstart */
export type Nr1CatalogQuickstartDashboardMetadata = Nr1CatalogQuickstartComponentMetadata & {
  __typename?: 'Nr1CatalogQuickstartDashboardMetadata';
  /** A short form description for the dashboard. */
  description?: Maybe<Scalars['String']['output']>;
  /** The human-readable name for the dashboard. */
  displayName?: Maybe<Scalars['String']['output']>;
  /** A list of previews for the dashboard, such as screenshots. */
  previews: Array<Nr1CatalogPreview>;
};

/** Information about a documentation component in a quickstart */
export type Nr1CatalogQuickstartDocumentation = Nr1CatalogQuickstartComponent & {
  __typename?: 'Nr1CatalogQuickstartDocumentation';
  /** Metadata associated with the dashboard */
  metadata: Nr1CatalogQuickstartDocumentationMetadata;
};

/** Metadata associated with the documentation component in a quickstart */
export type Nr1CatalogQuickstartDocumentationMetadata = Nr1CatalogQuickstartComponentMetadata & {
  __typename?: 'Nr1CatalogQuickstartDocumentationMetadata';
  /** A short form description for the documentation component. */
  description?: Maybe<Scalars['String']['output']>;
  /** The human-readable name for the documentation component. */
  displayName?: Maybe<Scalars['String']['output']>;
  /** The documentation URL */
  url: Scalars['String']['output'];
};

/** Information about an install plan component in a quickstart */
export type Nr1CatalogQuickstartInstallPlan = Nr1CatalogQuickstartComponent & {
  __typename?: 'Nr1CatalogQuickstartInstallPlan';
  /**
   * Metadata associated with the install plan
   * @deprecated This field is no longer supported. Please use installer instead.
   */
  metadata: Nr1CatalogQuickstartInstallPlanMetadata;
};

/** Metadata associated with the install plan in a quickstart */
export type Nr1CatalogQuickstartInstallPlanMetadata = Nr1CatalogQuickstartComponentMetadata & {
  __typename?: 'Nr1CatalogQuickstartInstallPlanMetadata';
  /**
   * A short form description for the documentation component.
   * @deprecated This field is no longer supported. Please use installer instead.
   */
  description?: Maybe<Scalars['String']['output']>;
  /**
   * The human-readable name for the install plan component.
   * @deprecated This field is no longer supported. Please use installer instead.
   */
  displayName?: Maybe<Scalars['String']['output']>;
};

/** Metadata associated with the quickstart that is available in New Relic I/O */
export type Nr1CatalogQuickstartMetadata = {
  __typename?: 'Nr1CatalogQuickstartMetadata';
  /** Authors for the quickstart */
  authors: Array<Nr1CatalogAuthor>;
  /** The list of categories for filtering, searching, and grouping associated with the quickstart */
  categories: Array<Nr1CatalogCategory>;
  /** The list of category terms associated with the quickstart */
  categoryTerms: Array<Scalars['String']['output']>;
  /** The list of data sources associated with the quickstart */
  dataSources: Array<Nr1CatalogDataSource>;
  /** A short form description for the quickstart. Used throughout the platform when displaying the quickstart. */
  description?: Maybe<Scalars['String']['output']>;
  /** The human-readable name for the quickstart. Used throughout the New Relic One platform when displaying the quickstart. */
  displayName?: Maybe<Scalars['String']['output']>;
  /** The corresponding icon for the quickstart */
  icon?: Maybe<Nr1CatalogIcon>;
  /**
   * Information about how a quickstart is installed
   * @deprecated This field is in a deprecation period. Please refer to `dataSources` for how a quickstart is installed.
   */
  installer?: Maybe<Nr1CatalogInstaller>;
  /** A list of keywords for filtering and searching */
  keywords: Array<Scalars['String']['output']>;
  /** List of components in a quickstart */
  quickstartComponents: Array<Nr1CatalogQuickstartComponent>;
  /** The URL friendly name of the quickstart */
  slug: Scalars['String']['output'];
  /** A short summary detailing the functionality of the quickstart */
  summary?: Maybe<Scalars['String']['output']>;
};

/** Metadata associated with the alert condition in this quickstart */
export type Nr1CatalogQuickstartMetadataAlertConditionInput = {
  /** A short form description for the alert condition. */
  description?: InputMaybe<Scalars['String']['input']>;
  /** The human-readable name for the alert condition. Used throughout the New Relic One platform when displaying the alert condition. */
  displayName: Scalars['String']['input'];
  /** The raw JSON configuration for the alert condition */
  rawConfiguration: Scalars['Nr1CatalogRawConfiguration']['input'];
  /** The source of the alert configuration */
  sourceUrl?: InputMaybe<Scalars['String']['input']>;
  /** Determines the type of alert condition that will be created */
  type: Nr1CatalogQuickstartAlertConditionType;
};

/** Metadata associated with the dashboard in this quickstart */
export type Nr1CatalogQuickstartMetadataDashboardInput = {
  /** A short form description for the dashboard. */
  description?: InputMaybe<Scalars['String']['input']>;
  /** The human-readable name for the dashboard. Used throughout the New Relic One platform when displaying the dashboard. */
  displayName: Scalars['String']['input'];
  /** The raw JSON configuration for the dashboard */
  rawConfiguration: Scalars['Nr1CatalogRawConfiguration']['input'];
  /** A list of previews for the dashboard, such as screenshots. */
  screenshots?: InputMaybe<Array<Nr1CatalogScreenshotInput>>;
  /** The source of the dashboard configuration */
  sourceUrl?: InputMaybe<Scalars['String']['input']>;
};

/** Metadata associated with the documentation in this quickstart */
export type Nr1CatalogQuickstartMetadataDocumentationInput = {
  /** A short form description for the documentation component. */
  description: Scalars['String']['input'];
  /** The human-readable name for the documentation component. Used throughout the New Relic One platform when displaying the documentation component. */
  displayName: Scalars['String']['input'];
  /** The documentation URL */
  url: Scalars['String']['input'];
};

/** Metadata associated with the quickstart that will be available in New Relic Instant Observability */
export type Nr1CatalogQuickstartMetadataInput = {
  /** A list of alert condition components that are included in the quickstart */
  alertConditions?: InputMaybe<Array<Nr1CatalogQuickstartMetadataAlertConditionInput>>;
  /** Authors for the quickstart */
  authors: Array<Nr1CatalogAuthorInput>;
  /** The list of category terms associated with the quickstart */
  categoryTerms?: InputMaybe<Array<Scalars['String']['input']>>;
  /** A list of dashboard components that are included in the quickstart */
  dashboards?: InputMaybe<Array<Nr1CatalogQuickstartMetadataDashboardInput>>;
  /** A list of data source ids corresponding to the data sources associated with this quickstart */
  dataSourceIds?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** A short form description for the quickstart. Used throughout the platform when displaying the quickstart. */
  description: Scalars['String']['input'];
  /** The human-readable name for the quickstart. Used throughout the New Relic One platform when displaying the quickstart. */
  displayName: Scalars['String']['input'];
  /** A list of documentation components that are included in the quickstart */
  documentation?: InputMaybe<Array<Nr1CatalogQuickstartMetadataDocumentationInput>>;
  /** The public url of an icon for the quickstart */
  icon: Scalars['String']['input'];
  /** A list of install plan step ids corresponding to the steps of the installation plan */
  installPlanStepIds?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** A list of keywords for filtering and searching */
  keywords?: InputMaybe<Array<Scalars['String']['input']>>;
  /** The URL friendly name for the quickstart */
  slug?: InputMaybe<Scalars['String']['input']>;
  /** Specifies the URL where the source definition for the quickstart can be found */
  sourceUrl?: InputMaybe<Scalars['String']['input']>;
  /** A short summary detailing the functionality of the quickstart */
  summary: Scalars['String']['input'];
  /** Level of support for the quickstart */
  supportLevel?: InputMaybe<Nr1CatalogSupportLevel>;
};

/** Paginated information about Quickstarts */
export type Nr1CatalogQuickstartsListing = {
  __typename?: 'Nr1CatalogQuickstartsListing';
  /** Cursor used to fetch the next set of results */
  nextCursor?: Maybe<Scalars['String']['output']>;
  /** The list of quickstart results */
  results: Array<Nr1CatalogQuickstart>;
  /** The total number of quickstart results */
  totalCount: Scalars['Int']['output'];
};

/** Information about the changes made to the metadata for a version of the Nerdpack */
export type Nr1CatalogReleaseNote = {
  __typename?: 'Nr1CatalogReleaseNote';
  /** The description of changes made for this version of the Nerdpack */
  changes: Scalars['String']['output'];
  /** The version of the Nerdpack the changes correspond with */
  version: Scalars['SemVer']['output'];
};

/** Supported rendering formats for data */
export enum Nr1CatalogRenderFormat {
  /** Renders the output in Markdown */
  Markdown = 'MARKDOWN'
}

/** Information about the publicly accessible screenshot */
export type Nr1CatalogScreenshot = Nr1CatalogPreview & {
  __typename?: 'Nr1CatalogScreenshot';
  /** The publicly accessible URL for the screenshot */
  url: Scalars['String']['output'];
};

/** Information about the publicly accessible screenshot */
export type Nr1CatalogScreenshotInput = {
  /** The publicly accessible URL for the screenshot */
  url: Scalars['String']['input'];
};

/** Possible component types to filter the search */
export enum Nr1CatalogSearchComponentType {
  /** Filter search results that contain alerts */
  Alerts = 'ALERTS',
  /** Filter search results that contain apps */
  Apps = 'APPS',
  /** Filter search results that contain dashboards */
  Dashboards = 'DASHBOARDS',
  /** Filter search results that contain data sources */
  DataSources = 'DATA_SOURCES',
  /** Filter search results that contain visualizations */
  Visualizations = 'VISUALIZATIONS'
}

/** Information about facets from a search */
export type Nr1CatalogSearchFacets = {
  __typename?: 'Nr1CatalogSearchFacets';
  /** Facet counts for each category */
  categories: Array<Nr1CatalogCategoryFacet>;
  /** Facet counts for each component */
  components: Array<Nr1CatalogComponentFacet>;
  /** Count of the number of featured results */
  featured: Scalars['Int']['output'];
  /** Facet counts for each search result type */
  types: Array<Nr1CatalogSearchResultTypeFacet>;
};

/** Criteria for applying filters to a search */
export type Nr1CatalogSearchFilter = {
  /** Filter the search results that match any in a list of category terms */
  categories?: InputMaybe<Array<Scalars['String']['input']>>;
  /** Filter the search results by a particular category */
  category?: InputMaybe<Scalars['String']['input']>;
  /** Filter the search results that contain a set of component types */
  components?: InputMaybe<Array<Nr1CatalogSearchComponentType>>;
  /** Filter the search results to those that match all keywords in the list */
  keywords?: InputMaybe<Array<Scalars['String']['input']>>;
  /** Filter the search results by install recipe name. This will be applied in an OR fashion. Schema is defined in the Open Install Library's recipe spec: https://github.com/newrelic/open-install-library/blob/main/docs/recipe-spec/recipe-spec.md#schema-definition. */
  recipeNames?: InputMaybe<Array<Scalars['String']['input']>>;
  /** Filter the search results that are of a specific type */
  types?: InputMaybe<Array<Nr1CatalogSearchResultType>>;
};

/** Information about results returned from a search */
export type Nr1CatalogSearchResponse = {
  __typename?: 'Nr1CatalogSearchResponse';
  /** Get count information about the filters */
  facets: Nr1CatalogSearchFacets;
  /** Cursor used to fetch the next set of results */
  nextCursor?: Maybe<Scalars['String']['output']>;
  /** The list of search results */
  results: Array<Nr1CatalogSearchResult>;
  /** The total number of results that match the search */
  totalCount: Scalars['Int']['output'];
};

/** A result returned when executing a search */
export type Nr1CatalogSearchResult = Nr1CatalogAlertPolicyTemplate | Nr1CatalogDashboardTemplate | Nr1CatalogDataSource | Nr1CatalogNerdpack | Nr1CatalogQuickstart;

/** Possible search result types used to filter search results */
export enum Nr1CatalogSearchResultType {
  /** Filter search results by alert policy templates */
  AlertPolicyTemplate = 'ALERT_POLICY_TEMPLATE',
  /** Filter search results by dashboard templates */
  DashboardTemplate = 'DASHBOARD_TEMPLATE',
  /** Filter search results by data sources */
  DataSource = 'DATA_SOURCE',
  /** Filter search results by nerdpacks */
  Nerdpack = 'NERDPACK',
  /** Filter search results by quickstarts */
  Quickstart = 'QUICKSTART'
}

/** Information about a facet count on a search result type */
export type Nr1CatalogSearchResultTypeFacet = {
  __typename?: 'Nr1CatalogSearchResultTypeFacet';
  /** The count of results for this search result type */
  count: Scalars['Int']['output'];
  /** The type of search result */
  type: Nr1CatalogSearchResultType;
};

/** Possible options to sort search results */
export enum Nr1CatalogSearchSortOption {
  /** Sort the search results alphabetically */
  Alphabetical = 'ALPHABETICAL',
  /** Sort the search results by most popular */
  Popularity = 'POPULARITY',
  /** Sort the search results by the most relevant to the search query */
  Relevance = 'RELEVANCE',
  /** Sort the search results alphabetically in reverse order */
  ReverseAlphabetical = 'REVERSE_ALPHABETICAL'
}

/** Information about the result of setting the auto install alert policy templates for a data source */
export type Nr1CatalogSetAutoInstallAlertPolicyTemplatesForDataSourceResult = {
  __typename?: 'Nr1CatalogSetAutoInstallAlertPolicyTemplatesForDataSourceResult';
  /** The data source that was updated from this mutation */
  dataSource?: Maybe<Nr1CatalogDataSource>;
};

/** Information about the result of setting the auto install dashboard templates for a data source */
export type Nr1CatalogSetAutoInstallDashboardTemplatesForDataSourceResult = {
  __typename?: 'Nr1CatalogSetAutoInstallDashboardTemplatesForDataSourceResult';
  /** The data source that was updated from this mutation */
  dataSource?: Maybe<Nr1CatalogDataSource>;
};

/** Information about the result of setting the required data sources for an alert policy template */
export type Nr1CatalogSetRequiredDataSourcesForAlertPolicyTemplateResult = {
  __typename?: 'Nr1CatalogSetRequiredDataSourcesForAlertPolicyTemplateResult';
  /** The dashboard template that was updated from this mutation */
  alertPolicyTemplate?: Maybe<Nr1CatalogAlertPolicyTemplate>;
};

/** Information about the result of setting the required data sources for a dashboard template */
export type Nr1CatalogSetRequiredDataSourcesForDashboardTemplateResult = {
  __typename?: 'Nr1CatalogSetRequiredDataSourcesForDashboardTemplateResult';
  /** The dashboard template that was updated from this mutation */
  dashboardTemplate?: Maybe<Nr1CatalogDashboardTemplate>;
};

/** Specifies the supported entity types to be a specific subset of entity types */
export type Nr1CatalogSpecificSupportedEntityTypes = Nr1CatalogSupportedEntityTypes & {
  __typename?: 'Nr1CatalogSpecificSupportedEntityTypes';
  /** The list of support entity types. */
  entityTypes: Array<DomainType>;
  /** The level of support entity types. Always set to SPECIFIC */
  mode: Nr1CatalogSupportedEntityTypesMode;
};

/** Information about the mutation result when submitting a data source */
export type Nr1CatalogSubmitDataSourceResult = {
  __typename?: 'Nr1CatalogSubmitDataSourceResult';
  /** The data source that was created or updated from the mutation */
  dataSource?: Maybe<Nr1CatalogDataSource>;
};

/** Information about the mutation result when submitting install plan metadata */
export type Nr1CatalogSubmitInstallPlanStepResult = {
  __typename?: 'Nr1CatalogSubmitInstallPlanStepResult';
  /** The install plan step with updated information as a result of running the mutation */
  installPlanStep?: Maybe<Nr1CatalogInstallPlanStep>;
};

/** Information about the error that occurred as a result of submitting metadata */
export type Nr1CatalogSubmitMetadataError = {
  __typename?: 'Nr1CatalogSubmitMetadataError';
  /** A human-readable description of the error when submitting metadata */
  description: Scalars['String']['output'];
  /** The field that caused the error when submitting metadata */
  field?: Maybe<Array<Scalars['String']['output']>>;
  /** The type of error that occurred when submitting metadata */
  type: Nr1CatalogSubmitMetadataErrorType;
};

/** The type of error that occurred during the mutation when submitting metadata */
export enum Nr1CatalogSubmitMetadataErrorType {
  /** The Nerdpack cannot be found */
  NerdpackNotFound = 'NERDPACK_NOT_FOUND',
  /** Something went wrong in the service */
  ServerError = 'SERVER_ERROR',
  /** The user does not have permission to update the metadata for the Nerdpack */
  Unauthorized = 'UNAUTHORIZED',
  /** The type of the Nerdpack is not supported in the New Relic One Catalog */
  UnsupportedType = 'UNSUPPORTED_TYPE',
  /** The submitted metadata is not valid and needs to be corrected to be accepted */
  ValidationFailed = 'VALIDATION_FAILED'
}

/** Metadata associated with the Nerdpack that will be available in the New Relic One Catalog */
export type Nr1CatalogSubmitMetadataInput = {
  /** Additional information relevant for the Nerdpack */
  additionalInfo?: InputMaybe<Scalars['String']['input']>;
  /** A list of terms for category grouping when filtering and searching the Nerdpack */
  categoryTerms?: InputMaybe<Array<Scalars['String']['input']>>;
  /** A long form description used in the catalog to detail the functionality of the Nerdpack */
  details?: InputMaybe<Scalars['String']['input']>;
  /** Additional documentation relevant for the Nerdpack */
  documentation?: InputMaybe<Scalars['String']['input']>;
  /** A list of keywords for filtering and searching the Nerdpack */
  keywords?: InputMaybe<Array<Scalars['String']['input']>>;
  /** A URL that links to the repository where the source code for this Nerdpack can be found */
  repository?: InputMaybe<Scalars['String']['input']>;
  /** Support channels where users can contact you to get support for the Nerdpack */
  support?: InputMaybe<Nr1CatalogSupportInput>;
  /** A tagline for the Nerdpack */
  tagline?: InputMaybe<Scalars['String']['input']>;
  /** The version of the Nerdpack that will be associated with this metadata */
  version: Scalars['SemVer']['input'];
  /** A description of changes describing what changed for this version of the Nerdpack */
  whatsNew?: InputMaybe<Scalars['String']['input']>;
};

/** Information about the mutation result when submitting metadata */
export type Nr1CatalogSubmitMetadataResult = {
  __typename?: 'Nr1CatalogSubmitMetadataResult';
  /** A list of errors that may have occurred as a result of submitting metadata */
  errors?: Maybe<Array<Nr1CatalogSubmitMetadataError>>;
  /** The Nerdpack with updated information as a result of running the mutation */
  nerdpack?: Maybe<Nr1CatalogNerdpack>;
  /** The mutation result when submitting metadata */
  result: Nr1CatalogMutationResult;
};

/** Information about the mutation result when updating quickstart metadata */
export type Nr1CatalogSubmitQuickstartResult = {
  __typename?: 'Nr1CatalogSubmitQuickstartResult';
  /** The quickstart with updated information as a result of running the mutation */
  quickstart?: Maybe<Nr1CatalogQuickstart>;
};

/** A container for the various support channels */
export type Nr1CatalogSupportChannels = {
  __typename?: 'Nr1CatalogSupportChannels';
  /** A support channel available via the community */
  community?: Maybe<Nr1CatalogCommunityContactChannel>;
  /** A support channel available via email */
  email?: Maybe<Nr1CatalogEmailContactChannel>;
  /** A support channel available via an issues page */
  issues?: Maybe<Nr1CatalogIssuesContactChannel>;
};

/** A container specifying the various types support channels */
export type Nr1CatalogSupportInput = {
  /** A support channel where users can get support via the community */
  community?: InputMaybe<Nr1CatalogCommunityContactChannelInput>;
  /** A support channel where users can get support via email */
  email?: InputMaybe<Nr1CatalogEmailContactChannelInput>;
  /** A support channel where users can get support via issues */
  issues?: InputMaybe<Nr1CatalogIssuesContactChannelInput>;
};

/** Possible levels of support */
export enum Nr1CatalogSupportLevel {
  /** Community supported */
  Community = 'COMMUNITY',
  /** Enterprise supported */
  Enterprise = 'ENTERPRISE',
  /** New Relic supported */
  NewRelic = 'NEW_RELIC',
  /** Partner supported */
  Verified = 'VERIFIED'
}

/** Specifies fields required for types that implement the ability to determine the level of supported entity types. */
export type Nr1CatalogSupportedEntityTypes = {
  /** Determines the supported entity type mode. */
  mode: Nr1CatalogSupportedEntityTypesMode;
};

/** Possible modes for supported entity types */
export enum Nr1CatalogSupportedEntityTypesMode {
  /** Indicates that all entity types are supported */
  All = 'ALL',
  /** Indicates that no entity types are supported */
  None = 'NONE',
  /** Indicates that a specific set of entity types are supported */
  Specific = 'SPECIFIC'
}

/** Targeted information for a directive */
export type Nr1CatalogTargetedDirectiveInput = {
  /** The recipe name to use for this directive */
  recipeName: Scalars['String']['input'];
};

/** Information about a targeted install plan directive */
export type Nr1CatalogTargetedInstallPlanDirective = Nr1CatalogInstallPlanDirective & {
  __typename?: 'Nr1CatalogTargetedInstallPlanDirective';
  /** The mode of the install plan directive */
  mode: Nr1CatalogInstallPlanDirectiveMode;
  /** The name of the recipe used for the installation */
  recipeName: Scalars['String']['output'];
};

/** Information about the mutation result when updating quickstart metadata */
export type Nr1CatalogUpdateQuickstartResult = {
  __typename?: 'Nr1CatalogUpdateQuickstartResult';
  /** The quickstart with updated information as a result of running the mutation */
  quickstart?: Maybe<Nr1CatalogQuickstart>;
};

/** Information about a visualization in a Nerdpack */
export type Nr1CatalogVisualization = Nr1CatalogNerdpackItem & {
  __typename?: 'Nr1CatalogVisualization';
  /** The unique identifier for the visualization. */
  id: Scalars['ID']['output'];
  /** Metadata associated with the visualization */
  metadata?: Maybe<Nr1CatalogVisualizationMetadata>;
};

/** Metadata information for a visualization */
export type Nr1CatalogVisualizationMetadata = Nr1CatalogNerdpackItemMetadata & {
  __typename?: 'Nr1CatalogVisualizationMetadata';
  /** A short form description for the visualization. */
  description?: Maybe<Scalars['String']['output']>;
  /** The human-readable name for the visualization. */
  displayName?: Maybe<Scalars['String']['output']>;
  /** A list of previews for the visualization, such as screenshots. */
  previews: Array<Nr1CatalogPreview>;
};

export type NrPlatformQueryNamespace = {
  __typename?: 'NrPlatformQueryNamespace';
  /** This field provides access to AddressAutocomplete data. */
  addressAutocomplete?: Maybe<AddressAutocompleteNrPlatformStitchedFields>;
  nerdGraph?: Maybe<NerdGraph>;
  nerdStoreCollections?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
  /** This field provides access to Provisioning data. */
  provisioning?: Maybe<ProvisioningNrPlatformStitchedFields>;
  serviceDiscovery?: Maybe<ServiceDiscoveryNamespace>;
};


export type NrPlatformQueryNamespaceNerdStoreCollectionsArgs = {
  scope: NerdStoreScopeInput;
};

/** An object containing metadata about the query and result. */
export type NrdbMetadata = {
  __typename?: 'NrdbMetadata';
  /** A list of the event types that were queried. */
  eventTypes?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
  /** A list of facets that were queried. */
  facets?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
  /** Messages from NRDB included with the result. */
  messages?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
  /** Details about the query time window. */
  timeWindow?: Maybe<NrdbMetadataTimeWindow>;
};

/** An object representing details about a query's time window. */
export type NrdbMetadataTimeWindow = {
  __typename?: 'NrdbMetadataTimeWindow';
  /** Timestamp marking the query begin time. */
  begin?: Maybe<Scalars['EpochMilliseconds']['output']>;
  /** A clause representing the comparison time window. */
  compareWith?: Maybe<Scalars['String']['output']>;
  /** Timestamp marking the query end time. */
  end?: Maybe<Scalars['EpochMilliseconds']['output']>;
  /** SINCE clause resulting from the query */
  since?: Maybe<Scalars['String']['output']>;
  /** UNTIL clause resulting from the query */
  until?: Maybe<Scalars['String']['output']>;
};

/** An object containing metadata about the execution of an asynchronous NRQL query. */
export type NrdbQueryProgress = {
  __typename?: 'NrdbQueryProgress';
  /** Whether the query has finished executing. */
  completed?: Maybe<Scalars['Boolean']['output']>;
  /** A token for retrieving the results of a previously executed asynchronous query. */
  queryId?: Maybe<Scalars['ID']['output']>;
  /** Results of the completed query will expire permanently after this long. */
  resultExpiration?: Maybe<Scalars['Seconds']['output']>;
  /** Wait at least this long before querying for completed results with the `queryId`. */
  retryAfter?: Maybe<Scalars['Seconds']['output']>;
  /** The server may cancel the NRDB query after this long if no GraphQL queries have been made to check the `queryId`'s status. */
  retryDeadline?: Maybe<Scalars['Seconds']['output']>;
};

/**
 * A data structure that contains the results of the NRDB query along
 * with other capabilities that enhance those results.
 *
 * Direct query results are available through `results`, `totalResult` and
 * `otherResult`. The query you made is accessible through `nrql`, along with
 * `metadata` about the query itself. Enhanced capabilities include
 * `eventDefinitions`, `suggestedFacets` and more.
 */
export type NrdbResultContainer = {
  __typename?: 'NrdbResultContainer';
  /** In a `COMPARE WITH` query, the `currentResults` contain the results for the current comparison time window. */
  currentResults?: Maybe<Array<Maybe<Scalars['NrdbResult']['output']>>>;
  /**
   * Generate a publicly sharable Embedded Chart URL for the NRQL query.
   *
   * For more details, see [our docs](https://docs.newrelic.com/docs/apis/graphql-api/tutorials/query-nrql-through-new-relic-graphql-api#embeddable-charts).
   */
  embeddedChartUrl?: Maybe<Scalars['String']['output']>;
  /**
   * Retrieve a list of event type definitions, providing descriptions
   * of the event types returned by this query, as well as details
   * of their attributes.
   */
  eventDefinitions?: Maybe<Array<Maybe<EventDefinition>>>;
  /** Metadata about the query and result. */
  metadata?: Maybe<NrdbMetadata>;
  /** The [NRQL](https://docs.newrelic.com/docs/insights/nrql-new-relic-query-language/nrql-resources/nrql-syntax-components-functions) query that was executed to yield these results. */
  nrql?: Maybe<Scalars['Nrql']['output']>;
  /**
   * In a `FACET` query, the `otherResult` contains the aggregates representing the events _not_
   * contained in an individual `results` facet.
   */
  otherResult?: Maybe<Scalars['NrdbResult']['output']>;
  /** In a `COMPARE WITH` query, the `previousResults` contain the results for the previous comparison time window. */
  previousResults?: Maybe<Array<Maybe<Scalars['NrdbResult']['output']>>>;
  /** Metadata about the execution of an asynchronous NRQL query. */
  queryProgress?: Maybe<NrdbQueryProgress>;
  /** The raw query results exactly as they are returned from NRDB. NerdGraph provides no additional transformation. */
  rawResponse?: Maybe<Scalars['NrdbRawResults']['output']>;
  /** The query results. This is a flat list of objects who's structure matches the query submitted. */
  results?: Maybe<Array<Maybe<Scalars['NrdbResult']['output']>>>;
  /** Generate a publicly sharable static chart URL for the NRQL query. */
  staticChartUrl?: Maybe<Scalars['String']['output']>;
  /**
   * Retrieve a list of suggested NRQL facets for this NRDB query, to be used with
   * the `FACET` keyword in NRQL.
   *
   * Results are based on historical query behaviors.
   *
   * If the query already has a `FACET` clause, it will be ignored for the purposes
   * of suggesting facets.
   *
   * For more details, see [our docs](https://docs.newrelic.com/docs/apis/graphql-api/tutorials/nerdgraph-graphiql-nrql-tutorial#suggest-facets).
   */
  suggestedFacets?: Maybe<Array<Maybe<NrqlFacetSuggestion>>>;
  /**
   * Suggested queries that could help explain an anomaly in your timeseries based on either statistical differences in the data or historical usage.
   *
   * If no `anomalyTimeWindow` is supplied, we will attempt to detect a spike in the NRQL results. If no spike is found, the suggested query results will be empty.
   *
   * Input NRQL must be a TIMESERIES query and must have exactly one result.
   */
  suggestedQueries?: Maybe<SuggestedNrqlQueryResponse>;
  /**
   * In a `FACET` query, the `totalResult` contains the aggregates representing _all_ the events,
   * whether or not they are contained in an individual `results` facet.
   */
  totalResult?: Maybe<Scalars['NrdbResult']['output']>;
};


/**
 * A data structure that contains the results of the NRDB query along
 * with other capabilities that enhance those results.
 *
 * Direct query results are available through `results`, `totalResult` and
 * `otherResult`. The query you made is accessible through `nrql`, along with
 * `metadata` about the query itself. Enhanced capabilities include
 * `eventDefinitions`, `suggestedFacets` and more.
 */
export type NrdbResultContainerEmbeddedChartUrlArgs = {
  chartType?: InputMaybe<EmbeddedChartType>;
};


/**
 * A data structure that contains the results of the NRDB query along
 * with other capabilities that enhance those results.
 *
 * Direct query results are available through `results`, `totalResult` and
 * `otherResult`. The query you made is accessible through `nrql`, along with
 * `metadata` about the query itself. Enhanced capabilities include
 * `eventDefinitions`, `suggestedFacets` and more.
 */
export type NrdbResultContainerStaticChartUrlArgs = {
  chartType?: InputMaybe<ChartImageType>;
  format?: InputMaybe<ChartFormatType>;
  height?: InputMaybe<Scalars['Int']['input']>;
  width?: InputMaybe<Scalars['Int']['input']>;
};


/**
 * A data structure that contains the results of the NRDB query along
 * with other capabilities that enhance those results.
 *
 * Direct query results are available through `results`, `totalResult` and
 * `otherResult`. The query you made is accessible through `nrql`, along with
 * `metadata` about the query itself. Enhanced capabilities include
 * `eventDefinitions`, `suggestedFacets` and more.
 */
export type NrdbResultContainerSuggestedQueriesArgs = {
  anomalyTimeWindow?: InputMaybe<TimeWindowInput>;
};

export type NrqlDropRulesAccountStitchedFields = {
  __typename?: 'NrqlDropRulesAccountStitchedFields';
  /** List the drop rules for the given account */
  list?: Maybe<NrqlDropRulesListDropRulesResult>;
};

/** Specifies how data matching the drop rule's NRQL string should be processed. */
export enum NrqlDropRulesAction {
  /** This action will strip the attributes specified in the SELECT clause of the NRQL string for all events that match the associated NRQL string. */
  DropAttributes = 'DROP_ATTRIBUTES',
  /** This action will strip the attributes specified in the SELECT clause of the NRQL string for metric aggregates. The event type must be Metric. */
  DropAttributesFromMetricAggregates = 'DROP_ATTRIBUTES_FROM_METRIC_AGGREGATES',
  /** This action will drop all data that match the associated NRQL string. That string MUST be a `SELECT *`. */
  DropData = 'DROP_DATA'
}

/** Error details about the rule that failed to be created and why. */
export type NrqlDropRulesCreateDropRuleFailure = {
  __typename?: 'NrqlDropRulesCreateDropRuleFailure';
  /** Information about why the create failed. */
  error: NrqlDropRulesError;
  /** Input information about a submitted rule that was unable to be created. */
  submitted: NrqlDropRulesCreateDropRuleSubmission;
};

/** Details needed to create a NRQL drop rule. */
export type NrqlDropRulesCreateDropRuleInput = {
  /** The type of drop rule you want. This changes the way your NRQL string is interpreted. */
  action: NrqlDropRulesAction;
  /** Additional information about the rule. */
  description?: InputMaybe<Scalars['String']['input']>;
  /** The NRQL string used to match data you want to take the specified action on. */
  nrql: Scalars['String']['input'];
  /** Who or what registered this rule. Defaults to 'NerdGraph' if not specified during creation. */
  source?: InputMaybe<Scalars['String']['input']>;
};

/** The result of which submitted drop rules were successfully and unsuccessfully created. */
export type NrqlDropRulesCreateDropRuleResult = {
  __typename?: 'NrqlDropRulesCreateDropRuleResult';
  /** Rules that were not created and why. */
  failures?: Maybe<Array<Maybe<NrqlDropRulesCreateDropRuleFailure>>>;
  /** Rules that were successfully created. */
  successes?: Maybe<Array<Maybe<NrqlDropRulesDropRule>>>;
};

/** The details that were submitted when creating a drop rule. */
export type NrqlDropRulesCreateDropRuleSubmission = {
  __typename?: 'NrqlDropRulesCreateDropRuleSubmission';
  /** The account the targeted data report to. */
  accountId: Scalars['Int']['output'];
  /** The type of drop rule you want. This changes the way your NRQL string is interpreted. */
  action: NrqlDropRulesAction;
  /** Additional information about the rule. */
  description?: Maybe<Scalars['String']['output']>;
  /** The NRQL string used to match data you want to take the specified action on. */
  nrql: Scalars['String']['output'];
  /** Who or what registered this rule. Defaults to 'NerdGraph' if not specified during creation. */
  source?: Maybe<Scalars['String']['output']>;
};

/** Error details about the rule that failed to be deleted and why. */
export type NrqlDropRulesDeleteDropRuleFailure = {
  __typename?: 'NrqlDropRulesDeleteDropRuleFailure';
  /** Information about why the delete failed. */
  error: NrqlDropRulesError;
  /** Input information about on what was unable to be deleted. */
  submitted: NrqlDropRulesDeleteDropRuleSubmission;
};

/** The result of which drop rules were successfully and unsuccessfully deleted. */
export type NrqlDropRulesDeleteDropRuleResult = {
  __typename?: 'NrqlDropRulesDeleteDropRuleResult';
  /** Rules that were not deleted and why. */
  failures?: Maybe<Array<Maybe<NrqlDropRulesDeleteDropRuleFailure>>>;
  /** Rules that were successfully deleted. */
  successes?: Maybe<Array<Maybe<NrqlDropRulesDropRule>>>;
};

/** The rules that were attempted to be deleted. */
export type NrqlDropRulesDeleteDropRuleSubmission = {
  __typename?: 'NrqlDropRulesDeleteDropRuleSubmission';
  /** Account the rule was created on. */
  accountId: Scalars['Int']['output'];
  /** Id of the rule you want to delete. */
  ruleId: Scalars['ID']['output'];
};

/** Details of a drop rule. */
export type NrqlDropRulesDropRule = {
  __typename?: 'NrqlDropRulesDropRule';
  /** The account this drop rule targets. */
  account?: Maybe<AccountReference>;
  /** The account this drop rule targets. */
  accountId: Scalars['Int']['output'];
  /** The behavior of the drop rule. */
  action: NrqlDropRulesAction;
  /** The time this drop rule was created. */
  createdAt: Scalars['DateTime']['output'];
  /** The id of the user that created the drop rule. */
  createdBy: Scalars['Int']['output'];
  /** The user reference of the user that created the drop rule */
  creator?: Maybe<UserReference>;
  /** Additional information about the rule. */
  description?: Maybe<Scalars['String']['output']>;
  /** The unique id for the drop rule. */
  id: Scalars['ID']['output'];
  /** The NRQL used to match data that will receive the `action`. */
  nrql: Scalars['String']['output'];
  /** Who or what registered this rule. */
  source?: Maybe<Scalars['String']['output']>;
};

/** Error details when processing drop rule requests. */
export type NrqlDropRulesError = {
  __typename?: 'NrqlDropRulesError';
  /** A detailed error message. */
  description: Scalars['String']['output'];
  /** The category of error that occurred. */
  reason: NrqlDropRulesErrorReason;
};

/** General error categories. */
export enum NrqlDropRulesErrorReason {
  /** Targeted account does not have access to this feature. */
  FeatureFlagDisabled = 'FEATURE_FLAG_DISABLED',
  /** Other errors. */
  General = 'GENERAL',
  /** Something about the request was invalid. */
  InvalidInput = 'INVALID_INPUT',
  /** The provided NRQL string was ill formed or used invalid features. */
  InvalidQuery = 'INVALID_QUERY',
  /** The drop rule being acted upon did not exist. */
  RuleNotFound = 'RULE_NOT_FOUND',
  /** The current user does not have authority to perform the given action. */
  UserNotAuthorized = 'USER_NOT_AUTHORIZED'
}

/** The result of the request to list drop rules for an account. */
export type NrqlDropRulesListDropRulesResult = {
  __typename?: 'NrqlDropRulesListDropRulesResult';
  /** Information about why we could not list rules. */
  error?: Maybe<NrqlDropRulesError>;
  /** The list of drop rules queried on the targeted account. */
  rules?: Maybe<Array<Maybe<NrqlDropRulesDropRule>>>;
};

/**
 * A suggested NRQL facet. Facet suggestions may be either a single attribute, or
 * a list of attributes in the case of multi-attribute facet suggestions.
 */
export type NrqlFacetSuggestion = {
  __typename?: 'NrqlFacetSuggestion';
  /**
   * A list of attribute names comprising the suggested facet.
   *
   * Raw attribute names will be returned here. Attribute names may need to be
   * backtick-quoted before inclusion in a NRQL query.
   */
  attributes?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
  /**
   * A modified version of the input NRQL, with a `FACET ...` clause appended.
   * If the original NRQL had a `FACET` clause already, it will be replaced.
   */
  nrql?: Maybe<Scalars['Nrql']['output']>;
};

/** An NRQL query executed in the past. */
export type NrqlHistoricalQuery = {
  __typename?: 'NrqlHistoricalQuery';
  /** The Account ID queried. */
  accountId?: Maybe<Scalars['Int']['output']>;
  /** The NRQL query executed. */
  nrql?: Maybe<Scalars['Nrql']['output']>;
  /** The time the query was executed. */
  timestamp?: Maybe<Scalars['EpochSeconds']['output']>;
};

export type NrqlLookupsAccountStitchedFields = {
  __typename?: 'NrqlLookupsAccountStitchedFields';
  /**
   * Get the REST endpoint through which the table's underlying CSV file can be managed
   * @deprecated This field is experimental and subject to breaking changes.
   */
  fileEndpoint?: Maybe<NrqlLookupsFileEndpoint>;
  /**
   * Get information about all lookup tables for the account.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  tables?: Maybe<Array<Maybe<NrqlLookupsLookupFileSummary>>>;
};


export type NrqlLookupsAccountStitchedFieldsFileEndpointArgs = {
  name: Scalars['String']['input'];
};

/** Response containing redirect URL for file uploads. */
export type NrqlLookupsFileEndpoint = {
  __typename?: 'NrqlLookupsFileEndpoint';
  /**
   * URI through which to perform the given action on the file
   * @deprecated This field is experimental and subject to breaking changes.
   */
  uri: Scalars['String']['output'];
};

/** Table Summary. Contains information about a Lookup Table */
export type NrqlLookupsLookupFileSummary = {
  __typename?: 'NrqlLookupsLookupFileSummary';
  /**
   * The account that owns the table
   * @deprecated This field is experimental and subject to breaking changes.
   */
  account?: Maybe<AccountReference>;
  /**
   * A description of the table
   * @deprecated This field is experimental and subject to breaking changes.
   */
  description?: Maybe<Scalars['String']['output']>;
  /**
   * The REST endpoint through which the table's underlying CSV file can be managed
   * @deprecated This field is experimental and subject to breaking changes.
   */
  fileEndpoint: NrqlLookupsFileEndpoint;
  /**
   * The time at which the table was most recently updated
   * @deprecated This field is experimental and subject to breaking changes.
   */
  lastUpdatedAt: Scalars['EpochMilliseconds']['output'];
  /**
   * The user that most recently updated the table
   * @deprecated This field is experimental and subject to breaking changes.
   */
  lastUpdatedBy: Scalars['String']['output'];
  /**
   * The table name
   * @deprecated This field is experimental and subject to breaking changes.
   */
  name: Scalars['String']['output'];
  /**
   * The number of rows in the table (excluding the header row)
   * @deprecated This field is experimental and subject to breaking changes.
   */
  rows: Scalars['Int']['output'];
  /**
   * The size of the uploaded CSV file represented by the table
   * @deprecated This field is experimental and subject to breaking changes.
   */
  size: Scalars['Int']['output'];
};

/** Type defined so its fields will be merged directly into NerdGraph's actor type. */
export type NrqlQueriedEntitiesActorStitchedFields = {
  __typename?: 'NrqlQueriedEntitiesActorStitchedFields';
  /** List of entities found in the NRQL query */
  query?: Maybe<NrqlQueriedEntitiesQueriedEntitiesResult>;
};


/** Type defined so its fields will be merged directly into NerdGraph's actor type. */
export type NrqlQueriedEntitiesActorStitchedFieldsQueryArgs = {
  filters?: InputMaybe<NrqlQueriedEntitiesFilters>;
  nrql: Scalars['Nrql']['input'];
};

/** Filters input */
export type NrqlQueriedEntitiesFilters = {
  /** An array of the specific accounts ids for which you want results. Null values are not allowed in the list. */
  accountIds?: InputMaybe<Array<Scalars['Int']['input']>>;
};

/** List of entities found in the NRQL query */
export type NrqlQueriedEntitiesQueriedEntitiesResult = {
  __typename?: 'NrqlQueriedEntitiesQueriedEntitiesResult';
  /** List of entities data */
  entities?: Maybe<Array<Maybe<EntityOutline>>>;
};

/** Additional options for NRQL queries. */
export type NrqlQueryOptions = {
  /**
   * Limit the NRQL query to return results from the chosen Event Namespaces.
   *
   * You must supply at least 1 valid event namespace when using this option.
   * Invalid event namespaces will be filtered out.
   *
   * If omitted, the default list will be `["Default"]`
   *
   * For more details about Event Namespaces, visit our [docs](https://docs.newrelic.com/docs/accounts/original-accounts-billing/original-product-based-pricing/introduction-new-relic-subscription-usage-data/#namespace).
   */
  eventNamespaces?: InputMaybe<Array<Scalars['String']['input']>>;
};

export type OpenAgentManagementAccountStitchedFields = {
  __typename?: 'OpenAgentManagementAccountStitchedFields';
  /**
   * Retrieves a specific agent
   * @deprecated This field is experimental and subject to breaking changes.
   */
  agent?: Maybe<OpenAgentManagementAgent>;
  /**
   * Retrieves a list of agents
   * @deprecated This field is experimental and subject to breaking changes.
   */
  agents?: Maybe<OpenAgentManagementAgents>;
  /**
   * Retrieves a specific configuration.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  configuration?: Maybe<OpenAgentManagementConfiguration>;
  /**
   * Retrieves a specific revision from a configuration.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  configurationRevision?: Maybe<OpenAgentManagementConfigurationRevision>;
  /**
   * Retrieves a set of configurations for this account. If no ids are specified, all configurations are returned.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  configurations?: Maybe<Array<Maybe<OpenAgentManagementConfiguration>>>;
  /**
   * Retrieves a specific fleet
   * @deprecated This field is experimental and subject to breaking changes.
   */
  fleet?: Maybe<OpenAgentManagementFleet>;
  /**
   * Retrieves the list of fleets
   * @deprecated This field is experimental and subject to breaking changes.
   */
  fleets?: Maybe<OpenAgentManagementFleets>;
};


export type OpenAgentManagementAccountStitchedFieldsAgentArgs = {
  agentUid: Scalars['ID']['input'];
};


export type OpenAgentManagementAccountStitchedFieldsAgentsArgs = {
  agentType?: InputMaybe<OpenAgentManagementAgentType>;
  authState?: InputMaybe<OpenAgentManagementAuthState>;
  configurationRevision?: InputMaybe<OpenAgentManagementConfigurationRevisionIdentifier>;
  cursor?: InputMaybe<Scalars['String']['input']>;
  fleetGuid?: InputMaybe<Scalars['EntityGuid']['input']>;
};


export type OpenAgentManagementAccountStitchedFieldsConfigurationArgs = {
  id: Scalars['ID']['input'];
};


export type OpenAgentManagementAccountStitchedFieldsConfigurationRevisionArgs = {
  configurationId: Scalars['ID']['input'];
  revisionNumber: Scalars['Int']['input'];
};


export type OpenAgentManagementAccountStitchedFieldsConfigurationsArgs = {
  ids?: InputMaybe<Array<Scalars['ID']['input']>>;
};


export type OpenAgentManagementAccountStitchedFieldsFleetArgs = {
  fleetGuid: Scalars['EntityGuid']['input'];
};


export type OpenAgentManagementAccountStitchedFieldsFleetsArgs = {
  configurationRevision?: InputMaybe<OpenAgentManagementConfigurationRevisionIdentifier>;
  cursor?: InputMaybe<Scalars['String']['input']>;
};

/** An agent */
export type OpenAgentManagementAgent = {
  __typename?: 'OpenAgentManagementAgent';
  /**
   * The account this agent belongs to.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  accountId?: Maybe<Scalars['Int']['output']>;
  /**
   * Auth state and last updated timestamp
   * @deprecated This field is experimental and subject to breaking changes.
   */
  authorization?: Maybe<OpenAgentManagementAuthStateLastUpdated>;
  /**
   * Timestamp indicating when the agent was created
   * @deprecated This field is experimental and subject to breaking changes.
   */
  createdAt?: Maybe<Scalars['EpochMilliseconds']['output']>;
  /**
   * The effective configurations used by the agent.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  effectiveConfigurations?: Maybe<Array<Maybe<OpenAgentManagementEffectiveConfiguration>>>;
  /**
   * The fleet this agent belongs to
   * @deprecated This field is experimental and subject to breaking changes.
   */
  fleet?: Maybe<OpenAgentManagementFleet>;
  /**
   * True if the Agent is up and healthy
   * @deprecated This field is experimental and subject to breaking changes.
   */
  healthy?: Maybe<Scalars['Boolean']['output']>;
  /**
   * The host the agent is running on
   * @deprecated This field is experimental and subject to breaking changes.
   */
  host?: Maybe<OpenAgentManagementHost>;
  /**
   * Error message returned by the agent when it is unhealthy
   * @deprecated This field is experimental and subject to breaking changes.
   */
  lastError?: Maybe<Scalars['String']['output']>;
  /**
   * Error message returned when the last remote configuration deploy is not successful
   * @deprecated This field is experimental and subject to breaking changes.
   */
  lastRemoteConfigError?: Maybe<Scalars['String']['output']>;
  /**
   * The last config hash sent by the agent
   * @deprecated This field is experimental and subject to breaking changes.
   */
  lastRemoteConfigHash?: Maybe<Scalars['String']['output']>;
  /**
   * Status of the last remote configuration deploy
   * @deprecated This field is experimental and subject to breaking changes.
   */
  lastRemoteConfigStatus?: Maybe<Scalars['String']['output']>;
  /**
   * The last time the agent connected via OpAMP
   * @deprecated This field is experimental and subject to breaking changes.
   */
  lastSeen?: Maybe<Scalars['EpochMilliseconds']['output']>;
  /**
   * The operating system the agent is running on
   * @deprecated This field is experimental and subject to breaking changes.
   */
  os?: Maybe<OpenAgentManagementOs>;
  /**
   * The configurations currently applied to this agent
   * @deprecated This field is experimental and subject to breaking changes.
   */
  remoteConfigurations?: Maybe<Array<Maybe<OpenAgentManagementConfigurationRevision>>>;
  /**
   * Timestamp indicating when the agent was started
   * @deprecated This field is experimental and subject to breaking changes.
   */
  startTime?: Maybe<Scalars['EpochMilliseconds']['output']>;
  /**
   * Type of the agent.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  type?: Maybe<OpenAgentManagementAgentType>;
  /**
   * The UID of this agent
   * @deprecated This field is experimental and subject to breaking changes.
   */
  uid?: Maybe<Scalars['ID']['output']>;
};

/** The information required to deploy a configuration revision on a specific agent */
export type OpenAgentManagementAgentDeploymentInput = {
  /** Id of the configuration. */
  configurationId: Scalars['ID']['input'];
  /** Revision number. */
  revisionNumber: Scalars['Int']['input'];
};

/** Type of the agent */
export enum OpenAgentManagementAgentType {
  /**
   * New Relic Infra Agent
   * @deprecated This field is experimental and subject to breaking changes.
   */
  NewrelicInfra = 'NEWRELIC_INFRA',
  /**
   * New Relic Super Agent
   * @deprecated This field is experimental and subject to breaking changes.
   */
  NewrelicSuper = 'NEWRELIC_SUPER',
  /**
   * OpenTelemetry Collector
   * @deprecated This field is experimental and subject to breaking changes.
   */
  OtelCollector = 'OTEL_COLLECTOR',
  /**
   * Unknown agent type
   * @deprecated This field is experimental and subject to breaking changes.
   */
  Unknown = 'UNKNOWN'
}

/** Results from the agents query */
export type OpenAgentManagementAgents = {
  __typename?: 'OpenAgentManagementAgents';
  /**
   * A cursor to pass in to get the next page of results
   * @deprecated This field is experimental and subject to breaking changes.
   */
  nextCursor?: Maybe<Scalars['String']['output']>;
  /**
   * List of agents
   * @deprecated This field is experimental and subject to breaking changes.
   */
  results?: Maybe<Array<Maybe<OpenAgentManagementAgent>>>;
  /**
   * Total number of agents
   * @deprecated This field is experimental and subject to breaking changes.
   */
  totalCount?: Maybe<Scalars['Int']['output']>;
};

/** Authorization state */
export enum OpenAgentManagementAuthState {
  /**
   * Authorized
   * @deprecated This field is experimental and subject to breaking changes.
   */
  Authorized = 'AUTHORIZED',
  /**
   * Denied
   * @deprecated This field is experimental and subject to breaking changes.
   */
  Denied = 'DENIED',
  /**
   * Unauthorized
   * @deprecated This field is experimental and subject to breaking changes.
   */
  Unauthorized = 'UNAUTHORIZED'
}

/** Auth state + last updated */
export type OpenAgentManagementAuthStateLastUpdated = {
  __typename?: 'OpenAgentManagementAuthStateLastUpdated';
  /**
   * Timestamp of the Auth state update
   * @deprecated This field is experimental and subject to breaking changes.
   */
  lastUpdated: Scalars['EpochMilliseconds']['output'];
  /**
   * Updated Auth state
   * @deprecated This field is experimental and subject to breaking changes.
   */
  state: OpenAgentManagementAuthState;
};

/** An agent configuration */
export type OpenAgentManagementConfiguration = {
  __typename?: 'OpenAgentManagementConfiguration';
  /**
   * The account this configuration belongs to.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  accountId?: Maybe<Scalars['Int']['output']>;
  /**
   * Timestamp indicating when the configuration was created
   * @deprecated This field is experimental and subject to breaking changes.
   */
  createdAt?: Maybe<Scalars['EpochMilliseconds']['output']>;
  /**
   * The unique id of this configuration.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  id?: Maybe<Scalars['ID']['output']>;
  /**
   * The latest revision that was created for this configuration. Null if no revision exists.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  latestRevision?: Maybe<OpenAgentManagementConfigurationRevision>;
  /**
   * The unique name of this configuration.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  name?: Maybe<Scalars['String']['output']>;
  /**
   * A list of revisions for this configuration.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  revisionNumbers?: Maybe<Array<Maybe<Scalars['Int']['output']>>>;
};

/** A configuration file for an agent */
export type OpenAgentManagementConfigurationInput = {
  /** Unique name of this configuration. */
  name: Scalars['String']['input'];
};

/** A revision for a configuration. */
export type OpenAgentManagementConfigurationRevision = {
  __typename?: 'OpenAgentManagementConfigurationRevision';
  /**
   * The id of the configuration this revision belongs to.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  configurationId?: Maybe<Scalars['ID']['output']>;
  /**
   * The name of the configuration this revision belongs to.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  configurationName?: Maybe<Scalars['String']['output']>;
  /**
   * The content of the configuration file. For the OTEL collector, this would be the content of the yaml file.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  content?: Maybe<Scalars['String']['output']>;
  /**
   * The content type of this file, e.g. 'text/yaml'.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  contentType?: Maybe<OpenAgentManagementContentType>;
  /**
   * Timestamp indicating when the configuration revision was created
   * @deprecated This field is experimental and subject to breaking changes.
   */
  createdAt?: Maybe<Scalars['EpochMilliseconds']['output']>;
  /**
   * The sequence number of this revision
   * @deprecated This field is experimental and subject to breaking changes.
   */
  revisionNumber?: Maybe<Scalars['Int']['output']>;
};

/** A unique identifier for a configuration revision */
export type OpenAgentManagementConfigurationRevisionIdentifier = {
  /** Unique identifier for the configuration. */
  configurationId: Scalars['ID']['input'];
  /** The revision number */
  revisionNumber: Scalars['Int']['input'];
};

/** A revision for a given configuration */
export type OpenAgentManagementConfigurationRevisionInput = {
  /** Unique identifier for the configuration. */
  configurationId: Scalars['ID']['input'];
  /** The content of the configuration file. For the OTEL collector, this would be the content of the yaml file. */
  content: Scalars['String']['input'];
  /** The content type of this file, e.g. 'text/yaml'. */
  contentType?: InputMaybe<OpenAgentManagementContentType>;
};

/** The content type of a configuration file */
export enum OpenAgentManagementContentType {
  /**
   * the text/yaml mime type
   * @deprecated This field is experimental and subject to breaking changes.
   */
  Yaml = 'YAML'
}

/** The result returned when deleting a configuration */
export type OpenAgentManagementDeleteConfigurationResult = {
  __typename?: 'OpenAgentManagementDeleteConfigurationResult';
  /**
   * The if of the deleted configuration
   * @deprecated This field is experimental and subject to breaking changes.
   */
  id?: Maybe<Scalars['ID']['output']>;
};

/** The result returned when deleting a revision */
export type OpenAgentManagementDeleteConfigurationRevisionResult = {
  __typename?: 'OpenAgentManagementDeleteConfigurationRevisionResult';
  /**
   * The id of the configuration this revision belonged to
   * @deprecated This field is experimental and subject to breaking changes.
   */
  configurationId?: Maybe<Scalars['ID']['output']>;
  /**
   * The revision number of the deleted revision
   * @deprecated This field is experimental and subject to breaking changes.
   */
  revisionNumber?: Maybe<Scalars['Int']['output']>;
};

/** Result of deleting a fleet */
export type OpenAgentManagementDeleteFleetResult = {
  __typename?: 'OpenAgentManagementDeleteFleetResult';
  /**
   * The fleet entityGuid
   * @deprecated This field is experimental and subject to breaking changes.
   */
  fleetGuid: Scalars['EntityGuid']['output'];
};

/** The result returned when setting a configuration */
export type OpenAgentManagementDeployAgentConfigurationRevisionsResult = {
  __typename?: 'OpenAgentManagementDeployAgentConfigurationRevisionsResult';
  /**
   * The uid of the agent to which the configurations were deployed
   * @deprecated This field is experimental and subject to breaking changes.
   */
  agentUid?: Maybe<Scalars['ID']['output']>;
};

/** The result returned when deploying a configuration to a fleet */
export type OpenAgentManagementDeployFleetConfigurationRevisionsResult = {
  __typename?: 'OpenAgentManagementDeployFleetConfigurationRevisionsResult';
  /**
   * The fleet entityGuid
   * @deprecated This field is experimental and subject to breaking changes.
   */
  fleetGuid: Scalars['EntityGuid']['output'];
};

/** The effective configuration */
export type OpenAgentManagementEffectiveConfiguration = {
  __typename?: 'OpenAgentManagementEffectiveConfiguration';
  /**
   * The content of the configuration
   * @deprecated This field is experimental and subject to breaking changes.
   */
  content?: Maybe<Scalars['String']['output']>;
  /**
   * The content type of the configuration
   * @deprecated This field is experimental and subject to breaking changes.
   */
  contentType?: Maybe<Scalars['String']['output']>;
  /**
   * The configuration file name
   * @deprecated This field is experimental and subject to breaking changes.
   */
  name?: Maybe<Scalars['String']['output']>;
};

/** A fleet of agents. */
export type OpenAgentManagementFleet = {
  __typename?: 'OpenAgentManagementFleet';
  /**
   * Type of agents in this fleet. TODO should be a string (not an enum).
   * @deprecated This field is experimental and subject to breaking changes.
   */
  agentType: OpenAgentManagementAgentType;
  /**
   * The fleet entityGuid
   * @deprecated This field is experimental and subject to breaking changes.
   */
  fleetGuid: Scalars['EntityGuid']['output'];
  /**
   * Name of the fleet
   * @deprecated This field is experimental and subject to breaking changes.
   */
  name: Scalars['String']['output'];
  /**
   * The configurations currently applied to all agents in this fleet
   * @deprecated This field is experimental and subject to breaking changes.
   */
  remoteConfigurations?: Maybe<Array<Maybe<OpenAgentManagementConfigurationRevision>>>;
};

/** The information required to deploy a configuration revision on a fleet */
export type OpenAgentManagementFleetDeploymentInput = {
  /** Id of the configuration. */
  configurationId: Scalars['ID']['input'];
  /** Revision number. */
  revisionNumber: Scalars['Int']['input'];
};

/** Results from the fleets query */
export type OpenAgentManagementFleets = {
  __typename?: 'OpenAgentManagementFleets';
  /**
   * A cursor to pass in to get the next page of results
   * @deprecated This field is experimental and subject to breaking changes.
   */
  nextCursor?: Maybe<Scalars['String']['output']>;
  /**
   * List of fleets
   * @deprecated This field is experimental and subject to breaking changes.
   */
  results?: Maybe<Array<Maybe<OpenAgentManagementFleet>>>;
  /**
   * Total number of fleets`
   * @deprecated This field is experimental and subject to breaking changes.
   */
  totalCount?: Maybe<Scalars['Int']['output']>;
};

/** A host an agent is running on. */
export type OpenAgentManagementHost = {
  __typename?: 'OpenAgentManagementHost';
  /**
   * The CPU architecture the host system is running on.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  arch?: Maybe<Scalars['String']['output']>;
  /**
   * Unique host ID. For Cloud, this is the instance_id assigned by the cloud provider. For non-containerized systems, this is the machine-id. Prefixed with host to avoid conflicts with GraphQL caching schemes, as uniqueness is not guaranteed.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  hostId?: Maybe<Scalars['String']['output']>;
  /**
   * Name of the host. On Unix systems, it may contain what the hostname command returns, or the fully qualified hostname, or another name specified by the user.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  name?: Maybe<Scalars['String']['output']>;
  /**
   * Type of host. For Cloud, this must be the machine type.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  type?: Maybe<Scalars['String']['output']>;
};

/** The result returned when moving an agent to a fleet */
export type OpenAgentManagementMoveAgentToFleetResult = {
  __typename?: 'OpenAgentManagementMoveAgentToFleetResult';
  /**
   * The UID of the agent
   * @deprecated This field is experimental and subject to breaking changes.
   */
  agentUid?: Maybe<Scalars['ID']['output']>;
  /**
   * The fleet entityGuid
   * @deprecated This field is experimental and subject to breaking changes.
   */
  fleetGuid: Scalars['EntityGuid']['output'];
};

/** The Operating System the agent is running on. */
export type OpenAgentManagementOs = {
  __typename?: 'OpenAgentManagementOs';
  /**
   * Human readable operating system name (e.g. Ubuntu, Android).
   * @deprecated This field is experimental and subject to breaking changes.
   */
  name?: Maybe<Scalars['String']['output']>;
  /**
   * The operating system type (e.g. windows, linux).
   * @deprecated This field is experimental and subject to breaking changes.
   */
  type?: Maybe<Scalars['String']['output']>;
  /**
   * The version string of the operating system.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  version?: Maybe<Scalars['String']['output']>;
};

/** Result of setting auth state */
export type OpenAgentManagementSetAgentAuthStateResult = {
  __typename?: 'OpenAgentManagementSetAgentAuthStateResult';
  /**
   * Agent UID
   * @deprecated This field is experimental and subject to breaking changes.
   */
  agentUid: Scalars['ID']['output'];
  /**
   * Timestamp of the Auth state update
   * @deprecated This field is experimental and subject to breaking changes.
   */
  lastUpdated: Scalars['EpochMilliseconds']['output'];
  /**
   * Updated Auth state
   * @deprecated This field is experimental and subject to breaking changes.
   */
  state: OpenAgentManagementAuthState;
};

/** The `Organization` object provides basic data about an organization. */
export type Organization = {
  __typename?: 'Organization';
  /** This field provides access to AccountManagement data. */
  accountManagement?: Maybe<AccountManagementOrganizationStitchedFields>;
  /** This field provides access to AccountShareInvitations data. */
  accountShareInvitations?: Maybe<AccountShareInvitationsOrganizationStitchedFields>;
  /** Namespace for querying and filtering the actor's organization's shared accounts */
  accountShares?: Maybe<OrganizationAccountShares>;
  /** The organization's administrator */
  administrator?: Maybe<OrganizationOrganizationAdministrator>;
  /** This field provides access to AuthorizationManagement data. */
  authorizationManagement?: Maybe<AuthorizationManagementOrganizationStitchedFields>;
  /** The billing structure for the organization */
  billingStructure?: Maybe<OrganizationBillingStructure>;
  /** The customer id for the organization. */
  customerId?: Maybe<Scalars['String']['output']>;
  /**
   * This field provides access to DomainManagement data.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  domainManagement?: Maybe<DomainManagementOrganizationStitchedFields>;
  /** The ID of the organization. */
  id?: Maybe<Scalars['ID']['output']>;
  /** This field provides access to Invitations data. */
  invitations?: Maybe<InvitationsOrganizationStitchedFields>;
  /** The name of the organization. */
  name?: Maybe<Scalars['String']['output']>;
  /** This field provides access to ProductRating data. */
  productRating?: Maybe<ProductRatingOrganizationStitchedFields>;
  /** This field provides access to Team data. */
  team?: Maybe<TeamOrganizationStitchedFields>;
  /** The telemetry id for the organization */
  telemetryId?: Maybe<Scalars['String']['output']>;
  /** This field provides access to UserConsumption data. */
  userConsumption?: Maybe<UserConsumptionOrganizationStitchedFields>;
  /** This field provides access to UserManagement data. */
  userManagement?: Maybe<UserManagementOrganizationStitchedFields>;
  /** This field provides access to UsersCount data. */
  usersCount?: Maybe<UsersCountOrganizationStitchedFields>;
};


/** The `Organization` object provides basic data about an organization. */
export type OrganizationAccountSharesArgs = {
  limitingRoleId?: InputMaybe<Scalars['Int']['input']>;
  sourceOrganizationId?: InputMaybe<Scalars['ID']['input']>;
  targetOrganizationId?: InputMaybe<Scalars['ID']['input']>;
};

/** The account type contains the properties of an account */
export type OrganizationAccount = {
  __typename?: 'OrganizationAccount';
  /** The account id */
  id: Scalars['Int']['output'];
  /** The account name */
  name: Scalars['String']['output'];
  /** The account region code */
  regionCode: Scalars['String']['output'];
  /** The status */
  status: Scalars['String']['output'];
};

/** Accounts */
export type OrganizationAccountCollection = {
  __typename?: 'OrganizationAccountCollection';
  /** Accounts */
  items?: Maybe<Array<OrganizationAccount>>;
  /** an opaque cursor to supply with subsequent requests to get the next page of results, null if there are no more pages */
  nextCursor?: Maybe<Scalars['String']['output']>;
  /** the total number of results */
  totalCount: Scalars['Int']['output'];
};

/** A filter for Accounts */
export type OrganizationAccountFilterInput = {
  /** Filter by account ID */
  id?: InputMaybe<OrganizationAccountIdFilterInput>;
  /** Filter by Account Name */
  name?: InputMaybe<OrganizationAccountNameFilterInput>;
  /** Filter by organization ID */
  organizationId: OrganizationAccountOrganizationIdFilterInput;
  /** Filter by Sharing Mode */
  sharingMode?: InputMaybe<OrganizationAccountSharingModeFilterInput>;
  /** Filter by an account status. By default filters to active accounts. */
  status?: InputMaybe<OrganizationAccountStatusFilterInput>;
};

/** A filter for an AccountID */
export type OrganizationAccountIdFilterInput = {
  /** An Account ID */
  eq?: InputMaybe<Scalars['Int']['input']>;
};

/** Provides the operations available on the account id */
export type OrganizationAccountIdInput = {
  /** An account id */
  eq: Scalars['Int']['input'];
};

/** A filter for Account name */
export type OrganizationAccountNameFilterInput = {
  /** Search text for an account name */
  contains?: InputMaybe<Scalars['String']['input']>;
};

/** A filter for OrganizationID */
export type OrganizationAccountOrganizationIdFilterInput = {
  /** An Organization ID */
  eq: Scalars['ID']['input'];
};

/** An account share */
export type OrganizationAccountShare = {
  __typename?: 'OrganizationAccountShare';
  /** The ID of the account being shared */
  accountId: Scalars['Int']['output'];
  /** The account share ID */
  id: Scalars['ID']['output'];
  /** The limiting role */
  limitingRole: OrganizationAccountShareLimitingRoleWrapper;
  /** The name of the account share */
  name: Scalars['String']['output'];
  /** The organization sending the account share. */
  source: OrganizationAccountShareOrganizationWrapper;
  /** The organization receiving the account share. */
  target: OrganizationAccountShareOrganizationWrapper;
};

/** An organization's shared accounts, both given and received. */
export type OrganizationAccountShareCollection = {
  __typename?: 'OrganizationAccountShareCollection';
  /** An organization's shared accounts, both given and received. */
  items?: Maybe<Array<OrganizationAccountShare>>;
  /** an opaque cursor to supply with subsequent requests to get the next page of results, null if there are no more pages */
  nextCursor?: Maybe<Scalars['String']['output']>;
};

/** A filter for account shares */
export type OrganizationAccountShareFilterInput = {
  /** Filter by account id */
  accountId: OrganizationAccountIdInput;
  /** Filter by target id */
  targetId?: InputMaybe<OrganizationTargetIdInput>;
};

/** An account share's limiting role */
export type OrganizationAccountShareLimitingRoleWrapper = {
  __typename?: 'OrganizationAccountShareLimitingRoleWrapper';
  /** id */
  id: Scalars['ID']['output'];
};

/** An account share's source or target organization */
export type OrganizationAccountShareOrganizationWrapper = {
  __typename?: 'OrganizationAccountShareOrganizationWrapper';
  /** id */
  id?: Maybe<Scalars['ID']['output']>;
  /** name */
  name?: Maybe<Scalars['String']['output']>;
};

/** Provides the available values of possible directions to sort the result */
export enum OrganizationAccountShareSortDirectionEnum {
  /** Sort in ascending order */
  Ascending = 'ASCENDING',
  /** Sort in descending order */
  Descending = 'DESCENDING'
}

/** Sort key and direction for account shares */
export type OrganizationAccountShareSortInput = {
  /** Direction to sort in */
  direction?: InputMaybe<OrganizationAccountShareSortDirectionEnum>;
  /** Account share attribute to sort on */
  key?: InputMaybe<OrganizationAccountShareSortKeyEnum>;
};

/** Provides the available values of possible fields that can be sorted */
export enum OrganizationAccountShareSortKeyEnum {
  /** Account id */
  AccountId = 'ACCOUNT_ID',
  /** Name of the target organization the account is shared with */
  TargetOrganizationName = 'TARGET_ORGANIZATION_NAME'
}

/** An organization's shared accounts, both given and received. */
export type OrganizationAccountShares = {
  __typename?: 'OrganizationAccountShares';
  /** An organization's shared accounts, both given and received. */
  sharedAccounts?: Maybe<Array<OrganizationSharedAccount>>;
};

/** A filter for Sharing Mode */
export type OrganizationAccountSharingModeFilterInput = {
  /** A Sharing Mode for the account. */
  eq?: InputMaybe<OrganizationSharingMode>;
};

/** Provides the available values of possible directions to sort the result */
export enum OrganizationAccountSortDirectionEnum {
  /** Sort in ascending order */
  Ascending = 'ASCENDING',
  /** Sort in descending order */
  Descending = 'DESCENDING'
}

/** Sort key and direction for accounts */
export type OrganizationAccountSortInput = {
  /** Direction to sort in */
  direction?: InputMaybe<OrganizationAccountSortDirectionEnum>;
  /** Account share attribute to sort on */
  key?: InputMaybe<OrganizationAccountSortKeyEnum>;
};

/** Provides the available values of possible fields that can be sorted */
export enum OrganizationAccountSortKeyEnum {
  /** Account ID */
  Id = 'ID',
  /** Account Name */
  Name = 'NAME'
}

/** Provides the types of account statuses available */
export enum OrganizationAccountStatus {
  /** Accounts that are not in canceled status */
  Active = 'ACTIVE',
  /** Accounts that have been canceled */
  Canceled = 'CANCELED'
}

/** A filter for Account Status */
export type OrganizationAccountStatusFilterInput = {
  /** An account status */
  eq?: InputMaybe<OrganizationAccountStatus>;
};

/** A grouping of users governed by the same user management settings */
export type OrganizationAuthenticationDomain = {
  __typename?: 'OrganizationAuthenticationDomain';
  /** Method of authenticating users */
  authenticationType: OrganizationAuthenticationTypeEnum;
  /** The authentication domain id */
  id: Scalars['ID']['output'];
  /** List of user attributes managed in identity provider */
  idpManagedAttributes: Array<OrganizationIdpManagedAttributesTypeEnum>;
  /** The authentication domain name */
  name: Scalars['String']['output'];
  /** The organization the authentication domain belongs to */
  organizationId: Scalars['ID']['output'];
  /** Method of provisioning users */
  provisioningType: OrganizationProvisioningTypeEnum;
};

/** Authentication domains */
export type OrganizationAuthenticationDomainCollection = {
  __typename?: 'OrganizationAuthenticationDomainCollection';
  /** Authentication domains */
  items: Array<OrganizationAuthenticationDomain>;
  /** an opaque cursor to supply with subsequent requests to get the next page of results, null if there are no more pages */
  nextCursor?: Maybe<Scalars['String']['output']>;
};

/** A filter for authentication domains */
export type OrganizationAuthenticationDomainFilterInput = {
  /** Filter authentication domains by id */
  id?: InputMaybe<OrganizationIdInput>;
  /** Filter authentication domains by name */
  name?: InputMaybe<OrganizationNameInput>;
  /** Filter authentication domains by organization */
  organizationId: OrganizationOrganizationIdInput;
};

/** Sort key and direction for authentication domains */
export type OrganizationAuthenticationDomainSortInput = {
  /** Direction to sort in */
  direction?: InputMaybe<OrganizationSortDirectionEnum>;
  /** Authentication domain attribute to sort on */
  key?: InputMaybe<OrganizationSortKeyEnum>;
};

/** Provides the available values for authentication type */
export enum OrganizationAuthenticationTypeEnum {
  /** Authentication not configured */
  Disabled = 'DISABLED',
  /** Heroku Single Sign-On */
  HerokuSso = 'HEROKU_SSO',
  /** Oidc Single Sign-On */
  OidcSso = 'OIDC_SSO',
  /** Username and password authentication */
  Password = 'PASSWORD',
  /** SAML Single Sign-On */
  SamlSso = 'SAML_SSO'
}

/** Valid billing structure values */
export enum OrganizationBillingStructure {
  /** Account Hierarchy */
  AccountHierarchy = 'ACCOUNT_HIERARCHY',
  /** Customer Contract */
  CustomerContract = 'CUSTOMER_CONTRACT',
  /** Unstructured */
  Unstructured = 'UNSTRUCTURED'
}

/** Provides all the available filters on the customer id */
export type OrganizationContractCustomerIdInputFilter = {
  /** performs an equals operation */
  eq: Scalars['String']['input'];
};

/** Provides all the available filters on the organization id */
export type OrganizationContractOrganizationIdInputFilter = {
  /** performs an equals operation */
  eq: Scalars['ID']['input'];
};

/** Attributes belonging to the organization to create. */
export type OrganizationCreateOrganizationInput = {
  /** The name for the new organization. */
  name: Scalars['String']['input'];
};

/** The object that's returned from successfully creating an organization. */
export type OrganizationCreateOrganizationResponse = {
  __typename?: 'OrganizationCreateOrganizationResponse';
  /** The job id of the organization creation task; query this job id to get latest state */
  jobId: Scalars['String']['output'];
};

/** Attributes for creating a shared account. */
export type OrganizationCreateSharedAccountInput = {
  /** The id of the account to be shared */
  accountId: Scalars['Int']['input'];
  /** The id of the limiting role */
  limitingRoleId: Scalars['Int']['input'];
  /** The name of the shared account */
  name?: InputMaybe<Scalars['String']['input']>;
  /** The id of the target organization */
  targetOrganizationId: Scalars['ID']['input'];
};

/** The object that's returned from successfully creating a shared account. */
export type OrganizationCreateSharedAccountResponse = {
  __typename?: 'OrganizationCreateSharedAccountResponse';
  /** The created shared account. */
  sharedAccount?: Maybe<OrganizationSharedAccount>;
};

/** A customer */
export type OrganizationCustomerContract = {
  __typename?: 'OrganizationCustomerContract';
  /** The customer contract''s billing structure */
  billingStructure?: Maybe<OrganizationBillingStructure>;
  /** The customers id */
  customerId: Scalars['String']['output'];
  /** The customer contracts ID */
  id: Scalars['ID']['output'];
  /** The customer contracts organization groups */
  organizationGroups: OrganizationOrganizationGroupWrapper;
  /** The customer contracts''s telemetry id */
  telemetryId?: Maybe<Scalars['String']['output']>;
};


/** A customer */
export type OrganizationCustomerContractOrganizationGroupsArgs = {
  cursor?: InputMaybe<Scalars['String']['input']>;
  filter?: InputMaybe<OrganizationOrganizationGroupFilterInput>;
};

/** A filter for customer contracts */
export type OrganizationCustomerContractFilterInput = {
  /** The id of the customer */
  customerId?: InputMaybe<OrganizationContractCustomerIdInputFilter>;
  /** The id of the organization */
  organizationId?: InputMaybe<OrganizationContractOrganizationIdInputFilter>;
};

/** Accessible customers */
export type OrganizationCustomerContractWrapper = {
  __typename?: 'OrganizationCustomerContractWrapper';
  /** Accessible customers */
  items: Array<OrganizationCustomerContract>;
  /** an opaque cursor to supply with subsequent requests to get the next page of results, null if there are no more pages */
  nextCursor?: Maybe<Scalars['String']['output']>;
};

/** A customer organization */
export type OrganizationCustomerOrganization = {
  __typename?: 'OrganizationCustomerOrganization';
  /** The ID of the organization group */
  contractId?: Maybe<Scalars['ID']['output']>;
  /** The ID of the customer */
  customerId?: Maybe<Scalars['String']['output']>;
  /** The ID of the organization */
  id: Scalars['ID']['output'];
  /** The name of the organization */
  name?: Maybe<Scalars['String']['output']>;
  /** The ID of the organization group */
  organizationGroupId?: Maybe<Scalars['ID']['output']>;
};

/** A filter for customer organizations */
export type OrganizationCustomerOrganizationFilterInput = {
  /** The id of the owned account */
  accountId?: InputMaybe<OrganizationOrganizationAccountIdInputFilter>;
  /** The id of the authentication domain */
  authenticationDomainId?: InputMaybe<OrganizationOrganizationAuthenticationDomainIdInputFilter>;
  /** The id of the customer */
  customerId?: InputMaybe<OrganizationOrganizationCustomerIdInputFilter>;
  /** The id of the organization */
  id?: InputMaybe<OrganizationOrganizationIdInputFilter>;
  /** The name of the organization */
  name?: InputMaybe<OrganizationOrganizationNameInputFilter>;
};

/** A customer organization */
export type OrganizationCustomerOrganizationWrapper = {
  __typename?: 'OrganizationCustomerOrganizationWrapper';
  /** Accessible customers */
  items: Array<OrganizationCustomerOrganization>;
  /** an opaque cursor to supply with subsequent requests to get the next page of results, null if there are no more pages */
  nextCursor?: Maybe<Scalars['String']['output']>;
};

/** A user-readable error */
export type OrganizationError = {
  __typename?: 'OrganizationError';
  /** A description of the error. */
  message: Scalars['String']['output'];
  /** A description of the type of error. */
  type: OrganizationUpdateErrorType;
};

/** Provides the operations available on the id */
export type OrganizationIdInput = {
  /** An authentication domain id */
  eq: Scalars['ID']['input'];
};

/** The user attributes that can be managed with SCIM */
export enum OrganizationIdpManagedAttributesTypeEnum {
  /** User type managed by SCIM nrUserType attribute */
  UserTierId = 'USER_TIER_ID'
}

/** The attributes of an organization. */
export type OrganizationInformation = {
  __typename?: 'OrganizationInformation';
  /** The ID of the organization. */
  id: Scalars['String']['output'];
  /** The name of the organization. */
  name: Scalars['String']['output'];
};

/** Provides the operations available on the name */
export type OrganizationNameInput = {
  /** Part of an authentication domain name */
  contains?: InputMaybe<Scalars['String']['input']>;
  /** An authentication domain name */
  eq?: InputMaybe<Scalars['String']['input']>;
};

/** Attributes for creating a new managed account. */
export type OrganizationNewManagedAccountInput = {
  /** The name of the new account to be created. */
  name?: InputMaybe<Scalars['String']['input']>;
  /** The region-code for the account to be created. */
  regionCode?: InputMaybe<OrganizationRegionCodeEnum>;
};

/** Provides all the available filters on the account id */
export type OrganizationOrganizationAccountIdInputFilter = {
  /** performs an equals operation */
  eq: Scalars['Int']['input'];
};

/** The organization's administrator */
export type OrganizationOrganizationAdministrator = {
  __typename?: 'OrganizationOrganizationAdministrator';
  /** The organization id of the organization's administrator */
  organizationId?: Maybe<Scalars['ID']['output']>;
  /** The organization name of the organization's administrator */
  organizationName?: Maybe<Scalars['String']['output']>;
};

/** Provides all the available filters on the authentication domain id */
export type OrganizationOrganizationAuthenticationDomainIdInputFilter = {
  /** performs an equals operation */
  eq: Scalars['ID']['input'];
};

/** An async organization creation result customer */
export type OrganizationOrganizationCreateAsyncCustomerResult = {
  __typename?: 'OrganizationOrganizationCreateAsyncCustomerResult';
  /** The customer ID */
  customerId?: Maybe<Scalars['String']['output']>;
};

/** An async organization creation job result */
export type OrganizationOrganizationCreateAsyncJobResult = {
  __typename?: 'OrganizationOrganizationCreateAsyncJobResult';
  /** The date and time the job was created in UTC */
  createdUtc: Scalars['String']['output'];
  /** The error message in case of job failure */
  errorMessage?: Maybe<Scalars['String']['output']>;
  /** The date and time the job was completed in UTC */
  finishedUtc?: Maybe<Scalars['String']['output']>;
  /** The id of the job */
  id: Scalars['ID']['output'];
  /** The status of the job */
  status: OrganizationOrganizationCreateJobResultStatusEnum;
};

/** An async organization creation result organization */
export type OrganizationOrganizationCreateAsyncOrganizationResult = {
  __typename?: 'OrganizationOrganizationCreateAsyncOrganizationResult';
  /** Organization ID */
  id?: Maybe<Scalars['ID']['output']>;
  /** Organization name */
  name?: Maybe<Scalars['String']['output']>;
};

/** An async organization creation result */
export type OrganizationOrganizationCreateAsyncResult = {
  __typename?: 'OrganizationOrganizationCreateAsyncResult';
  /** Organization Creation Async Job Customer */
  customer?: Maybe<OrganizationOrganizationCreateAsyncCustomerResult>;
  /** Organization Creation Async Job Result */
  job: OrganizationOrganizationCreateAsyncJobResult;
  /** Organization Creation Async Job Organization */
  organization?: Maybe<OrganizationOrganizationCreateAsyncOrganizationResult>;
};

/** Organization create async result collection */
export type OrganizationOrganizationCreateAsyncResultCollection = {
  __typename?: 'OrganizationOrganizationCreateAsyncResultCollection';
  /** Organization create async results */
  items: Array<OrganizationOrganizationCreateAsyncResult>;
  /** an opaque cursor to supply with subsequent requests to get the next page of results, null if there are no more pages */
  nextCursor?: Maybe<Scalars['String']['output']>;
};

/** A filter for organization create job results */
export type OrganizationOrganizationCreateAsyncResultFilterInput = {
  /** Filter organization create job results by customer ID */
  customerId?: InputMaybe<OrganizationOrganizationCreateJobCustomerIdInput>;
  /** Filter oganization create job results by id */
  jobId?: InputMaybe<OrganizationOrganizationCreateJobIdInput>;
  /** Filter organization create job results by status */
  status?: InputMaybe<OrganizationOrganizationCreateJobStatusInput>;
};

/** The customer id search for jobs */
export type OrganizationOrganizationCreateJobCustomerIdInput = {
  /** A customer id to search for jobs in */
  eq: Scalars['String']['input'];
};

/** The id of the job to retrieve */
export type OrganizationOrganizationCreateJobIdInput = {
  /** An organization create job id */
  eq?: InputMaybe<Scalars['ID']['input']>;
  /** A set of job ids to search for */
  in?: InputMaybe<Array<Scalars['ID']['input']>>;
};

/** The possible status values for job results */
export enum OrganizationOrganizationCreateJobResultStatusEnum {
  /** Jobs that have been created but not yet started running */
  Created = 'CREATED',
  /** Jobs that have failed and stopped running */
  Failed = 'FAILED',
  /** Jobs that are still running */
  Running = 'RUNNING',
  /** Jobs that completed successfully */
  Succeeded = 'SUCCEEDED'
}

/** The list of valid job statuses to search for */
export enum OrganizationOrganizationCreateJobStatusEnum {
  /** All jobs regardless of status */
  All = 'ALL',
  /** Jobs that have been created but not yet started running */
  Created = 'CREATED',
  /** Jobs that have failed and stopped running */
  Failed = 'FAILED',
  /** Jobs that are still running */
  Running = 'RUNNING',
  /** Jobs that completed successfully */
  Succeeded = 'SUCCEEDED'
}

/** The status of the jobs to search for */
export type OrganizationOrganizationCreateJobStatusInput = {
  /** a job status to search for */
  eq?: InputMaybe<OrganizationOrganizationCreateJobStatusEnum>;
  /** a set of job statuses to search for */
  in?: InputMaybe<Array<OrganizationOrganizationCreateJobStatusEnum>>;
};

/** Provides all the available filters on the customer id */
export type OrganizationOrganizationCustomerIdInputFilter = {
  /** performs an equals operation */
  eq: Scalars['String']['input'];
};

/** A customers organization group */
export type OrganizationOrganizationGroup = {
  __typename?: 'OrganizationOrganizationGroup';
  /** The ID of the organization group */
  id: Scalars['ID']['output'];
  /** The name of the organization group */
  name: Scalars['String']['output'];
};

/** A filter for organization groups */
export type OrganizationOrganizationGroupFilterInput = {
  /** The id of the organization group */
  id?: InputMaybe<OrganizationOrganizationGroupIdInputFilter>;
  /** The name of the organization group */
  name?: InputMaybe<OrganizationOrganizationGroupNameInputFilter>;
  /** The ID of the organization */
  organizationId?: InputMaybe<OrganizationOrganizationGroupOrganizationIdInputFilter>;
};

/** Provides all the available filters on the organization group id */
export type OrganizationOrganizationGroupIdInputFilter = {
  /** performs an equals operation */
  eq: Scalars['ID']['input'];
};

/** Provides all the available filters on the organization group name */
export type OrganizationOrganizationGroupNameInputFilter = {
  /** performs a contains operation */
  contains?: InputMaybe<Scalars['String']['input']>;
  /** performs an equals operation */
  eq?: InputMaybe<Scalars['String']['input']>;
};

/** Provides all the available filters on the organization group organization id */
export type OrganizationOrganizationGroupOrganizationIdInputFilter = {
  /** performs an equals operation */
  eq: Scalars['ID']['input'];
};

/** A customers organization groups */
export type OrganizationOrganizationGroupWrapper = {
  __typename?: 'OrganizationOrganizationGroupWrapper';
  /** A customers organization groups */
  items?: Maybe<Array<OrganizationOrganizationGroup>>;
  /** an opaque cursor to supply with subsequent requests to get the next page of results, null if there are no more pages */
  nextCursor?: Maybe<Scalars['String']['output']>;
};

/** Provides the operations available on the organization id */
export type OrganizationOrganizationIdInput = {
  /** An organization id */
  eq: Scalars['ID']['input'];
};

/** Provides all the available filters on the organization id */
export type OrganizationOrganizationIdInputFilter = {
  /** performs an equals operation */
  eq: Scalars['ID']['input'];
};

/** Provides all the available filters on the organization name */
export type OrganizationOrganizationNameInputFilter = {
  /** performs a contains operation */
  contains?: InputMaybe<Scalars['String']['input']>;
  /** performs an equals operation */
  eq?: InputMaybe<Scalars['String']['input']>;
};

/** A product. */
export type OrganizationProvisioningProductInput = {
  /** Unique id for Product */
  id: Scalars['Int']['input'];
  /** Product name */
  name?: InputMaybe<Scalars['String']['input']>;
  /** An array of unit and quantity for a product */
  unitsOfMeasure?: InputMaybe<Array<OrganizationProvisioningUnitOfMeasureInput>>;
};

/** Provides the available values for provisioning type */
export enum OrganizationProvisioningTypeEnum {
  /** Provisioning not configured */
  Disabled = 'DISABLED',
  /** Manual provisioning */
  Manual = 'MANUAL',
  /** SCIM automated provisioning */
  Scim = 'SCIM'
}

/** Types of units for entitlements */
export enum OrganizationProvisioningUnit {
  /** Additional days of data retention */
  AdditionalDaysOfRetention = 'ADDITIONAL_DAYS_OF_RETENTION',
  /** Mobile unit of measure of the number of mobile applications */
  Apps = 'APPS',
  /** Proactive Detection unit of measure */
  AppTransactionsInMillions = 'APP_TRANSACTIONS_IN_MILLIONS',
  /** Synthetics unit of measure */
  Checks = 'CHECKS',
  /** APM unit of measure of the number of compute units */
  ComputeUnit = 'COMPUTE_UNIT',
  /** The time that we retain data in days */
  DataRetentionInDays = 'DATA_RETENTION_IN_DAYS',
  /** Metrics unit of measure */
  Dpm = 'DPM',
  /** Insight events in multiples of millions */
  EventsInMillions = 'EVENTS_IN_MILLIONS',
  /** NR1 Data unit of measure */
  GbIngested = 'GB_INGESTED',
  /** Logs unit of measure */
  GbPerDay = 'GB_PER_DAY',
  /** Grace period in days before customer is billed for users */
  GracePeriod = 'GRACE_PERIOD',
  /** APM unit of measure for hosts */
  Hosts = 'HOSTS',
  /** AI unit of measure */
  IncidentEvents = 'INCIDENT_EVENTS',
  /** Serverless unit of measure */
  IngestedEvents = 'INGESTED_EVENTS',
  /** Mobile unit of measure */
  MonthlyActiveUsers = 'MONTHLY_ACTIVE_USERS',
  /** Browser unit of measure */
  PageViews = 'PAGE_VIEWS',
  /** NR1 Users unit of measure */
  ProvisionedUsers = 'PROVISIONED_USERS',
  /** Traces unit of measure */
  SpansInMillions = 'SPANS_IN_MILLIONS',
  /** Mobile unit of measure of the number of users */
  Users = 'USERS'
}

/** UOM or unit of measure used to know what a product charges for, such as events, hosts, CUs, etc. */
export type OrganizationProvisioningUnitOfMeasureInput = {
  /** Amount of unit */
  quantity: Scalars['Int']['input'];
  /** Unit, such as events, hosts, CUs, etc */
  unit: OrganizationProvisioningUnit;
};

/** Result of subscription update */
export type OrganizationProvisioningUpdateSubscriptionResult = {
  __typename?: 'OrganizationProvisioningUpdateSubscriptionResult';
  /** Status of enqueuing update in subscription change service */
  enqueued: Scalars['Boolean']['output'];
  /** Error message from enqueuing update in subscription change service */
  errors: Array<OrganizationProvisioningUserError>;
};

/** A user-readable error */
export type OrganizationProvisioningUserError = {
  __typename?: 'OrganizationProvisioningUserError';
  /** A description of the error */
  message: Scalars['String']['output'];
  /** Which input value this error came from */
  path?: Maybe<Array<Scalars['String']['output']>>;
};

/** Enums for region codes */
export enum OrganizationRegionCodeEnum {
  /** Region code for EU */
  Eu01 = 'EU01',
  /** Region code for US */
  Us01 = 'US01'
}

/** Attributes for revoking an account share. */
export type OrganizationRevokeSharedAccountInput = {
  /** The id of the account share to be revoked */
  id: Scalars['String']['input'];
};

/** The object that's returned from successfully revoking a shared account. */
export type OrganizationRevokeSharedAccountResponse = {
  __typename?: 'OrganizationRevokeSharedAccountResponse';
  /** Information about the revoked shared account. */
  sharedAccount?: Maybe<OrganizationSharedAccount>;
};

/** The attributes of an account share. */
export type OrganizationSharedAccount = {
  __typename?: 'OrganizationSharedAccount';
  /** The ID of the account being shared. */
  accountId: Scalars['Int']['output'];
  /** The ID of the account share. */
  id: Scalars['String']['output'];
  /** The ID of the limiting role for the account share. */
  limitingRoleId: Scalars['Int']['output'];
  /** The name of the account share. */
  name?: Maybe<Scalars['String']['output']>;
  /** The ID of the organization sending the account share. */
  sourceOrganizationId: Scalars['ID']['output'];
  /** The name of the organization sending the account share. */
  sourceOrganizationName?: Maybe<Scalars['String']['output']>;
  /** The ID of the organization receiving the account share. */
  targetOrganizationId: Scalars['ID']['output'];
  /** The name of the organization receiving the account share. */
  targetOrganizationName?: Maybe<Scalars['String']['output']>;
};

/** Attributes for creating an account share. */
export type OrganizationSharedAccountInput = {
  /** The id of the account to share with new organization */
  accountId: Scalars['Int']['input'];
  /** The limiting role id the new organization will be granted on for the shared account */
  limitingRoleId?: InputMaybe<Scalars['Int']['input']>;
};

/** Provides the types of sharing modes available */
export enum OrganizationSharingMode {
  /** Accounts that are accessible to this organization */
  All = 'ALL',
  /** Accounts that are managed by this organization */
  Managed = 'MANAGED',
  /** Accounts managed by this organization that are currently shared with other organizations */
  SharedWithOtherOrganizations = 'SHARED_WITH_OTHER_ORGANIZATIONS',
  /** Accounts that are shared with this organization */
  SharedWithThisOrganization = 'SHARED_WITH_THIS_ORGANIZATION'
}

/** Provides the available values of possible directions to sort the result */
export enum OrganizationSortDirectionEnum {
  /** Sort in ascending order */
  Ascending = 'ASCENDING',
  /** Sort in descending order */
  Descending = 'DESCENDING'
}

/** Provides the available values of possible fields that can be sorted */
export enum OrganizationSortKeyEnum {
  /** Authentication domain id */
  Id = 'ID',
  /** Authentication domain name */
  Name = 'NAME'
}

/** Provides the operations available on the target id */
export type OrganizationTargetIdInput = {
  /** An organization id */
  eq: Scalars['ID']['input'];
};

/** An enum specifying the specific types of errors that may be returned. */
export enum OrganizationUpdateErrorType {
  /** Returned when the attributes provided for an object are invalid. */
  InvalidRecord = 'INVALID_RECORD',
  /** Returned when the actor has insufficient capabilties to fulfill the request. */
  NotAuthorized = 'NOT_AUTHORIZED'
}

/** Attributes for updating an organization. */
export type OrganizationUpdateInput = {
  /** The new name for the organization. */
  name?: InputMaybe<Scalars['String']['input']>;
};

/** The return object for an update mutation. */
export type OrganizationUpdateResponse = {
  __typename?: 'OrganizationUpdateResponse';
  /** A description of any errors with the mutation. */
  errors: Array<OrganizationError>;
  /** Information about the updated organization. */
  organizationInformation?: Maybe<OrganizationInformation>;
};

/** Attributes for updating an account share. */
export type OrganizationUpdateSharedAccountInput = {
  /** The id of the account share to be updated */
  id: Scalars['String']['input'];
  /** The id of the limiting role to be updated */
  limitingRoleId: Scalars['Int']['input'];
};

/** The object that's returned from successfully updating a shared account. */
export type OrganizationUpdateSharedAccountResponse = {
  __typename?: 'OrganizationUpdateSharedAccountResponse';
  /** Information about the updated shared account. */
  sharedAccount?: Maybe<OrganizationSharedAccount>;
};

export type ParentAccountInfo = {
  __typename?: 'ParentAccountInfo';
  createdAt?: Maybe<Scalars['Int']['output']>;
  id?: Maybe<Scalars['Int']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  region?: Maybe<Region>;
  status?: Maybe<AccountStatus>;
};

export type PartnerAccountInfo = {
  __typename?: 'PartnerAccountInfo';
  children?: Maybe<Array<Maybe<AccountInfo>>>;
  createdAt?: Maybe<Scalars['Int']['output']>;
  id?: Maybe<Scalars['Int']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  status?: Maybe<AccountStatus>;
};

export type Partnership = {
  __typename?: 'Partnership';
  accounts?: Maybe<Array<Maybe<PartnerAccountInfo>>>;
  id?: Maybe<Scalars['Int']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  owner?: Maybe<AccountInfo>;
  payMethod?: Maybe<Scalars['String']['output']>;
};

/** An object for organizing parameters */
export type PartnershipMigrationMigrateAccountResponse = {
  __typename?: 'PartnershipMigrationMigrateAccountResponse';
  /** Returns true if migration started successfully */
  success: Scalars['Boolean']['output'];
};

export type PersonalizationActorStitchedFields = {
  __typename?: 'PersonalizationActorStitchedFields';
  /** Will result in true if any account that the user has access to has ingested data */
  hasIngestedData?: Maybe<Scalars['Boolean']['output']>;
};

export type PixieAccountStitchedFields = {
  __typename?: 'PixieAccountStitchedFields';
  /** Details for the linked Pixie project */
  linkedPixieProject?: Maybe<PixiePixieProject>;
  /** Get a Pixie access token */
  pixieAccessToken?: Maybe<Scalars['SecureValue']['output']>;
};

export type PixieActorStitchedFields = {
  __typename?: 'PixieActorStitchedFields';
  /** Details for the linked Pixie projects */
  linkedPixieProjects: Array<Maybe<PixieLinkedPixieProject>>;
};

/** An error object for linking a Pixie project. */
export type PixieLinkPixieProjectError = {
  __typename?: 'PixieLinkPixieProjectError';
  /** A message explaining what the error is about. */
  message?: Maybe<Scalars['String']['output']>;
  /** The type of error. */
  type?: Maybe<PixieLinkPixieProjectErrorType>;
};

/** The errors that can be returned when linking a New Relic account and Pixie project */
export enum PixieLinkPixieProjectErrorType {
  /** There is already a linked Pixie project for this New Relic account. */
  AlreadyLinked = 'ALREADY_LINKED',
  /** Automatic Pixie project creation not supported. */
  AutoCreationNotSupported = 'AUTO_CREATION_NOT_SUPPORTED',
  /** The provided account is not valid. */
  InvalidNewrelicAccount = 'INVALID_NEWRELIC_ACCOUNT',
  /** The provided Pixie API key is not valid. */
  InvalidPixieApiKey = 'INVALID_PIXIE_API_KEY',
  /** Unlinking is not supported. */
  UnlinkingNotSupported = 'UNLINKING_NOT_SUPPORTED'
}

/** The response returned when linking a Pixie project to a New Relic account */
export type PixieLinkPixieProjectResult = {
  __typename?: 'PixieLinkPixieProjectResult';
  /** An array containing errors, if any. */
  errors?: Maybe<Array<Maybe<PixieLinkPixieProjectError>>>;
  /** The Pixie project details that were linked. This will be null for unlinkAccount. */
  linkedPixieProject?: Maybe<PixiePixieProject>;
  /** Whether the linking succeeded or not. Check the "errors" list for details */
  success: Scalars['Boolean']['output'];
};

/** Pixie Project with the New Relic account */
export type PixieLinkedPixieProject = {
  __typename?: 'PixieLinkedPixieProject';
  /** The New Relic account id */
  accountId: Scalars['Int']['output'];
  /** The linked Pixie Project */
  pixieProject: PixiePixieProject;
};

/** Pixie Project keys linked to a New Relic account */
export type PixiePixieProject = {
  __typename?: 'PixiePixieProject';
  /** Pixie API key */
  apiKey?: Maybe<Scalars['SecureValue']['output']>;
  /** Pixie Deploy key */
  deployKey?: Maybe<Scalars['SecureValue']['output']>;
};

/** An error object for recording the Pixie terms of service acceptance */
export type PixieRecordPixieTosAcceptanceError = {
  __typename?: 'PixieRecordPixieTosAcceptanceError';
  /** A message explaining what the error is about. */
  message?: Maybe<Scalars['String']['output']>;
  /** The type of error. */
  type?: Maybe<PixieRecordPixieTosAcceptanceErrorType>;
};

/** The errors that can be returned when recording the Pixie terms of service acceptance */
export enum PixieRecordPixieTosAcceptanceErrorType {
  /** Some required data to record the Pixie terms of service acceptance is missing */
  MissingData = 'MISSING_DATA'
}

/** The reponse returned when record the acceptance of the Pixie terms of service on a given account */
export type PixieRecordPixieTosAcceptanceResult = {
  __typename?: 'PixieRecordPixieTosAcceptanceResult';
  /** An array containings errors, if any. */
  errors?: Maybe<Array<Maybe<PixieRecordPixieTosAcceptanceError>>>;
  /** Whether the Pixie terms of service acceptance was successfully recorded or not. */
  success: Scalars['Boolean']['output'];
};

export type PreReleaseProgramActorStitchedFields = {
  __typename?: 'PreReleaseProgramActorStitchedFields';
  /** Agreement Required for specific user's request. */
  agreementRequired?: Maybe<PreReleaseProgramAgreementRequired>;
  /** Checks if the user has access to the Pre Release Program. */
  hasAccess?: Maybe<Scalars['Boolean']['output']>;
  /** Determines if current user is eligible to sign up for a Pre-Release Program */
  isEligible?: Maybe<Scalars['Boolean']['output']>;
  /** Find a single program by ID */
  program?: Maybe<PreReleaseProgramProgram>;
  /** Find a single submission from current user by ProgramId */
  submissionByProgramId?: Maybe<PreReleaseProgramSubmission>;
};


export type PreReleaseProgramActorStitchedFieldsAgreementRequiredArgs = {
  accountId?: InputMaybe<Scalars['Int']['input']>;
};


export type PreReleaseProgramActorStitchedFieldsHasAccessArgs = {
  accountId?: InputMaybe<Scalars['Int']['input']>;
  readableId?: InputMaybe<Scalars['String']['input']>;
};


export type PreReleaseProgramActorStitchedFieldsIsEligibleArgs = {
  accountId?: InputMaybe<Scalars['Int']['input']>;
};


export type PreReleaseProgramActorStitchedFieldsProgramArgs = {
  id?: InputMaybe<Scalars['ID']['input']>;
  readableId?: InputMaybe<Scalars['String']['input']>;
};


export type PreReleaseProgramActorStitchedFieldsSubmissionByProgramIdArgs = {
  programId?: InputMaybe<Scalars['ID']['input']>;
};

/** Agreement Required information */
export type PreReleaseProgramAgreementRequired = {
  __typename?: 'PreReleaseProgramAgreementRequired';
  /** Account that owns the comment */
  accountId: Scalars['Int']['output'];
  /** Name of the account. */
  accountName?: Maybe<Scalars['String']['output']>;
  /** Type of account. */
  accountType?: Maybe<Scalars['String']['output']>;
  /** Date time in milliseconds when program agreement was accepted. */
  dateAccepted?: Maybe<Scalars['EpochMilliseconds']['output']>;
  /** A unique identifier for the the agreement required */
  id: Scalars['ID']['output'];
  /** Organization that owns the comment */
  organizationId?: Maybe<Scalars['ID']['output']>;
};

/** Pre-Release Program */
export type PreReleaseProgramProgram = {
  __typename?: 'PreReleaseProgramProgram';
  /** Program creation time */
  createdAt: Scalars['EpochMilliseconds']['output'];
  /** Program creator user id */
  creatorId: Scalars['ID']['output'];
  /** [Deprecated] If the program requires custom language to the standard pre-release agreement the copy will be entered here and displayed after the standard agreement copy */
  customLegal?: Maybe<Scalars['String']['output']>;
  /** If the program requires custom language to the standard pre-release agreement the copy will be entered here and displayed after the standard agreement copy */
  customLegalAddendum?: Maybe<Scalars['String']['output']>;
  /** True if the pre-release program requires custom legal terms. */
  customLegalRequired?: Maybe<Scalars['Boolean']['output']>;
  /** Stand-alone custom legal terms copy for customers that dont need to see the standard pre-release agreement */
  customLegalStandalone?: Maybe<Scalars['String']['output']>;
  /** Determines if program is Disabled */
  disabled: Scalars['Boolean']['output'];
  /** Email body to use if emailCustomer is true */
  emailBody?: Maybe<Scalars['String']['output']>;
  /** A flag to determine whether or not to send a confirmation email to the customer upon signing up */
  emailCustomer?: Maybe<Scalars['Boolean']['output']>;
  /** Email address to use as sender if emailCustomer is true */
  emailFrom?: Maybe<Scalars['String']['output']>;
  /** Email subject to use if emailCustomer is true */
  emailSubject?: Maybe<Scalars['String']['output']>;
  /** A list of entitlements to be used for blocking access to sign-up for a preview. For example 'hipaa, fedramp' would not allow customers with either a hipaa entitlement or fedramp entitlement from signing up for the preview. */
  excludeEntitlements?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
  /** [Deprecated] If true dont allow FedRAMP customers to sign-up */
  excludeFedramp?: Maybe<Scalars['Boolean']['output']>;
  /** [Deprecated] If true dont allow HIPPA customers to sign-up */
  excludeHippa?: Maybe<Scalars['Boolean']['output']>;
  /** A list of tiers to be used for blocking access to sign-up for a preview. */
  excludeTiers?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
  /** After accepting the pre-release agreement and submitting the form this field can allow the PM to customize the copy that appears on the form submit confirmation */
  formSubmitCopy: Scalars['String']['output'];
  /** When scope='USER' does this program have a submission made by someone else in the same account/organization */
  hasGroupSubmission?: Maybe<Scalars['Boolean']['output']>;
  /** A unique identifier for the the preview program */
  id: Scalars['ID']['output'];
  /** A list of entitlements a user must have in order to be able to sign-up for a preview. For example, if set to 'query-based_pricing' only users with that entitlement can sign-up and those without it will not have access. */
  includeEntitlements?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
  /** A list of feature flags to be included in the program pre release. */
  includeFeatureFlags?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
  /** The description to be used on the Preview Marketing page. The field name correlates to that used on empty gate component. */
  marketingDescription?: Maybe<Scalars['String']['output']>;
  /** True if there is subtext and need to display divider on the Preview Marketing page. The field name correlates to that used on empty gate component. */
  marketingDivider?: Maybe<Scalars['Boolean']['output']>;
  /** Information needed to display image or video on the Preview Marketing page. The field name correlates to that used on empty gate component. */
  marketingExtraContent?: Maybe<Scalars['String']['output']>;
  /** The label states the main purpose or type of message. Only allows GET_STARTED, MONITOR_MORE, and GET_DATA_PLUS. */
  marketingLabelType?: Maybe<PreReleaseProgramProgramMarketingLabelType>;
  /** An optional link to supporting documentation or extra information. */
  marketingLink?: Maybe<Scalars['String']['output']>;
  /** Subtext to be used on the Preview Marketing page. The field name correlates to that used on empty gate component. */
  marketingSubtext?: Maybe<Scalars['String']['output']>;
  /** The title to be used on the Preview Marketing page. The field name correlates to that used on empty gate component. */
  marketingTitle?: Maybe<Scalars['String']['output']>;
  /** An optional URL to a video or animation asset to support your message. Currently URLs for embedded Youtube and Wistia videos are supported. */
  marketingVideoUrl?: Maybe<Scalars['String']['output']>;
  /** Program modified time */
  modifiedAt: Scalars['EpochMilliseconds']['output'];
  /** The name of the program used for customization and reporting */
  name: Scalars['String']['output'];
  /** A unique identifier in kebab case for the preview program */
  readableId: Scalars['String']['output'];
  /** ORGANIZATION | ACCOUNT An identifier to determine if just the individual that completed agreement should have access to features, or the whole org */
  scope: PreReleaseProgramProgramScope;
  /** Determines if program is Active or Inactive */
  status: PreReleaseProgramProgramStatus;
  /** Submission to program form current user */
  submission?: Maybe<PreReleaseProgramSubmission>;
  /** List of submissions for current program */
  submissions?: Maybe<Array<Maybe<PreReleaseProgramSubmission>>>;
  /** List of internal email addresses to notify when a customer signs-up */
  team?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
};

/** The label states the main purpose or type of message on a program label. */
export enum PreReleaseProgramProgramMarketingLabelType {
  /** Sets the label to 'Get Data Plus' */
  GetDataPlus = 'GET_DATA_PLUS',
  /** Sets the label to 'Get started' */
  GetStarted = 'GET_STARTED',
  /** Sets the label to 'Monitor more' */
  MonitorMore = 'MONITOR_MORE'
}

/** ORGANIZATION | ACCOUNT An identifier to determine if just the individual that completed agreement should have access to features, or the whole org */
export enum PreReleaseProgramProgramScope {
  /** Allow access on submit only to specific account */
  Account = 'ACCOUNT',
  /** Allow access on submit to all organization */
  Organization = 'ORGANIZATION',
  /** Allow access on submit only to specific user */
  User = 'USER'
}

/** Determines if program is Active or Inactive */
export enum PreReleaseProgramProgramStatus {
  /** Pre Release Program is still available for sign up */
  Active = 'ACTIVE',
  /** Pre Release Program is not available for sign up */
  Inactive = 'INACTIVE'
}

/** Pre-Release Submission */
export type PreReleaseProgramSubmission = {
  __typename?: 'PreReleaseProgramSubmission';
  /** [Deprecated] Wether or not the user accepted the terms of the program */
  accepted?: Maybe<Scalars['Boolean']['output']>;
  /** Account that owns the comment */
  accountId: Scalars['Int']['output'];
  /** Represents which version, if any, of the pre-release agreement a customer sees. Potential values are 'standard', 'standard+custom', 'custom-only', 'none'. */
  agreementTypeAccepted?: Maybe<Scalars['String']['output']>;
  /** Submission creation time */
  createdAt: Scalars['EpochMilliseconds']['output'];
  /** Submission creator user id */
  creatorId: Scalars['ID']['output'];
  /** Date from which program will be available */
  enabledDate?: Maybe<Scalars['EpochMilliseconds']['output']>;
  /** Date until which the program will be available */
  expirationDate?: Maybe<Scalars['EpochMilliseconds']['output']>;
  /** A unique identifier for the the preview program */
  id: Scalars['ID']['output'];
  /** Submission modified time */
  modifiedAt: Scalars['EpochMilliseconds']['output'];
  /** Organization that owns the comment */
  organizationId?: Maybe<Scalars['ID']['output']>;
  /** Program from which this submission belongs to */
  program?: Maybe<PreReleaseProgramProgram>;
  /** Program Id from which this submission belongs to */
  programId: Scalars['String']['output'];
  /** Determines if submission is Active or Inactive */
  status: Scalars['String']['output'];
  /** User that submitted to the program */
  userId: Scalars['ID']['output'];
};

export type ProductConsumptionAccountStitchedFields = {
  __typename?: 'ProductConsumptionAccountStitchedFields';
  /** Return type for given account id */
  annualPoolOfFundsSummary?: Maybe<ProductConsumptionAnnualPoolOfFundsSummary>;
  /** Summary of month-to-date consumption for a given account */
  consumptionSummary?: Maybe<Array<Maybe<ProductConsumptionConsumptionSummary>>>;
  /** Pricebook for a given account */
  pricebook?: Maybe<Array<Maybe<ProductConsumptionPriceTier>>>;
};


export type ProductConsumptionAccountStitchedFieldsConsumptionSummaryArgs = {
  filter?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
};


export type ProductConsumptionAccountStitchedFieldsPricebookArgs = {
  filter?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
};

export type ProductConsumptionActorStitchedFields = {
  __typename?: 'ProductConsumptionActorStitchedFields';
  /** Gets a full list of all the currently enrolled APoF accounts */
  annualPoolOfFundsAccounts?: Maybe<Array<Maybe<ProductConsumptionAnnualPoolOfFundsAccount>>>;
};

/** This is an Annual Pool of Funds Account */
export type ProductConsumptionAnnualPoolOfFundsAccount = {
  __typename?: 'ProductConsumptionAnnualPoolOfFundsAccount';
  /** Account id for the annual pool of funds (APoF) account */
  accountId?: Maybe<Scalars['Int']['output']>;
};

/** Summary type representing an account's Annual Pool of Funds */
export type ProductConsumptionAnnualPoolOfFundsSummary = {
  __typename?: 'ProductConsumptionAnnualPoolOfFundsSummary';
  /** Account id for the annual pool of funds (APoF) account */
  accountId?: Maybe<Scalars['Int']['output']>;
  /** Total size of the accounts annual pool of funds */
  annualCommit?: Maybe<Scalars['ProductConsumptionBalance']['output']>;
  /** Total remaining APoF balance that is available for the customer */
  commitOutstandingBalance?: Maybe<Scalars['ProductConsumptionBalance']['output']>;
  /** The start date of the contract in the ISO8601 Date Format */
  contractStartDate?: Maybe<Scalars['Date']['output']>;
  /** Customer id for the annual pool of funds (APoF) account */
  customerId?: Maybe<Scalars['ID']['output']>;
  /** The amount of the accounts last invoice */
  lastInvoiceAmount?: Maybe<Scalars['ProductConsumptionBalance']['output']>;
  /** The date of the accounts last invoice in ISO8601 Date Format */
  lastInvoiceDate?: Maybe<Scalars['Date']['output']>;
  /** The last time the data was refreshed in the Consumption Data Service */
  lastUpdated?: Maybe<Scalars['Date']['output']>;
  /** Type of plan */
  planType?: Maybe<Scalars['String']['output']>;
  /** Total remaining APoF balance from prepaid installments */
  prepaidBalance?: Maybe<Scalars['ProductConsumptionBalance']['output']>;
  /** Amount of annual pool of funds that have been consumed thus far */
  utilization?: Maybe<Scalars['ProductConsumptionBalance']['output']>;
};

/** Summary of month-to-date consumption for a given account */
export type ProductConsumptionConsumptionSummary = {
  __typename?: 'ProductConsumptionConsumptionSummary';
  /**
   * Average cost for a single unit of a given metric
   * @deprecated estimated cost fields no longer provided
   */
  averageCostPerUnit?: Maybe<ProductConsumptionHistoricalDataPoint>;
  /** The consumption metric that this summary represents (i.e. FullUsers, GigabytesIngested, etc) */
  consumptionMetric?: Maybe<Scalars['String']['output']>;
  /**
   * Projected end-of-month cost at the current consumption rate and average per-unit cost
   * @deprecated estimated cost fields no longer provided
   */
  projectedMonthlyCost?: Maybe<ProductConsumptionHistoricalDataPoint>;
  /** Total month-to-date consumption for a given metric */
  totalConsumption?: Maybe<ProductConsumptionHistoricalDataPoint>;
};

/** The `customerAdministration` field is the entry point for data related to capabilities and access for a specific customer */
export type ProductConsumptionCustomerAdministrationStitchedFields = {
  __typename?: 'ProductConsumptionCustomerAdministrationStitchedFields';
  /** Return type for given customer id */
  annualPoolOfFundsSummary?: Maybe<ProductConsumptionAnnualPoolOfFundsSummary>;
};


/** The `customerAdministration` field is the entry point for data related to capabilities and access for a specific customer */
export type ProductConsumptionCustomerAdministrationStitchedFieldsAnnualPoolOfFundsSummaryArgs = {
  customerId: ProductConsumptionOrganizationCustomerIdInputFilter;
};

/** Represents a data point with a historical comparison */
export type ProductConsumptionHistoricalDataPoint = {
  __typename?: 'ProductConsumptionHistoricalDataPoint';
  /** The current value of the data point (i.e. this month's consumption) */
  current?: Maybe<Scalars['String']['output']>;
  /** The previous value of the data point (i.e. last month's consumption) */
  previous?: Maybe<Scalars['String']['output']>;
};

/** Provides all the available filters on the customer id */
export type ProductConsumptionOrganizationCustomerIdInputFilter = {
  /** performs an equals operation */
  eq: Scalars['String']['input'];
};

/** Price information for a given account */
export type ProductConsumptionPriceTier = {
  __typename?: 'ProductConsumptionPriceTier';
  /** Indicates if the pricing plan is tiered or not */
  isTiered?: Maybe<Scalars['Boolean']['output']>;
  /** Indicates which metric the price is for */
  metric?: Maybe<Scalars['String']['output']>;
  /** pricePerUnit for this pricing plan or tier */
  pricePerUnit?: Maybe<Scalars['ProductConsumptionBalance']['output']>;
  /** Threshold to activate the tier */
  threshold?: Maybe<Scalars['Int']['output']>;
  /** Indicates the tier this price is for */
  tier?: Maybe<Scalars['Int']['output']>;
};

/** An account with generated ingest */
export type ProductRatingIngestAccount = {
  __typename?: 'ProductRatingIngestAccount';
  /** The id of the account. */
  id?: Maybe<Scalars['ID']['output']>;
  /** The name of the account. */
  name?: Maybe<Scalars['String']['output']>;
};

/** The list of accounts with ingest and next cursor if results are paged. */
export type ProductRatingIngestAccountsResult = {
  __typename?: 'ProductRatingIngestAccountsResult';
  /** List of accounts with ingest */
  accounts?: Maybe<Array<Maybe<ProductRatingIngestAccount>>>;
  /** If nextCursor is present, set it to the cursor input field while searching in order to get the next page of results. */
  nextCursor?: Maybe<Scalars['String']['output']>;
};

export type ProductRatingOrganizationStitchedFields = {
  __typename?: 'ProductRatingOrganizationStitchedFields';
  /** The list of accounts that have ingest for a give organization. */
  ingestAccounts?: Maybe<ProductRatingIngestAccountsResult>;
};


export type ProductRatingOrganizationStitchedFieldsIngestAccountsArgs = {
  cursor?: InputMaybe<Scalars['String']['input']>;
  queryWindow: DateTimeWindowInput;
};

/** A filter for Accounts */
export type ProductRatingV2AccountFilterInput = {
  /** Filter by organization ID */
  organizationId: ProductRatingV2OrganizationIdFilterInput;
  /** Filter by datetime window */
  queryWindow: DateTimeWindowInput;
};

/** An account with generated ingest */
export type ProductRatingV2IngestAccount = {
  __typename?: 'ProductRatingV2IngestAccount';
  /** The id of the account. */
  id?: Maybe<Scalars['ID']['output']>;
  /** The name of the account. */
  name?: Maybe<Scalars['String']['output']>;
};

/** The list of accounts with ingest and next cursor if results are paged. */
export type ProductRatingV2IngestAccountsResultV2 = {
  __typename?: 'ProductRatingV2IngestAccountsResultV2';
  /** List of accounts with ingest */
  items?: Maybe<Array<Maybe<ProductRatingV2IngestAccount>>>;
  /** If nextCursor is present, set it to the cursor input field while searching in order to get the next page of results. */
  nextCursor?: Maybe<Scalars['String']['output']>;
};

/** An organization with generated ingest */
export type ProductRatingV2IngestOrganization = {
  __typename?: 'ProductRatingV2IngestOrganization';
  /** The id of the organization. */
  id?: Maybe<Scalars['ID']['output']>;
  /** The name of the organization. */
  name?: Maybe<Scalars['String']['output']>;
};

/** The list of organizations with ingest and next cursor if results are paged. */
export type ProductRatingV2IngestOrganizationsResult = {
  __typename?: 'ProductRatingV2IngestOrganizationsResult';
  /** List of organizations with ingest */
  items?: Maybe<Array<Maybe<ProductRatingV2IngestOrganization>>>;
  /** If nextCursor is present, set it to the cursor input field while searching in order to get the next page of results. */
  nextCursor?: Maybe<Scalars['String']['output']>;
};

/** A filter for Organizations */
export type ProductRatingV2OrganizationFilterInput = {
  /** Filter by datetime window */
  queryWindow: DateTimeWindowInput;
};

/** OrganizationIdFilterInput organization id */
export type ProductRatingV2OrganizationIdFilterInput = {
  /** An organization id */
  eq: Scalars['ID']['input'];
};

export type ProductSubscription = {
  __typename?: 'ProductSubscription';
  entitlements?: Maybe<Array<Maybe<SubscriptionEntitlement>>>;
  /** @deprecated Please use productName */
  name?: Maybe<Scalars['String']['output']>;
  pricingQuantity?: Maybe<Scalars['Int']['output']>;
  pricingUnit?: Maybe<Scalars['String']['output']>;
  productLine?: Maybe<Scalars['String']['output']>;
  productName?: Maybe<Scalars['String']['output']>;
  secondaryPricingQuantity?: Maybe<Scalars['Int']['output']>;
  secondaryPricingUnit?: Maybe<Scalars['String']['output']>;
  trial?: Maybe<ProductTrial>;
  trialEligibility?: Maybe<ProductTrialEligibility>;
  /** Max duration (seconds) used in time picker */
  visibleTimeWindow?: Maybe<Scalars['Int']['output']>;
};

export type ProductTrial = {
  __typename?: 'ProductTrial';
  endTime?: Maybe<Scalars['Int']['output']>;
  startTime?: Maybe<Scalars['Int']['output']>;
};

export type ProductTrialEligibility = {
  __typename?: 'ProductTrialEligibility';
  reason?: Maybe<Scalars['String']['output']>;
  state?: Maybe<Scalars['Boolean']['output']>;
};

/** The object contains information on who accepted the NR1 programmability terms and conditions and when. */
export type ProgrammabilityTnCAccepted = {
  __typename?: 'ProgrammabilityTnCAccepted';
  /** Date and time of acceptance of the New Relic terms and conditions. */
  acceptedOn: Scalars['DateTime']['output'];
  /** The account that accepted the New Relic terms and conditions. */
  account?: Maybe<AccountReference>;
  /** The user who accepted the New Relic terms and conditions. */
  user?: Maybe<UserReference>;
};

/** Accept terms and conditions input data. */
export type ProgrammabilityTnCAccountInput = {
  /** Unique identifier of the account that will accept the NR1 programmability terms and conditions. */
  accountId?: InputMaybe<Scalars['Int']['input']>;
};

/** Filter for account lists for terms and conditions operations. */
export type ProgrammabilityTnCAccountsFilterInput = {
  /** Unique identifiers of the accounts that will accept the NR1 programmability terms and conditions. */
  accountIds: Array<InputMaybe<Scalars['Int']['input']>>;
};

export type ProgrammabilityTnCActorStitchedFields = {
  __typename?: 'ProgrammabilityTnCActorStitchedFields';
  /** Retrieve the information of the accounts that have accepted the NR1 programmability terms and conditions. */
  acceptedAccounts?: Maybe<Array<Maybe<ProgrammabilityTnCAccepted>>>;
  /** Retrieve the information of the accounts that are forbidden from accepting the NR1 programmability terms and conditions. */
  disallowedAccounts?: Maybe<ProgrammabilityTnCDisallowedAccounts>;
};


export type ProgrammabilityTnCActorStitchedFieldsAcceptedAccountsArgs = {
  accounts?: InputMaybe<ProgrammabilityTnCAccountsFilterInput>;
};


export type ProgrammabilityTnCActorStitchedFieldsDisallowedAccountsArgs = {
  accounts?: InputMaybe<ProgrammabilityTnCAccountsFilterInput>;
};

/** The object contains the list of account IDs that are forbidden from accepting the NR1 programmability terms and conditions. */
export type ProgrammabilityTnCDisallowedAccounts = {
  __typename?: 'ProgrammabilityTnCDisallowedAccounts';
  /** List of account IDs that are forbidden from accepting the terms and conditions. */
  disallowedAccountIds: Array<Scalars['Int']['output']>;
};

/** Account Configurations are used to set configurable data on an account by type */
export type ProvisioningAccountConfiguration = {
  __typename?: 'ProvisioningAccountConfiguration';
  /** Array of configurations in data sets, of a key and value */
  configurationDataSet: Array<ProvisioningConfigurationKeyValuePair>;
  /** The current state of the configuration, enable or disabled */
  enabled: Scalars['Boolean']['output'];
  /** The configuration type; FedRAMP, HIPAA, etc */
  type: ProvisioningConfigurationType;
};

/** A error message related to what when wrong with changing an account configuration */
export type ProvisioningAccountConfigurationError = {
  __typename?: 'ProvisioningAccountConfigurationError';
  /** A description of the error */
  message: Scalars['String']['output'];
  /** Which input value this error came from */
  path?: Maybe<Scalars['String']['output']>;
};

/** Result of adjusting a configuration on an account */
export type ProvisioningAccountConfigurationResult = {
  __typename?: 'ProvisioningAccountConfigurationResult';
  /** Error messages from attempting to make changes to an account configuration */
  errors?: Maybe<Array<ProvisioningAccountConfigurationError>>;
  /** Returns true if the action completed successfully, false if the action failed */
  success?: Maybe<Scalars['Boolean']['output']>;
};

/** An entitlement package on an account */
export type ProvisioningAccountEntitlementPackage = {
  __typename?: 'ProvisioningAccountEntitlementPackage';
  /** The ID of an account */
  accountId: Scalars['Int']['output'];
  /** Enablement used to connect the entitlement package to the account */
  enablement?: Maybe<ProvisioningEnablement>;
  /** The end date of the promotion */
  endDate: Scalars['DateTime']['output'];
  /** Promotion used to connect the entitlement package to the account */
  promotion?: Maybe<ProvisioningPromotion>;
  /** The start date of the promotion */
  startDate: Scalars['DateTime']['output'];
};

/** An object containing information about a property quantity */
export type ProvisioningAccountEntitlementPropertyQuantity = {
  __typename?: 'ProvisioningAccountEntitlementPropertyQuantity';
  /** The default value for the property */
  defaultQuantity?: Maybe<Scalars['Int']['output']>;
  /** The maximum quantity allowed for the property */
  maxQuantity?: Maybe<Scalars['Int']['output']>;
  /** The minimum quantity allowed for the property */
  minQuantity?: Maybe<Scalars['Int']['output']>;
  /** The name of the property */
  propertyName: Scalars['String']['output'];
};

/** A list of an account's account entitlements */
export type ProvisioningAccountEntitlementSetResult = {
  __typename?: 'ProvisioningAccountEntitlementSetResult';
  /** List of entitlements */
  entitlementsList?: Maybe<ProvisioningEntitlementsList>;
};

/** A way of stitching into the existing account schema type oject on NerdGraph */
export type ProvisioningAccountStitchedFields = {
  __typename?: 'ProvisioningAccountStitchedFields';
  /** Retrieves configurations for an account */
  accountConfigurations?: Maybe<Array<ProvisioningAccountConfiguration>>;
  /** Returns all entitlement packages for a given account */
  accountEntitlementPackages?: Maybe<Array<ProvisioningAccountEntitlementPackage>>;
  /** Returns all account entitlements for a given account */
  accountEntitlements?: Maybe<ProvisioningAccountEntitlementSetResult>;
  /** Returns whether an account is legacy or platform */
  accountType?: Maybe<ProvisioningAccountType>;
  /** Returns all blocked entitlements for a given account */
  blockedEntitlementSet?: Maybe<ProvisioningBlockedEntitlementSetResult>;
  /** Returns all entitlements for a given account */
  currentEntitlementSet?: Maybe<ProvisioningCurrentEntitlementSetResult>;
  /** Retrieves subscription history data for account the request is nested under */
  subscriptionHistory?: Maybe<ProvisioningSubscriptionHistoryResult>;
};


/** A way of stitching into the existing account schema type oject on NerdGraph */
export type ProvisioningAccountStitchedFieldsAccountConfigurationsArgs = {
  type?: InputMaybe<Scalars['String']['input']>;
};


/** A way of stitching into the existing account schema type oject on NerdGraph */
export type ProvisioningAccountStitchedFieldsSubscriptionHistoryArgs = {
  cursor?: InputMaybe<Scalars['String']['input']>;
};

/** Types of accounts */
export enum ProvisioningAccountType {
  /** For features that don't require a specific account type */
  Generic = 'GENERIC',
  /** An account with legacy (i.e. old big six) products */
  Legacy = 'LEGACY',
  /** An account with consumption based / platform products */
  Platform = 'PLATFORM'
}

/** A way of stitching into the existing actor schema type object on NerdGraph */
export type ProvisioningActorStitchedFields = {
  __typename?: 'ProvisioningActorStitchedFields';
  /** Retrieves a list of all account ids with the given configuration */
  configuredAccounts?: Maybe<Array<ProvisioningConfiguredAccount>>;
};


/** A way of stitching into the existing actor schema type object on NerdGraph */
export type ProvisioningActorStitchedFieldsConfiguredAccountsArgs = {
  configurationTypeCode?: InputMaybe<Array<ProvisioningConfigurationTypeCode>>;
  enabled?: InputMaybe<Scalars['Boolean']['input']>;
};

/** A list of an account's blocked entitlements */
export type ProvisioningBlockedEntitlementSetResult = {
  __typename?: 'ProvisioningBlockedEntitlementSetResult';
  /** List of entitlements */
  entitlementsList?: Maybe<ProvisioningEntitlementsList>;
};

/** Autogenerated return type of BulkAccountRefresh */
export type ProvisioningBulkAccountRefreshPayload = {
  __typename?: 'ProvisioningBulkAccountRefreshPayload';
  /** Did the job enqueue */
  enqueued?: Maybe<Scalars['Boolean']['output']>;
};

/** A error message related to what when wrong with applying or removing an enablement or promotion */
export type ProvisioningBulkApplicationError = {
  __typename?: 'ProvisioningBulkApplicationError';
  /** A description of the error */
  message: Scalars['String']['output'];
  /** Which input value this error came from */
  path?: Maybe<Array<Scalars['String']['output']>>;
};

/** Result of attempting to apply an enablement or promotion code to multiple accounts */
export type ProvisioningBulkApplicationResult = {
  __typename?: 'ProvisioningBulkApplicationResult';
  /** Did the job enqueue */
  enqueued?: Maybe<Scalars['Boolean']['output']>;
  /** Error message from attempting to apply an enablement or promotion code to an account */
  errors?: Maybe<Array<ProvisioningBulkApplicationError>>;
};

/** An error message outlining what went wrong when bulk converting accounts to CPM */
export type ProvisioningBulkCpmConversionsError = {
  __typename?: 'ProvisioningBulkCpmConversionsError';
  /** A description of the error */
  message: Scalars['String']['output'];
  /** Which input value this error came from */
  path?: Maybe<Array<Scalars['String']['output']>>;
};

/** Result of bulk cpm conversion */
export type ProvisioningBulkCpmConversionsResult = {
  __typename?: 'ProvisioningBulkCpmConversionsResult';
  /** Did the accounts get converted to CPM */
  enqueued?: Maybe<Scalars['Boolean']['output']>;
  /** Error message from attempting to bulk convert accounts to CPM */
  errors?: Maybe<Array<ProvisioningBulkCpmConversionsError>>;
};

/** A data collection of a key and value pair that represents part of a larger configuration for an account */
export type ProvisioningConfigurationKeyValuePair = {
  __typename?: 'ProvisioningConfigurationKeyValuePair';
  /** The key of the key value pair, a string that describes the value being enabled or disabled */
  key: Scalars['String']['output'];
  /** The value of the key value pair, a boolean that enables or disables the configuration key */
  value: Scalars['Boolean']['output'];
};

/** A data collection of a key and value pair that represents part of a larger configuration for an account */
export type ProvisioningConfigurationKeyValuePairInput = {
  /** The key of the key value pair, a string that describes the value being enabled or disabled */
  key: Scalars['String']['input'];
  /** The value of the key value pair, a boolean that enables or disables the configuration key */
  value: Scalars['Boolean']['input'];
};

/** The type object that lets us know what kind of account configuration being viewed */
export type ProvisioningConfigurationType = {
  __typename?: 'ProvisioningConfigurationType';
  /** Describes whether a configuration type is allowed on subaccounts */
  allowedOnSubaccounts: Scalars['Boolean']['output'];
  /** The configuration type; FedRAMP, HIPAA, etc */
  code: Scalars['String']['output'];
  /** Description of what this configuration type represents */
  description: Scalars['String']['output'];
  /** List of available fields that can go into the configuration json blob */
  fields: Array<Scalars['String']['output']>;
  /** The user-friendly name of a configuration type */
  name: Scalars['String']['output'];
};

/** The code for the configuration type */
export enum ProvisioningConfigurationTypeCode {
  /** Fedramp compliant */
  Fedramp = 'FEDRAMP',
  /** Hipaa compliant */
  Hipaa = 'HIPAA'
}

/** A configured account */
export type ProvisioningConfiguredAccount = {
  __typename?: 'ProvisioningConfiguredAccount';
  /** The id of an account */
  accountId: Scalars['Int']['output'];
  /** Displays true when configuration is enabled */
  enabled: Scalars['Boolean']['output'];
};

/** Result of non profit conversion */
export type ProvisioningConvertAccountResult = {
  __typename?: 'ProvisioningConvertAccountResult';
  /** Status of enqueuing update in subscription change service */
  enqueued: Scalars['Boolean']['output'];
  /** Error message from enqueuing update in subscription change service */
  errors: Array<ProvisioningUserError>;
};

/** A listing of an account's entitlements */
export type ProvisioningCurrentEntitlementSetResult = {
  __typename?: 'ProvisioningCurrentEntitlementSetResult';
  /** List of entitlements */
  entitlementsList?: Maybe<ProvisioningEntitlementsList>;
};

/** Enablement used to grant an entitlement package to a legacy account that ordinarily would not have access if moved to platform (grandparenting) */
export type ProvisioningEnablement = {
  __typename?: 'ProvisioningEnablement';
  /** The type of account this enablement can be applied to */
  allowedAccountType: ProvisioningAccountType;
  /** The code of the enablement */
  code: Scalars['String']['output'];
  /** The description of the enablement */
  description: Scalars['String']['output'];
  /** The proper name of the enablement */
  name: Scalars['String']['output'];
};

/** A error message related to what when wrong with applying or removing an enablement */
export type ProvisioningEnablementApplicationError = {
  __typename?: 'ProvisioningEnablementApplicationError';
  /** A description of the error */
  message: Scalars['String']['output'];
  /** Which input value this error came from */
  path?: Maybe<Array<Scalars['String']['output']>>;
};

/** Result of attempting to apply an enablement code to an account */
export type ProvisioningEnablementApplicationResult = {
  __typename?: 'ProvisioningEnablementApplicationResult';
  /** Status of applying an enablement code to an account */
  appliedSuccessfully?: Maybe<Scalars['Boolean']['output']>;
  /** Error message from attempting to apply an enablement code to an account */
  errors?: Maybe<Array<ProvisioningEnablementApplicationError>>;
};

/** Result of attempting to remove an enablement from an account */
export type ProvisioningEnablementRemovalResult = {
  __typename?: 'ProvisioningEnablementRemovalResult';
  /** Error message from attempting to remove an enablement from an account */
  errors?: Maybe<Array<ProvisioningEnablementApplicationError>>;
  /** Status of removing an enablement from an account */
  removedSuccessfully?: Maybe<Scalars['Boolean']['output']>;
};

/** A listing of an account ids and status */
export type ProvisioningEntitleAccountStatus = {
  __typename?: 'ProvisioningEntitleAccountStatus';
  /** An account id */
  accountId?: Maybe<Scalars['Int']['output']>;
  /** Error or success status of adding the entitlement to the account */
  status?: Maybe<ProvisioningStatus>;
};

/** A listing of an account ids and status */
export type ProvisioningEntitleAccountsResult = {
  __typename?: 'ProvisioningEntitleAccountsResult';
  /** Status for each account given an entitlement */
  result?: Maybe<Array<ProvisioningEntitleAccountStatus>>;
};

/** An entitlement package */
export type ProvisioningEntitlementPackage = {
  __typename?: 'ProvisioningEntitlementPackage';
  /** The code of the Entitlement Package */
  code: Scalars['String']['output'];
  /** The entitlements belonging to the Entitlement Package */
  entitlements?: Maybe<Array<ProvisioningEntitlementResult>>;
  /** The ID of the Entitlement Package */
  id: Scalars['ID']['output'];
  /** The IDs of the inherited Entitlement Packages */
  inheritedEntitlementPackageIds?: Maybe<Array<Scalars['ID']['output']>>;
  /** The proper name of the Entitlement Package */
  name: Scalars['String']['output'];
};

/** An entitlement */
export type ProvisioningEntitlementResult = {
  __typename?: 'ProvisioningEntitlementResult';
  /** The email address of the person who authorized the entitlement */
  authorizedBy?: Maybe<Scalars['String']['output']>;
  /** If true, entitlement is available for beta use */
  availableForBeta?: Maybe<Scalars['Boolean']['output']>;
  /** The display name of the Entitlement */
  displayName?: Maybe<Scalars['String']['output']>;
  /** The end date of the Entitlement */
  endDate?: Maybe<Scalars['DateTime']['output']>;
  /** Entitlement Package for the Entitlement */
  entitlementPackage?: Maybe<ProvisioningEntitlementPackage>;
  /** The name of the Entitlement */
  name: Scalars['String']['output'];
  /** The product_line of the entitlements */
  productLine?: Maybe<Scalars['String']['output']>;
  /** A string containing the current properties on the Entitlement */
  properties?: Maybe<Scalars['String']['output']>;
  /** The allowable quantities associated with the entitlement properties */
  propertyQuantities?: Maybe<Array<ProvisioningAccountEntitlementPropertyQuantity>>;
};

/** A list of entitlements for an account */
export type ProvisioningEntitlementsList = {
  __typename?: 'ProvisioningEntitlementsList';
  /** Array of entitlements */
  entitlementResults?: Maybe<Array<ProvisioningEntitlementResult>>;
};

/** line items */
export type ProvisioningLineItem = {
  __typename?: 'ProvisioningLineItem';
  /** The code of the line item */
  code: Scalars['String']['output'];
  /** The ID of the line item */
  id: Scalars['Int']['output'];
};

/** A line item. */
export type ProvisioningLineItemInput = {
  /** Unique id for line item */
  id: Scalars['Int']['input'];
  /** Line item name */
  name?: InputMaybe<Scalars['String']['input']>;
};

/** The type of non-profit */
export enum ProvisioningNonProfit {
  /** A standard non-profit */
  Standard = 'STANDARD',
  /** Student Edition */
  Student = 'STUDENT'
}

/** A way of stitching into the existing account schema type object on NerdGraph */
export type ProvisioningNrPlatformStitchedFields = {
  __typename?: 'ProvisioningNrPlatformStitchedFields';
  /** Retrieves a list of all configuration types */
  configurationTypes?: Maybe<Array<ProvisioningConfigurationType>>;
  /** Retrieves a list of all enablements */
  enablements?: Maybe<Array<ProvisioningEnablement>>;
  /** Retrieves a list of all entitlements */
  entitlements?: Maybe<Array<ProvisioningEntitlementResult>>;
  /** Retrieves a list of all promotions */
  promotions?: Maybe<Array<ProvisioningPromotion>>;
};

/** A product. */
export type ProvisioningProduct = {
  __typename?: 'ProvisioningProduct';
  /** Unique id for Product */
  id: Scalars['Int']['output'];
  /** Line items */
  lineItems?: Maybe<Array<ProvisioningLineItem>>;
  /** Product name */
  name: Scalars['String']['output'];
  /** The product line for a subscription product */
  productLine: Scalars['String']['output'];
  /** An array of unit and quantity for a product */
  unitsOfMeasure?: Maybe<Array<ProvisioningUnitOfMeasure>>;
};

/** A product. */
export type ProvisioningProductInput = {
  /** Unique id for Product */
  id: Scalars['Int']['input'];
  /** An array of line items */
  lineItems?: InputMaybe<Array<ProvisioningLineItemInput>>;
  /** Product name */
  name?: InputMaybe<Scalars['String']['input']>;
  /** An array of unit and quantity for a product */
  unitsOfMeasure?: InputMaybe<Array<ProvisioningUnitOfMeasureInput>>;
};

/** Promotion used to grant an entitlement package to account temporarily */
export type ProvisioningPromotion = {
  __typename?: 'ProvisioningPromotion';
  /** The type of account this promotion can be applied to */
  allowedAccountType: ProvisioningAccountType;
  /** The code of the promotion */
  code: Scalars['String']['output'];
  /** The number of days the promotion lasts */
  daysDuration: Scalars['Int']['output'];
  /** The proper name of the promotion */
  name: Scalars['String']['output'];
  /** If single use is true, the promotion can only be used once */
  singleUse: Scalars['Boolean']['output'];
  /** Determines whether a promotion should be presented in the UI */
  visible: Scalars['Boolean']['output'];
};

/** A error message related to what when wrong with applying or removing a promotion */
export type ProvisioningPromotionApplicationError = {
  __typename?: 'ProvisioningPromotionApplicationError';
  /** A description of the error */
  message: Scalars['String']['output'];
  /** Which input value this error came from */
  path?: Maybe<Array<Scalars['String']['output']>>;
};

/** Result of attempting to apply a promotion code to an account */
export type ProvisioningPromotionApplicationResult = {
  __typename?: 'ProvisioningPromotionApplicationResult';
  /** Status of applying a promotion code to an account */
  appliedSuccessfully?: Maybe<Scalars['Boolean']['output']>;
  /** Error message from attempting to apply a promotion code to an account */
  errors?: Maybe<Array<ProvisioningPromotionApplicationError>>;
};

/** Result of attempting to remove a promotion code from an account */
export type ProvisioningPromotionRemovalResult = {
  __typename?: 'ProvisioningPromotionRemovalResult';
  /** Error message from attempting to remove a promotion from an account */
  errors?: Maybe<Array<ProvisioningPromotionApplicationError>>;
  /** Status of removing a promotion from an account */
  removedSuccessfully?: Maybe<Scalars['Boolean']['output']>;
};

/** Result of an entitlement refresh */
export type ProvisioningRefreshEntitlementResult = {
  __typename?: 'ProvisioningRefreshEntitlementResult';
  /** Error messages from attempting to refresh an account */
  errors?: Maybe<Array<ProvisioningRefreshEntitlementsError>>;
  /** Informational message returned from refreshing entitlements on an account */
  message: Scalars['String']['output'];
  /** Returns true if the action completed successfully, false if the action failed */
  success?: Maybe<Scalars['Boolean']['output']>;
};

/** A error message describing what when wrong while refreshing the entitlements on an account */
export type ProvisioningRefreshEntitlementsError = {
  __typename?: 'ProvisioningRefreshEntitlementsError';
  /** A description of the error */
  message: Scalars['String']['output'];
  /** Which input value this error came from */
  path?: Maybe<Array<Scalars['String']['output']>>;
};

/** Result of removing platform record */
export type ProvisioningRemovePlatformResult = {
  __typename?: 'ProvisioningRemovePlatformResult';
  /** The account id of the removed platform record */
  accountId: Scalars['Int']['output'];
  /** Description of the error or success result */
  resultMessage?: Maybe<Scalars['String']['output']>;
  /** True if removal of platform record succeeded, false if action failed */
  success: Scalars['Boolean']['output'];
};

/** Status for accounts when adding entitlements */
export enum ProvisioningStatus {
  /** Child accounts cannot be modified */
  AccountHasParent = 'ACCOUNT_HAS_PARENT',
  /** Internal accounts cannot be modified */
  AccountIsInternal = 'ACCOUNT_IS_INTERNAL',
  /** The accountType must be platform to be modified */
  AccountIsNotPlatform = 'ACCOUNT_IS_NOT_PLATFORM',
  /** There is no account with the given id */
  AccountNotFound = 'ACCOUNT_NOT_FOUND',
  /** The account does not have the specified entitlement auth or block, therefore it cannot be removed */
  CannotRemoveEntitlement = 'CANNOT_REMOVE_ENTITLEMENT',
  /** The entitlement was successfully assigned/removed for the account */
  Success = 'SUCCESS'
}

/** A single set of subscription history for an account based off a specific start and end date */
export type ProvisioningSubscriptionEntry = {
  __typename?: 'ProvisioningSubscriptionEntry';
  /** Expiration/End date of the subscription */
  endDate?: Maybe<Scalars['DateTime']['output']>;
  /** An array of Products was apart of the subscription */
  products: Array<ProvisioningProduct>;
  /** Time that the subscription finished provisioning */
  provisionedDate: Scalars['DateTime']['output'];
  /** Start date of the subscription */
  startDate: Scalars['DateTime']['output'];
  /** Status of the subscription, such as being PAID, PENDING, REPLACED, CANCELLED, etc */
  status: ProvisioningSubscriptionStatus;
  /** ID of the user that made the request/change */
  userId?: Maybe<Scalars['Int']['output']>;
};

/** A listing of an accounts subscription history */
export type ProvisioningSubscriptionHistoryResult = {
  __typename?: 'ProvisioningSubscriptionHistoryResult';
  /** String used to request the next available page of results */
  nextCursor?: Maybe<Scalars['String']['output']>;
  /** An array of SubscriptionEntry's */
  subscriptionEntries: Array<ProvisioningSubscriptionEntry>;
  /** Total number of subscription histories available */
  totalCount?: Maybe<Scalars['Int']['output']>;
};

/** Types of statuses a subscription can have */
export enum ProvisioningSubscriptionStatus {
  /** Subscription is authorized to be active */
  Authorized = 'AUTHORIZED',
  /** Subsciption was cancelled */
  Cancelled = 'CANCELLED',
  /** Subscription is active and not considered a paid subscription */
  Free = 'FREE',
  /** Payment successfully recieved for subscription */
  Paid = 'PAID',
  /** Payment did not go through */
  PaymentDeclined = 'PAYMENT_DECLINED',
  /** Subscription is waiting on payment to go through */
  Pending = 'PENDING',
  /** Subscription was replaced by a new subscription */
  Replaced = 'REPLACED'
}

/** Types of units for entitlements */
export enum ProvisioningUnit {
  /** Additional days of data retention */
  AdditionalDaysOfRetention = 'ADDITIONAL_DAYS_OF_RETENTION',
  /** Mobile unit of measure of the number of mobile applications */
  Apps = 'APPS',
  /** Proactive Detection unit of measure */
  AppTransactionsInMillions = 'APP_TRANSACTIONS_IN_MILLIONS',
  /** Synthetics unit of measure */
  Checks = 'CHECKS',
  /** APM unit of measure of the number of compute units */
  ComputeUnit = 'COMPUTE_UNIT',
  /** The time that we retain data in days */
  DataRetentionInDays = 'DATA_RETENTION_IN_DAYS',
  /** Metrics unit of measure */
  Dpm = 'DPM',
  /** Insight events in multiples of millions */
  EventsInMillions = 'EVENTS_IN_MILLIONS',
  /** NR1 Data unit of measure */
  GbIngested = 'GB_INGESTED',
  /** Logs unit of measure */
  GbPerDay = 'GB_PER_DAY',
  /** Grace period in days before customer is billed for users */
  GracePeriod = 'GRACE_PERIOD',
  /** APM unit of measure for hosts */
  Hosts = 'HOSTS',
  /** AI unit of measure */
  IncidentEvents = 'INCIDENT_EVENTS',
  /** Serverless unit of measure */
  IngestedEvents = 'INGESTED_EVENTS',
  /** Mobile unit of measure */
  MonthlyActiveUsers = 'MONTHLY_ACTIVE_USERS',
  /** Browser unit of measure */
  PageViews = 'PAGE_VIEWS',
  /** NR1 Users unit of measure */
  ProvisionedUsers = 'PROVISIONED_USERS',
  /** Traces unit of measure */
  SpansInMillions = 'SPANS_IN_MILLIONS',
  /** Mobile unit of measure of the number of users */
  Users = 'USERS'
}

/** UOM or unit of measure used to know what a product charges for, such as events, hosts, CUs, etc. */
export type ProvisioningUnitOfMeasure = {
  __typename?: 'ProvisioningUnitOfMeasure';
  /** Number of UOMs a subscription has */
  quantity?: Maybe<Scalars['ID']['output']>;
  /** A Enum that tells what type of UOM is being used, such as HOSTS, INGESTED_EVENTS, USERS, APPS, COMPUTE_UNIT, DPM, INCIDENT_EVENTS, etc */
  unit?: Maybe<ProvisioningUnit>;
};

/** UOM or unit of measure used to know what a product charges for, such as events, hosts, CUs, etc. */
export type ProvisioningUnitOfMeasureInput = {
  /** Amount of unit */
  quantity: Scalars['Int']['input'];
  /** Unit, such as events, hosts, CUs, etc */
  unit: ProvisioningUnit;
};

/** Result of subscription update */
export type ProvisioningUpdateSubscriptionResult = {
  __typename?: 'ProvisioningUpdateSubscriptionResult';
  /** Status of enqueuing update in subscription change service */
  enqueued: Scalars['Boolean']['output'];
  /** Error message from enqueuing update in subscription change service */
  errors: Array<ProvisioningUserError>;
};

/** A user-readable error */
export type ProvisioningUserError = {
  __typename?: 'ProvisioningUserError';
  /** A description of the error */
  message: Scalars['String']['output'];
  /** Which input value this error came from */
  path?: Maybe<Array<Scalars['String']['output']>>;
};

/** Type defined so its fields will be merged directly into NerdGraph's actor type. */
export type QueryHistoryActorStitchedFields = {
  __typename?: 'QueryHistoryActorStitchedFields';
  /** List of records of the query history for the current user. */
  nrql?: Maybe<Array<QueryHistoryNrqlHistoryResult>>;
};


/** Type defined so its fields will be merged directly into NerdGraph's actor type. */
export type QueryHistoryActorStitchedFieldsNrqlArgs = {
  options?: InputMaybe<QueryHistoryQueryHistoryOptionsInput>;
};

/** Represents the result of the query history record. */
export type QueryHistoryNrqlHistoryResult = {
  __typename?: 'QueryHistoryNrqlHistoryResult';
  /** List of cross accounts where the query is executed. */
  accountIds?: Maybe<Array<Scalars['Int']['output']>>;
  /** The time the query was created as an ISO8601 formatted string. */
  createdAt?: Maybe<Scalars['DateTime']['output']>;
  /** Query executed. */
  query?: Maybe<Scalars['Nrql']['output']>;
};

/** Input condition to select query records. */
export type QueryHistoryQueryHistoryOptionsInput = {
  /** Total number of query records to be returned. */
  limit?: InputMaybe<Scalars['Int']['input']>;
};

/** Input for recording a NRQL query in the user's query history. */
export type QueryHistoryRecordNrqlInput = {
  /** List of accounts on which the query is executed. */
  accountIds: Array<Scalars['Int']['input']>;
  /** The NRQL query string. */
  query: Scalars['Nrql']['input'];
};

/** Represents the result of recording a NRQL query. */
export type QueryHistoryRecordNrqlResult = {
  __typename?: 'QueryHistoryRecordNrqlResult';
  /** The time the query was created as an ISO8601 formatted string. */
  createdAt?: Maybe<Scalars['DateTime']['output']>;
};

export type RealAgent = {
  __typename?: 'RealAgent';
  dispatcher?: Maybe<Scalars['String']['output']>;
  host?: Maybe<Scalars['String']['output']>;
  id?: Maybe<Scalars['Int']['output']>;
  language?: Maybe<Scalars['String']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  port?: Maybe<Scalars['Int']['output']>;
  updatedAt?: Maybe<Scalars['EpochMilliseconds']['output']>;
};

/** Type that wraps the errors from a entity create operation. */
export type ReferenceEntityCreateRepositoryError = {
  __typename?: 'ReferenceEntityCreateRepositoryError';
  /** Guid related to the error. */
  guid?: Maybe<Scalars['EntityGuid']['output']>;
  /** User-friendly message describing the error. */
  message: Scalars['String']['output'];
  /** Describes all potential error types that a create operation might return. */
  type: ReferenceEntityCreateRepositoryErrorType;
};

/** List of all potential error types that an entity create operation might return. */
export enum ReferenceEntityCreateRepositoryErrorType {
  /** Forbidden request */
  Forbidden = 'FORBIDDEN',
  /** Invalid input */
  InvalidInput = 'INVALID_INPUT'
}

/** Information needed to create a repository entity. */
export type ReferenceEntityCreateRepositoryInput = {
  /** The account id this repository will live under. */
  accountId: Scalars['Int']['input'];
  /** The name of the repository. */
  name: Scalars['String']['input'];
  /** The url of the repository. */
  url: Scalars['String']['input'];
};

/** Response type for create operations over entities. */
export type ReferenceEntityCreateRepositoryResult = {
  __typename?: 'ReferenceEntityCreateRepositoryResult';
  /** The list of entities guids that have been created correctly. */
  created: Array<Scalars['EntityGuid']['output']>;
  /** List of failures for the create operation. */
  failures: Array<ReferenceEntityCreateRepositoryError>;
  /** The list of entities guids that have been updated correctly. */
  updated: Array<Scalars['EntityGuid']['output']>;
};

export type Region = {
  __typename?: 'Region';
  code?: Maybe<Scalars['String']['output']>;
  id?: Maybe<Scalars['Int']['output']>;
  name?: Maybe<Scalars['String']['output']>;
};

export enum RegionScope {
  /** Do not filter by region */
  Global = 'GLOBAL',
  /** Filter by region */
  InRegion = 'IN_REGION'
}

/** Related dashboards found for an entity GUID */
export type RelatedDashboardsRelatedDashboardResult = {
  __typename?: 'RelatedDashboardsRelatedDashboardResult';
  /**
   * GUIDs of dashboards related to the given entity; empty if none found
   * @deprecated [DEPRECATED] Use dashboards field instead
   */
  dashboardGuids: Array<Scalars['EntityGuid']['output']>;
  /** EntityOutlines of dashboards related to the given entity; empty if none found */
  dashboards: Array<EntityOutline>;
};

/** The direction of a connected entity. */
export enum RelatedExternalsDirection {
  /**
   * A downstream dependency.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  Downstream = 'DOWNSTREAM',
  /**
   * The entity at the center of these dependencies.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  FocalEntity = 'FOCAL_ENTITY',
  /**
   * An upstream dependency.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  Upstream = 'UPSTREAM'
}

/** A connection between two entities in the entity connections result graph. */
export type RelatedExternalsEntityEdge = {
  __typename?: 'RelatedExternalsEntityEdge';
  /**
   * Performance data for an edge in the entity connections result graph.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  performance?: Maybe<Array<RelatedExternalsPerformance>>;
  /**
   * The entity of the source (upstream) vertex in the entity connections result graph.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  sourceEntity: EntityOutline;
  /**
   * The entity guid of the source (upstream) vertex in the entity connections result graph.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  sourceEntityGuid: Scalars['EntityGuid']['output'];
  /**
   * The ID of the source (upstream) vertex in the entity connections result graph.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  sourceId: Scalars['ID']['output'];
  /**
   * The entity of the target (downstream) vertex in the entity result graph.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  targetEntity: EntityOutline;
  /**
   * The entity guid of the target (downstream) vertex in the entity connections result graph.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  targetEntityGuid: Scalars['EntityGuid']['output'];
  /**
   * The ID of the target (downstream) vertex in the entity transaction connections result graph.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  targetId: Scalars['ID']['output'];
};

/** Lists upstream and downstream dependencies for the specified entity, including performance data during the given time window. */
export type RelatedExternalsEntityResult = {
  __typename?: 'RelatedExternalsEntityResult';
  /**
   * Dependencies between entities in the entity connections result graph.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  edges?: Maybe<Array<RelatedExternalsEntityEdge>>;
  /**
   * Entities in the entity connections result graph.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  vertices?: Maybe<Array<RelatedExternalsEntityVertex>>;
};

/** An entity in the entity connections result graph. */
export type RelatedExternalsEntityVertex = {
  __typename?: 'RelatedExternalsEntityVertex';
  /**
   * The direction of the vertex
   * @deprecated This field is experimental and subject to breaking changes.
   */
  direction: RelatedExternalsDirection;
  /**
   * The entity for a vertex in the entity connections result graph.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  entity: EntityOutline;
  /**
   * The entity guid for a vertex in the entity connections result graph.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  entityGuid: Scalars['EntityGuid']['output'];
  /**
   * The ID for a vertex in the entity transaction connections result graph.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  id: Scalars['ID']['output'];
  /**
   * Performance data for a vertex in the entity connections result graph.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  performance?: Maybe<Array<RelatedExternalsPerformance>>;
};

/** Entity connection performance values */
export type RelatedExternalsPerformance = {
  __typename?: 'RelatedExternalsPerformance';
  /**
   * The average value for the signal over the queried time window.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  averageValue: Scalars['Float']['output'];
  /**
   * The name of the performance signal.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  name: Scalars['String']['output'];
  /**
   * Time series performance data for the performance signal.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  timeseries: Array<RelatedExternalsPerformanceValue>;
  /**
   * The unit for the performance signal.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  unit: Scalars['String']['output'];
};

/** A time series value for an entity connection performance signal. */
export type RelatedExternalsPerformanceValue = {
  __typename?: 'RelatedExternalsPerformanceValue';
  /**
   * The average value of the signal at the given time.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  averageValue: Scalars['Float']['output'];
  /**
   * The start time in epoch milliseconds for this value.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  timestamp: Scalars['EpochMilliseconds']['output'];
};

/** Specifies an entity, either upstream or downstream of the queried entity, to filter results to. */
export type RelatedExternalsSearch = {
  /** Specify the direction of the connected entity: (UPSTREAM or DOWNSTREAM). */
  direction: RelatedExternalsDirection;
  /** Filter to a specific connected entity. */
  entityGuid: Scalars['EntityGuid']['input'];
};

/** A connection between two entity transactions on two entities in the entity transaction connections result graph. */
export type RelatedExternalsTransactionEdge = {
  __typename?: 'RelatedExternalsTransactionEdge';
  /**
   * Performance data for an edge in the entity transaction connections result graph.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  performance?: Maybe<Array<RelatedExternalsPerformance>>;
  /**
   * The ID of the source (upstream) vertex in the entity transaction connections result graph.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  sourceId: Scalars['ID']['output'];
  /**
   * The ID of the target (downstream) vertex in the entity transaction connections result graph.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  targetId: Scalars['ID']['output'];
};

/** Lists transaction dependencies between the two specified entities, including performance data during the given time window. */
export type RelatedExternalsTransactionResult = {
  __typename?: 'RelatedExternalsTransactionResult';
  /**
   * Dependencies between transactions on two specified entities.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  edges?: Maybe<Array<RelatedExternalsTransactionEdge>>;
  /**
   * Transactions for each entity in the entity transaction connections result graph.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  vertices?: Maybe<Array<RelatedExternalsTransactionVertex>>;
};

/** An entity transaction in the entity transaction connections result graph. */
export type RelatedExternalsTransactionVertex = {
  __typename?: 'RelatedExternalsTransactionVertex';
  /**
   * The direction of the vertex
   * @deprecated This field is experimental and subject to breaking changes.
   */
  direction: RelatedExternalsDirection;
  /**
   * The entity for a vertex in the entity transaction connections result graph.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  entity: EntityOutline;
  /**
   * The entity guid for a vertex in the entity transaction connections result graph.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  entityGuid: Scalars['EntityGuid']['output'];
  /**
   * The ID for a vertex in the entity transaction connections result graph.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  id: Scalars['ID']['output'];
  /**
   * Performance data for a vertex in the entity transaction connections result graph.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  performance?: Maybe<Array<RelatedExternalsPerformance>>;
  /**
   * The transaction for a vertex in the entity transaction connections result graph.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  transactionName?: Maybe<Scalars['String']['output']>;
};

/** This object exposes contextual information about an API request. */
export type RequestContext = {
  __typename?: 'RequestContext';
  /** The API key used to make this request */
  apiKey?: Maybe<Scalars['String']['output']>;
  /** The id of the user making this request */
  userId?: Maybe<Scalars['ID']['output']>;
};

/** This describes the root cause chain */
export type RootCauseAnalysisAsyncResult = {
  __typename?: 'RootCauseAnalysisAsyncResult';
  /**
   * A lists describing step by step the root cause chain
   * @deprecated This field is experimental and subject to breaking changes.
   */
  requestId: Scalars['String']['output'];
};

/** This is a key value representing context item */
export type RootCauseAnalysisContextItem = {
  __typename?: 'RootCauseAnalysisContextItem';
  /**
   * Context item key
   * @deprecated This field is experimental and subject to breaking changes.
   */
  key: Scalars['String']['output'];
  /**
   * Context item val
   * @deprecated This field is experimental and subject to breaking changes.
   */
  val: Scalars['String']['output'];
};

/** This describes the root cause chain */
export type RootCauseAnalysisResult = {
  __typename?: 'RootCauseAnalysisResult';
  /**
   * True: async operation is in progress as results are being processed. False: async operation complete
   * @deprecated This field is experimental and subject to breaking changes.
   */
  asyncInProgress: Scalars['Boolean']['output'];
  /**
   * A lists describing step by step the root cause chain
   * @deprecated This field is experimental and subject to breaking changes.
   */
  results?: Maybe<Array<RootCauseAnalysisResultItem>>;
};

/** This describes the root cause chain */
export type RootCauseAnalysisResultItem = {
  __typename?: 'RootCauseAnalysisResultItem';
  /**
   * Overall confidence in the solution
   * @deprecated This field is experimental and subject to breaking changes.
   */
  confidence: Scalars['Float']['output'];
  /**
   * A lists describing step by step the root cause chain
   * @deprecated This field is experimental and subject to breaking changes.
   */
  details: Array<RootCauseAnalysisStepResult>;
  /**
   * True if root cause succeeded, False otherwise
   * @deprecated This field is experimental and subject to breaking changes.
   */
  success: Scalars['String']['output'];
};

/** Please set values for filter */
export type RootCauseAnalysisSearchFilter = {
  /** Search time window. If not specified, defaults to the past hour. */
  timeWindow?: InputMaybe<TimeWindowInput>;
};

/** This describes one stage in the root cause */
export type RootCauseAnalysisStepResult = {
  __typename?: 'RootCauseAnalysisStepResult';
  /**
   * Confidence in the findings
   * @deprecated This field is experimental and subject to breaking changes.
   */
  confidence: Scalars['Float']['output'];
  /**
   * This provides an additional context to this step
   * @deprecated This field is experimental and subject to breaking changes.
   */
  context: Array<RootCauseAnalysisContextItem>;
  /**
   * Description of the findings
   * @deprecated This field is experimental and subject to breaking changes.
   */
  description: Scalars['String']['output'];
  /**
   * Stage in the root cause pipe
   * @deprecated This field is experimental and subject to breaking changes.
   */
  entity?: Maybe<EntityOutline>;
  /**
   * Investigated entity guid
   * @deprecated This field is experimental and subject to breaking changes.
   */
  reason: Scalars['String']['output'];
  /**
   * Stage number in the root cause pipe
   * @deprecated This field is experimental and subject to breaking changes.
   */
  step: Scalars['Int']['output'];
};

/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationType = {
  __typename?: 'RootMutationType';
  /** This calculates which experimental variation a user should see. NOTE: Calling this function will record an impression! */
  abTestGetVariation?: Maybe<AbTestGetVariationResponse>;
  /** This tracks user behaviors. */
  abTestTrackEvent?: Maybe<Scalars['Boolean']['output']>;
  accountFeatureConfigurationSetFedrampCompliance: AccountFeatureConfigurationSetFedrampComplianceResult;
  accountFeatureConfigurationSetHipaaCompliance: AccountFeatureConfigurationSetHipaaComplianceResult;
  /** Creates an organization-scoped account. */
  accountManagementCreateAccount?: Maybe<AccountManagementCreateResponse>;
  /** Updates an account. */
  accountManagementUpdateAccount?: Maybe<AccountManagementUpdateResponse>;
  /** Accept an invitation by passing it's token */
  accountShareInvitationsAcceptInvitation?: Maybe<AccountShareInvitationsAcceptInvitationByTokenMutationPayload>;
  /** Create an account share invitation */
  accountShareInvitationsCreateAccountShareInvitation?: Maybe<AccountShareInvitationsCreateAccountShareMutationPayload>;
  /** Revoke an invitation */
  accountShareInvitationsRevokeInvitation?: Maybe<AccountShareInvitationsRevokeInvitationByIdMutationPayload>;
  /** If you aren't using an auto-instrumenting agent on the backend, use this to set up browser monitoring for an application. For more information on enabling copy/paste, [see our docs](https://docs.newrelic.com/docs/browser/browser-monitoring/installation/install-browser-monitoring-agent/#copy-paste-app) */
  agentApplicationCreateBrowser?: Maybe<AgentApplicationCreateBrowserResult>;
  /** Create a new mobile application. */
  agentApplicationCreateMobile?: Maybe<AgentApplicationCreateMobileResult>;
  /** Deletes a browser, mobile, or APM application. This isn't allowed if an application is actively reporting data. */
  agentApplicationDelete?: Maybe<AgentApplicationDeleteResult>;
  /** Enable browser monitoring for an application monitored by APM. For information about specific APM agents, [see our docs](https://docs.newrelic.com/docs/browser/browser-monitoring/installation/install-browser-monitoring-agent/#agent-instrumentation) */
  agentApplicationEnableApmBrowser?: Maybe<AgentApplicationEnableBrowserResult>;
  /** Replaces the entity's allow list with the provided segments. */
  agentApplicationSegmentsReplaceAllBrowserSegmentAllowList?: Maybe<AgentApplicationSegmentsBrowserSegmentAllowListResult>;
  /** Update configuration for APM applications. Includes thresholds for how often to record Transaction traces, SQL traces, enabling Distributed traces, ignoring certain error classes. This is the main mutation that powers the Application > Settings page in APM. */
  agentApplicationSettingsUpdate?: Maybe<AgentApplicationSettingsUpdateResult>;
  /** Deletes an existing error trace returning a collection of errors if any */
  agentTracesDeleteErrorTrace?: Maybe<AgentTracesTraceMutationResult>;
  /** Deletes all existing Error traces for the provided realAgentsIds returning a collection of errors if any */
  agentTracesDeleteErrorTraces?: Maybe<AgentTracesTraceMutationResult>;
  /** Deletes an existing SQL trace returning a collection of errors if any */
  agentTracesDeleteSqlTrace?: Maybe<AgentTracesTraceMutationResult>;
  /** Deletes all existing SQL traces for the provided realAgentsIds returning a collection of errors if any */
  agentTracesDeleteSqlTraces?: Maybe<AgentTracesTraceMutationResult>;
  /** Deletes an existing Transaction trace returning a collection of errors if any */
  agentTracesDeleteTransactionTrace?: Maybe<AgentTracesTraceMutationResult>;
  /** Deletes all existing Transaction traces for the provided realAgentsIds returning a collection of errors if any */
  agentTracesDeleteTransactionTraces?: Maybe<AgentTracesTraceMutationResult>;
  /** Create Enrichers and attach them to a given Workflow, returns the entire Workflow */
  aiConnectAddEnrichers: AiConnectWorkflowResponse;
  /** Create a new Notifier and attach it to a given Workflow */
  aiConnectAddNotifier: AiConnectWorkflowResponse;
  /** Creates a new Connect Workflow */
  aiConnectCreateWorkflow: AiConnectWorkflowResponse;
  /** Delete an Enricher from the system */
  aiConnectDeleteEnricher: AiConnectDeleteResponse;
  /** Delete a Notifier from the system */
  aiConnectDeleteNotifier: AiConnectDeleteResponse;
  /** Delete a Workflow and all its entities from the system */
  aiConnectDeleteWorkflow: AiConnectDeleteResponse;
  /** Edit an Enricher, return the successfully updated Enrichers and/or errors */
  aiConnectEditEnricher: AiConnectResponse;
  /** Edit a Notifier by Id, return the successfully updated Notifiers and/or errors */
  aiConnectEditNotifier: AiConnectResponse;
  /** Update a Workflow by Id - change name, policies or status */
  aiConnectEditWorkflow: AiConnectWorkflowResponse;
  /** Test a single Notifier */
  aiConnectTestNotifier: AiConnectNotifierTestResponse;
  /** Test a single Notifier after it was saved */
  aiConnectTestNotifierById: AiConnectNotifierTestResponse;
  /** Test a complete Workflow before saving it */
  aiConnectTestWorkflow: AiConnectWorkflowTestResponse;
  /** Test a complete workflow after it was saved, only test active components (enrichers/notifiers) */
  aiConnectTestWorkflowById: AiConnectWorkflowTestResponse;
  /** Accept and deploy an existing suggested rule. */
  aiDecisionsAcceptSuggestion: AiDecisionsRule;
  /** Create and deploy a new implicit rule. */
  aiDecisionsCreateImplicitRule: AiDecisionsRule;
  /** Create and deploy a new rule. */
  aiDecisionsCreateRule: AiDecisionsRule;
  /** Create a new suggested rule. */
  aiDecisionsCreateSuggestion: AiDecisionsSuggestion;
  /** Decline an existing suggested rule. */
  aiDecisionsDeclineSuggestion: AiDecisionsOperationResult;
  /** Delete existing feedback for a merge. */
  aiDecisionsDeleteMergeFeedback: AiDecisionsOperationResult;
  /** Delete an existing rule. */
  aiDecisionsDeleteRule: AiDecisionsOperationResult;
  /** Delete an existing suggested rule. */
  aiDecisionsDeleteSuggestion: AiDecisionsOperationResult;
  /** Disable an existing enabled rule. */
  aiDecisionsDisableRule: AiDecisionsOperationResult;
  /** Enable an existing disabled rule. */
  aiDecisionsEnableRule: AiDecisionsOperationResult;
  /** Create a search operation to fetch applicable incidents for a rule expression */
  aiDecisionsFindApplicableIncidents: AiDecisionsApplicableIncidentSearch;
  /** Postpone an existing suggested rule. */
  aiDecisionsPostponeSuggestion: AiDecisionsRule;
  /** Record feedback for a merge */
  aiDecisionsRecordMergeFeedback: AiDecisionsMergeFeedback;
  /** Create an arbitrary expression simulation. */
  aiDecisionsSimulate: AiDecisionsSimulation;
  /** Update an existing implicit rule. */
  aiDecisionsUpdateImplicitRule: AiDecisionsRule;
  /** Update an existing rule. */
  aiDecisionsUpdateRule: AiDecisionsRule;
  /** Acknowledge issue */
  aiIssuesAckIssue: AiIssuesIssueUserActionResponse;
  /** Close incident */
  aiIssuesCloseIncident?: Maybe<AiIssuesIncidentUserActionResponse>;
  /** Resolve issue */
  aiIssuesResolveIssue: AiIssuesIssueUserActionResponse;
  /** Unacknowledge issue */
  aiIssuesUnackIssue: AiIssuesIssueUserActionResponse;
  /** Set interval between issue being created and being activated (and user being notified) */
  aiIssuesUpdateGracePeriod: AiIssuesConfigurationOverrideResponse;
  /** Update issue TTL */
  aiIssuesUpdateIssueTtl: AiIssuesConfigurationOverrideResponse;
  /** Create a Channel */
  aiNotificationsCreateChannel: AiNotificationsChannelResponse;
  /** Create a Destination */
  aiNotificationsCreateDestination: AiNotificationsDestinationResponse;
  /** Delete a Channel */
  aiNotificationsDeleteChannel: AiNotificationsDeleteResponse;
  /** Delete a Destination */
  aiNotificationsDeleteDestination: AiNotificationsDeleteResponse;
  /** Merge several destinations together */
  aiNotificationsMergeDestinations?: Maybe<AiNotificationsMergeDestinationsResponse>;
  /** Test notifications */
  aiNotificationsTestChannel: AiNotificationsChannelTestResponse;
  /** Test channel by channelId */
  aiNotificationsTestChannelById: AiNotificationsChannelTestResponse;
  /** Test connection */
  aiNotificationsTestDestination: AiNotificationsDestinationTestResponse;
  /** Test connection by destination id */
  aiNotificationsTestDestinationById: AiNotificationsDestinationTestResponse;
  /** Update a Channel */
  aiNotificationsUpdateChannel: AiNotificationsChannelResponse;
  /** Update a Destination */
  aiNotificationsUpdateDestination: AiNotificationsDestinationResponse;
  /** Add an Incident Intelligence destination to all of the provided configurations */
  aiOpsAddIncidentIntelligenceDestinationToConfigs?: Maybe<AiOpsProactiveDetectionConfigMutationResults>;
  /**
   * Archive a Proactive Detection configuration.
   * These allow users to stop receiving events for the configured entities.
   */
  aiOpsArchiveProactiveDetectionConfig?: Maybe<AiOpsProactiveDetectionConfigMutationResult>;
  /** Clear a user message view */
  aiOpsClearUserMessage?: Maybe<AiOpsUserMessageResult>;
  /** Closes an anomaly */
  aiOpsCloseAnomaly?: Maybe<AiOpsAnomalyCloseResult>;
  /** Creates a comment for an anomaly */
  aiOpsCreateAnomalyComment?: Maybe<AiOpsCommentsResult>;
  /**
   * Draft a Proactive Detection configuration.
   * Drafts allow users to store temporary changes to a config.
   * Drafts will be ignored whenever events are detected.
   */
  aiOpsCreateDraftProactiveDetectionConfig?: Maybe<AiOpsProactiveDetectionConfigMutationResult>;
  /** Creates a comment for an incident */
  aiOpsCreateIncidentComment?: Maybe<AiOpsCommentsResult>;
  /**
   * Create a Proactive Detection configuration.
   * These allow users to subscribe to events detected by the AiOps platform.
   */
  aiOpsCreateProactiveDetectionConfig?: Maybe<AiOpsProactiveDetectionConfigMutationResult>;
  /** Deletes a comment */
  aiOpsDeleteComment?: Maybe<AiOpsCommentDeleteResult>;
  /** Preview the request that will be sent when the webhook is called */
  aiOpsPreviewWebhook?: Maybe<AiOpsWebhookPreviewResult>;
  /** Remove an Incident Intelligence destination to all of the provided configurations */
  aiOpsRemoveIncidentIntelligenceDestinationFromConfigs?: Maybe<AiOpsProactiveDetectionConfigMutationResults>;
  /** Stores a training session for an entity guid */
  aiOpsStoreTrainingSession: AiOpsStoreTrainingSessionResult;
  /** Send a test notification to the webhook */
  aiOpsTestWebhook?: Maybe<AiOpsWebhookTestResult>;
  /**
   * Update a Proactive Detection configuration.
   * These allow users to change the slack channels or entities associated with a real time failure warning.
   */
  aiOpsUpdateProactiveDetectionConfig?: Maybe<AiOpsProactiveDetectionConfigMutationResult>;
  /** Tracks when a user has acknowledged viewing a particular User Message */
  aiOpsViewUserMessage?: Maybe<AiOpsUserMessageResult>;
  /**
   * Create a postmortem piece.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  aiPostmortemCreatePostmortem: Scalars['String']['output'];
  /**
   * Delete a postmortem piece.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  aiPostmortemDeletePostmortem: AiPostmortemOperationResult;
  /**
   * Update a postmortem piece.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  aiPostmortemUpdatePostmortem: Scalars['String']['output'];
  /** Create a list of new edges. */
  aiTopologyCollectorCreateEdges: AiTopologyCollectorOperationResult;
  /** Create a list of new vertices. */
  aiTopologyCollectorCreateVertices: AiTopologyCollectorOperationResult;
  /** Delete an existing list of edges. */
  aiTopologyCollectorDeleteEdges: AiTopologyCollectorOperationResult;
  /** Delete an existing list of vertices. */
  aiTopologyCollectorDeleteVertices: AiTopologyCollectorOperationResult;
  /** Create a new Workflow with issues filter, enrichments and destinations */
  aiWorkflowsCreateWorkflow: AiWorkflowsCreateWorkflowResponse;
  /** Delete a workflow and all it's sub entities: filter, enrichments and destinations */
  aiWorkflowsDeleteWorkflow: AiWorkflowsDeleteWorkflowResponse;
  /** test a workflow and all it's sub entities: filter, enrichments and destinations */
  aiWorkflowsTestWorkflow: AiWorkflowsTestWorkflowResponse;
  /** Update Workflow with issues filter, enrichments and destinations */
  aiWorkflowsUpdateWorkflow: AiWorkflowsUpdateWorkflowResponse;
  /** Delete an Alerts condition. */
  alertsConditionDelete?: Maybe<AlertsConditionDeleteResponse>;
  /** Enable or disable an Alerts condition. */
  alertsConditionUpdateEnabled?: Maybe<AlertsConditionUpdateEnabledResponse>;
  /** Create a muting rule for New Relic Alerts violations. */
  alertsMutingRuleCreate?: Maybe<AlertsMutingRule>;
  /** Delete a muting rule for New Relic Alerts violations. */
  alertsMutingRuleDelete?: Maybe<AlertsMutingRuleDeleteResponse>;
  /** Update a muting rule for New Relic Alerts violations. */
  alertsMutingRuleUpdate?: Maybe<AlertsMutingRule>;
  /**
   * Creates a notification channel
   * @deprecated Support for notification channels is being discontinued as of **Dec 31, 2023**. Use the [`aiNotificationsCreateDestination` mutation](https://docs.newrelic.com/docs/apis/nerdgraph/examples/nerdgraph-api-notifications-destinations/#create-destination) instead. For more information about the deprecation, [see the EOL announcement](https://forum.newrelic.com/s/hubtopic/aAX8W0000008dKOWAY/plan-to-upgrade-alert-notification-channels-to-workflows-and-destinations).
   */
  alertsNotificationChannelCreate?: Maybe<AlertsNotificationChannelCreateResponse>;
  /**
   * Deletes a notification channel
   * @deprecated Support for notification channels is being discontinued as of **Dec 31, 2023**. Use the [`aiNotificationsDeleteDestination` mutation](https://docs.newrelic.com/docs/apis/nerdgraph/examples/nerdgraph-api-notifications-destinations/#delete-destination) instead. For more information about the deprecation, [see the EOL announcement](https://forum.newrelic.com/s/hubtopic/aAX8W0000008dKOWAY/plan-to-upgrade-alert-notification-channels-to-workflows-and-destinations).
   */
  alertsNotificationChannelDelete?: Maybe<AlertsNotificationChannelDeleteResponse>;
  /**
   * Updates an existing notification channel
   * @deprecated Support for notification channels is being discontinued as of **Dec 31, 2023**. Use the [`aiNotificationsUpdateDestination` mutation](https://docs.newrelic.com/docs/apis/nerdgraph/examples/nerdgraph-api-notifications-destinations/#update-destination) instead. For more information about the deprecation, [see the EOL announcement](https://forum.newrelic.com/s/hubtopic/aAX8W0000008dKOWAY/plan-to-upgrade-alert-notification-channels-to-workflows-and-destinations).
   */
  alertsNotificationChannelUpdate?: Maybe<AlertsNotificationChannelUpdateResponse>;
  /**
   * Associates notification channels with a policy.
   * @deprecated Support for notification channels is being discontinued as of **Dec 31, 2023**. Use the [`aiWorkflowsCreateWorkflow` mutation](https://docs.newrelic.com/docs/apis/nerdgraph/examples/nerdgraph-api-workflows/#create-workflow) instead. For more information about the deprecation, [see the EOL announcement](https://forum.newrelic.com/s/hubtopic/aAX8W0000008dKOWAY/plan-to-upgrade-alert-notification-channels-to-workflows-and-destinations).
   */
  alertsNotificationChannelsAddToPolicy?: Maybe<AlertsNotificationChannelsAddToPolicyResponse>;
  /**
   * Dissociates notification channels from a policy.
   * @deprecated Support for notification channels is being discontinued as of **Dec 31, 2023**. Use the [`aiWorkflowsDeleteWorkflow` mutation](https://docs.newrelic.com/docs/apis/nerdgraph/examples/nerdgraph-api-workflows/#delete-workflow) instead. For more information about the deprecation, [see the EOL announcement](https://forum.newrelic.com/s/hubtopic/aAX8W0000008dKOWAY/plan-to-upgrade-alert-notification-channels-to-workflows-and-destinations).
   */
  alertsNotificationChannelsRemoveFromPolicy?: Maybe<AlertsNotificationChannelsRemoveFromPolicyResponse>;
  /** Create a baseline NRQL condition. */
  alertsNrqlConditionBaselineCreate?: Maybe<AlertsNrqlBaselineCondition>;
  /** Update a baseline NRQL condition. */
  alertsNrqlConditionBaselineUpdate?: Maybe<AlertsNrqlBaselineCondition>;
  /**
   * Create an outlier NRQL condition.
   * @deprecated Outlier condition creation stops Dec 8th, 2021. All outlier conditions will be removed Mar 31, 2022.
   */
  alertsNrqlConditionOutlierCreate?: Maybe<AlertsNrqlOutlierCondition>;
  /**
   * Update an outlier NRQL condition.
   * @deprecated Were removing outlier conditions on Mar 31, 2022.
   */
  alertsNrqlConditionOutlierUpdate?: Maybe<AlertsNrqlOutlierCondition>;
  /** Create a static NRQL condition. */
  alertsNrqlConditionStaticCreate?: Maybe<AlertsNrqlStaticCondition>;
  /** Update a static NRQL condition. */
  alertsNrqlConditionStaticUpdate?: Maybe<AlertsNrqlStaticCondition>;
  /** Create an Alerts policy. */
  alertsPolicyCreate?: Maybe<AlertsPolicy>;
  /** Delete an Alerts policy. This archives all conditions associated to the policy. */
  alertsPolicyDelete?: Maybe<AlertsPolicyDeleteResponse>;
  /** Update an Alerts policy. */
  alertsPolicyUpdate?: Maybe<AlertsPolicy>;
  /**
   * Delete an anomaly detector.
   * @deprecated Usage not recommended. Will be removed in future release.
   */
  anomalyDetectorConfigurationsAnomalyDetectorDelete?: Maybe<AnomalyDetectorConfigurationsAnomalyDetectorDeleteResponse>;
  /**
   * Create an anomaly detector scoped to an entity type. An anomaly detector is a set of data checked for anomalies at a regular interval.
   * @deprecated Usage not recommended. Will be removed in future release.
   */
  anomalyDetectorConfigurationsEntityTypeAnomalyDetectorCreate?: Maybe<AnomalyDetectorConfigurationsEntityTypeAnomalyDetectorCreateResponse>;
  /**
   * Update an anomaly detector scoped to an entity type.
   * @deprecated Usage not recommended. Will be removed in future release.
   */
  anomalyDetectorConfigurationsEntityTypeAnomalyDetectorUpdate?: Maybe<AnomalyDetectorConfigurationsEntityTypeAnomalyDetectorUpdateResponse>;
  /**
   * Create an anomaly detector scoped to custom NRQL results. An anomaly detector is a set of data checked for anomalies at a regular interval.
   * @deprecated Usage not recommended. Will be removed in future release.
   */
  anomalyDetectorConfigurationsNrqlAnomalyDetectorCreate?: Maybe<AnomalyDetectorConfigurationsNrqlAnomalyDetectorCreateResponse>;
  /**
   * Update an anomaly detector scoped to custom nrql results.
   * @deprecated Usage not recommended. Will be removed in future release.
   */
  anomalyDetectorConfigurationsNrqlAnomalyDetectorUpdate?: Maybe<AnomalyDetectorConfigurationsNrqlAnomalyDetectorUpdateResponse>;
  /**
   * Change the status of any type of anomaly detector.
   * @deprecated Usage not recommended. Will be removed in future release.
   */
  anomalyDetectorConfigurationsUpdateStatus?: Maybe<AnomalyDetectorConfigurationsStatusUpdateResponse>;
  /**
   * Verify a NRQL query is valid for use in an anomaly detector. Anomaly detection does not support all valid NRQL features.
   * @deprecated Usage not recommended. Will be removed in future release.
   */
  anomalyDetectorConfigurationsValidateNrqlSignal?: Maybe<AnomalyDetectorConfigurationsNrqlValidatorResponse>;
  /**
   * Create an anomaly detector scoped to entities in a workload. An anomaly detector is a set of data checked for anomalies at a regular interval.
   * @deprecated Usage not recommended. Will be removed in future release.
   */
  anomalyDetectorConfigurationsWorkloadAnomalyDetectorCreate?: Maybe<AnomalyDetectorConfigurationsWorkloadAnomalyDetectorCreateResponse>;
  /**
   * Update an anomaly detector scoped to entities in a workload.
   * @deprecated Usage not recommended. Will be removed in future release.
   */
  anomalyDetectorConfigurationsWorkloadAnomalyDetectorUpdate?: Maybe<AnomalyDetectorConfigurationsWorkloadAnomalyDetectorUpdateResponse>;
  /** Create keys. You can create keys for multiple accounts at once. You can read more about managing keys on [this documentation page](https://docs.newrelic.com/docs/apis/nerdgraph/examples/use-nerdgraph-manage-license-keys-personal-api-keys). */
  apiAccessCreateKeys?: Maybe<ApiAccessCreateKeyResponse>;
  /** A mutation to delete keys. */
  apiAccessDeleteKeys?: Maybe<ApiAccessDeleteKeyResponse>;
  /** Update keys. You can update keys for multiple accounts at once. You can read more about managing keys on [this documentation page](https://docs.newrelic.com/docs/apis/nerdgraph/examples/use-nerdgraph-manage-license-keys-personal-api-keys). */
  apiAccessUpdateKeys?: Maybe<ApiAccessUpdateKeyResponse>;
  /**
   * Change the settings of an ApmApplicationEntity.
   * @deprecated This mutation is deprecated. Use `agentApplicationSettingsUpdate` instead.
   */
  apmApplicationEntityChangeSettings?: Maybe<ApmApplicationEntitySettingsResult>;
  /** Grant access for a group */
  authorizationManagementGrantAccess?: Maybe<AuthorizationManagementGrantAccessPayload>;
  /** Revoke access for a group */
  authorizationManagementRevokeAccess?: Maybe<AuthorizationManagementRevokeAccessPayload>;
  /**
   * Create a list of new edges.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  cartographerCollectorCreateEdges: CartographerCollectorOperationResult;
  /**
   * Create a list of new vertices.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  cartographerCollectorCreateVertices: CartographerCollectorOperationResult;
  /**
   * Delete an existing list of edges.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  cartographerCollectorDeleteEdges: CartographerCollectorOperationResult;
  /**
   * Delete an existing list of vertices.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  cartographerCollectorDeleteVertices: CartographerCollectorOperationResult;
  /** Creates a new change tracking event in NRDB and its associated marker. */
  changeTrackingCreateChangeTrackingEvent?: Maybe<ChangeTrackingChangeTrackingResponse>;
  /** Creates a new deployment record in NRDB and its associated deployment marker. */
  changeTrackingCreateDeployment?: Maybe<ChangeTrackingDeployment>;
  /**
   * Begin a chaos test with the provided configuration.
   *
   * When this mutation is run by a user, it will affect all queries made by that user
   * for 1 hour, or until the `chaosEnd` mutation is sent. Chaos testing is only available in `staging`.
   *
   * For more information visit the [Chaos Testing docs](https://pages.datanerd.us/unified-api/nerdgraph-documentation/platform/chaos_testing/)
   */
  chaosStart?: Maybe<Scalars['String']['output']>;
  chaosStop?: Maybe<Scalars['String']['output']>;
  /**
   * Create or modify a cloud integration.
   *
   * For details and mutation examples visit
   * [our docs](https://docs.newrelic.com/docs/apis/graphql-api/tutorials/manage-your-aws-azure-google-cloud-integrations-graphql-api).
   */
  cloudConfigureIntegration?: Maybe<CloudConfigureIntegrationPayload>;
  /**
   * Disable a cloud integration. Stops collecting data for the specified integration.
   *
   * For details and mutation examples visit
   * [our docs](https://docs.newrelic.com/docs/apis/graphql-api/tutorials/manage-your-aws-azure-google-cloud-integrations-graphql-api).
   */
  cloudDisableIntegration?: Maybe<CloudDisableIntegrationPayload>;
  /**
   * Create the credentials for the auth of the service account, if the credentials are already created just gets it.
   * The return value is an unique guid that is bound to the credentials
   */
  cloudGcpServiceAccountAuth?: Maybe<CloudGcpServiceAccountAuthPayload>;
  /**
   * Link a cloud provider account to a New Relic Account.
   *
   * For details and mutation examples visit
   * [our docs](https://docs.newrelic.com/docs/apis/graphql-api/tutorials/manage-your-aws-azure-google-cloud-integrations-graphql-api).
   */
  cloudLinkAccount?: Maybe<CloudLinkAccountPayload>;
  /**
   * Migrate one or more existing AWS GovCloud Accounts to use AssumeRole authentication.
   *
   * For details and mutation examples visit
   * [our docs](https://docs.newrelic.com/docs/apis/graphql-api/tutorials/manage-your-aws-azure-google-cloud-integrations-graphql-api).
   */
  cloudMigrateAwsGovCloudToAssumeRole?: Maybe<CloudMigrateAwsGovCloudToAssumeRolePayload>;
  /**
   * Rename one or more linked cloud provider accounts.
   *
   * For details and mutation examples visit
   * [our docs](https://docs.newrelic.com/docs/apis/graphql-api/tutorials/manage-your-aws-azure-google-cloud-integrations-graphql-api).
   */
  cloudRenameAccount?: Maybe<CloudRenameAccountPayload>;
  /**
   * Unlink one or more cloud provider accounts.
   * Stops collecting data for all the associated integrations.
   *
   * For details and mutation examples visit
   * [our docs](https://docs.newrelic.com/docs/apis/graphql-api/tutorials/manage-your-aws-azure-google-cloud-integrations-graphql-api).
   */
  cloudUnlinkAccount?: Maybe<CloudUnlinkAccountPayload>;
  /**
   * Create code mark
   * @deprecated This field is experimental and subject to breaking changes.
   */
  collaborationCreateCodeMark?: Maybe<CollaborationCodeMark>;
  /**
   * Create a new comment on a thread
   * @deprecated This field is experimental and subject to breaking changes.
   */
  collaborationCreateComment?: Maybe<CollaborationComment>;
  /**
   * Create a context
   * @deprecated This field is experimental and subject to breaking changes.
   */
  collaborationCreateContext?: Maybe<CollaborationContext>;
  /**
   * Create a new email address to mention
   * @deprecated This field is experimental and subject to breaking changes.
   */
  collaborationCreateEmail?: Maybe<CollaborationEmail>;
  /**
   * Create an external service connection
   * @deprecated This field is experimental and subject to breaking changes.
   */
  collaborationCreateExternalServiceConnection?: Maybe<CollaborationExternalServiceConnection>;
  /**
   * Create a new mention
   * @deprecated This field is experimental and subject to breaking changes.
   */
  collaborationCreateMention?: Maybe<CollaborationMention>;
  /**
   * Create a new thread
   * @deprecated This field is experimental and subject to breaking changes.
   */
  collaborationCreateThread?: Maybe<CollaborationThread>;
  /**
   * deactivates code mark
   * @deprecated This field is experimental and subject to breaking changes.
   */
  collaborationDeactivateCodeMark?: Maybe<CollaborationCodeMark>;
  /**
   * Deactivate a comment
   * @deprecated This field is experimental and subject to breaking changes.
   */
  collaborationDeactivateComment?: Maybe<CollaborationComment>;
  /**
   * Deactivate a context
   * @deprecated This field is experimental and subject to breaking changes.
   */
  collaborationDeactivateContext?: Maybe<CollaborationContext>;
  /**
   * Deactivate an external service connection
   * @deprecated This field is experimental and subject to breaking changes.
   */
  collaborationDeactivateExternalServiceConnection?: Maybe<CollaborationExternalServiceConnection>;
  /**
   * Deactivate a file
   * @deprecated This field is experimental and subject to breaking changes.
   */
  collaborationDeactivateFile?: Maybe<Scalars['String']['output']>;
  /**
   * Deactivate a mention
   * @deprecated This field is experimental and subject to breaking changes.
   */
  collaborationDeactivateMention?: Maybe<CollaborationMention>;
  /**
   * Deactivate a thread
   * @deprecated This field is experimental and subject to breaking changes.
   */
  collaborationDeactivateThread?: Maybe<CollaborationThread>;
  /**
   * Rate a bot reponse
   * @deprecated This field is experimental and subject to breaking changes.
   */
  collaborationFeedbackOnBotResponse?: Maybe<CollaborationBotResponseFeedback>;
  /**
   * Upload a new file
   * @deprecated This field is experimental and subject to breaking changes.
   */
  collaborationGetUploadUrl?: Maybe<CollaborationFile>;
  /**
   * Register the current user's email and map it to any mentions
   * @deprecated This field is experimental and subject to breaking changes.
   */
  collaborationRegisterEmail?: Maybe<CollaborationEmail>;
  /**
   * Send a message without a thread
   * @deprecated This field is experimental and subject to breaking changes.
   */
  collaborationSendMessage?: Maybe<CollaborationMessageSent>;
  /**
   * Set the channel of the external service connection
   * @deprecated This field is experimental and subject to breaking changes.
   */
  collaborationSetExternalServiceConnectionChannel?: Maybe<CollaborationExternalServiceConnection>;
  /**
   * Subscribe your websocket to one or more subscriptionKeys
   * @deprecated This field is experimental and subject to breaking changes.
   */
  collaborationSocketSubscribe?: Maybe<Scalars['String']['output']>;
  /**
   * Subscribe to a thread
   * @deprecated This field is experimental and subject to breaking changes.
   */
  collaborationSubscribeToThread?: Maybe<CollaborationSubscriber>;
  /**
   * Unsubscribe from a thread
   * @deprecated This field is experimental and subject to breaking changes.
   */
  collaborationUnsubscribeFromThread?: Maybe<CollaborationSubscriber>;
  /**
   * Update a comment
   * @deprecated This field is experimental and subject to breaking changes.
   */
  collaborationUpdateComment?: Maybe<CollaborationComment>;
  /**
   * Add a comment to the context's comment count
   * @deprecated This field is experimental and subject to breaking changes.
   */
  collaborationUpdateContextAddComment?: Maybe<CollaborationContext>;
  /**
   * Add a thread to a context's thread count
   * @deprecated This field is experimental and subject to breaking changes.
   */
  collaborationUpdateContextAddThread?: Maybe<CollaborationContext>;
  /**
   * Update unread counts for a subscription
   * @deprecated This field is experimental and subject to breaking changes.
   */
  collaborationUpdateSubscriptionReadInfo?: Maybe<CollaborationSubscriber>;
  /**
   * Update a thread with a new comment
   * @deprecated This field is experimental and subject to breaking changes.
   */
  collaborationUpdateThreadAddComment?: Maybe<CollaborationThread>;
  /**
   * Update a thread's status
   * @deprecated This field is experimental and subject to breaking changes.
   */
  collaborationUpdateThreadStatus?: Maybe<CollaborationThread>;
  /** Cancels the customer's active subscription if they pass validations. */
  commerceCancelSubscription?: Maybe<CommerceCancelResult>;
  /** Create payment run for unpaid invoices */
  commerceExecutePaymentRun?: Maybe<Scalars['Boolean']['output']>;
  /** Extend data retention period. */
  commerceExtendRetention?: Maybe<CommercePurchaseResult>;
  /**
   * Certain notifications can be muted for a set period of time. Depending on
   *  the notification, there may be limits on the number of times a request
   *  will be granted.
   */
  commerceNotificationsMuteNotification?: Maybe<CommerceNotificationsMuteNotificationResult>;
  /** Purchases an offer by offerId. */
  commercePurchaseOffer?: Maybe<CommercePurchaseResult>;
  /** Set the default payment method of the account. Only allowed for credit card accounts. */
  commerceSetDefaultPaymentMethod?: Maybe<CommercePaymentInfo>;
  /** Update billing information. */
  commerceUpdateBillingInfo?: Maybe<CommerceBillingInfo>;
  /** Share content with recipients. If the recipient does not exist or does not have access, we will send request access to the Admin of the content. */
  contentSharingShareWithRecipients?: Maybe<ContentSharingShareContentResponse>;
  /**
   * Accept and deploy an existing suggested rule.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  correlationAcceptSuggestion: CorrelationRule;
  /**
   * Create and deploy a new implicit rule.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  correlationCreateImplicitRule: CorrelationRule;
  /**
   * Create and deploy a new rule.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  correlationCreateRule: CorrelationRule;
  /**
   * Create a new suggested rule.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  correlationCreateSuggestion: CorrelationSuggestion;
  /**
   * Decline an existing suggested rule.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  correlationDeclineSuggestion: CorrelationOperationResult;
  /**
   * Delete existing feedback for a merge.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  correlationDeleteMergeFeedback: CorrelationOperationResult;
  /**
   * Delete existing feedback by rule ids for a merge.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  correlationDeleteMergeFeedbackByRules?: Maybe<CorrelationOperationResult>;
  /**
   * Delete an existing rule.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  correlationDeleteRule: CorrelationOperationResult;
  /**
   * Delete an existing suggested rule.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  correlationDeleteSuggestion: CorrelationOperationResult;
  /**
   * Disable an existing enabled rule.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  correlationDisableRule: CorrelationOperationResult;
  /**
   * Enable an existing disabled rule.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  correlationEnableRule: CorrelationOperationResult;
  /**
   * Create a search operation to fetch applicable incidents for a rule expression
   * @deprecated This field is experimental and subject to breaking changes.
   */
  correlationFindApplicableIncidents: CorrelationApplicableIncidentSearch;
  /**
   * Postpone an existing suggested rule.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  correlationPostponeSuggestion: CorrelationRule;
  /**
   * Record feedback for a merge
   * @deprecated This field is experimental and subject to breaking changes.
   */
  correlationRecordMergeFeedback: CorrelationMergeFeedback;
  /**
   * Record feedback by rule ids for a merge
   * @deprecated This field is experimental and subject to breaking changes.
   */
  correlationRecordMergeFeedbackByRules?: Maybe<Array<CorrelationMergeFeedback>>;
  /**
   * Create an arbitrary expression simulation.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  correlationSimulate: CorrelationSimulation;
  /**
   * Update an existing implicit rule.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  correlationUpdateImplicitRule: CorrelationRule;
  /**
   * Update an existing rule.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  correlationUpdateRule: CorrelationRule;
  /**
   * Upsert an annotation entry to an existing rule.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  correlationUpsertRuleAnnotations: CorrelationOperationResult;
  /**
   * Update notification preferences for a user
   * @deprecated This field is experimental and subject to breaking changes.
   */
  courierNotificationPreferencesUpdate?: Maybe<Array<Maybe<CourierNotificationPreferencesUpdatedNotificationPreferenceResponse>>>;
  /** Add widgets to a `DashboardPage` */
  dashboardAddWidgetsToPage?: Maybe<DashboardAddWidgetsToPageResult>;
  /** Create a `DashboardEntity` */
  dashboardCreate?: Maybe<DashboardCreateResult>;
  /** Creates a public Live URL where a `DashboardEntity` will show data changes in real time. */
  dashboardCreateLiveUrl?: Maybe<DashboardLiveUrl>;
  /** Creates a public URL where a `DashboardPage` can be accessed in the form of a static snapshot. */
  dashboardCreateSnapshotUrl?: Maybe<Scalars['String']['output']>;
  /** Delete an existing `DashboardEntity` */
  dashboardDelete?: Maybe<DashboardDeleteResult>;
  /** Revokes a `DashboardEntity` public live URL */
  dashboardRevokeLiveUrl?: Maybe<DashboardRevokeLiveDashboardUrlResult>;
  /** Undelete a `DashboardEntity` that was previously deleted. */
  dashboardUndelete?: Maybe<DashboardUndeleteResult>;
  /** Update an existing `DashboardEntity` */
  dashboardUpdate?: Maybe<DashboardUpdateResult>;
  /** Update a page in a dashboard. */
  dashboardUpdatePage?: Maybe<DashboardUpdatePageResult>;
  /** Update an existing set of `Widget`s in a `DashboardPage` */
  dashboardUpdateWidgetsInPage?: Maybe<DashboardUpdateWidgetsInPageResult>;
  /** Revokes a `DashboardWidget` public live URL that was created in advance. */
  dashboardWidgetRevokeLiveUrl?: Maybe<DashboardRevokeLiveUrlResult>;
  /** Bulk copy account rules to list of accounts */
  dataManagementCopyRetentions?: Maybe<DataManagementBulkCopyResult>;
  /** Create a new event retention rule for a namespace on an account */
  dataManagementCreateEventRetentionRule?: Maybe<DataManagementRule>;
  /** Create event retention rules for namespaces */
  dataManagementCreateRetentionRules?: Maybe<Array<Maybe<DataManagementRule>>>;
  /** Delete the event retention rule for a namespace on an account, if it exists */
  dataManagementDeleteEventRetentionRule?: Maybe<DataManagementRule>;
  /** Mutation to add and change a feature setting toggle for an account */
  dataManagementUpdateFeatureSettings?: Maybe<DataManagementFeatureSetting>;
  /**
   * Create a new Post.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  discussionCreateErrorGroupPost?: Maybe<DiscussionErrorGroupPost>;
  /**
   * Delete (mark deactivated) an existing Post.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  discussionDeleteErrorGroupPost?: Maybe<DiscussionErrorGroupPost>;
  /**
   * Update an existing Post.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  discussionUpdateErrorGroupPost?: Maybe<DiscussionErrorGroupPost>;
  /**
   * Creates a new domain, and begins the domain verification process
   * @deprecated This field is experimental and subject to breaking changes.
   */
  domainManagementCreateDomain?: Maybe<DomainManagementCreateDomainResponse>;
  /**
   * Removes a domain
   * @deprecated This field is experimental and subject to breaking changes.
   */
  domainManagementDeleteDomain?: Maybe<DomainManagementDomainDeleteResponse>;
  /**
   * Replaces existing verification record with a new one. Won't be allowed if a domain is already verified
   * @deprecated This field is experimental and subject to breaking changes.
   */
  domainManagementRetryDomainVerification?: Maybe<DomainManagementCreateDomainResponse>;
  /**
   * Updates an existing capture record for the given domainId
   * @deprecated This field is experimental and subject to breaking changes.
   */
  domainManagementUpdateCaptureConfiguration?: Maybe<DomainManagementUpdateCaptureConfigurationResponse>;
  /** Create one or more trace filter rules, as defined by the `CreateTraceFilterRulesInput`. */
  edgeCreateTraceFilterRules: EdgeCreateTraceFilterRuleResponses;
  /** Create one or more trace observers, as defined by the `CreateTraceObserverInput`. Currently, only one trace observer can be created per provider region. */
  edgeCreateTraceObserver: EdgeCreateTraceObserverResponses;
  /** Delete one or more trace filter rules, as defined by the `DeleteTraceFilterRulesInput`. */
  edgeDeleteTraceFilterRules: EdgeDeleteTraceFilterRuleResponses;
  edgeDeleteTraceObservers: EdgeDeleteTraceObserverResponses;
  /** Update one or more trace observers, as defined by the `UpdateTraceObserverInput`. */
  edgeUpdateTraceObservers: EdgeUpdateTraceObserverResponses;
  /** Delete an entity */
  entityDelete?: Maybe<EntityDeleteResult>;
  /** Override the default golden metrics given an account or a collection guid. Only use one context */
  entityGoldenMetricsOverride: EntityGoldenMetricsDomainTypeScopedResponse;
  /** Reset the default golden metrics given an account or a collection guid. Only use one context */
  entityGoldenMetricsReset: EntityGoldenMetricsDomainTypeScopedResponse;
  /** Override the default tags given an account or a collection guid. Only use one context */
  entityGoldenTagsOverride: EntityGoldenTagsDomainTypeScopedResponse;
  /** Reset the default tags given an account or a collection guid. Only use one context */
  entityGoldenTagsReset: EntityGoldenTagsDomainTypeScopedResponse;
  /** Keep an entity alive by refreshing its TTL */
  entityKeepAlive?: Maybe<EntityKeepAliveResult>;
  /** Create a relationship between entities. */
  entityRelationshipUserDefinedCreateOrReplace: EntityRelationshipUserDefinedCreateOrReplaceResult;
  /** Delete a relationship between entities. If no type is provided, it will delete all relationships between source and target. */
  entityRelationshipUserDefinedDelete: EntityRelationshipUserDefinedDeleteResult;
  /**
   * Assigns a user to the error group
   * @deprecated This field is experimental and subject to breaking changes.
   */
  errorTrackingAssignErrorGroup?: Maybe<ErrorTrackingAssignErrorGroupResponse>;
  /**
   * Comment on error group
   * @deprecated This field is experimental and subject to breaking changes.
   */
  errorTrackingCommentOnErrorGroup?: Maybe<ErrorTrackingCommentOnErrorGroupResponse>;
  /**
   * Associates a notification channel with an error group and generates a notification.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  errorTrackingConfigureErrorGroupChannel?: Maybe<ErrorTrackingConfigureErrorGroupChannelResponse>;
  /**
   * Creates or updates notification policies.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  errorTrackingConfigureNotificationPolicy?: Maybe<ErrorTrackingConfigureNotificationPolicyResponse>;
  /**
   * Delete comment from error group
   * @deprecated This field is experimental and subject to breaking changes.
   */
  errorTrackingDeleteCommentFromErrorGroup?: Maybe<ErrorTrackingDeleteCommentFromErrorGroupResponse>;
  /**
   * Removes a notification channel from an error group.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  errorTrackingDeleteErrorGroupChannel?: Maybe<ErrorTrackingDeleteErrorGroupChannelResponse>;
  /**
   * Removes a configured notification policy.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  errorTrackingDeleteNotificationPolicy?: Maybe<ErrorTrackingDeleteNotificationPolicyResponse>;
  /**
   * Marks the error group as expected.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  errorTrackingUpdateErrorGroupState?: Maybe<ErrorTrackingUpdateErrorGroupStateResponse>;
  /** Assigns a user to an error group */
  errorsInboxAssignErrorGroup?: Maybe<ErrorsInboxAssignErrorGroupResponse>;
  /** Creates or updates notification policies. */
  errorsInboxConfigureNotificationPolicy?: Maybe<ErrorsInboxConfigureNotificationPolicyResponse>;
  /** Removes a resource from an error group. */
  errorsInboxDeleteErrorGroupResource?: Maybe<ErrorsInboxDeleteErrorGroupResourceResponse>;
  /** Removes a configured notification policy. */
  errorsInboxDeleteNotificationPolicy?: Maybe<ErrorsInboxDeleteNotificationPolicyResponse>;
  /** Updates the states of error groups. */
  errorsInboxUpdateErrorGroupState?: Maybe<ErrorsInboxUpdateErrorGroupStateResponse>;
  eventTransformationCreateRule?: Maybe<EventTransformationRule>;
  eventTransformationUpdateRule?: Maybe<EventTransformationRule>;
  /** Create a new rule which will make metrics from event data. */
  eventsToMetricsCreateRule?: Maybe<EventsToMetricsCreateRuleResult>;
  /** Delete an event-to-metric rule. */
  eventsToMetricsDeleteRule?: Maybe<EventsToMetricsDeleteRuleResult>;
  /** Enable or disable an event-to-metric rule. */
  eventsToMetricsUpdateRule?: Maybe<EventsToMetricsUpdateRuleResult>;
  /**
   * Create a new Grok feedback
   * @deprecated This field is experimental and subject to breaking changes.
   */
  grokCreateFeedback?: Maybe<GrokFeedback>;
  /**
   * Create a new Grok prompt
   * @deprecated This field is experimental and subject to breaking changes.
   */
  grokCreatePrompt?: Maybe<GrokGrokPrompt>;
  /**
   * Update an existing Grok feedback
   * @deprecated This field is experimental and subject to breaking changes.
   */
  grokUpdateFeedback?: Maybe<GrokFeedback>;
  /** Cancel a historic export */
  historicalDataExportCancelExport?: Maybe<HistoricalDataExportCustomerExportResponse>;
  /** Create a historic export */
  historicalDataExportCreateExport?: Maybe<HistoricalDataExportCustomerExportResponse>;
  /** Consent accounts to usage of the Incident Intelligence product in the EU or FedRAMP */
  incidentIntelligenceEnvironmentConsentAccounts?: Maybe<IncidentIntelligenceEnvironmentConsentAccounts>;
  /** Consent all of the user's authorized accounts */
  incidentIntelligenceEnvironmentConsentAuthorizedAccounts?: Maybe<IncidentIntelligenceEnvironmentConsentAuthorizedAccounts>;
  /**
   * Creates a new environment, each environment is attached to a parent account and an account. Note that only one environment per parent account is supported.
   * @deprecated Deprecated. Please concat support for existing cross-account environment changes
   */
  incidentIntelligenceEnvironmentCreateEnvironment?: Maybe<IncidentIntelligenceEnvironmentCreateEnvironment>;
  /** Deletes an existing environment */
  incidentIntelligenceEnvironmentDeleteEnvironment?: Maybe<IncidentIntelligenceEnvironmentDeleteEnvironment>;
  /** Dissent accounts to usage of the Incident Intelligence product in the EU or FedRAMP (removes the consent marking) */
  incidentIntelligenceEnvironmentDissentAccounts?: Maybe<IncidentIntelligenceEnvironmentDissentAccounts>;
  /**
   * Create a new pathway
   * @deprecated This field is experimental and subject to breaking changes.
   */
  incidentIntelligencePlatformCreatePathway?: Maybe<IncidentIntelligencePlatformCreatePathway>;
  /**
   * Create PagerDuty platform
   * @deprecated This field is experimental and subject to breaking changes.
   */
  incidentIntelligencePlatformCreatePlatformPagerduty?: Maybe<IncidentIntelligencePlatformCreatePlatformPagerDuty>;
  /**
   * Delete pathway
   * @deprecated This field is experimental and subject to breaking changes.
   */
  incidentIntelligencePlatformDeletePathway?: Maybe<IncidentIntelligencePlatformDeletePathway>;
  /**
   * Delete platform
   * @deprecated This field is experimental and subject to breaking changes.
   */
  incidentIntelligencePlatformDeletePlatform?: Maybe<IncidentIntelligencePlatformDeletePlatform>;
  /**
   * Deprovision destination
   * @deprecated This field is experimental and subject to breaking changes.
   */
  incidentIntelligencePlatformDeprovisionDestination?: Maybe<IncidentIntelligencePlatformDeprovisionDestination>;
  /**
   * Deprovision source
   * @deprecated This field is experimental and subject to breaking changes.
   */
  incidentIntelligencePlatformDeprovisionSource?: Maybe<IncidentIntelligencePlatformDeprovisionSource>;
  /**
   * Set user as admin in PagerDuty
   * @deprecated This field is experimental and subject to breaking changes.
   */
  incidentIntelligencePlatformPagerdutySetAdmin?: Maybe<IncidentIntelligencePlatformPagerDutySetAdmin>;
  /**
   * Provision a new PagerDuty destination
   * @deprecated This field is experimental and subject to breaking changes.
   */
  incidentIntelligencePlatformProvisionDestinationPagerduty?: Maybe<IncidentIntelligencePlatformProvisionDestinationPagerDuty>;
  /**
   * Provision a new Webhook destination
   * @deprecated This field is experimental and subject to breaking changes.
   */
  incidentIntelligencePlatformProvisionDestinationWebhook?: Maybe<IncidentIntelligencePlatformProvisionDestinationWebhook>;
  /**
   * Provision a new PagerDuty source
   * @deprecated This field is experimental and subject to breaking changes.
   */
  incidentIntelligencePlatformProvisionSourcePagerduty?: Maybe<IncidentIntelligencePlatformProvisionSourcePagerDuty>;
  /**
   * Sync services from PagerDuty
   * @deprecated This field is experimental and subject to breaking changes.
   */
  incidentIntelligencePlatformSyncServicesPagerduty?: Maybe<IncidentIntelligencePlatformSyncServicesPagerDuty>;
  /**
   * Update PagerDuty destination
   * @deprecated This field is experimental and subject to breaking changes.
   */
  incidentIntelligencePlatformUpdateDestinationPagerduty?: Maybe<IncidentIntelligencePlatformUpdateDestinationPagerDuty>;
  /**
   * Update Webhook destination
   * @deprecated This field is experimental and subject to breaking changes.
   */
  incidentIntelligencePlatformUpdateDestinationWebhook?: Maybe<IncidentIntelligencePlatformUpdateDestinationWebhook>;
  /**
   * Update pathway
   * @deprecated This field is experimental and subject to breaking changes.
   */
  incidentIntelligencePlatformUpdatePathway?: Maybe<IncidentIntelligencePlatformUpdatePathway>;
  /**
   * Update platform
   * @deprecated This field is experimental and subject to breaking changes.
   */
  incidentIntelligencePlatformUpdatePlatformPagerduty?: Maybe<IncidentIntelligencePlatformUpdatePlatformPagerDuty>;
  /** Activate an integration on a given host */
  infrastructureAgentRunIntegration?: Maybe<InfrastructureAgentSendCommandResult>;
  /** Stop an integration on a given host */
  infrastructureAgentStopIntegration?: Maybe<InfrastructureAgentSendCommandResult>;
  /**
   * Creates a new install status.
   * An install status is created on behalf of the newrelic-cli whenever the CLI has started an installation and completed an installation.
   *
   * Guided install: https://docs.newrelic.com/docs/full-stack-observability/observe-everything/get-started/new-relic-guided-install-overview/
   * newrelic-cli: https://github.com/newrelic/newrelic-cli
   */
  installationCreateInstallStatus: InstallationInstallStatus;
  /**
   * Creates a new recipe event.
   * - A recipe event is created on behalf of the newrelic-cli whenever the CLI attempts to install the infrastructure-agent, for example.
   * - A recipe event is appended to any existing recipe events, if there are any present in the cache.
   *
   * Guided install: https://docs.newrelic.com/docs/full-stack-observability/observe-everything/get-started/new-relic-guided-install-overview/
   * newrelic-cli: https://github.com/newrelic/newrelic-cli
   */
  installationCreateRecipeEvent: InstallationRecipeEvent;
  /** Deletes an installation status and all recipe statuses given the accountId. */
  installationDeleteInstall: Scalars['Boolean']['output'];
  /** Invite a new user to the specified account */
  invitationsInviteUser?: Maybe<InvitationsInviteResponse>;
  /** Invite a new user to the Organization */
  invitationsInviteUserToOrganization?: Maybe<InvitationsInviteUserToOrganizationResponse>;
  /** Manage add user to organization requests */
  invitationsManageAddUserToOrganizationRequests?: Maybe<InvitationsManageAddUserToOrganizationRequestsResponse>;
  /** Manage invite user to organization requests */
  invitationsManageInviteUserToOrganizationRequests?: Maybe<InvitationsManageInviteUserToOrganizationRequestsResponse>;
  /** Manage user upgrade requests */
  invitationsManageUserUpgradeRequests?: Maybe<InvitationsManageUserUpgradeRequestsResponse>;
  /** Request access to higher user type */
  invitationsRequestAccess?: Maybe<InvitationsRequestAccessResponse>;
  /** Creates a key transaction. */
  keyTransactionCreate?: Maybe<KeyTransactionCreateResult>;
  /** Deletes a key transaction (historical data is not removed). */
  keyTransactionDelete?: Maybe<KeyTransactionDeleteResult>;
  /** Deletes all key transactions associated with an application (historical data is not removed). */
  keyTransactionDeleteAllByApplicationId?: Maybe<KeyTransactionDeleteResult>;
  /** Update a key transaction. */
  keyTransactionUpdate?: Maybe<KeyTransactionUpdateResult>;
  /** Create a new data partition rule. */
  logConfigurationsCreateDataPartitionRule?: Maybe<LogConfigurationsCreateDataPartitionRuleResponse>;
  /** Create an obfuscation expression. */
  logConfigurationsCreateObfuscationExpression?: Maybe<LogConfigurationsObfuscationExpression>;
  /** Create an obfuscation rule. */
  logConfigurationsCreateObfuscationRule?: Maybe<LogConfigurationsObfuscationRule>;
  /** Create a new parsing rule. */
  logConfigurationsCreateParsingRule?: Maybe<LogConfigurationsCreateParsingRuleResponse>;
  /**
   * Delete an existing data partition rule.
   * This operation will result in data to be allocated in the main NRDB storage (Log) if no other data partition rule exists intercepting the logs matching this rule.
   * A deleted data partition rule can be recreated using the same name.
   */
  logConfigurationsDeleteDataPartitionRule?: Maybe<LogConfigurationsDeleteDataPartitionRuleResponse>;
  /** Delete an obfuscation expression. */
  logConfigurationsDeleteObfuscationExpression?: Maybe<LogConfigurationsObfuscationExpression>;
  /** Delete an obfuscation rule. */
  logConfigurationsDeleteObfuscationRule?: Maybe<LogConfigurationsObfuscationRule>;
  /** Delete an existing parsing rule. */
  logConfigurationsDeleteParsingRule?: Maybe<LogConfigurationsDeleteParsingRuleResponse>;
  /** Update an existing data partition rule. */
  logConfigurationsUpdateDataPartitionRule?: Maybe<LogConfigurationsUpdateDataPartitionRuleResponse>;
  /** Update the Live Archive configuration of an event type. */
  logConfigurationsUpdateLiveArchiveConfiguration?: Maybe<LogConfigurationsLiveArchiveConfiguration>;
  /** Update an existing data partition rule. */
  logConfigurationsUpdateObfuscationExpression?: Maybe<LogConfigurationsObfuscationExpression>;
  /** Update an existing data partition rule. */
  logConfigurationsUpdateObfuscationRule?: Maybe<LogConfigurationsObfuscationRule>;
  /** Update an existing parsing rule. */
  logConfigurationsUpdateParsingRule?: Maybe<LogConfigurationsUpdateParsingRuleResponse>;
  /** Upsert pipeline configuration for an account. */
  logConfigurationsUpsertPipelineConfiguration?: Maybe<LogConfigurationsUpsertPipelineConfigurationResponse>;
  /** Creates a metric normalization rule */
  metricNormalizationCreateRule?: Maybe<MetricNormalizationRuleMutationResponse>;
  /** Disables a metric normalization rule */
  metricNormalizationDisableRule?: Maybe<MetricNormalizationRuleMutationResponse>;
  /** edit a metric normalization rule */
  metricNormalizationEditRule?: Maybe<MetricNormalizationRuleMutationResponse>;
  /** Enables a metric normalization rule */
  metricNormalizationEnableRule?: Maybe<MetricNormalizationRuleMutationResponse>;
  /** Add a mobile device that will receive push notifications */
  mobilePushNotificationAddDevice: MobilePushNotificationDevice;
  /** Remove a mobile device from the users list of devices */
  mobilePushNotificationRemoveDevice: MobilePushNotificationRemoveDeviceResult;
  /** Send a test push notification to a users specific mobile device */
  mobilePushNotificationSendTestPush: MobilePushNotificationSendPushResult;
  /** Send a test push notification to all of a users mobile devices */
  mobilePushNotificationSendTestPushToAll: MobilePushNotificationSendPushResult;
  /**
   * Delete a NerdStorage collection.
   *
   * To use the NerdStorage schema you must specify a Nerdpack ID using the NewRelic-Package-Id header in your request.
   */
  nerdStorageDeleteCollection?: Maybe<NerdStorageDeleteResult>;
  /**
   * Delete a NerdStorage document.
   *
   * To use the NerdStorage schema you must specify a Nerdpack ID using the NewRelic-Package-Id header in your request.
   */
  nerdStorageDeleteDocument?: Maybe<NerdStorageDeleteResult>;
  /** Delete an existing secret for the selected scope. */
  nerdStorageVaultDeleteSecret: NerdStorageVaultDeleteSecretResult;
  /** Store or modify a secret. */
  nerdStorageVaultWriteSecret: NerdStorageVaultWriteSecretResult;
  /**
   * Create a new NerdStorage document.
   *
   * To use the NerdStorage schema you must specify a Nerdpack ID using the NewRelic-Package-Id header in your request.
   */
  nerdStorageWriteDocument?: Maybe<Scalars['NerdStorageDocument']['output']>;
  nerdStoreDeleteCollection?: Maybe<NerdStoreDeleteResult>;
  nerdStoreDeleteDocument?: Maybe<NerdStoreDeleteResult>;
  nerdStoreWriteDocument?: Maybe<Scalars['NerdStoreDocument']['output']>;
  /** Adds accounts to the Nerdpack allow list. The accounts must belong to the user's authorized account list. */
  nerdpackAddAllowedAccounts?: Maybe<NerdpackAllowListResult>;
  /** Creates a Nerdpack with a unique and random uuid V5. */
  nerdpackCreate: NerdpackData;
  /** Removes accounts from the Nerdpack allow list. The accounts must belong to the user's authorized account list. */
  nerdpackRemoveAllowedAccounts?: Maybe<NerdpackAllowListResult>;
  /**
   * Remove a specific nerdpack version tag. This operation can only be performed if:
   * - User has untagging capabilities.
   * - User has accepted the terms and conditions.
   * - User's account is the Nerdpack owner, or is an authorized account, or is an admin account for the Nerdpack owner account.
   */
  nerdpackRemoveVersionTag?: Maybe<NerdpackRemovedTagResponse>;
  /** Make a Nerdpack publication available to a list of accounts. Providing partial results. */
  nerdpackSubscribeAccounts?: Maybe<NerdpackSubscribeResult>;
  /**
   * Tag a Nerdpack version. This operation can only be performed if:
   * - User has tagging capabilities.
   * - User has accepted the terms and conditions.
   * - User's account is the Nerdpack owner, or is an authorized account, or is an admin account for the Nerdpack owner account.
   */
  nerdpackTagVersion?: Maybe<NerdpackVersion>;
  /** Make a Nerdpack publication unavailable to a list of accounts. Providing partial results. */
  nerdpackUnsubscribeAccounts?: Maybe<NerdpackUnsubscribeResult>;
  /** Creates a network agent configuration. */
  networkMonitoringCreateAgentConfiguration?: Maybe<Scalars['String']['output']>;
  /** Delete a network agent configuration. */
  networkMonitoringDeleteAgentConfiguration?: Maybe<Scalars['String']['output']>;
  /** Publish the current version of a network agent's configuration. Only changes to specific fields will be stored */
  networkMonitoringPublishAgentConfiguration?: Maybe<NetworkMonitoringPublishAgentConfigurationResponse>;
  /** Updates a network agent configuration. */
  networkMonitoringUpdateAgentConfiguration?: Maybe<Scalars['String']['output']>;
  /**
   * Creates a new notification configuration allowing a user to receive status updates on New Relic health
   * @deprecated This field is experimental and subject to breaking changes.
   */
  newRelicServiceHealthCreateStatusNotificationConfiguration?: Maybe<Scalars['String']['output']>;
  /**
   * update a notification configuration allowing a user to receive status updates on New Relic health
   * @deprecated This field is experimental and subject to breaking changes.
   */
  newRelicServiceHealthUpdateStatusNotificationConfiguration?: Maybe<NewRelicServiceHealthNotificationConfiguration>;
  /**
   * Generates an auth token for the currently logged in user
   * @deprecated This field is experimental and subject to breaking changes.
   */
  notificationAuthenticationGenerateToken?: Maybe<NotificationAuthenticationGenerateTokenResponse>;
  /**
   * Submit a new quickstart to New Relic Instant Observability
   * @deprecated This field is no longer supported. Please use `nr1CatalogSubmitQuickstart` instead.
   */
  nr1CatalogCreateQuickstart?: Maybe<Nr1CatalogCreateQuickstartResult>;
  /** Install an alert policy template on a given account for use in it */
  nr1CatalogInstallAlertPolicyTemplate?: Maybe<Nr1CatalogInstallAlertPolicyTemplateResult>;
  /** Install a dashboard template on a given account for use in it */
  nr1CatalogInstallDashboardTemplate?: Maybe<Nr1CatalogInstallDashboardTemplateResult>;
  /** Sets the set of auto install dashboard templates for a data source */
  nr1CatalogSetAutoInstallAlertPolicyTemplatesForDataSource?: Maybe<Nr1CatalogSetAutoInstallAlertPolicyTemplatesForDataSourceResult>;
  /** Sets the set of auto install dashboard templates for a data source */
  nr1CatalogSetAutoInstallDashboardTemplatesForDataSource?: Maybe<Nr1CatalogSetAutoInstallDashboardTemplatesForDataSourceResult>;
  /** Sets the set of required data sources for an alert policy template */
  nr1CatalogSetRequiredDataSourcesForAlertPolicyTemplate?: Maybe<Nr1CatalogSetRequiredDataSourcesForAlertPolicyTemplateResult>;
  /** Sets the set of required data sources for a dashboard template */
  nr1CatalogSetRequiredDataSourcesForDashboardTemplate?: Maybe<Nr1CatalogSetRequiredDataSourcesForDashboardTemplateResult>;
  /** Submit a data source that will be available in New Relic Instant Observability */
  nr1CatalogSubmitDataSource?: Maybe<Nr1CatalogSubmitDataSourceResult>;
  /**
   * Submit an install plan step that will be used to facilitate installation of a quickstart in New Relic Instant Observability
   * @deprecated This mutation is no longer supported. Please use `nr1CatalogSubmitDataSource` instead
   */
  nr1CatalogSubmitInstallPlanStep?: Maybe<Nr1CatalogSubmitInstallPlanStepResult>;
  /** Submit metadata for a Nerdpack that will be available in the New Relic One Catalog */
  nr1CatalogSubmitMetadata?: Maybe<Nr1CatalogSubmitMetadataResult>;
  /** Submit a quickstart that will be available in New Relic Instant Observability */
  nr1CatalogSubmitQuickstart?: Maybe<Nr1CatalogSubmitQuickstartResult>;
  /**
   * Update an existing quickstart in New Relic Instant Observability
   * @deprecated This field is no longer supported. Please use `nr1CatalogSubmitQuickstart` instead.
   */
  nr1CatalogUpdateQuickstart?: Maybe<Nr1CatalogUpdateQuickstartResult>;
  /** Create new drop rule(s). */
  nrqlDropRulesCreate?: Maybe<NrqlDropRulesCreateDropRuleResult>;
  /** Delete drop rule(s) by id. */
  nrqlDropRulesDelete?: Maybe<NrqlDropRulesDeleteDropRuleResult>;
  /**
   * Delete a lookup table.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  nrqlLookupsDelete?: Maybe<NrqlLookupsLookupFileSummary>;
  /**
   * Edit the description of a lookup table.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  nrqlLookupsEdit?: Maybe<NrqlLookupsLookupFileSummary>;
  /**
   * Create a configuration in the specified account.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  openAgentManagementCreateConfiguration?: Maybe<OpenAgentManagementConfiguration>;
  /**
   * Create a new revision for the specified configuration
   * @deprecated This field is experimental and subject to breaking changes.
   */
  openAgentManagementCreateConfigurationRevision?: Maybe<OpenAgentManagementConfigurationRevision>;
  /**
   * Create a fleet
   * @deprecated This field is experimental and subject to breaking changes.
   */
  openAgentManagementCreateFleet?: Maybe<OpenAgentManagementFleet>;
  /**
   * Delete a configuration
   * @deprecated This field is experimental and subject to breaking changes.
   */
  openAgentManagementDeleteConfiguration?: Maybe<OpenAgentManagementDeleteConfigurationResult>;
  /**
   * Delete a configuration revision
   * @deprecated This field is experimental and subject to breaking changes.
   */
  openAgentManagementDeleteConfigurationRevision?: Maybe<OpenAgentManagementDeleteConfigurationRevisionResult>;
  /**
   * Delete a fleet. Will return an error if there are agents associated to it.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  openAgentManagementDeleteFleet?: Maybe<OpenAgentManagementDeleteFleetResult>;
  /**
   * Attach a set of configurations to an agent
   * @deprecated This field is experimental and subject to breaking changes.
   */
  openAgentManagementDeployAgentConfigurations?: Maybe<OpenAgentManagementDeployAgentConfigurationRevisionsResult>;
  /**
   * Attach a set of configurations to a fleet
   * @deprecated This field is experimental and subject to breaking changes.
   */
  openAgentManagementDeployFleetConfigurations?: Maybe<OpenAgentManagementDeployFleetConfigurationRevisionsResult>;
  /**
   * Add an agent to a fleet. If the agent was already in a fleet
   * @deprecated This field is experimental and subject to breaking changes.
   */
  openAgentManagementMoveAgentToFleet?: Maybe<OpenAgentManagementMoveAgentToFleetResult>;
  /**
   * Update Auth state for an agent
   * @deprecated This field is experimental and subject to breaking changes.
   */
  openAgentManagementSetAgentAuthState?: Maybe<OpenAgentManagementSetAgentAuthStateResult>;
  /**
   * Update a configuration.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  openAgentManagementUpdateConfiguration?: Maybe<OpenAgentManagementConfiguration>;
  /** The new organization to create. */
  organizationCreate?: Maybe<OrganizationCreateOrganizationResponse>;
  /** The shared account to create */
  organizationCreateSharedAccount?: Maybe<OrganizationCreateSharedAccountResponse>;
  organizationProvisioningUpdatePartnerSubscription: OrganizationProvisioningUpdateSubscriptionResult;
  /** The shared account to revoke */
  organizationRevokeSharedAccount?: Maybe<OrganizationRevokeSharedAccountResponse>;
  /** The organization to update */
  organizationUpdate?: Maybe<OrganizationUpdateResponse>;
  /** The shared account to update */
  organizationUpdateSharedAccount?: Maybe<OrganizationUpdateSharedAccountResponse>;
  /** Disconnects account from partnership and will eventually move to a standalone NR1 account */
  partnershipMigrationMigrateAccount?: Maybe<PartnershipMigrationMigrateAccountResponse>;
  /** Link a Pixie project to a New Relic account using a Pixie API key */
  pixieLinkPixieProject?: Maybe<PixieLinkPixieProjectResult>;
  /** Record the Pixie terms of service acceptance for a given account */
  pixieRecordPixieTosAcceptance?: Maybe<PixieRecordPixieTosAcceptanceResult>;
  /** Unlink a Pixie project to a New Relic account */
  pixieUnlinkPixieProject?: Maybe<PixieLinkPixieProjectResult>;
  /** Allows to create a new Pre Release Program */
  preReleaseProgramCreateProgram?: Maybe<PreReleaseProgramProgram>;
  /** Allows to submit an agreement for a specific Pre Release Program */
  preReleaseProgramCreateSubmission?: Maybe<PreReleaseProgramSubmission>;
  /** The user account provided in the `AccountInput` argument accepts the NR1 programmability terms and conditions. */
  programmabilityTnCAccept: ProgrammabilityTnCAccepted;
  provisioningAddAccountEntitlementBlocklistToAccounts?: Maybe<ProvisioningEntitleAccountsResult>;
  provisioningAddBetaEntitlementToAccounts?: Maybe<ProvisioningEntitleAccountsResult>;
  provisioningAddEntitlementToAccounts?: Maybe<ProvisioningEntitleAccountsResult>;
  provisioningApplyAccountConfigurations?: Maybe<ProvisioningAccountConfigurationResult>;
  provisioningApplyAccountEnablementPackages?: Maybe<ProvisioningEnablementApplicationResult>;
  provisioningApplyEnablementToAccounts?: Maybe<ProvisioningBulkApplicationResult>;
  provisioningApplyPromoCodeToAccount?: Maybe<ProvisioningPromotionApplicationResult>;
  provisioningApplyPromotionToAccounts?: Maybe<ProvisioningBulkApplicationResult>;
  provisioningBulkAccountRefresh?: Maybe<ProvisioningBulkAccountRefreshPayload>;
  provisioningBulkCpmConversions?: Maybe<ProvisioningBulkCpmConversionsResult>;
  provisioningBulkRemoveEnablementFromAccounts?: Maybe<ProvisioningBulkApplicationResult>;
  provisioningConvertAccountToNonProfit?: Maybe<ProvisioningConvertAccountResult>;
  provisioningRefreshEntitlements?: Maybe<ProvisioningRefreshEntitlementResult>;
  provisioningRemoveAccountEnablementPackages?: Maybe<ProvisioningEnablementRemovalResult>;
  provisioningRemoveAccountEntitlementBlocklistFromAccounts?: Maybe<ProvisioningEntitleAccountsResult>;
  provisioningRemoveBetaEntitlementFromAccounts?: Maybe<ProvisioningEntitleAccountsResult>;
  provisioningRemoveEntitlementFromAccounts?: Maybe<ProvisioningEntitleAccountsResult>;
  provisioningRemovePlatformRecord?: Maybe<Array<ProvisioningRemovePlatformResult>>;
  provisioningRemovePromotionFromAccount?: Maybe<ProvisioningPromotionRemovalResult>;
  provisioningRemovePromotionFromAccounts?: Maybe<ProvisioningBulkApplicationResult>;
  provisioningToggleAccountConfiguration: ProvisioningAccountConfigurationResult;
  provisioningUpdateAccountConfiguration?: Maybe<ProvisioningAccountConfigurationResult>;
  provisioningUpdateAccountEntitlement?: Maybe<ProvisioningEntitleAccountsResult>;
  provisioningUpdateSubscriptions: ProvisioningUpdateSubscriptionResult;
  /** Record a NRQL query in the user's query history. */
  queryHistoryRecordNrql?: Maybe<QueryHistoryRecordNrqlResult>;
  /** Creates or updates repository entities. */
  referenceEntityCreateOrUpdateRepository?: Maybe<ReferenceEntityCreateRepositoryResult>;
  /**
   * This submits a request for a root cause analysis
   * @deprecated This field is experimental and subject to breaking changes.
   */
  rootCauseAnalysisSubmit?: Maybe<RootCauseAnalysisAsyncResult>;
  /**
   * Create a new Saved View.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  savedViewsCreate?: Maybe<SavedViewsCreateResult>;
  /**
   * Delete a saved view.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  savedViewsDelete?: Maybe<SavedViewsDeleteResult>;
  /**
   * Update a saved view.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  savedViewsUpdate?: Maybe<SavedViewsUpdateResult>;
  /** Creates a new SLI. */
  serviceLevelCreate?: Maybe<ServiceLevelIndicator>;
  /** Creates a new SLI with recommended indicators. */
  serviceLevelCreateRecommendedIndicators?: Maybe<ServiceLevelRecommendedIndicatorsCreationResult>;
  /** Deletes an existing SLI by the GUID. */
  serviceLevelDelete?: Maybe<ServiceLevelIndicator>;
  /** Updates an existing SLI by the GUID. */
  serviceLevelUpdate?: Maybe<ServiceLevelIndicator>;
  /** Creates a PromoCodes in bulk. Returns an array with the PromoCodes created. */
  signupIntegrationsBulkCreatePromoCodes?: Maybe<SignupIntegrationsBulkCreatePromoCodesResult>;
  /** Create new streaming rule */
  streamingExportCreateRule?: Maybe<StreamingExportRule>;
  /** Delete a streaming rule */
  streamingExportDeleteRule?: Maybe<StreamingExportRule>;
  /** Disable an existing streaming rule */
  streamingExportDisableRule?: Maybe<StreamingExportRule>;
  /** Enable an existing streaming rule */
  streamingExportEnableRule?: Maybe<StreamingExportRule>;
  /** Update an existing streaming rule */
  streamingExportUpdateRule?: Maybe<StreamingExportRule>;
  /** Creates category for Guided Diagnostics */
  supportDiagnosticsCategoryCreate?: Maybe<SupportGuidedDiagnosticsCategory>;
  /** Deletes category for Guided Diagnostics */
  supportDiagnosticsCategoryDelete?: Maybe<SupportGuidedDiagnosticsDeleteResponse>;
  /** Updates category for Guided Diagnostics */
  supportDiagnosticsCategoryUpdate?: Maybe<SupportGuidedDiagnosticsCategory>;
  /** Creates edge for Guided Diagnostics */
  supportDiagnosticsEdgeCreate?: Maybe<SupportGuidedDiagnosticsEdge>;
  /** Deletes edge for Guided Diagnostics */
  supportDiagnosticsEdgeDelete?: Maybe<SupportGuidedDiagnosticsEdgeDeleteResponse>;
  /** Creates a new framework or new framework revision for Guided Diagnostics */
  supportDiagnosticsFrameworkCreate?: Maybe<SupportGuidedDiagnosticsFramework>;
  /** Deletes framework for Guided Diagnostics */
  supportDiagnosticsFrameworkDelete?: Maybe<SupportGuidedDiagnosticsDeleteResponse>;
  /** Updates active framework revision */
  supportDiagnosticsFrameworkUpdateActiveRevision?: Maybe<SupportGuidedDiagnosticsFramework>;
  /** Updates framework state */
  supportDiagnosticsFrameworkUpdateState?: Maybe<SupportGuidedDiagnosticsFramework>;
  /** Add a Nerdgraph query for use with Guided Diagnostics */
  supportDiagnosticsNerdgraphQueryAdd?: Maybe<SupportDiagnosticsNerdgraphQueryMutationResponse>;
  /** Delete a Guided Diagnostics Query */
  supportDiagnosticsNerdgraphQueryDelete?: Maybe<SupportDiagnosticsQueryDeleteResponse>;
  /** Creates node for Guided Diagnostics */
  supportDiagnosticsNodeCreate?: Maybe<SupportGuidedDiagnosticsNode>;
  /** Deletes node for Guided Diagnostics */
  supportDiagnosticsNodeDelete?: Maybe<SupportGuidedDiagnosticsDeleteResponse>;
  /** Add a query for use with Guided Diagnostics */
  supportDiagnosticsQueryAdd?: Maybe<SupportDiagnosticsQueryMutationResponse>;
  /** Delete a Guided Diagnostics Query */
  supportDiagnosticsQueryDelete?: Maybe<SupportDiagnosticsQueryDeleteResponse>;
  /** Create an attachment for a support ticket or ticket comment */
  supportTicketAttachmentCreate?: Maybe<SupportTicketAttachment>;
  /** Adds collaborators to the ticket */
  supportTicketCollaboratorsAdd?: Maybe<SupportTicketCollaboratorsResponse>;
  /** Adds collaborators to the ticket */
  supportTicketCollaboratorsRemove?: Maybe<SupportTicketCollaboratorsResponse>;
  /** Creates a support ticket */
  supportTicketCreate?: Maybe<SupportTicketCreateResponse>;
  /** Creates a ticket escalation */
  supportTicketEscalate?: Maybe<SupportTicketEscalationResponse>;
  /** Creates a message associated with a case */
  supportTicketMessageCreate?: Maybe<SupportTicketMessageCreateResponse>;
  /** Create a Synthetic Broken Links monitor */
  syntheticsCreateBrokenLinksMonitor?: Maybe<SyntheticsBrokenLinksMonitorCreateMutationResult>;
  /** Create a Synthetic Cert Check (Certificate check) monitor */
  syntheticsCreateCertCheckMonitor?: Maybe<SyntheticsCertCheckMonitorCreateMutationResult>;
  /** Create a monitor downtime that runs daily */
  syntheticsCreateDailyMonitorDowntime?: Maybe<SyntheticsDailyMonitorDowntimeMutationResult>;
  /** Create a Synthetic Monitor */
  syntheticsCreateMonitor?: Maybe<SyntheticsMonitorMutationResult>;
  /** Create a monitor downtime that runs monthly */
  syntheticsCreateMonthlyMonitorDowntime?: Maybe<SyntheticsMonthlyMonitorDowntimeMutationResult>;
  /** Create a monitor downtime that runs once */
  syntheticsCreateOnceMonitorDowntime?: Maybe<SyntheticsOnceMonitorDowntimeMutationResult>;
  /** Create a Synthetics Private Location */
  syntheticsCreatePrivateLocation?: Maybe<SyntheticsPrivateLocationMutationResult>;
  /** Create a Synthetic Script Api monitor */
  syntheticsCreateScriptApiMonitor?: Maybe<SyntheticsScriptApiMonitorCreateMutationResult>;
  /** Create a Synthetic Script Browser Monitor */
  syntheticsCreateScriptBrowserMonitor?: Maybe<SyntheticsScriptBrowserMonitorCreateMutationResult>;
  /** Queues a request to create a secure credential */
  syntheticsCreateSecureCredential?: Maybe<SyntheticsSecureCredentialMutationResult>;
  /** Create a Synthetic Simple (Ping) monitor */
  syntheticsCreateSimpleBrowserMonitor?: Maybe<SyntheticsSimpleBrowserMonitorCreateMutationResult>;
  /** Create a Synthetic Simple (Ping) monitor */
  syntheticsCreateSimpleMonitor?: Maybe<SyntheticsSimpleBrowserMonitorCreateMutationResult>;
  /** Create a Synthetic Step monitor */
  syntheticsCreateStepMonitor?: Maybe<SyntheticsStepMonitorCreateMutationResult>;
  /** Create a monitor downtime that runs weekly */
  syntheticsCreateWeeklyMonitorDowntime?: Maybe<SyntheticsWeeklyMonitorDowntimeMutationResult>;
  /** Delete a Synthetic Monitor */
  syntheticsDeleteMonitor?: Maybe<SyntheticsMonitorDeleteMutationResult>;
  /** Delete a Synthetic Monitor */
  syntheticsDeleteMonitorByGuid?: Maybe<SyntheticsMonitorDeleteMutationResult>;
  /** Delete a monitor downtime */
  syntheticsDeleteMonitorDowntime?: Maybe<SyntheticsMonitorDowntimeDeleteResult>;
  /** Delete a Synthetics Private Location */
  syntheticsDeletePrivateLocation?: Maybe<SyntheticsPrivateLocationDeleteResult>;
  /** Delete a Synthetic Monitor script */
  syntheticsDeleteScript?: Maybe<SyntheticsMonitorScriptMutationResult>;
  /** Queues a request to delete an existing secure credential */
  syntheticsDeleteSecureCredential?: Maybe<SyntheticsSecureCredentialMutationResult>;
  /** Edit a monitor downtime */
  syntheticsEditMonitorDowntime?: Maybe<SyntheticsMonitorDowntimeMutationResult>;
  /** Generate a script from monitor steps */
  syntheticsGenerateStepScript?: Maybe<SyntheticsGenerateMonitorScriptResult>;
  /** Purge the job queue for a specified private location */
  syntheticsPurgePrivateLocationQueue?: Maybe<SyntheticsPrivateLocationPurgeQueueResult>;
  /** Queues a manual request to execute a check in location */
  syntheticsRunMonitor?: Maybe<SyntheticsRunMonitorMutationResult>;
  /** Starts automated testing job */
  syntheticsStartAutomatedTest?: Maybe<SyntheticsAutomatedTestStartResult>;
  /** Queues a manual request to execute a job in location using a given script */
  syntheticsTriggerScriptValidation?: Maybe<SyntheticsTriggerScriptValidationResponse>;
  /** Update a Synthetic Broken Links monitor */
  syntheticsUpdateBrokenLinksMonitor?: Maybe<SyntheticsBrokenLinksMonitorUpdateMutationResult>;
  /** Update a Synthetic Cert Check (Certificate check) monitor */
  syntheticsUpdateCertCheckMonitor?: Maybe<SyntheticsCertCheckMonitorUpdateMutationResult>;
  /** Update a Synthetic Monitor */
  syntheticsUpdateMonitor?: Maybe<SyntheticsMonitorMutationResult>;
  /** Update a Synthetics Private Location */
  syntheticsUpdatePrivateLocation?: Maybe<SyntheticsPrivateLocationMutationResult>;
  /** Update a monitor script */
  syntheticsUpdateScript?: Maybe<SyntheticsMonitorScriptMutationResult>;
  /** Update a Synthetic Script Api monitor */
  syntheticsUpdateScriptApiMonitor?: Maybe<SyntheticsScriptApiMonitorUpdateMutationResult>;
  /** Update a Synthetic Script Browser Monitor */
  syntheticsUpdateScriptBrowserMonitor?: Maybe<SyntheticsScriptBrowserMonitorUpdateMutationResult>;
  /** Queues a request to update an existing secure credential */
  syntheticsUpdateSecureCredential?: Maybe<SyntheticsSecureCredentialMutationResult>;
  /** Update a Synthetic Simple Browser monitor */
  syntheticsUpdateSimpleBrowserMonitor?: Maybe<SyntheticsSimpleBrowserMonitorUpdateMutationResult>;
  /** Update a Synthetic Simple (Ping) monitor */
  syntheticsUpdateSimpleMonitor?: Maybe<SyntheticsSimpleMonitorUpdateMutationResult>;
  /** Update a Synthetic Step monitor */
  syntheticsUpdateStepMonitor?: Maybe<SyntheticsStepMonitorUpdateMutationResult>;
  /** Update the runtime for Monitors */
  syntheticsUpgradeMonitorRuntime?: Maybe<SyntheticsUpgradeMonitorRuntimeResult>;
  /** Update the runtimes for monitors belonging to the supplied accounts with any of the supplied statuses */
  syntheticsUpgradeMonitorRuntimeByAccountsAndStatuses?: Maybe<SyntheticsUpgradeMonitorRuntimeResult>;
  /**
   * Adds the provided tags to your specified entity, without deleting existing ones.
   * The maximum number of tag-values per entity is 100; if the sum of existing and new tag-values if over the limit this mutation will fail.
   *
   * For details and mutation examples, visit [our docs](https://docs.newrelic.com/docs/apis/nerdgraph/examples/nerdgraph-tagging-api-tutorial).
   */
  taggingAddTagsToEntity?: Maybe<TaggingMutationResult>;
  /**
   * Delete specific tag keys from the entity.
   *
   * For details and mutation examples, visit [our docs](https://docs.newrelic.com/docs/apis/nerdgraph/examples/nerdgraph-tagging-api-tutorial).
   */
  taggingDeleteTagFromEntity?: Maybe<TaggingMutationResult>;
  /**
   * Delete specific tag key-values from the entity.
   *
   * For details and mutation examples, visit [our docs](https://docs.newrelic.com/docs/apis/nerdgraph/examples/nerdgraph-tagging-api-tutorial).
   */
  taggingDeleteTagValuesFromEntity?: Maybe<TaggingMutationResult>;
  /**
   * Replaces the entity's entire set of tags with the provided tag set.
   * The maximum number of tag-values per entity is 100; if more than 100 tag-values are provided this mutation will fail.
   *
   * For details and mutation examples, visit [our docs](https://docs.newrelic.com/docs/apis/nerdgraph/examples/nerdgraph-tagging-api-tutorial).
   */
  taggingReplaceTagsOnEntity?: Maybe<TaggingMutationResult>;
  /** Append a list of entities to an existing team */
  teamAddEntities?: Maybe<TeamDefinition>;
  /** Creates a new Team */
  teamCreate?: Maybe<TeamDefinition>;
  /** Deletes an existing Team by the GUID */
  teamDelete?: Maybe<TeamDefinition>;
  /** Delete a list of entities of an existing team */
  teamDeleteEntities?: Maybe<TeamDefinition>;
  /** Updates an existing Team by the GUID */
  teamUpdate?: Maybe<TeamDefinition>;
  /**
   * [DEPRECATED] Update several teams ownerships of an entity
   * @deprecated This mutation will be removed.
   */
  teamUpdateEntityOwners?: Maybe<TeamUpdatedEntityOwners>;
  /** Edit teams global settings */
  teamUpdateGlobalSettings?: Maybe<TeamGlobalSettings>;
  /**
   * Update notification preferences for a user
   * @deprecated This field is experimental and subject to breaking changes.
   */
  userEmailNotificationPreferencesUpdate?: Maybe<Array<Maybe<UserEmailNotificationPreferencesUpdatedNotificationPreferenceResponse>>>;
  /**
   * Update suppression group for a user
   * @deprecated This field is experimental and subject to breaking changes.
   */
  userEmailNotificationPreferencesUpdateSuppressionGroup?: Maybe<Array<Maybe<UserEmailNotificationPreferencesUpdatedSuppressionGroupResponse>>>;
  /** A mutation for adding user(s) to group(s). */
  userManagementAddUsersToGroups?: Maybe<UserManagementAddUsersToGroupsPayload>;
  /** A mutation for creating a group in an authentication domain. */
  userManagementCreateGroup?: Maybe<UserManagementCreateGroupPayload>;
  /** A mutation for creating a user in an authentication domain. */
  userManagementCreateUser?: Maybe<UserManagementCreateUserPayload>;
  /** A mutation for deleting a group. */
  userManagementDeleteGroup?: Maybe<UserManagementDeleteGroupPayload>;
  /** A mutation for deleting a user. */
  userManagementDeleteUser?: Maybe<UserManagementDeleteUserPayload>;
  /** A mutation for removing user(s) from group(s). */
  userManagementRemoveUsersFromGroups?: Maybe<UserManagementRemoveUsersFromGroupsPayload>;
  /** A mutation for updating an existing group. */
  userManagementUpdateGroup?: Maybe<UserManagementUpdateGroupPayload>;
  /** A mutation for updating an existing user. */
  userManagementUpdateUser?: Maybe<UserManagementUpdateUserPayload>;
  /** Update the data corresponding to the user preferences */
  userUpdatePreferences?: Maybe<UserUpdatePreferencesPayload>;
  /** Change the current user's tier */
  userUpgradeSelf?: Maybe<UserUpgradeSelfPayload>;
  /**
   * Creates synthetics script monitor for lighthouse metrics for the given website
   * @deprecated This field is experimental and subject to breaking changes.
   */
  websitePerformanceMonitoringCreateLighthouseScriptMonitor?: Maybe<WebsitePerformanceMonitoringCreateMonitorsResponse>;
  /**
   * Creates syntheticsMonitors for the given website
   * @deprecated This field is experimental and subject to breaking changes.
   */
  websitePerformanceMonitoringCreateWebsitePerformanceMonitors?: Maybe<WebsitePerformanceMonitoringCreateMonitorsResponse>;
  /**
   * Update website Performance monitoring
   * @deprecated This field is experimental and subject to breaking changes.
   */
  websitePerformanceMonitoringUpdateRequest?: Maybe<WebsitePerformanceMonitoringUpdateRequestResponse>;
  /** Updates the date the current user last read the news. */
  whatsNewSetLastReadDate?: Maybe<Scalars['EpochMilliseconds']['output']>;
  /** Creates a new workload. */
  workloadCreate?: Maybe<WorkloadCollection>;
  /** Deletes an existing workload. */
  workloadDelete?: Maybe<WorkloadCollection>;
  /** Duplicates an existing workload. */
  workloadDuplicate?: Maybe<WorkloadCollection>;
  /** Updates an existing workload. */
  workloadUpdate?: Maybe<WorkloadCollection>;
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeAbTestGetVariationArgs = {
  req: AbTestGetVariationRequest;
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeAbTestTrackEventArgs = {
  req: AbTestTrackEventRequest;
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeAccountFeatureConfigurationSetFedrampComplianceArgs = {
  accountId: Scalars['Int']['input'];
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeAccountFeatureConfigurationSetHipaaComplianceArgs = {
  accountId: Scalars['Int']['input'];
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeAccountManagementCreateAccountArgs = {
  managedAccount: AccountManagementCreateInput;
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeAccountManagementUpdateAccountArgs = {
  managedAccount: AccountManagementUpdateInput;
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeAccountShareInvitationsAcceptInvitationArgs = {
  token: Scalars['SecureValue']['input'];
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeAccountShareInvitationsCreateAccountShareInvitationArgs = {
  accountId: Scalars['Int']['input'];
  limitingRoleId: Scalars['Int']['input'];
  note?: InputMaybe<Scalars['String']['input']>;
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeAccountShareInvitationsRevokeInvitationArgs = {
  id?: InputMaybe<Scalars['SecureValue']['input']>;
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeAgentApplicationCreateBrowserArgs = {
  accountId: Scalars['Int']['input'];
  name: Scalars['String']['input'];
  settings?: InputMaybe<AgentApplicationBrowserSettingsInput>;
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeAgentApplicationCreateMobileArgs = {
  accountId: Scalars['Int']['input'];
  name: Scalars['String']['input'];
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeAgentApplicationDeleteArgs = {
  guid: Scalars['EntityGuid']['input'];
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeAgentApplicationEnableApmBrowserArgs = {
  guid: Scalars['EntityGuid']['input'];
  settings?: InputMaybe<AgentApplicationBrowserSettingsInput>;
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeAgentApplicationSegmentsReplaceAllBrowserSegmentAllowListArgs = {
  allowList: AgentApplicationSegmentsBrowserSegmentAllowListInput;
  entityGuid: Scalars['EntityGuid']['input'];
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeAgentApplicationSettingsUpdateArgs = {
  guid: Scalars['EntityGuid']['input'];
  settings: AgentApplicationSettingsUpdateInput;
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeAgentTracesDeleteErrorTraceArgs = {
  guid: Scalars['EntityGuid']['input'];
  id: Scalars['ID']['input'];
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeAgentTracesDeleteErrorTracesArgs = {
  guid: Scalars['EntityGuid']['input'];
  realAgentIds: Array<InputMaybe<Scalars['ID']['input']>>;
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeAgentTracesDeleteSqlTraceArgs = {
  guid: Scalars['EntityGuid']['input'];
  id: Scalars['ID']['input'];
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeAgentTracesDeleteSqlTracesArgs = {
  guid: Scalars['EntityGuid']['input'];
  realAgentIds: Array<InputMaybe<Scalars['ID']['input']>>;
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeAgentTracesDeleteTransactionTraceArgs = {
  guid: Scalars['EntityGuid']['input'];
  id: Scalars['ID']['input'];
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeAgentTracesDeleteTransactionTracesArgs = {
  guid: Scalars['EntityGuid']['input'];
  realAgentIds: Array<InputMaybe<Scalars['ID']['input']>>;
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeAiConnectAddEnrichersArgs = {
  accountId: Scalars['Int']['input'];
  enrichers: AiConnectEnrichers;
  workflowId: Scalars['ID']['input'];
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeAiConnectAddNotifierArgs = {
  accountId: Scalars['Int']['input'];
  notifiers: AiConnectNotifiers;
  workflowId: Scalars['ID']['input'];
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeAiConnectCreateWorkflowArgs = {
  accountId: Scalars['Int']['input'];
  workflow: AiConnectWorkflowInput;
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeAiConnectDeleteEnricherArgs = {
  accountId: Scalars['Int']['input'];
  entityId: Scalars['ID']['input'];
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeAiConnectDeleteNotifierArgs = {
  accountId: Scalars['Int']['input'];
  entityId: Scalars['ID']['input'];
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeAiConnectDeleteWorkflowArgs = {
  accountId: Scalars['Int']['input'];
  workflowId: Scalars['ID']['input'];
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeAiConnectEditEnricherArgs = {
  accountId: Scalars['Int']['input'];
  enricher: AiConnectEnrichersUpdate;
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeAiConnectEditNotifierArgs = {
  accountId: Scalars['Int']['input'];
  notifier: AiConnectNotifiersUpdate;
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeAiConnectEditWorkflowArgs = {
  accountId: Scalars['Int']['input'];
  workflowUpdate: AiConnectWorkflowUpdate;
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeAiConnectTestNotifierArgs = {
  accountId: Scalars['Int']['input'];
  notifier: AiConnectNotifierTestInput;
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeAiConnectTestNotifierByIdArgs = {
  accountId: Scalars['Int']['input'];
  notifierId: Scalars['ID']['input'];
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeAiConnectTestWorkflowArgs = {
  accountId: Scalars['Int']['input'];
  workflow: AiConnectWorkflowInput;
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeAiConnectTestWorkflowByIdArgs = {
  accountId: Scalars['Int']['input'];
  workflowId: Scalars['ID']['input'];
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeAiDecisionsAcceptSuggestionArgs = {
  accountId: Scalars['Int']['input'];
  suggestionId: Scalars['ID']['input'];
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeAiDecisionsCreateImplicitRuleArgs = {
  accountId: Scalars['Int']['input'];
  rule: AiDecisionsRuleBlueprint;
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeAiDecisionsCreateRuleArgs = {
  accountId: Scalars['Int']['input'];
  rule: AiDecisionsRuleBlueprint;
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeAiDecisionsCreateSuggestionArgs = {
  accountId: Scalars['Int']['input'];
  suggestion: AiDecisionsSuggestionBlueprint;
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeAiDecisionsDeclineSuggestionArgs = {
  accountId: Scalars['Int']['input'];
  suggestionId: Scalars['ID']['input'];
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeAiDecisionsDeleteMergeFeedbackArgs = {
  accountId: Scalars['Int']['input'];
  childIssueId: Scalars['ID']['input'];
  parentIssueId: Scalars['ID']['input'];
  ruleId: Scalars['ID']['input'];
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeAiDecisionsDeleteRuleArgs = {
  accountId: Scalars['Int']['input'];
  ruleId: Scalars['ID']['input'];
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeAiDecisionsDeleteSuggestionArgs = {
  accountId: Scalars['Int']['input'];
  suggestionId: Scalars['ID']['input'];
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeAiDecisionsDisableRuleArgs = {
  accountId: Scalars['Int']['input'];
  ruleId: Scalars['ID']['input'];
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeAiDecisionsEnableRuleArgs = {
  accountId: Scalars['Int']['input'];
  ruleId: Scalars['ID']['input'];
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeAiDecisionsFindApplicableIncidentsArgs = {
  accountId: Scalars['Int']['input'];
  search: AiDecisionsSearchBlueprint;
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeAiDecisionsPostponeSuggestionArgs = {
  accountId: Scalars['Int']['input'];
  suggestionId: Scalars['ID']['input'];
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeAiDecisionsRecordMergeFeedbackArgs = {
  accountId: Scalars['Int']['input'];
  childIssueId: Scalars['ID']['input'];
  opinion: AiDecisionsOpinion;
  parentIssueId: Scalars['ID']['input'];
  ruleId: Scalars['ID']['input'];
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeAiDecisionsSimulateArgs = {
  accountId: Scalars['Int']['input'];
  simulation: AiDecisionsSimulationBlueprint;
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeAiDecisionsUpdateImplicitRuleArgs = {
  accountId: Scalars['Int']['input'];
  rule: AiDecisionsRuleBlueprint;
  ruleId: Scalars['ID']['input'];
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeAiDecisionsUpdateRuleArgs = {
  accountId: Scalars['Int']['input'];
  rule: AiDecisionsRuleBlueprint;
  ruleId: Scalars['ID']['input'];
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeAiIssuesAckIssueArgs = {
  accountId: Scalars['Int']['input'];
  issueId: Scalars['ID']['input'];
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeAiIssuesCloseIncidentArgs = {
  accountId: Scalars['Int']['input'];
  incidentId: Scalars['ID']['input'];
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeAiIssuesResolveIssueArgs = {
  accountId: Scalars['Int']['input'];
  issueId: Scalars['ID']['input'];
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeAiIssuesUnackIssueArgs = {
  accountId: Scalars['Int']['input'];
  issueId: Scalars['ID']['input'];
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeAiIssuesUpdateGracePeriodArgs = {
  accountId: Scalars['Int']['input'];
  gracePeriod: AiIssuesGracePeriodConfigurationInput;
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeAiIssuesUpdateIssueTtlArgs = {
  accountId: Scalars['Int']['input'];
  issueTtl: Scalars['Seconds']['input'];
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeAiNotificationsCreateChannelArgs = {
  accountId: Scalars['Int']['input'];
  channel: AiNotificationsChannelInput;
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeAiNotificationsCreateDestinationArgs = {
  accountId: Scalars['Int']['input'];
  destination: AiNotificationsDestinationInput;
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeAiNotificationsDeleteChannelArgs = {
  accountId: Scalars['Int']['input'];
  channelId: Scalars['ID']['input'];
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeAiNotificationsDeleteDestinationArgs = {
  accountId: Scalars['Int']['input'];
  destinationId: Scalars['ID']['input'];
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeAiNotificationsMergeDestinationsArgs = {
  accountId: Scalars['Int']['input'];
  mergeGroups: Array<AiNotificationsMergeGroup>;
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeAiNotificationsTestChannelArgs = {
  accountId: Scalars['Int']['input'];
  channel: AiNotificationsChannelInput;
  variables?: InputMaybe<Array<AiNotificationsDynamicVariable>>;
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeAiNotificationsTestChannelByIdArgs = {
  accountId: Scalars['Int']['input'];
  channelId: Scalars['ID']['input'];
  variables?: InputMaybe<Array<AiNotificationsDynamicVariable>>;
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeAiNotificationsTestDestinationArgs = {
  accountId: Scalars['Int']['input'];
  destination: AiNotificationsDestinationInput;
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeAiNotificationsTestDestinationByIdArgs = {
  accountId: Scalars['Int']['input'];
  destinationId: Scalars['ID']['input'];
  update?: InputMaybe<AiNotificationsDestinationUpdate>;
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeAiNotificationsUpdateChannelArgs = {
  accountId: Scalars['Int']['input'];
  channel: AiNotificationsChannelUpdate;
  channelId: Scalars['ID']['input'];
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeAiNotificationsUpdateDestinationArgs = {
  accountId: Scalars['Int']['input'];
  destination: AiNotificationsDestinationUpdate;
  destinationId: Scalars['ID']['input'];
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeAiOpsAddIncidentIntelligenceDestinationToConfigsArgs = {
  destination: AiOpsIncidentIntelligenceDestinationInput;
  ids: Array<Scalars['ID']['input']>;
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeAiOpsArchiveProactiveDetectionConfigArgs = {
  id: Scalars['ID']['input'];
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeAiOpsClearUserMessageArgs = {
  userMessageId?: InputMaybe<AiOpsUserMessageId>;
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeAiOpsCloseAnomalyArgs = {
  accountId: Scalars['Int']['input'];
  id: Scalars['ID']['input'];
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeAiOpsCreateAnomalyCommentArgs = {
  accountId: Scalars['Int']['input'];
  anomalyId: Scalars['ID']['input'];
  text: Scalars['String']['input'];
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeAiOpsCreateDraftProactiveDetectionConfigArgs = {
  config?: InputMaybe<AiOpsProactiveDetectionConfigInput>;
  id?: InputMaybe<Scalars['ID']['input']>;
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeAiOpsCreateIncidentCommentArgs = {
  accountId: Scalars['Int']['input'];
  incidentId: Scalars['ID']['input'];
  text: Scalars['String']['input'];
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeAiOpsCreateProactiveDetectionConfigArgs = {
  config?: InputMaybe<AiOpsProactiveDetectionConfigInput>;
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeAiOpsDeleteCommentArgs = {
  accountId: Scalars['Int']['input'];
  id: Scalars['ID']['input'];
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeAiOpsPreviewWebhookArgs = {
  webhook: AiOpsWebhookInput;
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeAiOpsRemoveIncidentIntelligenceDestinationFromConfigsArgs = {
  destination: AiOpsIncidentIntelligenceDestinationInput;
  ids: Array<Scalars['ID']['input']>;
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeAiOpsStoreTrainingSessionArgs = {
  accountId: Scalars['Int']['input'];
  anomalyId: Scalars['String']['input'];
  feedback: AiOpsFeedbackLabel;
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeAiOpsTestWebhookArgs = {
  webhook: AiOpsWebhookInput;
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeAiOpsUpdateProactiveDetectionConfigArgs = {
  config?: InputMaybe<AiOpsProactiveDetectionConfigInput>;
  id: Scalars['ID']['input'];
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeAiOpsViewUserMessageArgs = {
  userMessageId?: InputMaybe<AiOpsUserMessageId>;
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeAiPostmortemCreatePostmortemArgs = {
  accountId: Scalars['Int']['input'];
  postmortem: AiPostmortemPostmortemBlueprint;
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeAiPostmortemDeletePostmortemArgs = {
  accountId: Scalars['Int']['input'];
  postmortemId: Scalars['ID']['input'];
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeAiPostmortemUpdatePostmortemArgs = {
  accountId: Scalars['Int']['input'];
  postmortem: AiPostmortemPostmortemBlueprint;
  postmortemId: Scalars['ID']['input'];
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeAiTopologyCollectorCreateEdgesArgs = {
  accountId: Scalars['Int']['input'];
  edges: Array<AiTopologyCollectorEdgeBlueprint>;
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeAiTopologyCollectorCreateVerticesArgs = {
  accountId: Scalars['Int']['input'];
  vertices: Array<AiTopologyCollectorVertexBlueprint>;
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeAiTopologyCollectorDeleteEdgesArgs = {
  accountId: Scalars['Int']['input'];
  edgeIds: Array<Scalars['ID']['input']>;
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeAiTopologyCollectorDeleteVerticesArgs = {
  accountId: Scalars['Int']['input'];
  vertexNames: Array<Scalars['ID']['input']>;
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeAiWorkflowsCreateWorkflowArgs = {
  accountId: Scalars['Int']['input'];
  createWorkflowData: AiWorkflowsCreateWorkflowInput;
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeAiWorkflowsDeleteWorkflowArgs = {
  accountId: Scalars['Int']['input'];
  deleteChannels?: Scalars['Boolean']['input'];
  id: Scalars['ID']['input'];
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeAiWorkflowsTestWorkflowArgs = {
  accountId: Scalars['Int']['input'];
  testWorkflowData: AiWorkflowsTestWorkflowInput;
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeAiWorkflowsUpdateWorkflowArgs = {
  accountId: Scalars['Int']['input'];
  deleteUnusedChannels?: Scalars['Boolean']['input'];
  updateWorkflowData: AiWorkflowsUpdateWorkflowInput;
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeAlertsConditionDeleteArgs = {
  accountId: Scalars['Int']['input'];
  id: Scalars['ID']['input'];
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeAlertsConditionUpdateEnabledArgs = {
  accountId: Scalars['Int']['input'];
  enabled: Scalars['Boolean']['input'];
  id: Scalars['ID']['input'];
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeAlertsMutingRuleCreateArgs = {
  accountId: Scalars['Int']['input'];
  rule: AlertsMutingRuleInput;
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeAlertsMutingRuleDeleteArgs = {
  accountId: Scalars['Int']['input'];
  id: Scalars['ID']['input'];
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeAlertsMutingRuleUpdateArgs = {
  accountId: Scalars['Int']['input'];
  id: Scalars['ID']['input'];
  rule: AlertsMutingRuleUpdateInput;
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeAlertsNotificationChannelCreateArgs = {
  accountId: Scalars['Int']['input'];
  notificationChannel: AlertsNotificationChannelCreateConfiguration;
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeAlertsNotificationChannelDeleteArgs = {
  accountId: Scalars['Int']['input'];
  id: Scalars['ID']['input'];
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeAlertsNotificationChannelUpdateArgs = {
  accountId: Scalars['Int']['input'];
  id: Scalars['ID']['input'];
  notificationChannel: AlertsNotificationChannelUpdateConfiguration;
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeAlertsNotificationChannelsAddToPolicyArgs = {
  accountId: Scalars['Int']['input'];
  notificationChannelIds: Array<Scalars['ID']['input']>;
  policyId: Scalars['ID']['input'];
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeAlertsNotificationChannelsRemoveFromPolicyArgs = {
  accountId: Scalars['Int']['input'];
  notificationChannelIds: Array<Scalars['ID']['input']>;
  policyId: Scalars['ID']['input'];
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeAlertsNrqlConditionBaselineCreateArgs = {
  accountId: Scalars['Int']['input'];
  condition: AlertsNrqlConditionBaselineInput;
  policyId: Scalars['ID']['input'];
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeAlertsNrqlConditionBaselineUpdateArgs = {
  accountId: Scalars['Int']['input'];
  condition: AlertsNrqlConditionUpdateBaselineInput;
  id: Scalars['ID']['input'];
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeAlertsNrqlConditionOutlierCreateArgs = {
  accountId: Scalars['Int']['input'];
  condition: AlertsNrqlConditionOutlierInput;
  policyId: Scalars['ID']['input'];
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeAlertsNrqlConditionOutlierUpdateArgs = {
  accountId: Scalars['Int']['input'];
  condition: AlertsNrqlConditionUpdateOutlierInput;
  id: Scalars['ID']['input'];
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeAlertsNrqlConditionStaticCreateArgs = {
  accountId: Scalars['Int']['input'];
  condition: AlertsNrqlConditionStaticInput;
  policyId: Scalars['ID']['input'];
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeAlertsNrqlConditionStaticUpdateArgs = {
  accountId: Scalars['Int']['input'];
  condition: AlertsNrqlConditionUpdateStaticInput;
  id: Scalars['ID']['input'];
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeAlertsPolicyCreateArgs = {
  accountId: Scalars['Int']['input'];
  policy: AlertsPolicyInput;
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeAlertsPolicyDeleteArgs = {
  accountId: Scalars['Int']['input'];
  id: Scalars['ID']['input'];
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeAlertsPolicyUpdateArgs = {
  accountId: Scalars['Int']['input'];
  id: Scalars['ID']['input'];
  policy: AlertsPolicyUpdateInput;
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeAnomalyDetectorConfigurationsAnomalyDetectorDeleteArgs = {
  anomalyDetectorId: Scalars['Int']['input'];
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeAnomalyDetectorConfigurationsEntityTypeAnomalyDetectorCreateArgs = {
  accountId: Scalars['Int']['input'];
  anomalyDetector: AnomalyDetectorConfigurationsCreateEntityTypeAnomalyDetectorInput;
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeAnomalyDetectorConfigurationsEntityTypeAnomalyDetectorUpdateArgs = {
  anomalyDetector: AnomalyDetectorConfigurationsUpdateEntityTypeAnomalyDetectorInput;
  anomalyDetectorId: Scalars['Int']['input'];
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeAnomalyDetectorConfigurationsNrqlAnomalyDetectorCreateArgs = {
  accountId: Scalars['Int']['input'];
  anomalyDetector: AnomalyDetectorConfigurationsCreateNrqlAnomalyDetectorInput;
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeAnomalyDetectorConfigurationsNrqlAnomalyDetectorUpdateArgs = {
  accountId?: InputMaybe<Scalars['Int']['input']>;
  anomalyDetector?: InputMaybe<AnomalyDetectorConfigurationsUpdateNrqlAnomalyDetectorInput>;
  anomalyDetectorId: Scalars['Int']['input'];
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeAnomalyDetectorConfigurationsUpdateStatusArgs = {
  anomalyDetectorId: Scalars['Int']['input'];
  status: AnomalyDetectorConfigurationsAnomalyDetectorStatus;
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeAnomalyDetectorConfigurationsValidateNrqlSignalArgs = {
  accountId: Scalars['Int']['input'];
  nrql: Scalars['Nrql']['input'];
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeAnomalyDetectorConfigurationsWorkloadAnomalyDetectorCreateArgs = {
  anomalyDetector: AnomalyDetectorConfigurationsCreateWorkloadAnomalyDetectorInput;
  workloadGuid: Scalars['EntityGuid']['input'];
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeAnomalyDetectorConfigurationsWorkloadAnomalyDetectorUpdateArgs = {
  anomalyDetector: AnomalyDetectorConfigurationsUpdateWorkloadAnomalyDetectorInput;
  anomalyDetectorId: Scalars['Int']['input'];
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeApiAccessCreateKeysArgs = {
  keys: ApiAccessCreateInput;
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeApiAccessDeleteKeysArgs = {
  keys: ApiAccessDeleteInput;
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeApiAccessUpdateKeysArgs = {
  keys: ApiAccessUpdateInput;
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeApmApplicationEntityChangeSettingsArgs = {
  guid: Scalars['EntityGuid']['input'];
  settings: ApmApplicationEntitySettings;
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeAuthorizationManagementGrantAccessArgs = {
  grantAccessOptions?: InputMaybe<AuthorizationManagementGrantAccess>;
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeAuthorizationManagementRevokeAccessArgs = {
  revokeAccessOptions?: InputMaybe<AuthorizationManagementRevokeAccess>;
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeCartographerCollectorCreateEdgesArgs = {
  accountId: Scalars['Int']['input'];
  edges: Array<CartographerCollectorEdgeBlueprint>;
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeCartographerCollectorCreateVerticesArgs = {
  accountId: Scalars['Int']['input'];
  vertices: Array<CartographerCollectorVertexBlueprint>;
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeCartographerCollectorDeleteEdgesArgs = {
  accountId: Scalars['Int']['input'];
  edgeIds: Array<Scalars['ID']['input']>;
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeCartographerCollectorDeleteVerticesArgs = {
  accountId: Scalars['Int']['input'];
  vertexIds: Array<Scalars['ID']['input']>;
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeChangeTrackingCreateChangeTrackingEventArgs = {
  changeTrackingEvent: ChangeTrackingChangeTrackingInput;
  dataHandlingRules?: InputMaybe<ChangeTrackingDataHandlingRules>;
  entityGuid: Scalars['EntityGuid']['input'];
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeChangeTrackingCreateDeploymentArgs = {
  dataHandlingRules?: InputMaybe<ChangeTrackingDataHandlingRules>;
  deployment: ChangeTrackingDeploymentInput;
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeChaosStartArgs = {
  configuration: ChaosConfiguration;
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeCloudConfigureIntegrationArgs = {
  accountId: Scalars['Int']['input'];
  integrations: CloudIntegrationsInput;
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeCloudDisableIntegrationArgs = {
  accountId: Scalars['Int']['input'];
  integrations?: InputMaybe<CloudDisableIntegrationsInput>;
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeCloudGcpServiceAccountAuthArgs = {
  accountId: Scalars['Int']['input'];
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeCloudLinkAccountArgs = {
  accountId: Scalars['Int']['input'];
  accounts?: InputMaybe<CloudLinkCloudAccountsInput>;
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeCloudMigrateAwsGovCloudToAssumeRoleArgs = {
  accountId: Scalars['Int']['input'];
  accounts: Array<CloudAwsGovCloudMigrateToAssumeroleInput>;
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeCloudRenameAccountArgs = {
  accountId: Scalars['Int']['input'];
  accounts?: InputMaybe<Array<InputMaybe<CloudRenameAccountsInput>>>;
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeCloudUnlinkAccountArgs = {
  accountId: Scalars['Int']['input'];
  accounts?: InputMaybe<Array<InputMaybe<CloudUnlinkAccountsInput>>>;
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeCollaborationCreateCodeMarkArgs = {
  code: Scalars['String']['input'];
  file: Scalars['String']['input'];
  permalink: Scalars['String']['input'];
  repo: Scalars['String']['input'];
  sha: Scalars['String']['input'];
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeCollaborationCreateCommentArgs = {
  assistant?: InputMaybe<Scalars['String']['input']>;
  assistantConfig?: InputMaybe<Array<InputMaybe<CollaborationAssistantConfigInput>>>;
  body: Scalars['String']['input'];
  contextMetadata?: InputMaybe<Scalars['CollaborationRawContextMetadata']['input']>;
  destinationId?: InputMaybe<Scalars['String']['input']>;
  nRConnectionId?: InputMaybe<Scalars['String']['input']>;
  referenceUrl?: InputMaybe<Scalars['String']['input']>;
  slackChannelId?: InputMaybe<Scalars['String']['input']>;
  suppress3rdPartyFileShare?: InputMaybe<Scalars['Boolean']['input']>;
  threadId: Scalars['ID']['input'];
  timePickerFrom?: InputMaybe<Scalars['EpochMilliseconds']['input']>;
  timePickerTo?: InputMaybe<Scalars['EpochMilliseconds']['input']>;
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeCollaborationCreateContextArgs = {
  accountId?: InputMaybe<Scalars['Int']['input']>;
  contextMetadata?: InputMaybe<Scalars['CollaborationRawContextMetadata']['input']>;
  entityGuid?: InputMaybe<Scalars['EntityGuid']['input']>;
  id: Scalars['ID']['input'];
  referenceUrl?: InputMaybe<Scalars['String']['input']>;
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeCollaborationCreateEmailArgs = {
  emailAddress: Scalars['String']['input'];
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeCollaborationCreateExternalServiceConnectionArgs = {
  channelId?: InputMaybe<Scalars['ID']['input']>;
  sessionId: Scalars['ID']['input'];
  threadId: Scalars['ID']['input'];
  type: Scalars['String']['input'];
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeCollaborationCreateMentionArgs = {
  commentId: Scalars['ID']['input'];
  externalApplicationType?: InputMaybe<CollaborationExternalApplicationType>;
  externalCreatorId?: InputMaybe<Scalars['ID']['input']>;
  mentionableItemId: Scalars['ID']['input'];
  type: Scalars['String']['input'];
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeCollaborationCreateThreadArgs = {
  contextId: Scalars['ID']['input'];
  contextMetadata?: InputMaybe<Scalars['CollaborationRawContextMetadata']['input']>;
  externalApplicationType?: InputMaybe<Scalars['String']['input']>;
  referenceUrl?: InputMaybe<Scalars['String']['input']>;
  visibility?: InputMaybe<Scalars['String']['input']>;
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeCollaborationDeactivateCodeMarkArgs = {
  id: Scalars['ID']['input'];
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeCollaborationDeactivateCommentArgs = {
  id: Scalars['ID']['input'];
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeCollaborationDeactivateContextArgs = {
  id: Scalars['ID']['input'];
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeCollaborationDeactivateExternalServiceConnectionArgs = {
  id: Scalars['ID']['input'];
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeCollaborationDeactivateFileArgs = {
  id: Scalars['ID']['input'];
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeCollaborationDeactivateMentionArgs = {
  id: Scalars['ID']['input'];
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeCollaborationDeactivateThreadArgs = {
  id: Scalars['ID']['input'];
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeCollaborationFeedbackOnBotResponseArgs = {
  content?: InputMaybe<Scalars['String']['input']>;
  rating: Scalars['Int']['input'];
  responseId: Scalars['ID']['input'];
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeCollaborationGetUploadUrlArgs = {
  fileName: Scalars['ID']['input'];
  isScreenshot?: InputMaybe<Scalars['Boolean']['input']>;
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeCollaborationSendMessageArgs = {
  accountId: Scalars['Int']['input'];
  body: Scalars['String']['input'];
  destinationId?: InputMaybe<Scalars['String']['input']>;
  emailAddress?: InputMaybe<Scalars['String']['input']>;
  referenceUrl: Scalars['String']['input'];
  sharedToType: Scalars['String']['input'];
  slackChannelId?: InputMaybe<Scalars['String']['input']>;
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeCollaborationSetExternalServiceConnectionChannelArgs = {
  channelId: Scalars['ID']['input'];
  id: Scalars['ID']['input'];
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeCollaborationSocketSubscribeArgs = {
  nrConnectionId?: InputMaybe<Scalars['String']['input']>;
  subscriptionKeys?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeCollaborationSubscribeToThreadArgs = {
  threadId: Scalars['ID']['input'];
  userId?: InputMaybe<Scalars['ID']['input']>;
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeCollaborationUnsubscribeFromThreadArgs = {
  threadId: Scalars['ID']['input'];
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeCollaborationUpdateCommentArgs = {
  body: Scalars['String']['input'];
  id: Scalars['ID']['input'];
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeCollaborationUpdateContextAddCommentArgs = {
  commentId: Scalars['ID']['input'];
  id: Scalars['ID']['input'];
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeCollaborationUpdateContextAddThreadArgs = {
  id: Scalars['ID']['input'];
  threadId: Scalars['ID']['input'];
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeCollaborationUpdateSubscriptionReadInfoArgs = {
  commentsReadCount?: InputMaybe<Scalars['Int']['input']>;
  lastCommentReadId?: InputMaybe<Scalars['ID']['input']>;
  mentionsReadCount?: InputMaybe<Scalars['Int']['input']>;
  threadId: Scalars['ID']['input'];
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeCollaborationUpdateThreadAddCommentArgs = {
  commentId: Scalars['ID']['input'];
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeCollaborationUpdateThreadStatusArgs = {
  id: Scalars['ID']['input'];
  status?: InputMaybe<CollaborationStatus>;
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeCommerceCancelSubscriptionArgs = {
  accountId: Scalars['Int']['input'];
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeCommerceExecutePaymentRunArgs = {
  accountId: Scalars['Int']['input'];
  invoiceIds?: InputMaybe<Array<Scalars['ID']['input']>>;
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeCommerceExtendRetentionArgs = {
  accountId: Scalars['Int']['input'];
  numberOfDays: Scalars['Int']['input'];
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeCommerceNotificationsMuteNotificationArgs = {
  accountId: Scalars['Int']['input'];
  notificationId: Scalars['ID']['input'];
  notificationType: CommerceNotificationsNotificationType;
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeCommercePurchaseOfferArgs = {
  accountId: Scalars['Int']['input'];
  offerId: Scalars['String']['input'];
  options?: InputMaybe<CommerceOptionsInput>;
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeCommerceSetDefaultPaymentMethodArgs = {
  accountId: Scalars['Int']['input'];
  paymentMethodId: Scalars['ID']['input'];
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeCommerceUpdateBillingInfoArgs = {
  accountId: Scalars['Int']['input'];
  billingInfo: CommerceBillingInfoInput;
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeContentSharingShareWithRecipientsArgs = {
  comment?: InputMaybe<Scalars['String']['input']>;
  recipients: Array<ContentSharingRecipientInput>;
  sharedContent: Array<ContentSharingContentInput>;
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeCorrelationAcceptSuggestionArgs = {
  accountId: Scalars['Int']['input'];
  suggestionId: Scalars['ID']['input'];
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeCorrelationCreateImplicitRuleArgs = {
  accountId: Scalars['Int']['input'];
  rule: CorrelationRuleBlueprint;
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeCorrelationCreateRuleArgs = {
  accountId: Scalars['Int']['input'];
  rule: CorrelationRuleBlueprint;
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeCorrelationCreateSuggestionArgs = {
  accountId: Scalars['Int']['input'];
  suggestion: CorrelationSuggestionBlueprint;
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeCorrelationDeclineSuggestionArgs = {
  accountId: Scalars['Int']['input'];
  suggestionId: Scalars['ID']['input'];
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeCorrelationDeleteMergeFeedbackArgs = {
  accountId: Scalars['Int']['input'];
  childIssueId: Scalars['ID']['input'];
  parentIssueId: Scalars['ID']['input'];
  ruleId: Scalars['ID']['input'];
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeCorrelationDeleteMergeFeedbackByRulesArgs = {
  accountId: Scalars['Int']['input'];
  childIssueId: Scalars['ID']['input'];
  parentIssueId: Scalars['ID']['input'];
  ruleIds: Array<Scalars['ID']['input']>;
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeCorrelationDeleteRuleArgs = {
  accountId: Scalars['Int']['input'];
  ruleId: Scalars['ID']['input'];
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeCorrelationDeleteSuggestionArgs = {
  accountId: Scalars['Int']['input'];
  suggestionId: Scalars['ID']['input'];
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeCorrelationDisableRuleArgs = {
  accountId: Scalars['Int']['input'];
  ruleId: Scalars['ID']['input'];
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeCorrelationEnableRuleArgs = {
  accountId: Scalars['Int']['input'];
  ruleId: Scalars['ID']['input'];
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeCorrelationFindApplicableIncidentsArgs = {
  accountId: Scalars['Int']['input'];
  search: CorrelationSearchBlueprint;
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeCorrelationPostponeSuggestionArgs = {
  accountId: Scalars['Int']['input'];
  suggestionId: Scalars['ID']['input'];
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeCorrelationRecordMergeFeedbackArgs = {
  accountId: Scalars['Int']['input'];
  childIssueId: Scalars['ID']['input'];
  opinion: CorrelationOpinion;
  parentIssueId: Scalars['ID']['input'];
  ruleId: Scalars['ID']['input'];
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeCorrelationRecordMergeFeedbackByRulesArgs = {
  accountId: Scalars['Int']['input'];
  childIssueId: Scalars['ID']['input'];
  opinion: CorrelationOpinion;
  parentIssueId: Scalars['ID']['input'];
  ruleIds: Array<Scalars['ID']['input']>;
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeCorrelationSimulateArgs = {
  accountId: Scalars['Int']['input'];
  simulation: CorrelationSimulationBlueprint;
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeCorrelationUpdateImplicitRuleArgs = {
  accountId: Scalars['Int']['input'];
  rule: CorrelationRuleBlueprint;
  ruleId: Scalars['ID']['input'];
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeCorrelationUpdateRuleArgs = {
  accountId: Scalars['Int']['input'];
  rule: CorrelationRuleBlueprint;
  ruleId: Scalars['ID']['input'];
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeCorrelationUpsertRuleAnnotationsArgs = {
  accountId: Scalars['Int']['input'];
  ruleAnnotation: CorrelationAnnotationInput;
  ruleId: Scalars['ID']['input'];
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeCourierNotificationPreferencesUpdateArgs = {
  updatedNotificationPreferences: Array<InputMaybe<CourierNotificationPreferencesUpdatedNotificationPreference>>;
  userId: Scalars['String']['input'];
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeDashboardAddWidgetsToPageArgs = {
  guid: Scalars['EntityGuid']['input'];
  widgets: Array<DashboardWidgetInput>;
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeDashboardCreateArgs = {
  accountId: Scalars['Int']['input'];
  dashboard: DashboardInput;
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeDashboardCreateLiveUrlArgs = {
  guid: Scalars['EntityGuid']['input'];
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeDashboardCreateSnapshotUrlArgs = {
  guid: Scalars['EntityGuid']['input'];
  params?: InputMaybe<DashboardSnapshotUrlInput>;
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeDashboardDeleteArgs = {
  guid: Scalars['EntityGuid']['input'];
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeDashboardRevokeLiveUrlArgs = {
  id: Scalars['ID']['input'];
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeDashboardUndeleteArgs = {
  guid: Scalars['EntityGuid']['input'];
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeDashboardUpdateArgs = {
  dashboard: DashboardInput;
  guid: Scalars['EntityGuid']['input'];
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeDashboardUpdatePageArgs = {
  guid: Scalars['EntityGuid']['input'];
  page: DashboardUpdatePageInput;
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeDashboardUpdateWidgetsInPageArgs = {
  guid: Scalars['EntityGuid']['input'];
  widgets: Array<DashboardUpdateWidgetInput>;
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeDashboardWidgetRevokeLiveUrlArgs = {
  uuid: Scalars['ID']['input'];
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeDataManagementCopyRetentionsArgs = {
  destinationAccountIds: Array<InputMaybe<Scalars['Int']['input']>>;
  sourceAccountId: Scalars['Int']['input'];
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeDataManagementCreateEventRetentionRuleArgs = {
  accountId: Scalars['Int']['input'];
  namespace: Scalars['String']['input'];
  retentionInDays: Scalars['Int']['input'];
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeDataManagementCreateRetentionRulesArgs = {
  accountId: Scalars['Int']['input'];
  retentionRules?: InputMaybe<Array<InputMaybe<DataManagementRuleInput>>>;
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeDataManagementDeleteEventRetentionRuleArgs = {
  accountId: Scalars['Int']['input'];
  namespace: Scalars['String']['input'];
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeDataManagementUpdateFeatureSettingsArgs = {
  accountId: Scalars['Int']['input'];
  setting?: InputMaybe<DataManagementAccountFeatureSettingInput>;
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeDiscussionCreateErrorGroupPostArgs = {
  errorGroupGuid: Scalars['EntityGuid']['input'];
  post?: InputMaybe<DiscussionCreateErrorGroupPostInput>;
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeDiscussionDeleteErrorGroupPostArgs = {
  errorGroupGuid: Scalars['EntityGuid']['input'];
  postId: Scalars['String']['input'];
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeDiscussionUpdateErrorGroupPostArgs = {
  errorGroupGuid: Scalars['EntityGuid']['input'];
  post: DiscussionUpdateErrorGroupPostInput;
  postId: Scalars['String']['input'];
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeDomainManagementCreateDomainArgs = {
  domainName: Scalars['String']['input'];
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeDomainManagementDeleteDomainArgs = {
  domainId: Scalars['String']['input'];
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeDomainManagementRetryDomainVerificationArgs = {
  domainId: Scalars['String']['input'];
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeDomainManagementUpdateCaptureConfigurationArgs = {
  domainId: Scalars['String']['input'];
  joinOrganizationPreference?: InputMaybe<DomainManagementJoinOrganizationPreference>;
  message?: InputMaybe<Scalars['String']['input']>;
  newUserConfiguration?: InputMaybe<DomainManagementNewUserConfigurationInput>;
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeEdgeCreateTraceFilterRulesArgs = {
  accountId: Scalars['Int']['input'];
  rules: EdgeCreateTraceFilterRulesInput;
  traceObserverId: Scalars['Int']['input'];
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeEdgeCreateTraceObserverArgs = {
  accountId: Scalars['Int']['input'];
  traceObserverConfigs: Array<EdgeCreateTraceObserverInput>;
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeEdgeDeleteTraceFilterRulesArgs = {
  accountId: Scalars['Int']['input'];
  rules: EdgeDeleteTraceFilterRulesInput;
  traceObserverId: Scalars['Int']['input'];
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeEdgeDeleteTraceObserversArgs = {
  accountId: Scalars['Int']['input'];
  traceObserverConfigs: Array<EdgeDeleteTraceObserverInput>;
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeEdgeUpdateTraceObserversArgs = {
  accountId: Scalars['Int']['input'];
  traceObserverConfigs: Array<EdgeUpdateTraceObserverInput>;
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeEntityDeleteArgs = {
  forceDelete?: Scalars['Boolean']['input'];
  guids: Array<Scalars['EntityGuid']['input']>;
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeEntityGoldenMetricsOverrideArgs = {
  context: EntityGoldenContextInput;
  domainType: DomainTypeInput;
  metrics: Array<EntityGoldenMetricInput>;
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeEntityGoldenMetricsResetArgs = {
  context: EntityGoldenContextInput;
  domainType: DomainTypeInput;
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeEntityGoldenTagsOverrideArgs = {
  context: EntityGoldenContextInput;
  domainType: DomainTypeInput;
  tags: Array<EntityGoldenTagInput>;
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeEntityGoldenTagsResetArgs = {
  context: EntityGoldenContextInput;
  domainType: DomainTypeInput;
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeEntityKeepAliveArgs = {
  guids: Array<Scalars['EntityGuid']['input']>;
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeEntityRelationshipUserDefinedCreateOrReplaceArgs = {
  sourceEntityGuid: Scalars['EntityGuid']['input'];
  targetEntityGuid: Scalars['EntityGuid']['input'];
  type: EntityRelationshipEdgeType;
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeEntityRelationshipUserDefinedDeleteArgs = {
  sourceEntityGuid: Scalars['EntityGuid']['input'];
  targetEntityGuid: Scalars['EntityGuid']['input'];
  type?: InputMaybe<EntityRelationshipEdgeType>;
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeErrorTrackingAssignErrorGroupArgs = {
  assignment: ErrorTrackingAssignErrorGroupInput;
  id: Scalars['ID']['input'];
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeErrorTrackingCommentOnErrorGroupArgs = {
  comment: ErrorTrackingCommentOnErrorGroupInput;
  id: Scalars['ID']['input'];
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeErrorTrackingConfigureErrorGroupChannelArgs = {
  channel: ErrorTrackingErrorGroupChannelInput;
  id: Scalars['ID']['input'];
  workloadGuid: Scalars['EntityGuid']['input'];
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeErrorTrackingConfigureNotificationPolicyArgs = {
  policy: ErrorTrackingConfigureNotificationPolicyInput;
  workloadGuid: Scalars['EntityGuid']['input'];
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeErrorTrackingDeleteCommentFromErrorGroupArgs = {
  comment: ErrorTrackingDeleteCommentFromErrorGroupInput;
  id: Scalars['ID']['input'];
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeErrorTrackingDeleteErrorGroupChannelArgs = {
  channelId: Scalars['ID']['input'];
  id: Scalars['ID']['input'];
  workloadGuid: Scalars['EntityGuid']['input'];
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeErrorTrackingDeleteNotificationPolicyArgs = {
  workloadGuid: Scalars['EntityGuid']['input'];
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeErrorTrackingUpdateErrorGroupStateArgs = {
  id: Scalars['ID']['input'];
  state: ErrorTrackingUpdateErrorGroupStateInput;
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeErrorsInboxAssignErrorGroupArgs = {
  assignment: ErrorsInboxAssignErrorGroupInput;
  id: Scalars['ID']['input'];
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeErrorsInboxConfigureNotificationPolicyArgs = {
  entityGuid: Scalars['EntityGuid']['input'];
  policy: ErrorsInboxConfigureNotificationPolicyInput;
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeErrorsInboxDeleteErrorGroupResourceArgs = {
  id: Scalars['ID']['input'];
  resourceId: Scalars['ID']['input'];
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeErrorsInboxDeleteNotificationPolicyArgs = {
  entityGuid: Scalars['EntityGuid']['input'];
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeErrorsInboxUpdateErrorGroupStateArgs = {
  id?: InputMaybe<Scalars['ID']['input']>;
  ids?: InputMaybe<Array<Scalars['ID']['input']>>;
  resolveInNextVersion?: InputMaybe<Scalars['Boolean']['input']>;
  state: ErrorsInboxErrorGroupState;
  versions?: InputMaybe<ErrorsInboxStateVersionInput>;
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeEventTransformationCreateRuleArgs = {
  accountId: Scalars['Int']['input'];
  rule: EventTransformationRuleInput;
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeEventTransformationUpdateRuleArgs = {
  accountId: Scalars['Int']['input'];
  id: Scalars['Int']['input'];
  updates: EventTransformationRuleUpdates;
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeEventsToMetricsCreateRuleArgs = {
  rules: Array<InputMaybe<EventsToMetricsCreateRuleInput>>;
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeEventsToMetricsDeleteRuleArgs = {
  deletes: Array<InputMaybe<EventsToMetricsDeleteRuleInput>>;
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeEventsToMetricsUpdateRuleArgs = {
  updates: Array<InputMaybe<EventsToMetricsUpdateRuleInput>>;
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeGrokCreateFeedbackArgs = {
  capabilityId?: InputMaybe<Scalars['ID']['input']>;
  messageId: Scalars['ID']['input'];
  nerdletId?: InputMaybe<Scalars['String']['input']>;
  sentiment: Scalars['Boolean']['input'];
  sentimentCategories?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  sentimentDetail?: InputMaybe<Scalars['String']['input']>;
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeGrokCreatePromptArgs = {
  accountId: Scalars['Int']['input'];
  assistant: Scalars['String']['input'];
  assistantConfig?: InputMaybe<Array<InputMaybe<GrokAssistantConfigInput>>>;
  nRConnectionId?: InputMaybe<Scalars['String']['input']>;
  prompt: Scalars['String']['input'];
  source?: InputMaybe<Scalars['String']['input']>;
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeGrokUpdateFeedbackArgs = {
  id: Scalars['ID']['input'];
  sentiment: Scalars['Boolean']['input'];
  sentimentCategories?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  sentimentDetail?: InputMaybe<Scalars['String']['input']>;
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeHistoricalDataExportCancelExportArgs = {
  accountId: Scalars['Int']['input'];
  id: Scalars['String']['input'];
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeHistoricalDataExportCreateExportArgs = {
  accountId: Scalars['Int']['input'];
  nrql?: InputMaybe<Scalars['Nrql']['input']>;
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeIncidentIntelligenceEnvironmentConsentAccountsArgs = {
  accountIds: Array<InputMaybe<Scalars['Int']['input']>>;
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeIncidentIntelligenceEnvironmentCreateEnvironmentArgs = {
  associatedAccountIds?: InputMaybe<Array<InputMaybe<Scalars['Int']['input']>>>;
  incidentIntelligenceAccountId: Scalars['Int']['input'];
  name?: InputMaybe<Scalars['String']['input']>;
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeIncidentIntelligenceEnvironmentDeleteEnvironmentArgs = {
  accountId: Scalars['Int']['input'];
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeIncidentIntelligenceEnvironmentDissentAccountsArgs = {
  accountIds: Array<InputMaybe<Scalars['Int']['input']>>;
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeIncidentIntelligencePlatformCreatePathwayArgs = {
  accountId: Scalars['Int']['input'];
  pathway?: InputMaybe<IncidentIntelligencePlatformPathwayInput>;
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeIncidentIntelligencePlatformCreatePlatformPagerdutyArgs = {
  accountId: Scalars['Int']['input'];
  platformConfiguration: IncidentIntelligencePlatformPagerDutyPlatformConfigurationInput;
  platformEnabled: Scalars['Boolean']['input'];
  platformType: IncidentIntelligencePlatformPlatforms;
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeIncidentIntelligencePlatformDeletePathwayArgs = {
  accountId: Scalars['Int']['input'];
  pathwayId: Scalars['String']['input'];
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeIncidentIntelligencePlatformDeletePlatformArgs = {
  accountId: Scalars['Int']['input'];
  platformType: IncidentIntelligencePlatformPlatforms;
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeIncidentIntelligencePlatformDeprovisionDestinationArgs = {
  accountId: Scalars['Int']['input'];
  destinationId: Scalars['String']['input'];
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeIncidentIntelligencePlatformDeprovisionSourceArgs = {
  accountId: Scalars['Int']['input'];
  sourceId: Scalars['String']['input'];
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeIncidentIntelligencePlatformPagerdutySetAdminArgs = {
  accountId: Scalars['Int']['input'];
  user: Scalars['String']['input'];
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeIncidentIntelligencePlatformProvisionDestinationPagerdutyArgs = {
  accountId: Scalars['Int']['input'];
  channelConfiguration: IncidentIntelligencePlatformPagerDutyDestinationConfigurationInput;
  serviceId: Scalars['String']['input'];
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeIncidentIntelligencePlatformProvisionDestinationWebhookArgs = {
  accountId: Scalars['Int']['input'];
  channelConfiguration: IncidentIntelligencePlatformWebHookDestinationConfigurationInput;
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeIncidentIntelligencePlatformProvisionSourcePagerdutyArgs = {
  accountId: Scalars['Int']['input'];
  serviceId: Scalars['String']['input'];
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeIncidentIntelligencePlatformSyncServicesPagerdutyArgs = {
  accountId: Scalars['Int']['input'];
  forceSync?: InputMaybe<Scalars['Boolean']['input']>;
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeIncidentIntelligencePlatformUpdateDestinationPagerdutyArgs = {
  accountId: Scalars['Int']['input'];
  channelConfiguration: IncidentIntelligencePlatformPagerDutyDestinationConfigurationInput;
  destinationId: Scalars['String']['input'];
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeIncidentIntelligencePlatformUpdateDestinationWebhookArgs = {
  accountId: Scalars['Int']['input'];
  channelConfiguration: IncidentIntelligencePlatformWebHookDestinationConfigurationInput;
  destinationId: Scalars['String']['input'];
  enabled?: InputMaybe<Scalars['Boolean']['input']>;
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeIncidentIntelligencePlatformUpdatePathwayArgs = {
  accountId: Scalars['Int']['input'];
  pathway?: InputMaybe<IncidentIntelligencePlatformUpdatePathwayInput>;
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeIncidentIntelligencePlatformUpdatePlatformPagerdutyArgs = {
  accountId: Scalars['Int']['input'];
  platformConfiguration?: InputMaybe<IncidentIntelligencePlatformPagerDutyPlatformConfigurationInput>;
  platformEnabled?: InputMaybe<Scalars['Boolean']['input']>;
  platformType: IncidentIntelligencePlatformPlatforms;
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeInfrastructureAgentRunIntegrationArgs = {
  guid: Scalars['EntityGuid']['input'];
  integrationArgs?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  integrationName: Scalars['String']['input'];
  target: InfrastructureAgentTargetDetails;
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeInfrastructureAgentStopIntegrationArgs = {
  guid: Scalars['EntityGuid']['input'];
  integrationArgs?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  integrationName: Scalars['String']['input'];
  target: InfrastructureAgentTargetDetails;
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeInstallationCreateInstallStatusArgs = {
  accountId: Scalars['Int']['input'];
  installStatus: InstallationInstallStatusInput;
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeInstallationCreateRecipeEventArgs = {
  accountId: Scalars['Int']['input'];
  status: InstallationRecipeStatus;
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeInstallationDeleteInstallArgs = {
  accountId: Scalars['Int']['input'];
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeInvitationsInviteUserArgs = {
  accountId: Scalars['Int']['input'];
  invitee: InvitationsInviteeInput;
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeInvitationsInviteUserToOrganizationArgs = {
  invitee: InvitationsInviteeInput;
  inviteeName?: InputMaybe<Scalars['String']['input']>;
  sourceInfo?: InputMaybe<InvitationsSourceInfoInput>;
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeInvitationsManageAddUserToOrganizationRequestsArgs = {
  addRequestResponse: InvitationsAddUserRequestAdminResponse;
  requestIds: Array<Scalars['ID']['input']>;
  requestResponseMessage?: InputMaybe<Scalars['String']['input']>;
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeInvitationsManageInviteUserToOrganizationRequestsArgs = {
  inviteRequestResponse: InvitationsUserInviteRequestAdminResponse;
  inviteRequestResponseMessage?: InputMaybe<Scalars['String']['input']>;
  requestIds: Array<Scalars['ID']['input']>;
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeInvitationsManageUserUpgradeRequestsArgs = {
  accountId: Scalars['Int']['input'];
  requestResponse: InvitationsUserUpgradeRequestAdminResponse;
  requestResponseMessage?: InputMaybe<Scalars['String']['input']>;
  requests: Array<Scalars['Int']['input']>;
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeInvitationsRequestAccessArgs = {
  accountId: Scalars['Int']['input'];
  currentUserType?: InputMaybe<InvitationsRequestableUserType>;
  requestReason?: InputMaybe<Scalars['String']['input']>;
  requestedUserType?: InputMaybe<InvitationsRequestableUserType>;
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeKeyTransactionCreateArgs = {
  apdexTarget: Scalars['Float']['input'];
  applicationGuid: Scalars['EntityGuid']['input'];
  browserApdexTarget: Scalars['Float']['input'];
  metricName: Scalars['String']['input'];
  name: Scalars['String']['input'];
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeKeyTransactionDeleteArgs = {
  guid: Scalars['EntityGuid']['input'];
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeKeyTransactionDeleteAllByApplicationIdArgs = {
  guid: Scalars['EntityGuid']['input'];
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeKeyTransactionUpdateArgs = {
  apdexTarget?: InputMaybe<Scalars['Float']['input']>;
  browserApdexTarget?: InputMaybe<Scalars['Float']['input']>;
  guid: Scalars['EntityGuid']['input'];
  name?: InputMaybe<Scalars['String']['input']>;
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeLogConfigurationsCreateDataPartitionRuleArgs = {
  accountId: Scalars['Int']['input'];
  rule: LogConfigurationsCreateDataPartitionRuleInput;
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeLogConfigurationsCreateObfuscationExpressionArgs = {
  accountId: Scalars['Int']['input'];
  expression: LogConfigurationsCreateObfuscationExpressionInput;
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeLogConfigurationsCreateObfuscationRuleArgs = {
  accountId: Scalars['Int']['input'];
  rule: LogConfigurationsCreateObfuscationRuleInput;
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeLogConfigurationsCreateParsingRuleArgs = {
  accountId: Scalars['Int']['input'];
  rule: LogConfigurationsParsingRuleConfiguration;
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeLogConfigurationsDeleteDataPartitionRuleArgs = {
  accountId: Scalars['Int']['input'];
  id: Scalars['ID']['input'];
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeLogConfigurationsDeleteObfuscationExpressionArgs = {
  accountId: Scalars['Int']['input'];
  id: Scalars['ID']['input'];
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeLogConfigurationsDeleteObfuscationRuleArgs = {
  accountId: Scalars['Int']['input'];
  id: Scalars['ID']['input'];
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeLogConfigurationsDeleteParsingRuleArgs = {
  accountId: Scalars['Int']['input'];
  id: Scalars['ID']['input'];
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeLogConfigurationsUpdateDataPartitionRuleArgs = {
  accountId: Scalars['Int']['input'];
  rule?: InputMaybe<LogConfigurationsUpdateDataPartitionRuleInput>;
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeLogConfigurationsUpdateLiveArchiveConfigurationArgs = {
  accountId: Scalars['Int']['input'];
  enabled: Scalars['Boolean']['input'];
  eventType: Scalars['String']['input'];
  retentionPolicy: LogConfigurationsLiveArchiveRetentionPolicyType;
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeLogConfigurationsUpdateObfuscationExpressionArgs = {
  accountId: Scalars['Int']['input'];
  expression: LogConfigurationsUpdateObfuscationExpressionInput;
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeLogConfigurationsUpdateObfuscationRuleArgs = {
  accountId: Scalars['Int']['input'];
  rule: LogConfigurationsUpdateObfuscationRuleInput;
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeLogConfigurationsUpdateParsingRuleArgs = {
  accountId: Scalars['Int']['input'];
  id: Scalars['ID']['input'];
  rule: LogConfigurationsParsingRuleConfiguration;
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeLogConfigurationsUpsertPipelineConfigurationArgs = {
  accountId: Scalars['Int']['input'];
  pipelineConfiguration: LogConfigurationsPipelineConfigurationInput;
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeMetricNormalizationCreateRuleArgs = {
  accountId: Scalars['Int']['input'];
  rule: MetricNormalizationCreateRuleInput;
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeMetricNormalizationDisableRuleArgs = {
  accountId: Scalars['Int']['input'];
  ruleId: Scalars['Int']['input'];
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeMetricNormalizationEditRuleArgs = {
  accountId: Scalars['Int']['input'];
  rule: MetricNormalizationEditRuleInput;
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeMetricNormalizationEnableRuleArgs = {
  accountId: Scalars['Int']['input'];
  ruleId: Scalars['Int']['input'];
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeMobilePushNotificationAddDeviceArgs = {
  appVersion: Scalars['SemVer']['input'];
  deviceId: Scalars['String']['input'];
  deviceName: Scalars['String']['input'];
  deviceToken: Scalars['SecureValue']['input'];
  operatingSystem: Scalars['String']['input'];
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeMobilePushNotificationRemoveDeviceArgs = {
  deviceId: Scalars['String']['input'];
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeMobilePushNotificationSendTestPushArgs = {
  deviceId: Scalars['String']['input'];
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeNerdStorageDeleteCollectionArgs = {
  collection: Scalars['String']['input'];
  scope: NerdStorageScopeInput;
  scopeByActor?: InputMaybe<Scalars['Boolean']['input']>;
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeNerdStorageDeleteDocumentArgs = {
  collection: Scalars['String']['input'];
  documentId: Scalars['String']['input'];
  scope: NerdStorageScopeInput;
  scopeByActor?: InputMaybe<Scalars['Boolean']['input']>;
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeNerdStorageVaultDeleteSecretArgs = {
  key: Scalars['String']['input'];
  scope: NerdStorageVaultScope;
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeNerdStorageVaultWriteSecretArgs = {
  scope: NerdStorageVaultScope;
  secret: NerdStorageVaultWriteSecretInput;
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeNerdStorageWriteDocumentArgs = {
  collection: Scalars['String']['input'];
  document: Scalars['NerdStorageDocument']['input'];
  documentId: Scalars['String']['input'];
  scope: NerdStorageScopeInput;
  scopeByActor?: InputMaybe<Scalars['Boolean']['input']>;
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeNerdStoreDeleteCollectionArgs = {
  collection: Scalars['String']['input'];
  scope: NerdStoreScopeInput;
  scopeByActor?: InputMaybe<Scalars['Boolean']['input']>;
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeNerdStoreDeleteDocumentArgs = {
  collection: Scalars['String']['input'];
  documentId: Scalars['String']['input'];
  scope: NerdStoreScopeInput;
  scopeByActor?: InputMaybe<Scalars['Boolean']['input']>;
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeNerdStoreWriteDocumentArgs = {
  collection: Scalars['String']['input'];
  document: Scalars['NerdStoreDocument']['input'];
  documentId: Scalars['String']['input'];
  scope: NerdStoreScopeInput;
  scopeByActor?: InputMaybe<Scalars['Boolean']['input']>;
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeNerdpackAddAllowedAccountsArgs = {
  allowList: NerdpackAllowListInput;
  nerdpackId: Scalars['ID']['input'];
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeNerdpackCreateArgs = {
  nerdpackData?: InputMaybe<NerdpackCreationInput>;
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeNerdpackRemoveAllowedAccountsArgs = {
  allowList: NerdpackAllowListInput;
  nerdpackId: Scalars['ID']['input'];
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeNerdpackRemoveVersionTagArgs = {
  nerdpackId: Scalars['ID']['input'];
  versionTag: NerdpackRemoveVersionTagInput;
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeNerdpackSubscribeAccountsArgs = {
  nerdpackId: Scalars['ID']['input'];
  subscription: NerdpackSubscribeAccountsInput;
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeNerdpackTagVersionArgs = {
  nerdpackId: Scalars['ID']['input'];
  versionTag: NerdpackTagVersionInput;
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeNerdpackUnsubscribeAccountsArgs = {
  nerdpackId: Scalars['ID']['input'];
  subscription: NerdpackUnsubscribeAccountsInput;
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeNetworkMonitoringCreateAgentConfigurationArgs = {
  configuration: NetworkMonitoringCreateAgentConfigurationInput;
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeNetworkMonitoringDeleteAgentConfigurationArgs = {
  agentConfigurationId: Scalars['ID']['input'];
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeNetworkMonitoringPublishAgentConfigurationArgs = {
  agentConfigurationId: Scalars['ID']['input'];
  rawConfiguration: Scalars['NetworkMonitoringRawConfiguration']['input'];
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeNetworkMonitoringUpdateAgentConfigurationArgs = {
  configuration: NetworkMonitoringUpdateAgentConfigurationInput;
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeNewRelicServiceHealthCreateStatusNotificationConfigurationArgs = {
  accounts: Array<Scalars['Int']['input']>;
  active: Scalars['Boolean']['input'];
  email: Scalars['String']['input'];
  name: Scalars['String']['input'];
  services: Array<Scalars['String']['input']>;
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeNewRelicServiceHealthUpdateStatusNotificationConfigurationArgs = {
  accounts?: InputMaybe<Array<InputMaybe<Scalars['Int']['input']>>>;
  active?: InputMaybe<Scalars['Boolean']['input']>;
  email?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  services?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  uuid: Scalars['String']['input'];
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeNotificationAuthenticationGenerateTokenArgs = {
  userId: Scalars['ID']['input'];
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeNr1CatalogCreateQuickstartArgs = {
  dryRun?: InputMaybe<Scalars['Boolean']['input']>;
  quickstartMetadata: Nr1CatalogQuickstartMetadataInput;
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeNr1CatalogInstallAlertPolicyTemplateArgs = {
  accountId: Scalars['Int']['input'];
  alertPolicyTemplateId: Scalars['ID']['input'];
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeNr1CatalogInstallDashboardTemplateArgs = {
  accountId: Scalars['Int']['input'];
  dashboardTemplateId: Scalars['ID']['input'];
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeNr1CatalogSetAutoInstallAlertPolicyTemplatesForDataSourceArgs = {
  alertPolicyTemplateIds: Array<Scalars['ID']['input']>;
  dataSourceId: Scalars['ID']['input'];
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeNr1CatalogSetAutoInstallDashboardTemplatesForDataSourceArgs = {
  dashboardTemplateIds: Array<Scalars['ID']['input']>;
  dataSourceId: Scalars['ID']['input'];
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeNr1CatalogSetRequiredDataSourcesForAlertPolicyTemplateArgs = {
  alertPolicyTemplateId: Scalars['ID']['input'];
  dataSourceIds: Array<Scalars['ID']['input']>;
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeNr1CatalogSetRequiredDataSourcesForDashboardTemplateArgs = {
  dashboardTemplateId: Scalars['ID']['input'];
  dataSourceIds: Array<Scalars['ID']['input']>;
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeNr1CatalogSubmitDataSourceArgs = {
  dataSourceMetadata: Nr1CatalogDataSourceMetadataInput;
  dryRun?: InputMaybe<Scalars['Boolean']['input']>;
  id: Scalars['ID']['input'];
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeNr1CatalogSubmitInstallPlanStepArgs = {
  dryRun?: InputMaybe<Scalars['Boolean']['input']>;
  installPlanStep: Nr1CatalogInstallPlanStepInput;
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeNr1CatalogSubmitMetadataArgs = {
  id: Scalars['ID']['input'];
  nerdpackMetadata: Nr1CatalogSubmitMetadataInput;
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeNr1CatalogSubmitQuickstartArgs = {
  dryRun?: InputMaybe<Scalars['Boolean']['input']>;
  id: Scalars['ID']['input'];
  quickstartMetadata: Nr1CatalogQuickstartMetadataInput;
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeNr1CatalogUpdateQuickstartArgs = {
  dryRun?: InputMaybe<Scalars['Boolean']['input']>;
  id: Scalars['ID']['input'];
  quickstartMetadata: Nr1CatalogQuickstartMetadataInput;
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeNrqlDropRulesCreateArgs = {
  accountId: Scalars['Int']['input'];
  rules: Array<InputMaybe<NrqlDropRulesCreateDropRuleInput>>;
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeNrqlDropRulesDeleteArgs = {
  accountId: Scalars['Int']['input'];
  ruleIds: Array<InputMaybe<Scalars['ID']['input']>>;
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeNrqlLookupsDeleteArgs = {
  accountId: Scalars['Int']['input'];
  name: Scalars['String']['input'];
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeNrqlLookupsEditArgs = {
  accountId: Scalars['Int']['input'];
  description?: InputMaybe<Scalars['String']['input']>;
  name: Scalars['String']['input'];
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeOpenAgentManagementCreateConfigurationArgs = {
  accountId: Scalars['Int']['input'];
  configuration: OpenAgentManagementConfigurationInput;
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeOpenAgentManagementCreateConfigurationRevisionArgs = {
  accountId: Scalars['Int']['input'];
  configurationRevision: OpenAgentManagementConfigurationRevisionInput;
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeOpenAgentManagementCreateFleetArgs = {
  accountId: Scalars['Int']['input'];
  agentType: OpenAgentManagementAgentType;
  name: Scalars['String']['input'];
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeOpenAgentManagementDeleteConfigurationArgs = {
  accountId: Scalars['Int']['input'];
  configurationId: Scalars['ID']['input'];
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeOpenAgentManagementDeleteConfigurationRevisionArgs = {
  accountId: Scalars['Int']['input'];
  configurationId: Scalars['ID']['input'];
  revisionNumber?: InputMaybe<Scalars['Int']['input']>;
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeOpenAgentManagementDeleteFleetArgs = {
  fleetGuid: Scalars['EntityGuid']['input'];
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeOpenAgentManagementDeployAgentConfigurationsArgs = {
  accountId: Scalars['Int']['input'];
  agentUid: Scalars['ID']['input'];
  configurationRevisions?: InputMaybe<Array<OpenAgentManagementAgentDeploymentInput>>;
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeOpenAgentManagementDeployFleetConfigurationsArgs = {
  accountId: Scalars['Int']['input'];
  configurationRevisions?: InputMaybe<Array<OpenAgentManagementFleetDeploymentInput>>;
  fleetGuid: Scalars['EntityGuid']['input'];
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeOpenAgentManagementMoveAgentToFleetArgs = {
  agentUid: Scalars['ID']['input'];
  fleetGuid: Scalars['EntityGuid']['input'];
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeOpenAgentManagementSetAgentAuthStateArgs = {
  accountId: Scalars['Int']['input'];
  agentUid: Scalars['ID']['input'];
  authState: OpenAgentManagementAuthState;
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeOpenAgentManagementUpdateConfigurationArgs = {
  accountId: Scalars['Int']['input'];
  configuration: OpenAgentManagementConfigurationInput;
  configurationId: Scalars['ID']['input'];
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeOrganizationCreateArgs = {
  customerId?: InputMaybe<Scalars['ID']['input']>;
  newManagedAccount?: InputMaybe<OrganizationNewManagedAccountInput>;
  organization: OrganizationCreateOrganizationInput;
  sharedAccount?: InputMaybe<OrganizationSharedAccountInput>;
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeOrganizationCreateSharedAccountArgs = {
  sharedAccount: OrganizationCreateSharedAccountInput;
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeOrganizationProvisioningUpdatePartnerSubscriptionArgs = {
  accountId: Scalars['Int']['input'];
  affectedAccountId: Scalars['Int']['input'];
  products: Array<OrganizationProvisioningProductInput>;
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeOrganizationRevokeSharedAccountArgs = {
  sharedAccount: OrganizationRevokeSharedAccountInput;
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeOrganizationUpdateArgs = {
  organization: OrganizationUpdateInput;
  organizationId?: InputMaybe<Scalars['ID']['input']>;
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeOrganizationUpdateSharedAccountArgs = {
  sharedAccount: OrganizationUpdateSharedAccountInput;
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypePartnershipMigrationMigrateAccountArgs = {
  accountId: Scalars['Int']['input'];
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypePixieLinkPixieProjectArgs = {
  accountId: Scalars['Int']['input'];
  apiKey?: InputMaybe<Scalars['SecureValue']['input']>;
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypePixieRecordPixieTosAcceptanceArgs = {
  accountId: Scalars['Int']['input'];
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypePixieUnlinkPixieProjectArgs = {
  accountId: Scalars['Int']['input'];
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypePreReleaseProgramCreateProgramArgs = {
  customLegal?: InputMaybe<Scalars['String']['input']>;
  customLegalAddendum?: InputMaybe<Scalars['String']['input']>;
  customLegalRequired?: InputMaybe<Scalars['Boolean']['input']>;
  customLegalStandalone?: InputMaybe<Scalars['String']['input']>;
  emailBody?: InputMaybe<Scalars['String']['input']>;
  emailCustomer?: InputMaybe<Scalars['Boolean']['input']>;
  emailFrom?: InputMaybe<Scalars['String']['input']>;
  emailSubject?: InputMaybe<Scalars['String']['input']>;
  excludeEntitlements?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  excludeFeatureFlags?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  excludeFedramp?: InputMaybe<Scalars['Boolean']['input']>;
  excludeHippa?: InputMaybe<Scalars['Boolean']['input']>;
  excludeTiers?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  formSubmitCopy: Scalars['String']['input'];
  includeEntitlements?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  includeFeatureFlags?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  marketingDescription?: InputMaybe<Scalars['String']['input']>;
  marketingDivider?: InputMaybe<Scalars['Boolean']['input']>;
  marketingExtraContent?: InputMaybe<Scalars['String']['input']>;
  marketingLabelType?: InputMaybe<PreReleaseProgramProgramMarketingLabelType>;
  marketingLink?: InputMaybe<Scalars['String']['input']>;
  marketingSubtext?: InputMaybe<Scalars['String']['input']>;
  marketingTitle?: InputMaybe<Scalars['String']['input']>;
  marketingVideoUrl?: InputMaybe<Scalars['String']['input']>;
  name: Scalars['String']['input'];
  readableId?: InputMaybe<Scalars['String']['input']>;
  scope: PreReleaseProgramProgramScope;
  status: PreReleaseProgramProgramStatus;
  team?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypePreReleaseProgramCreateSubmissionArgs = {
  accepted?: InputMaybe<Scalars['Boolean']['input']>;
  accountId?: InputMaybe<Scalars['Int']['input']>;
  agreementTypeAccepted?: InputMaybe<Scalars['String']['input']>;
  enabledDate?: InputMaybe<Scalars['EpochMilliseconds']['input']>;
  expirationDate?: InputMaybe<Scalars['EpochMilliseconds']['input']>;
  programId: Scalars['String']['input'];
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeProgrammabilityTnCAcceptArgs = {
  account: ProgrammabilityTnCAccountInput;
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeProvisioningAddAccountEntitlementBlocklistToAccountsArgs = {
  accountIds: Array<Scalars['Int']['input']>;
  authorizedBy?: InputMaybe<Scalars['String']['input']>;
  entitlementName: Scalars['String']['input'];
  skipRefresh?: InputMaybe<Scalars['Boolean']['input']>;
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeProvisioningAddBetaEntitlementToAccountsArgs = {
  accountIds: Array<Scalars['Int']['input']>;
  authorizedBy?: InputMaybe<Scalars['String']['input']>;
  entitlementName: Scalars['String']['input'];
  skipRefresh?: InputMaybe<Scalars['Boolean']['input']>;
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeProvisioningAddEntitlementToAccountsArgs = {
  accountIds: Array<Scalars['Int']['input']>;
  authorizedBy?: InputMaybe<Scalars['String']['input']>;
  endDate?: InputMaybe<Scalars['DateTime']['input']>;
  entitlementName: Scalars['String']['input'];
  skipRefresh?: InputMaybe<Scalars['Boolean']['input']>;
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeProvisioningApplyAccountConfigurationsArgs = {
  accountIds: Array<Scalars['Int']['input']>;
  dataSet?: InputMaybe<Array<ProvisioningConfigurationKeyValuePairInput>>;
  enabled: Scalars['Boolean']['input'];
  type: Scalars['String']['input'];
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeProvisioningApplyAccountEnablementPackagesArgs = {
  accountId: Scalars['Int']['input'];
  enablementCode: Scalars['String']['input'];
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeProvisioningApplyEnablementToAccountsArgs = {
  accountIds: Array<Scalars['Int']['input']>;
  enablementCode: Scalars['String']['input'];
  endDate?: InputMaybe<Scalars['DateTime']['input']>;
  skipRefresh?: InputMaybe<Scalars['Boolean']['input']>;
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeProvisioningApplyPromoCodeToAccountArgs = {
  accountId: Scalars['Int']['input'];
  promotionCode: Scalars['String']['input'];
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeProvisioningApplyPromotionToAccountsArgs = {
  accountIds: Array<Scalars['Int']['input']>;
  endDate?: InputMaybe<Scalars['DateTime']['input']>;
  promotionCode: Scalars['String']['input'];
  skipRefresh?: InputMaybe<Scalars['Boolean']['input']>;
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeProvisioningBulkAccountRefreshArgs = {
  accountIds: Array<Scalars['Int']['input']>;
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeProvisioningBulkCpmConversionsArgs = {
  accountIds: Array<Scalars['Int']['input']>;
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeProvisioningBulkRemoveEnablementFromAccountsArgs = {
  accountIds: Array<Scalars['Int']['input']>;
  enablementCode: Scalars['String']['input'];
  skipRefresh?: InputMaybe<Scalars['Boolean']['input']>;
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeProvisioningConvertAccountToNonProfitArgs = {
  accountId: Scalars['Int']['input'];
  type?: InputMaybe<ProvisioningNonProfit>;
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeProvisioningRefreshEntitlementsArgs = {
  accountId: Scalars['Int']['input'];
  linkId?: InputMaybe<Scalars['Int']['input']>;
  linkType?: InputMaybe<Scalars['String']['input']>;
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeProvisioningRemoveAccountEnablementPackagesArgs = {
  accountId: Scalars['Int']['input'];
  enablementCode: Scalars['String']['input'];
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeProvisioningRemoveAccountEntitlementBlocklistFromAccountsArgs = {
  accountIds: Array<Scalars['Int']['input']>;
  entitlementName: Scalars['String']['input'];
  skipRefresh?: InputMaybe<Scalars['Boolean']['input']>;
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeProvisioningRemoveBetaEntitlementFromAccountsArgs = {
  accountIds: Array<Scalars['Int']['input']>;
  entitlementName: Scalars['String']['input'];
  skipRefresh?: InputMaybe<Scalars['Boolean']['input']>;
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeProvisioningRemoveEntitlementFromAccountsArgs = {
  accountIds: Array<Scalars['Int']['input']>;
  entitlementName: Scalars['String']['input'];
  skipRefresh?: InputMaybe<Scalars['Boolean']['input']>;
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeProvisioningRemovePlatformRecordArgs = {
  accountIds: Array<Scalars['Int']['input']>;
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeProvisioningRemovePromotionFromAccountArgs = {
  accountId: Scalars['Int']['input'];
  promotionCode: Scalars['String']['input'];
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeProvisioningRemovePromotionFromAccountsArgs = {
  accountIds: Array<Scalars['Int']['input']>;
  promotionCode: Scalars['String']['input'];
  skipRefresh?: InputMaybe<Scalars['Boolean']['input']>;
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeProvisioningToggleAccountConfigurationArgs = {
  accountId: Scalars['Int']['input'];
  enabled: Scalars['Boolean']['input'];
  type: Scalars['String']['input'];
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeProvisioningUpdateAccountConfigurationArgs = {
  accountId: Scalars['Int']['input'];
  dataSet?: InputMaybe<Array<ProvisioningConfigurationKeyValuePairInput>>;
  type: Scalars['String']['input'];
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeProvisioningUpdateAccountEntitlementArgs = {
  accountIds: Array<Scalars['Int']['input']>;
  authorizedBy?: InputMaybe<Scalars['String']['input']>;
  entitlementName: Scalars['String']['input'];
  propertyName: Scalars['String']['input'];
  propertyQuantity: Scalars['Int']['input'];
  skipRefresh?: InputMaybe<Scalars['Boolean']['input']>;
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeProvisioningUpdateSubscriptionsArgs = {
  accountId: Scalars['Int']['input'];
  enableConsumptionPricing?: InputMaybe<Scalars['Boolean']['input']>;
  products: Array<ProvisioningProductInput>;
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeQueryHistoryRecordNrqlArgs = {
  query: QueryHistoryRecordNrqlInput;
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeReferenceEntityCreateOrUpdateRepositoryArgs = {
  repositories: Array<ReferenceEntityCreateRepositoryInput>;
  sync?: InputMaybe<Scalars['Boolean']['input']>;
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeRootCauseAnalysisSubmitArgs = {
  entityGuid?: InputMaybe<Scalars['EntityGuid']['input']>;
  filter?: InputMaybe<RootCauseAnalysisSearchFilter>;
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeSavedViewsCreateArgs = {
  account?: InputMaybe<Scalars['Int']['input']>;
  additionalData?: InputMaybe<Scalars['SavedViewsRawAdditionalData']['input']>;
  capability?: InputMaybe<Scalars['String']['input']>;
  favorite: Scalars['Boolean']['input'];
  filter: Scalars['Nrql']['input'];
  name: Scalars['String']['input'];
  viewType?: InputMaybe<SavedViewsViewType>;
  visibility?: SavedViewsVisibility;
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeSavedViewsDeleteArgs = {
  id: Scalars['ID']['input'];
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeSavedViewsUpdateArgs = {
  account?: InputMaybe<Scalars['Int']['input']>;
  additionalData?: InputMaybe<Scalars['SavedViewsRawAdditionalData']['input']>;
  capability?: InputMaybe<Scalars['String']['input']>;
  creator?: InputMaybe<Scalars['Int']['input']>;
  favorite?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<Scalars['Nrql']['input']>;
  id: Scalars['ID']['input'];
  name?: InputMaybe<Scalars['String']['input']>;
  viewType?: InputMaybe<SavedViewsViewType>;
  visibility?: InputMaybe<SavedViewsVisibility>;
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeServiceLevelCreateArgs = {
  entityGuid: Scalars['EntityGuid']['input'];
  indicator: ServiceLevelIndicatorCreateInput;
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeServiceLevelCreateRecommendedIndicatorsArgs = {
  entityGuid: Scalars['EntityGuid']['input'];
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeServiceLevelDeleteArgs = {
  guid?: InputMaybe<Scalars['EntityGuid']['input']>;
  id?: InputMaybe<Scalars['ID']['input']>;
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeServiceLevelUpdateArgs = {
  guid?: InputMaybe<Scalars['EntityGuid']['input']>;
  id?: InputMaybe<Scalars['ID']['input']>;
  indicator: ServiceLevelIndicatorUpdateInput;
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeSignupIntegrationsBulkCreatePromoCodesArgs = {
  expiresOn?: InputMaybe<Scalars['DateTime']['input']>;
  integrationId: Scalars['String']['input'];
  issuedOn?: InputMaybe<Scalars['DateTime']['input']>;
  promoCode?: InputMaybe<Scalars['String']['input']>;
  promoCodeSize?: InputMaybe<Scalars['Int']['input']>;
  promoKey: Scalars['String']['input'];
  quantity: Scalars['Int']['input'];
  reusable?: InputMaybe<Scalars['Boolean']['input']>;
  urlForInvalid?: InputMaybe<Scalars['String']['input']>;
  urlForValid?: InputMaybe<Scalars['String']['input']>;
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeStreamingExportCreateRuleArgs = {
  accountId: Scalars['Int']['input'];
  awsParameters?: InputMaybe<StreamingExportAwsInput>;
  azureParameters?: InputMaybe<StreamingExportAzureInput>;
  ruleParameters: StreamingExportRuleInput;
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeStreamingExportDeleteRuleArgs = {
  id: Scalars['ID']['input'];
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeStreamingExportDisableRuleArgs = {
  id: Scalars['ID']['input'];
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeStreamingExportEnableRuleArgs = {
  id: Scalars['ID']['input'];
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeStreamingExportUpdateRuleArgs = {
  awsParameters?: InputMaybe<StreamingExportAwsInput>;
  azureParameters?: InputMaybe<StreamingExportAzureInput>;
  id: Scalars['ID']['input'];
  ruleParameters: StreamingExportRuleInput;
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeSupportDiagnosticsCategoryCreateArgs = {
  category: SupportCategoryCreateInput;
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeSupportDiagnosticsCategoryDeleteArgs = {
  id: Scalars['ID']['input'];
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeSupportDiagnosticsCategoryUpdateArgs = {
  category: SupportCategoryUpdateInput;
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeSupportDiagnosticsEdgeCreateArgs = {
  edge: SupportEdgeCreateInput;
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeSupportDiagnosticsEdgeDeleteArgs = {
  edge: SupportEdgeDeleteInput;
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeSupportDiagnosticsFrameworkCreateArgs = {
  framework: SupportFrameworkCreateInput;
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeSupportDiagnosticsFrameworkDeleteArgs = {
  id: Scalars['ID']['input'];
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeSupportDiagnosticsFrameworkUpdateActiveRevisionArgs = {
  id: Scalars['ID']['input'];
  revision: Scalars['Int']['input'];
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeSupportDiagnosticsFrameworkUpdateStateArgs = {
  id: Scalars['ID']['input'];
  state: SupportStateType;
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeSupportDiagnosticsNerdgraphQueryAddArgs = {
  nerdgraphQuery: SupportDiagnosticsNerdgraphQueryCreateInput;
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeSupportDiagnosticsNerdgraphQueryDeleteArgs = {
  id: Scalars['ID']['input'];
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeSupportDiagnosticsNodeCreateArgs = {
  node: SupportNodeCreateInput;
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeSupportDiagnosticsNodeDeleteArgs = {
  id: Scalars['ID']['input'];
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeSupportDiagnosticsQueryAddArgs = {
  query: SupportDiagnosticsQueryCreateInput;
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeSupportDiagnosticsQueryDeleteArgs = {
  id: Scalars['ID']['input'];
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeSupportTicketAttachmentCreateArgs = {
  filename: Scalars['String']['input'];
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeSupportTicketCollaboratorsAddArgs = {
  collaboratorEmails?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  ticketId: Scalars['String']['input'];
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeSupportTicketCollaboratorsRemoveArgs = {
  collaboratorEmails?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  ticketId: Scalars['String']['input'];
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeSupportTicketCreateArgs = {
  accountId: Scalars['Int']['input'];
  ticket: SupportTicketCreateInput;
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeSupportTicketEscalateArgs = {
  accountId: Scalars['Int']['input'];
  ticketEscalation: SupportTicketEscalationInput;
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeSupportTicketMessageCreateArgs = {
  message: SupportTicketMessageInput;
  ticketId: Scalars['String']['input'];
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeSyntheticsCreateBrokenLinksMonitorArgs = {
  accountId: Scalars['Int']['input'];
  monitor: SyntheticsCreateBrokenLinksMonitorInput;
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeSyntheticsCreateCertCheckMonitorArgs = {
  accountId: Scalars['Int']['input'];
  monitor: SyntheticsCreateCertCheckMonitorInput;
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeSyntheticsCreateDailyMonitorDowntimeArgs = {
  accountId: Scalars['Int']['input'];
  endRepeat?: InputMaybe<SyntheticsDateWindowEndConfig>;
  endTime: Scalars['NaiveDateTime']['input'];
  monitorGuids?: InputMaybe<Array<InputMaybe<Scalars['EntityGuid']['input']>>>;
  name: Scalars['String']['input'];
  startTime: Scalars['NaiveDateTime']['input'];
  timezone: Scalars['String']['input'];
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeSyntheticsCreateMonitorArgs = {
  accountId: Scalars['Int']['input'];
  advancedOptions?: InputMaybe<SyntheticsAdvancedOptionsInput>;
  extendedTypeMetadata?: InputMaybe<SyntheticsExtendedTypeInput>;
  hmacs?: InputMaybe<Array<InputMaybe<SyntheticsPrivateLocationHmacInput>>>;
  locations: Array<InputMaybe<Scalars['String']['input']>>;
  name: Scalars['String']['input'];
  period: SyntheticsMonitorPeriod;
  script?: InputMaybe<Scalars['String']['input']>;
  slaThreshold: Scalars['Float']['input'];
  status: SyntheticsMonitorStatus;
  steps?: InputMaybe<Array<InputMaybe<SyntheticsStepInput>>>;
  tags?: InputMaybe<Array<InputMaybe<SyntheticsTag>>>;
  type: SyntheticsMonitorType;
  uri?: InputMaybe<Scalars['String']['input']>;
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeSyntheticsCreateMonthlyMonitorDowntimeArgs = {
  accountId: Scalars['Int']['input'];
  endRepeat?: InputMaybe<SyntheticsDateWindowEndConfig>;
  endTime: Scalars['NaiveDateTime']['input'];
  frequency: SyntheticsMonitorDowntimeMonthlyFrequency;
  monitorGuids?: InputMaybe<Array<InputMaybe<Scalars['EntityGuid']['input']>>>;
  name: Scalars['String']['input'];
  startTime: Scalars['NaiveDateTime']['input'];
  timezone: Scalars['String']['input'];
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeSyntheticsCreateOnceMonitorDowntimeArgs = {
  accountId: Scalars['Int']['input'];
  endTime: Scalars['NaiveDateTime']['input'];
  monitorGuids?: InputMaybe<Array<InputMaybe<Scalars['EntityGuid']['input']>>>;
  name: Scalars['String']['input'];
  startTime: Scalars['NaiveDateTime']['input'];
  timezone: Scalars['String']['input'];
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeSyntheticsCreatePrivateLocationArgs = {
  accountId: Scalars['Int']['input'];
  description?: InputMaybe<Scalars['String']['input']>;
  name: Scalars['String']['input'];
  verifiedScriptExecution: Scalars['Boolean']['input'];
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeSyntheticsCreateScriptApiMonitorArgs = {
  accountId: Scalars['Int']['input'];
  monitor: SyntheticsCreateScriptApiMonitorInput;
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeSyntheticsCreateScriptBrowserMonitorArgs = {
  accountId: Scalars['Int']['input'];
  monitor: SyntheticsCreateScriptBrowserMonitorInput;
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeSyntheticsCreateSecureCredentialArgs = {
  accountId: Scalars['Int']['input'];
  description?: InputMaybe<Scalars['String']['input']>;
  key: Scalars['String']['input'];
  value: Scalars['SecureValue']['input'];
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeSyntheticsCreateSimpleBrowserMonitorArgs = {
  accountId: Scalars['Int']['input'];
  monitor: SyntheticsCreateSimpleBrowserMonitorInput;
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeSyntheticsCreateSimpleMonitorArgs = {
  accountId: Scalars['Int']['input'];
  monitor: SyntheticsCreateSimpleMonitorInput;
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeSyntheticsCreateStepMonitorArgs = {
  accountId: Scalars['Int']['input'];
  monitor: SyntheticsCreateStepMonitorInput;
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeSyntheticsCreateWeeklyMonitorDowntimeArgs = {
  accountId: Scalars['Int']['input'];
  endRepeat?: InputMaybe<SyntheticsDateWindowEndConfig>;
  endTime: Scalars['NaiveDateTime']['input'];
  maintenanceDays: Array<InputMaybe<SyntheticsMonitorDowntimeWeekDays>>;
  monitorGuids?: InputMaybe<Array<InputMaybe<Scalars['EntityGuid']['input']>>>;
  name: Scalars['String']['input'];
  startTime: Scalars['NaiveDateTime']['input'];
  timezone: Scalars['String']['input'];
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeSyntheticsDeleteMonitorArgs = {
  guid: Scalars['EntityGuid']['input'];
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeSyntheticsDeleteMonitorByGuidArgs = {
  guid: Scalars['EntityGuid']['input'];
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeSyntheticsDeleteMonitorDowntimeArgs = {
  guid: Scalars['EntityGuid']['input'];
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeSyntheticsDeletePrivateLocationArgs = {
  guid: Scalars['EntityGuid']['input'];
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeSyntheticsDeleteScriptArgs = {
  guid?: InputMaybe<Scalars['EntityGuid']['input']>;
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeSyntheticsDeleteSecureCredentialArgs = {
  accountId: Scalars['Int']['input'];
  key: Scalars['String']['input'];
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeSyntheticsEditMonitorDowntimeArgs = {
  daily?: InputMaybe<SyntheticsMonitorDowntimeDailyConfig>;
  guid: Scalars['EntityGuid']['input'];
  monitorGuids?: InputMaybe<Array<InputMaybe<Scalars['EntityGuid']['input']>>>;
  monthly?: InputMaybe<SyntheticsMonitorDowntimeMonthlyConfig>;
  name?: InputMaybe<Scalars['String']['input']>;
  once?: InputMaybe<SyntheticsMonitorDowntimeOnceConfig>;
  weekly?: InputMaybe<SyntheticsMonitorDowntimeWeeklyConfig>;
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeSyntheticsGenerateStepScriptArgs = {
  accountId: Scalars['Int']['input'];
  stepMonitorScriptDefinition: SyntheticsGenerateMonitorScriptInput;
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeSyntheticsPurgePrivateLocationQueueArgs = {
  guid: Scalars['EntityGuid']['input'];
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeSyntheticsRunMonitorArgs = {
  guid: Scalars['EntityGuid']['input'];
  locationId: Scalars['String']['input'];
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeSyntheticsStartAutomatedTestArgs = {
  config?: InputMaybe<SyntheticsAutomatedTestConfigInput>;
  tests?: InputMaybe<Array<InputMaybe<SyntheticsAutomatedTestMonitorInput>>>;
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeSyntheticsTriggerScriptValidationArgs = {
  accountId?: InputMaybe<Scalars['Int']['input']>;
  deviceEmulation?: InputMaybe<SyntheticsDeviceEmulationInput>;
  guid?: InputMaybe<Scalars['EntityGuid']['input']>;
  hmacs?: InputMaybe<Array<InputMaybe<SyntheticsPrivateLocationHmacInput>>>;
  locations: Array<InputMaybe<Scalars['String']['input']>>;
  monitorApiVersion: Scalars['String']['input'];
  monitorType: SyntheticsMonitorType;
  runtime?: InputMaybe<SyntheticsRuntimeInput>;
  script: Scalars['String']['input'];
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeSyntheticsUpdateBrokenLinksMonitorArgs = {
  guid: Scalars['EntityGuid']['input'];
  monitor: SyntheticsUpdateBrokenLinksMonitorInput;
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeSyntheticsUpdateCertCheckMonitorArgs = {
  guid: Scalars['EntityGuid']['input'];
  monitor: SyntheticsUpdateCertCheckMonitorInput;
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeSyntheticsUpdateMonitorArgs = {
  advancedOptions?: InputMaybe<SyntheticsAdvancedOptionsInput>;
  extendedTypeMetadata?: InputMaybe<SyntheticsExtendedTypeInput>;
  guid: Scalars['EntityGuid']['input'];
  hmacs?: InputMaybe<Array<InputMaybe<SyntheticsPrivateLocationHmacInput>>>;
  locations?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  name?: InputMaybe<Scalars['String']['input']>;
  period?: InputMaybe<SyntheticsMonitorPeriod>;
  slaThreshold?: InputMaybe<Scalars['Float']['input']>;
  status?: InputMaybe<SyntheticsMonitorStatus>;
  steps?: InputMaybe<Array<InputMaybe<SyntheticsStepInput>>>;
  tags?: InputMaybe<Array<InputMaybe<SyntheticsTag>>>;
  type?: InputMaybe<SyntheticsMonitorType>;
  uri?: InputMaybe<Scalars['String']['input']>;
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeSyntheticsUpdatePrivateLocationArgs = {
  description?: InputMaybe<Scalars['String']['input']>;
  guid: Scalars['EntityGuid']['input'];
  verifiedScriptExecution?: InputMaybe<Scalars['Boolean']['input']>;
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeSyntheticsUpdateScriptArgs = {
  guid: Scalars['EntityGuid']['input'];
  script: Scalars['String']['input'];
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeSyntheticsUpdateScriptApiMonitorArgs = {
  guid: Scalars['EntityGuid']['input'];
  monitor: SyntheticsUpdateScriptApiMonitorInput;
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeSyntheticsUpdateScriptBrowserMonitorArgs = {
  guid: Scalars['EntityGuid']['input'];
  monitor: SyntheticsUpdateScriptBrowserMonitorInput;
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeSyntheticsUpdateSecureCredentialArgs = {
  accountId: Scalars['Int']['input'];
  description?: InputMaybe<Scalars['String']['input']>;
  key: Scalars['String']['input'];
  value?: InputMaybe<Scalars['SecureValue']['input']>;
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeSyntheticsUpdateSimpleBrowserMonitorArgs = {
  guid: Scalars['EntityGuid']['input'];
  monitor: SyntheticsUpdateSimpleBrowserMonitorInput;
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeSyntheticsUpdateSimpleMonitorArgs = {
  guid: Scalars['EntityGuid']['input'];
  monitor: SyntheticsUpdateSimpleMonitorInput;
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeSyntheticsUpdateStepMonitorArgs = {
  guid: Scalars['EntityGuid']['input'];
  monitor: SyntheticsUpdateStepMonitorInput;
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeSyntheticsUpgradeMonitorRuntimeArgs = {
  monitors: Array<Scalars['EntityGuid']['input']>;
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeSyntheticsUpgradeMonitorRuntimeByAccountsAndStatusesArgs = {
  accounts: Array<Scalars['Int']['input']>;
  validationStatuses: Array<SyntheticsValidationStatus>;
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeTaggingAddTagsToEntityArgs = {
  guid: Scalars['EntityGuid']['input'];
  tags: Array<TaggingTagInput>;
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeTaggingDeleteTagFromEntityArgs = {
  guid: Scalars['EntityGuid']['input'];
  tagKeys: Array<Scalars['String']['input']>;
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeTaggingDeleteTagValuesFromEntityArgs = {
  guid: Scalars['EntityGuid']['input'];
  tagValues: Array<TaggingTagValueInput>;
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeTaggingReplaceTagsOnEntityArgs = {
  guid: Scalars['EntityGuid']['input'];
  tags: Array<TaggingTagInput>;
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeTeamAddEntitiesArgs = {
  entityGuids?: InputMaybe<Array<InputMaybe<Scalars['EntityGuid']['input']>>>;
  guid?: InputMaybe<Scalars['EntityGuid']['input']>;
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeTeamCreateArgs = {
  accountId: Scalars['Int']['input'];
  team: TeamCreateInput;
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeTeamDeleteArgs = {
  guid: Scalars['EntityGuid']['input'];
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeTeamDeleteEntitiesArgs = {
  entityGuids?: InputMaybe<Array<Scalars['EntityGuid']['input']>>;
  guid?: InputMaybe<Scalars['EntityGuid']['input']>;
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeTeamUpdateArgs = {
  guid: Scalars['EntityGuid']['input'];
  team: TeamUpdateInput;
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeTeamUpdateEntityOwnersArgs = {
  newTeams?: InputMaybe<Array<Scalars['EntityGuid']['input']>>;
  oldTeams?: InputMaybe<Array<Scalars['EntityGuid']['input']>>;
  targetGuid: Scalars['EntityGuid']['input'];
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeTeamUpdateGlobalSettingsArgs = {
  updateGlobalSettings: TeamUpdateGlobalSettingsInput;
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeUserEmailNotificationPreferencesUpdateArgs = {
  updatedNotificationPreferences: Array<InputMaybe<UserEmailNotificationPreferencesUpdatedNotificationPreference>>;
  userId: Scalars['String']['input'];
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeUserEmailNotificationPreferencesUpdateSuppressionGroupArgs = {
  updatedSuppressionGroup: Array<InputMaybe<UserEmailNotificationPreferencesUpdatedSuppressionGroup>>;
  userId: Scalars['String']['input'];
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeUserManagementAddUsersToGroupsArgs = {
  addUsersToGroupsOptions?: InputMaybe<UserManagementUsersGroupsInput>;
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeUserManagementCreateGroupArgs = {
  createGroupOptions?: InputMaybe<UserManagementCreateGroup>;
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeUserManagementCreateUserArgs = {
  createUserOptions: UserManagementCreateUser;
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeUserManagementDeleteGroupArgs = {
  groupOptions?: InputMaybe<UserManagementDeleteGroup>;
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeUserManagementDeleteUserArgs = {
  deleteUserOptions: UserManagementDeleteUser;
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeUserManagementRemoveUsersFromGroupsArgs = {
  removeUsersFromGroupsOptions: UserManagementUsersGroupsInput;
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeUserManagementUpdateGroupArgs = {
  updateGroupOptions?: InputMaybe<UserManagementUpdateGroup>;
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeUserManagementUpdateUserArgs = {
  updateUserOptions: UserManagementUpdateUser;
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeUserUpdatePreferencesArgs = {
  userPreferences: UserUpdatePreferences;
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeUserUpgradeSelfArgs = {
  upgradeSelfOptions?: InputMaybe<UserUpgradeSelf>;
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeWebsitePerformanceMonitoringCreateLighthouseScriptMonitorArgs = {
  accountId: Scalars['Int']['input'];
  requestSource?: InputMaybe<WebsitePerformanceMonitoringRequestSource>;
  websiteDetails: WebsitePerformanceMonitoringWebsiteInput;
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeWebsitePerformanceMonitoringCreateWebsitePerformanceMonitorsArgs = {
  accountId: Scalars['Int']['input'];
  requestSource?: InputMaybe<WebsitePerformanceMonitoringRequestSource>;
  requestType?: InputMaybe<WebsitePerformanceMonitoringRequestType>;
  websiteDetails: WebsitePerformanceMonitoringWebsiteInput;
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeWebsitePerformanceMonitoringUpdateRequestArgs = {
  accountId: Scalars['Int']['input'];
  requestFields: WebsitePerformanceMonitoringUpdateRequestFields;
  websiteDetails: WebsitePerformanceMonitoringWebsiteInput;
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeWhatsNewSetLastReadDateArgs = {
  date: Scalars['EpochMilliseconds']['input'];
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeWorkloadCreateArgs = {
  accountId: Scalars['Int']['input'];
  workload: WorkloadCreateInput;
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeWorkloadDeleteArgs = {
  guid: Scalars['EntityGuid']['input'];
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeWorkloadDuplicateArgs = {
  accountId: Scalars['Int']['input'];
  sourceGuid: Scalars['EntityGuid']['input'];
  workload?: InputMaybe<WorkloadDuplicateInput>;
};


/**
 * This is the root of all GraphQL mutations. Unlike queries, mutations
 * represent actions that have a side effects, like `create` or `update`.
 */
export type RootMutationTypeWorkloadUpdateArgs = {
  guid: Scalars['EntityGuid']['input'];
  workload: WorkloadUpdateInput;
};

/**
 * This is the root of all GraphQL queries. The fields in this object
 * are available at the top level of a query.
 */
export type RootQueryType = {
  __typename?: 'RootQueryType';
  /**
   * This field is deprecated and usage is locked to legacy clients.
   *
   * To access account information, please use `actor.account(id: N)`
   * @deprecated Please use `actor.account(id: N)`
   */
  account?: Maybe<AccountObject>;
  /**
   * The `actor` field is the top-level entry into all data that is scoped
   * to the API user's access level.
   */
  actor?: Maybe<Actor>;
  currentUser?: Maybe<UserObject>;
  /** The `customerAdministration` field is the place for managing the configuration that defines the business relationships between New Relic, partners, and customers. */
  customerAdministration?: Maybe<CustomerAdministration>;
  /** Access to structured New Relic documentation data */
  docs?: Maybe<DocumentationFields>;
  nerdGraphContext?: Maybe<NerdGraphContext>;
  nrPlatform?: Maybe<NrPlatformQueryNamespace>;
  /** The `requestContext` field provides contextual information about the API request itself. */
  requestContext?: Maybe<RequestContext>;
  /**
   * This field is deprecated and usage is locked to legacy clients.
   *
   * To access user information, please use `actor.user` or `currentUser`.
   * Accessing information about another user must be managed in the API
   * to prevent leaking personal information.
   * @deprecated Please use `actor.user` or `currentUser`
   */
  user?: Maybe<UserObject>;
};


/**
 * This is the root of all GraphQL queries. The fields in this object
 * are available at the top level of a query.
 */
export type RootQueryTypeAccountArgs = {
  id: Scalars['Int']['input'];
};


/**
 * This is the root of all GraphQL queries. The fields in this object
 * are available at the top level of a query.
 */
export type RootQueryTypeUserArgs = {
  email?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
};

export type RootSubscriptionType = {
  __typename?: 'RootSubscriptionType';
  /**
   * @deprecated This field is experimental! It may change at any time.
   *
   * NerdGraph subscriptions don't work in GraphiQL, since they are based in
   * HTTP Server Sent Events, not Web Sockets. You can access them via `curl`
   * or `Event Source` in the browser.
   *
   */
  logsLiveTail?: Maybe<LogsLiveTailResult>;
};


export type RootSubscriptionTypeLogsLiveTailArgs = {
  accountId: Scalars['Int']['input'];
  maxBatchSize?: InputMaybe<Scalars['Int']['input']>;
  nrql: Scalars['Nrql']['input'];
  publishIntervalMs?: InputMaybe<Scalars['Milliseconds']['input']>;
};

/** Retrieve saved view information. */
export type SavedViewsActorStitchedFields = {
  __typename?: 'SavedViewsActorStitchedFields';
  /**
   * Retrieve saved views by applying a set of query filters.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  viewSearch?: Maybe<SavedViewsQueryResults>;
};


/** Retrieve saved view information. */
export type SavedViewsActorStitchedFieldsViewSearchArgs = {
  cursor?: InputMaybe<Scalars['String']['input']>;
  filter: SavedViewsQueryFilter;
  limit?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<SavedViewsSortingCriteria>;
};

/** Contains the query context about a given saved view. */
export type SavedViewsContext = {
  __typename?: 'SavedViewsContext';
  /**
   * Unstructured arbitrary data associated with the Saved View.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  additionalData?: Maybe<Scalars['SavedViewsRawAdditionalData']['output']>;
  /**
   * How many times this saved view was favorited.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  favoriteCount: Scalars['Int']['output'];
};

/** Wrap errors from a saved view create operation. */
export type SavedViewsCreateError = {
  __typename?: 'SavedViewsCreateError';
  /**
   * User-friendly message describing the error.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  message: Scalars['String']['output'];
  /**
   * Describes all potential error types that a saved view operation might return.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  type: SavedViewsCreateErrorType;
};

/** Describe all potential error types that a saved view create operation might return. */
export enum SavedViewsCreateErrorType {
  /**
   * Filter validation error.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  FilterValidationError = 'FILTER_VALIDATION_ERROR',
  /**
   * Forbidden request input.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  Forbidden = 'FORBIDDEN',
  /**
   * Invalid request input.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  InvalidInput = 'INVALID_INPUT'
}

/** Response type for saved view create operations. */
export type SavedViewsCreateResult = {
  __typename?: 'SavedViewsCreateResult';
  /**
   * List of failures for operation.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  failures?: Maybe<Array<SavedViewsCreateError>>;
  /**
   * Identifier of the created saved view.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  id: Scalars['ID']['output'];
};

/** Wrap errors from a saved view delete update operation. */
export type SavedViewsDeleteError = {
  __typename?: 'SavedViewsDeleteError';
  /**
   * User-friendly message describing the error.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  message: Scalars['String']['output'];
  /**
   * Describes all potential error types that a saved view operation might return.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  type: SavedViewsDeleteErrorType;
};

/** Describe all potential error types that a saved view delete operation might return. */
export enum SavedViewsDeleteErrorType {
  /**
   * Forbidden request.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  Forbidden = 'FORBIDDEN'
}

/** Response type for saved view delete operations. */
export type SavedViewsDeleteResult = {
  __typename?: 'SavedViewsDeleteResult';
  /**
   * List of failures for operation.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  failures?: Maybe<Array<SavedViewsDeleteError>>;
};

/** Describe all potential permissions an actor can have on a saved view. */
export enum SavedViewsPermission {
  /**
   * Delete permission.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  Delete = 'DELETE',
  /**
   * Read permission.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  Read = 'READ',
  /**
   * Write permission.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  Write = 'WRITE'
}

/** Saved view query filters. */
export type SavedViewsQueryFilter = {
  /** Retrieve saved views by accounts. */
  accounts?: InputMaybe<Array<Scalars['Int']['input']>>;
  /** An optional array of capabilities. A given returned Saved Views will belong to one of the capabilities provided. */
  capabilities?: InputMaybe<Array<Scalars['String']['input']>>;
  /** Filter saved views retrieved by favorite. If it is true, returns only saved views favorited by this user actor. */
  filterFavorites?: InputMaybe<Scalars['Boolean']['input']>;
  /** Retrieve saved views by ids. */
  ids?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** Retrieve saved views by owner user id. */
  owners?: InputMaybe<Array<Scalars['Int']['input']>>;
  /** Retrieve saved views that contains the provided text in the query or in the name. */
  searchText?: InputMaybe<Scalars['String']['input']>;
};

/** Represent a list of saved views. */
export type SavedViewsQueryResults = {
  __typename?: 'SavedViewsQueryResults';
  /**
   * String that used to fetch the next page.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  nextCursor?: Maybe<Scalars['String']['output']>;
  /**
   * List of resulting saved views.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  results: Array<SavedViewsView>;
  /**
   * Total saved views for the given filter.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  totalCount?: Maybe<Scalars['Int']['output']>;
};

/** This object contains the needed information to sort the list. The sorting column and the direction. */
export type SavedViewsSortingCriteria = {
  /** Direction of the sorting asc/desc. */
  direction?: InputMaybe<SortBy>;
  /** Name of the field that will be used for sorting the result list. */
  field?: InputMaybe<SavedViewsSortingField>;
};

/** Define the possible fields to be used to order the saved views list. */
export enum SavedViewsSortingField {
  /**
   * It will sort based on the creation date.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  Created = 'CREATED',
  /**
   * It will sort the list based on the view name.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  Name = 'NAME',
  /**
   * It will sort the list based on the query.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  Query = 'QUERY'
}

/** Wrap errors from a saved view update operation. */
export type SavedViewsUpdateError = {
  __typename?: 'SavedViewsUpdateError';
  /**
   * User-friendly message describing the error.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  message: Scalars['String']['output'];
  /**
   * Describes all potential error types that a saved view operation might return.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  type: SavedViewsUpdateErrorType;
};

/** Describe all potential error types that a saved view update operation might return. */
export enum SavedViewsUpdateErrorType {
  /**
   * Filter validation error.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  FilterValidationError = 'FILTER_VALIDATION_ERROR',
  /**
   * Forbidden request.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  Forbidden = 'FORBIDDEN',
  /**
   * Invalid request input.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  InvalidInput = 'INVALID_INPUT'
}

/** Response type for saved view update operations. */
export type SavedViewsUpdateResult = {
  __typename?: 'SavedViewsUpdateResult';
  /**
   * List of failures for operation.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  failures?: Maybe<Array<SavedViewsUpdateError>>;
};

/** Contain a saved view. */
export type SavedViewsView = {
  __typename?: 'SavedViewsView';
  /**
   * The account that owns the saved view.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  account?: Maybe<AccountReference>;
  /**
   * The optional Capability the Saved View is scoped to.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  capability?: Maybe<Scalars['String']['output']>;
  /**
   * Query context including metadata about a given saved view.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  context: SavedViewsContext;
  /**
   * The time the saved view was created.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  createdAt: Scalars['EpochMilliseconds']['output'];
  /**
   * The user that created the saved view.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  createdByUser?: Maybe<UserReference>;
  /**
   * Mark if the saved view is a favorite for the user making the request.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  favorite: Scalars['Boolean']['output'];
  /**
   * The saved view filter query e.g. A common query for Entity Explorer.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  filter: Scalars['Nrql']['output'];
  /**
   * Unique identifier of the saved view.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  id: Scalars['ID']['output'];
  /**
   * Name of the saved view.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  name: Scalars['String']['output'];
  /**
   * Permissions of the current actor on a saved view.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  permissions: Array<SavedViewsPermission>;
  /**
   * The last time the saved view was updated.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  updatedAt: Scalars['EpochMilliseconds']['output'];
  /**
   * Define how the saved view should be shown to the user in the UI (Tiles/Table).
   * @deprecated This field is experimental and subject to breaking changes.
   */
  viewType?: Maybe<SavedViewsViewType>;
  /**
   * Visibility of the saved view.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  visibility: SavedViewsVisibility;
};

/** Define the visualization type for a saved view. */
export enum SavedViewsViewType {
  /**
   * Saved view result will be displayed in table format.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  Table = 'TABLE',
  /**
   * Saved view result will be displayed in tiles format.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  Tiles = 'TILES'
}

/** Define the visibility for a saved view. */
export enum SavedViewsVisibility {
  /**
   * Saved view will be only visible to its owner.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  Private = 'PRIVATE',
  /**
   * Saved view will be visible by other users on the same account.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  Shared = 'SHARED'
}

/** A secure credential entity. */
export type SecureCredentialEntity = AlertableEntity & Entity & {
  __typename?: 'SecureCredentialEntity';
  account?: Maybe<AccountOutline>;
  /** The New Relic account ID associated with this entity. */
  accountId?: Maybe<Scalars['Int']['output']>;
  /** The current alerting severity of the entity. */
  alertSeverity?: Maybe<EntityAlertSeverity>;
  /**
   * The alert status of the entity.
   * @deprecated Please use `alertSeverity` and `reporting`
   */
  alertStatus?: Maybe<EntityAlertStatus>;
  /** Violations on the entity that were open during the specified time window. This will return up to 500 violations - if there are more in the time window selected, you must narrow the time window or look at fewer entities. */
  alertViolations?: Maybe<Array<Maybe<EntityAlertViolation>>>;
  /** Retrieve the deployment event(s). Ordered by timestamp DESC. */
  deploymentSearch?: Maybe<ChangeTrackingDeploymentSearchResult>;
  /** The description of the entity. */
  description?: Maybe<Scalars['String']['output']>;
  /** The entity's domain */
  domain?: Maybe<Scalars['String']['output']>;
  /** A value representing the combination of the entity's domain and type. */
  entityType?: Maybe<EntityType>;
  /** The date of last time the entity has updated any of its fields. */
  firstIndexedAt?: Maybe<Scalars['EpochMilliseconds']['output']>;
  /** The list of golden metrics for a specific entity */
  goldenMetrics?: Maybe<EntityGoldenContextScopedGoldenMetrics>;
  /**
   * For the golden signal on this entity, show correlated signals from related entities.
   * Well inspect the golden signals for all related entities and return a sorted list.
   * You can also filter the results.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  goldenSignalCorrelations?: Maybe<GoldenSignalCorrelationResult>;
  /**
   * The deviation from normal of golden signal(s) for the given entity.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  goldenSignalDeviations?: Maybe<Array<Maybe<GoldenSignalSignalDeviation>>>;
  /**
   * The stored golden signal(s) for the given entity.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  goldenSignalValues?: Maybe<GoldenSignalValues>;
  /**
   * The stored golden signal(s) for the given entity. To be removed, use goldenSignalValues instead.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  goldenSignalValuesV2?: Maybe<GoldenSignalValues>;
  /** The list of golden tags for a specific entityType. */
  goldenTags?: Maybe<EntityGoldenContextScopedGoldenTags>;
  /** A unique entity identifier. */
  guid?: Maybe<Scalars['EntityGuid']['output']>;
  /** The time the entity was indexed. */
  indexedAt?: Maybe<Scalars['EpochMilliseconds']['output']>;
  /** The last time the entity's reporting status changed. */
  lastReportingChangeAt?: Maybe<Scalars['EpochMilliseconds']['output']>;
  /** The name of this entity. */
  name?: Maybe<Scalars['String']['output']>;
  nerdStorage?: Maybe<NerdStorageEntityScope>;
  nerdStoreCollection?: Maybe<Array<Maybe<NerdStoreCollectionMember>>>;
  nerdStoreDocument?: Maybe<Scalars['NerdStoreDocument']['output']>;
  /**
   * Make an `Entity` scoped query to NRDB with a NRQL string.
   *
   * A relevant `WHERE` clause will be added to your query to scope data to the entity in question.
   *
   * See the [NRQL Docs](https://docs.newrelic.com/docs/insights/nrql-new-relic-query-language/nrql-resources/nrql-syntax-components-functions) for more information about generating a query string.
   */
  nrdbQuery?: Maybe<NrdbResultContainer>;
  /**
   * Poll for the results of a previously-executed asychronous NRDB query.
   *
   * The `queryId` is available in the `queryProgress` data returned by the original asynchronous query.
   *
   * See [this page](https://docs.newrelic.com/docs/apis/nerdgraph/examples/async-queries-nrql-tutorial) for additional asynchronous query documentation.
   * @deprecated This field is experimental! It may change at any time.
   *
   */
  nrdbQueryProgress?: Maybe<NrdbResultContainer>;
  /** The url to the entity. */
  permalink?: Maybe<Scalars['String']['output']>;
  /** Recent violations on the entity. */
  recentAlertViolations?: Maybe<Array<Maybe<EntityAlertViolation>>>;
  /** The recommended service levels for the entity. */
  recommendedServiceLevel?: Maybe<ServiceLevelRecommendation>;
  /** Related dashboards results */
  relatedDashboards: RelatedDashboardsRelatedDashboardResult;
  /** Related entities result with optional filtering. */
  relatedEntities?: Maybe<EntityRelationshipRelatedEntitiesResult>;
  /** Relationship traversal results with optional filtering. WARNING: this query is still experimental, and subject to breaking changes. */
  relationshipTraversal?: Maybe<EntityRelationshipTraversalResult>;
  /**
   * A list of the entities' relationships.
   *
   * For more information, visit [our docs](https://docs.newrelic.com/docs/apis/graphql-api/tutorials/graphql-relationships-api-tutorial).
   * @deprecated This field is deprecated! Please use `relatedEntities`.
   */
  relationships?: Maybe<Array<Maybe<EntityRelationship>>>;
  /** The reporting status of the entity. If New Relic is successfully collecting data from your application, this will be true. */
  reporting?: Maybe<Scalars['Boolean']['output']>;
  /** The domain-specific identifier for the entity. */
  secureCredentialId?: Maybe<Scalars['ID']['output']>;
  /** Summary statistics for the Synthetic Monitor Secure Credential. */
  secureCredentialSummary?: Maybe<SecureCredentialSummaryData>;
  /** The service level defined for the entity. */
  serviceLevel?: Maybe<ServiceLevelDefinition>;
  /** The list of summary metrics. */
  summaryMetrics?: Maybe<Array<Maybe<EntitySummaryMetric>>>;
  /**
   * The tags applied to the entity.
   *
   * For details on tags, as well as query and mutation examples, visit [our docs](https://docs.newrelic.com/docs/apis/graphql-api/tutorials/graphql-tagging-api-tutorial).
   */
  tags?: Maybe<Array<Maybe<EntityTag>>>;
  /** The tags applied to the entity with their metadata. */
  tagsWithMetadata?: Maybe<Array<Maybe<EntityTagWithMetadata>>>;
  /** Look up Distributed Tracing summary data for the selected `EntityGuid` */
  tracingSummary?: Maybe<DistributedTracingEntityTracingSummary>;
  /** The entity's type */
  type?: Maybe<Scalars['String']['output']>;
  /** List of templates availables for this entity. */
  uiTemplates?: Maybe<Array<EntityDashboardTemplatesUi>>;
  /** The time at which the entity was last updated. */
  updatedAt?: Maybe<Scalars['EpochMilliseconds']['output']>;
};


/** A secure credential entity. */
export type SecureCredentialEntityAlertViolationsArgs = {
  endTime: Scalars['EpochMilliseconds']['input'];
  startTime: Scalars['EpochMilliseconds']['input'];
};


/** A secure credential entity. */
export type SecureCredentialEntityDeploymentSearchArgs = {
  filter?: InputMaybe<ChangeTrackingSearchFilter>;
};


/** A secure credential entity. */
export type SecureCredentialEntityGoldenMetricsArgs = {
  context?: InputMaybe<EntityGoldenContextInput>;
  timeWindow?: InputMaybe<EntityGoldenNrqlTimeWindowInput>;
};


/** A secure credential entity. */
export type SecureCredentialEntityGoldenSignalCorrelationsArgs = {
  filter?: InputMaybe<GoldenSignalCorrelationsEntityFilter>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  timeWindow?: InputMaybe<TimeWindowInput>;
};


/** A secure credential entity. */
export type SecureCredentialEntityGoldenSignalDeviationsArgs = {
  comparisonTimeWindow?: InputMaybe<TimeWindowInput>;
  evaluationTimeWindow?: InputMaybe<TimeWindowInput>;
};


/** A secure credential entity. */
export type SecureCredentialEntityGoldenSignalValuesArgs = {
  timeWindow?: InputMaybe<TimeWindowInput>;
};


/** A secure credential entity. */
export type SecureCredentialEntityGoldenSignalValuesV2Args = {
  timeWindow?: InputMaybe<TimeWindowInput>;
};


/** A secure credential entity. */
export type SecureCredentialEntityGoldenTagsArgs = {
  context?: InputMaybe<EntityGoldenContextInput>;
};


/** A secure credential entity. */
export type SecureCredentialEntityNerdStoreCollectionArgs = {
  collection: Scalars['String']['input'];
  scopeByActor?: InputMaybe<Scalars['Boolean']['input']>;
};


/** A secure credential entity. */
export type SecureCredentialEntityNerdStoreDocumentArgs = {
  collection: Scalars['String']['input'];
  documentId: Scalars['String']['input'];
  scopeByActor?: InputMaybe<Scalars['Boolean']['input']>;
};


/** A secure credential entity. */
export type SecureCredentialEntityNrdbQueryArgs = {
  async?: InputMaybe<Scalars['Boolean']['input']>;
  nrql: Scalars['Nrql']['input'];
  options?: InputMaybe<NrqlQueryOptions>;
  timeout?: InputMaybe<Scalars['Seconds']['input']>;
};


/** A secure credential entity. */
export type SecureCredentialEntityNrdbQueryProgressArgs = {
  queryId: Scalars['ID']['input'];
};


/** A secure credential entity. */
export type SecureCredentialEntityRecentAlertViolationsArgs = {
  count?: InputMaybe<Scalars['Int']['input']>;
};


/** A secure credential entity. */
export type SecureCredentialEntityRelatedEntitiesArgs = {
  cursor?: InputMaybe<Scalars['String']['input']>;
  filter?: InputMaybe<EntityRelationshipEdgeFilter>;
  limit?: InputMaybe<Scalars['Int']['input']>;
};


/** A secure credential entity. */
export type SecureCredentialEntityRelationshipTraversalArgs = {
  cursor?: InputMaybe<Scalars['String']['input']>;
  hopFilters?: InputMaybe<EntityRelationshipTraversalHopFilters>;
  hops?: InputMaybe<Scalars['Int']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
};


/** A secure credential entity. */
export type SecureCredentialEntityRelationshipsArgs = {
  endTime?: InputMaybe<Scalars['EpochMilliseconds']['input']>;
  filter?: InputMaybe<EntityRelationshipFilter>;
};


/** A secure credential entity. */
export type SecureCredentialEntitySummaryMetricsArgs = {
  timeWindow?: InputMaybe<TimeWindowInput>;
};


/** A secure credential entity. */
export type SecureCredentialEntityTracingSummaryArgs = {
  timeWindow?: InputMaybe<TimeWindowInput>;
};

/** A secure credential entity outline. */
export type SecureCredentialEntityOutline = AlertableEntityOutline & EntityOutline & {
  __typename?: 'SecureCredentialEntityOutline';
  account?: Maybe<AccountOutline>;
  /** The New Relic account ID associated with this entity. */
  accountId?: Maybe<Scalars['Int']['output']>;
  /** The current alerting severity of the entity. */
  alertSeverity?: Maybe<EntityAlertSeverity>;
  /**
   * The alert status of the entity.
   * @deprecated Please use `alertSeverity` and `reporting`
   */
  alertStatus?: Maybe<EntityAlertStatus>;
  /** The description of the entity. */
  description?: Maybe<Scalars['String']['output']>;
  /** The entity's domain */
  domain?: Maybe<Scalars['String']['output']>;
  /** A value representing the combination of the entity's domain and type. */
  entityType?: Maybe<EntityType>;
  /** The date of last time the entity has updated any of its fields. */
  firstIndexedAt?: Maybe<Scalars['EpochMilliseconds']['output']>;
  /** The list of golden metrics for a specific entity */
  goldenMetrics?: Maybe<EntityGoldenContextScopedGoldenMetrics>;
  /**
   * For the golden signal on this entity, show correlated signals from related entities.
   * Well inspect the golden signals for all related entities and return a sorted list.
   * You can also filter the results.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  goldenSignalCorrelations?: Maybe<GoldenSignalCorrelationResult>;
  /**
   * The deviation from normal of golden signal(s) for the given entity.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  goldenSignalDeviations?: Maybe<Array<Maybe<GoldenSignalSignalDeviation>>>;
  /**
   * The stored golden signal(s) for the given entity.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  goldenSignalValues?: Maybe<GoldenSignalValues>;
  /**
   * The stored golden signal(s) for the given entity. To be removed, use goldenSignalValues instead.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  goldenSignalValuesV2?: Maybe<GoldenSignalValues>;
  /** The list of golden tags for a specific entityType. */
  goldenTags?: Maybe<EntityGoldenContextScopedGoldenTags>;
  /** A unique entity identifier. */
  guid?: Maybe<Scalars['EntityGuid']['output']>;
  /** The time the entity was indexed. */
  indexedAt?: Maybe<Scalars['EpochMilliseconds']['output']>;
  /** The last time the entity's reporting status changed. */
  lastReportingChangeAt?: Maybe<Scalars['EpochMilliseconds']['output']>;
  /** The name of this entity. */
  name?: Maybe<Scalars['String']['output']>;
  /** The url to the entity. */
  permalink?: Maybe<Scalars['String']['output']>;
  /** The recommended service levels for the entity. */
  recommendedServiceLevel?: Maybe<ServiceLevelRecommendation>;
  /** Related dashboards results */
  relatedDashboards: RelatedDashboardsRelatedDashboardResult;
  /** The reporting status of the entity. If New Relic is successfully collecting data from your application, this will be true. */
  reporting?: Maybe<Scalars['Boolean']['output']>;
  /** The domain-specific identifier for the entity. */
  secureCredentialId?: Maybe<Scalars['ID']['output']>;
  /** Summary statistics for the Synthetic Monitor Secure Credential. */
  secureCredentialSummary?: Maybe<SecureCredentialSummaryData>;
  /** The service level defined for the entity. */
  serviceLevel?: Maybe<ServiceLevelDefinition>;
  /** The list of summary metrics. */
  summaryMetrics?: Maybe<Array<Maybe<EntitySummaryMetric>>>;
  /**
   * The tags applied to the entity.
   *
   * For details on tags, as well as query and mutation examples, visit [our docs](https://docs.newrelic.com/docs/apis/graphql-api/tutorials/graphql-tagging-api-tutorial).
   */
  tags?: Maybe<Array<Maybe<EntityTag>>>;
  /** The entity's type */
  type?: Maybe<Scalars['String']['output']>;
  /** List of templates availables for this entity. */
  uiTemplates?: Maybe<Array<EntityDashboardTemplatesUi>>;
  /** The time at which the entity was last updated. */
  updatedAt?: Maybe<Scalars['EpochMilliseconds']['output']>;
};


/** A secure credential entity outline. */
export type SecureCredentialEntityOutlineGoldenMetricsArgs = {
  context?: InputMaybe<EntityGoldenContextInput>;
  timeWindow?: InputMaybe<EntityGoldenNrqlTimeWindowInput>;
};


/** A secure credential entity outline. */
export type SecureCredentialEntityOutlineGoldenSignalCorrelationsArgs = {
  filter?: InputMaybe<GoldenSignalCorrelationsEntityFilter>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  timeWindow?: InputMaybe<TimeWindowInput>;
};


/** A secure credential entity outline. */
export type SecureCredentialEntityOutlineGoldenSignalDeviationsArgs = {
  comparisonTimeWindow?: InputMaybe<TimeWindowInput>;
  evaluationTimeWindow?: InputMaybe<TimeWindowInput>;
};


/** A secure credential entity outline. */
export type SecureCredentialEntityOutlineGoldenSignalValuesArgs = {
  timeWindow?: InputMaybe<TimeWindowInput>;
};


/** A secure credential entity outline. */
export type SecureCredentialEntityOutlineGoldenSignalValuesV2Args = {
  timeWindow?: InputMaybe<TimeWindowInput>;
};


/** A secure credential entity outline. */
export type SecureCredentialEntityOutlineGoldenTagsArgs = {
  context?: InputMaybe<EntityGoldenContextInput>;
};


/** A secure credential entity outline. */
export type SecureCredentialEntityOutlineSummaryMetricsArgs = {
  timeWindow?: InputMaybe<TimeWindowInput>;
};

/** Summary statistics for the Synthetic Monitor Secure Credential. */
export type SecureCredentialSummaryData = {
  __typename?: 'SecureCredentialSummaryData';
  /**
   * The number of monitors that contain this secure credential and failed their last check.
   * @deprecated This field is deprecated and will not return valid data.
   */
  failingMonitorCount?: Maybe<Scalars['Int']['output']>;
  /**
   * The number of monitors that contain this secure credential.
   * @deprecated This field is deprecated and will not return valid data.
   */
  monitorCount?: Maybe<Scalars['Int']['output']>;
};

export type ServiceDiscoveryEndpoint = {
  __typename?: 'ServiceDiscoveryEndpoint';
  endpoint?: Maybe<Scalars['String']['output']>;
  path?: Maybe<Scalars['String']['output']>;
};

export type ServiceDiscoveryNamespace = {
  __typename?: 'ServiceDiscoveryNamespace';
  endpointBootstrapScript?: Maybe<Scalars['String']['output']>;
  endpoints?: Maybe<Array<Maybe<ServiceDiscoveryEndpoint>>>;
};


export type ServiceDiscoveryNamespaceEndpointBootstrapScriptArgs = {
  paths: Array<InputMaybe<Scalars['String']['input']>>;
};


export type ServiceDiscoveryNamespaceEndpointsArgs = {
  paths: Array<InputMaybe<Scalars['String']['input']>>;
};

/** The limits of the computed value and the default value to fall back if it cannot be computed successfully */
export type ServiceLevelComputedValueLimits = {
  __typename?: 'ServiceLevelComputedValueLimits';
  /** A default value to fall back if the computation cannot be completed successfully. */
  fallback?: Maybe<Scalars['Float']['output']>;
  /** Computed values greater than the maximum limit must fall back to the maximum value. If null, ignore it. */
  maximum?: Maybe<Scalars['Float']['output']>;
  /** Computed values less than the minimum limit must fall back to the minimum value. If null, ignore it. */
  minimum?: Maybe<Scalars['Float']['output']>;
};

/** The service level defined for a specific entity. */
export type ServiceLevelDefinition = {
  __typename?: 'ServiceLevelDefinition';
  /** The SLIs attached to the entity. */
  indicators?: Maybe<Array<ServiceLevelIndicator>>;
};

/** An SLI general error. */
export type ServiceLevelError = {
  __typename?: 'ServiceLevelError';
  /** The description of the error. */
  description?: Maybe<Scalars['String']['output']>;
};

/** The events that define the SLI. */
export type ServiceLevelEvents = {
  __typename?: 'ServiceLevelEvents';
  /** The New Relic account to fetch the events from. */
  account?: Maybe<AccountReference>;
  /** The definition of bad events. */
  badEvents?: Maybe<ServiceLevelEventsQuery>;
  /** The definition of good events. */
  goodEvents?: Maybe<ServiceLevelEventsQuery>;
  /** The definition of valid events. */
  validEvents: ServiceLevelEventsQuery;
};

/** The events that define the SLI. */
export type ServiceLevelEventsCreateInput = {
  /** The New Relic account ID where the events are fetched from. */
  accountId: Scalars['Int']['input'];
  /** The definition of bad events. */
  badEvents?: InputMaybe<ServiceLevelEventsQueryCreateInput>;
  /** The definition of good events. */
  goodEvents?: InputMaybe<ServiceLevelEventsQueryCreateInput>;
  /** The definition of valid events. */
  validEvents: ServiceLevelEventsQueryCreateInput;
};

/** The query that represents the events to fetch. */
export type ServiceLevelEventsQuery = {
  __typename?: 'ServiceLevelEventsQuery';
  /** The NRDB event to fetch the data from. */
  from: Scalars['Nrql']['output'];
  /** The NRQL SELECT clause to aggregate events. */
  select?: Maybe<ServiceLevelEventsQuerySelect>;
  /** The NRQL condition to filter the events. */
  where?: Maybe<Scalars['Nrql']['output']>;
};

/** The query that represents the events to fetch. */
export type ServiceLevelEventsQueryCreateInput = {
  /** The NRDB event to fetch the data from. */
  from: Scalars['Nrql']['input'];
  /** The NRQL SELECT clause to aggregate events. Default is COUNT(*). */
  select?: InputMaybe<ServiceLevelEventsQuerySelectCreateInput>;
  /** The NRQL condition to filter the events. */
  where?: InputMaybe<Scalars['Nrql']['input']>;
};

/** The resulting NRQL SELECT clause to aggregate events. */
export type ServiceLevelEventsQuerySelect = {
  __typename?: 'ServiceLevelEventsQuerySelect';
  /** The attribute used in the selected function. */
  attribute?: Maybe<Scalars['String']['output']>;
  /** The function to use in the SELECT clause. */
  function: ServiceLevelEventsQuerySelectFunction;
  /** The threshold used in the selected function. */
  threshold?: Maybe<Scalars['Float']['output']>;
};

/** The NRQL SELECT clause to aggregate events. */
export type ServiceLevelEventsQuerySelectCreateInput = {
  /** The attribute used in the selected function. Only use it in combination with the SUM, GET_FIELD and GET_CDF_COUNT functions. */
  attribute?: InputMaybe<Scalars['String']['input']>;
  /** The function to use in the SELECT clause. */
  function: ServiceLevelEventsQuerySelectFunction;
  /** The threshold used in the selected function. Only use it in combination with the GET_CDF_COUNT function. */
  threshold?: InputMaybe<Scalars['Float']['input']>;
};

/** The function to use in the SELECT clause. */
export enum ServiceLevelEventsQuerySelectFunction {
  /** Use on events and unaggregated data. */
  Count = 'COUNT',
  /** Use on distribution metric types. */
  GetCdfCount = 'GET_CDF_COUNT',
  /** Use in valid events combined with GET_CDF_COUNT. */
  GetField = 'GET_FIELD',
  /** Use on aggregated counts. */
  Sum = 'SUM'
}

/** The NRQL SELECT clause to aggregate events. */
export type ServiceLevelEventsQuerySelectUpdateInput = {
  /** The attribute used in the selected function. Only use it in combination with the SUM, GET_FIELD and GET_CDF_COUNT functions. */
  attribute?: InputMaybe<Scalars['String']['input']>;
  /** The function to use in the SELECT clause. */
  function: ServiceLevelEventsQuerySelectFunction;
  /** The threshold used in the selected function. Only use it in combination with the GET_CDF_COUNT function. */
  threshold?: InputMaybe<Scalars['Float']['input']>;
};

/** The query that represents the events to fetch. */
export type ServiceLevelEventsQueryUpdateInput = {
  /** The NRDB event to fetch the data from. */
  from: Scalars['Nrql']['input'];
  /** The NRQL SELECT clause to aggregate events. Default is COUNT(*). */
  select?: InputMaybe<ServiceLevelEventsQuerySelectUpdateInput>;
  /** The NRQL condition to filter the events. */
  where?: InputMaybe<Scalars['Nrql']['input']>;
};

/** The events that define the SLI. */
export type ServiceLevelEventsUpdateInput = {
  /** The definition of bad events. */
  badEvents?: InputMaybe<ServiceLevelEventsQueryUpdateInput>;
  /** The definition of good events. */
  goodEvents?: InputMaybe<ServiceLevelEventsQueryUpdateInput>;
  /** The definition of valid events. */
  validEvents: ServiceLevelEventsQueryUpdateInput;
};

/** A failure during request processing. */
export type ServiceLevelFailure = {
  __typename?: 'ServiceLevelFailure';
  /** The errors that caused the failure. */
  errors?: Maybe<Array<Maybe<ServiceLevelError>>>;
};

/** The definition of the SLI. */
export type ServiceLevelIndicator = {
  __typename?: 'ServiceLevelIndicator';
  /** The date when the SLI was created represented in the number of milliseconds since the Unix epoch. */
  createdAt: Scalars['EpochMilliseconds']['output'];
  /** The user who created the SLI. */
  createdBy?: Maybe<UserReference>;
  /** The description of the SLI. */
  description?: Maybe<Scalars['String']['output']>;
  /** The entity which the SLI is attached to. */
  entityGuid: Scalars['EntityGuid']['output'];
  /** The events that define the SLI. */
  events: ServiceLevelEvents;
  /** The unique entity identifier of the SLI. */
  guid: Scalars['EntityGuid']['output'];
  /** The unique identifier of the SLI. */
  id: Scalars['ID']['output'];
  /** The name of the SLI. */
  name: Scalars['String']['output'];
  /** A list of objective definitions. */
  objectives?: Maybe<Array<ServiceLevelObjective>>;
  /** The resulting NRQL queries that help consume the metrics of the SLI. */
  resultQueries?: Maybe<ServiceLevelIndicatorResultQueries>;
  /**
   * [DEPRECATED] The slug is deprecated and it will be removed from the schema as soon as possible.
   * @deprecated The slug is deprecated and it will be removed from the schema as soon as possible.
   */
  slug: Scalars['String']['output'];
  /** The date when the SLI was last updated represented in the number of milliseconds since the Unix epoch. */
  updatedAt?: Maybe<Scalars['EpochMilliseconds']['output']>;
  /** The user who last update the SLI. */
  updatedBy?: Maybe<UserReference>;
};

/** The input object that represents the SLI that will be created. */
export type ServiceLevelIndicatorCreateInput = {
  /** The description of the SLI. */
  description?: InputMaybe<Scalars['String']['input']>;
  /** The events that define the SLI. */
  events: ServiceLevelEventsCreateInput;
  /** The name of the SLI. */
  name: Scalars['String']['input'];
  /** A list of objective definitions. */
  objectives?: InputMaybe<Array<ServiceLevelObjectiveCreateInput>>;
  /** [DEPRECATED] The slug is deprecated and it will be removed from the schema as soon as possible. */
  slug?: InputMaybe<Scalars['String']['input']>;
  /** The source provides context about the SLI creation. */
  source?: InputMaybe<ServiceLevelServiceLevelSource>;
};

/** The resulting NRQL queries that help consume the metrics of the SLI. */
export type ServiceLevelIndicatorResultQueries = {
  __typename?: 'ServiceLevelIndicatorResultQueries';
  /** The NRQL query that measures the good events. */
  goodEvents: ServiceLevelResultQuery;
  /** The NRQL query that measures the value of the SLI. */
  indicator: ServiceLevelResultQuery;
  /** The NRQL query that measures the valid events. */
  validEvents: ServiceLevelResultQuery;
};

/** The input object that represents the SLI that will be updated. */
export type ServiceLevelIndicatorUpdateInput = {
  /** The description of the SLI. */
  description?: InputMaybe<Scalars['String']['input']>;
  /** The events that define the SLI. */
  events?: InputMaybe<ServiceLevelEventsUpdateInput>;
  /** The name of the SLI. */
  name?: InputMaybe<Scalars['String']['input']>;
  /** A list of objective definitions. */
  objectives?: InputMaybe<Array<ServiceLevelObjectiveUpdateInput>>;
};

/** An objective definition. */
export type ServiceLevelObjective = {
  __typename?: 'ServiceLevelObjective';
  /** The description of the SLO. */
  description?: Maybe<Scalars['String']['output']>;
  /** The name of the SLO. */
  name?: Maybe<Scalars['String']['output']>;
  /** The resulting NRQL queries that help consume the metrics of the SLO. */
  resultQueries?: Maybe<ServiceLevelObjectiveResultQueries>;
  /** The target percentage of the SLO. */
  target: Scalars['Float']['output'];
  /** The time window configuration of the SLO. */
  timeWindow: ServiceLevelObjectiveTimeWindow;
};

/** The input object that represents an objective definition. */
export type ServiceLevelObjectiveCreateInput = {
  /** The description of the SLO. */
  description?: InputMaybe<Scalars['String']['input']>;
  /** The name of the SLO. */
  name?: InputMaybe<Scalars['String']['input']>;
  /** The target percentage of the SLO. Maximum value is 100. */
  target: Scalars['Float']['input'];
  /** The time window configuration of the SLO. */
  timeWindow: ServiceLevelObjectiveTimeWindowCreateInput;
};

/** The resulting NRQL queries that help consume the metrics of the SLO. */
export type ServiceLevelObjectiveResultQueries = {
  __typename?: 'ServiceLevelObjectiveResultQueries';
  /** The NRQL query that measures the attainment of the SLO target. */
  attainment: ServiceLevelResultQuery;
};

/** The rolling time window configuration of the SLO. */
export type ServiceLevelObjectiveRollingTimeWindow = {
  __typename?: 'ServiceLevelObjectiveRollingTimeWindow';
  /** The count of time units. */
  count: Scalars['Int']['output'];
  /** The time unit. */
  unit: ServiceLevelObjectiveRollingTimeWindowUnit;
};

/** The rolling time window configuration of the SLO. */
export type ServiceLevelObjectiveRollingTimeWindowCreateInput = {
  /** The count of time units. Accepted values are 1, 7 and 28 days. */
  count: Scalars['Int']['input'];
  /** The time unit. */
  unit: ServiceLevelObjectiveRollingTimeWindowUnit;
};

/** The rolling time window units. */
export enum ServiceLevelObjectiveRollingTimeWindowUnit {
  /** Day. */
  Day = 'DAY'
}

/** The rolling time window configuration of the SLO. */
export type ServiceLevelObjectiveRollingTimeWindowUpdateInput = {
  /** The count of time units. Accepted values are 1, 7 and 28 days. */
  count: Scalars['Int']['input'];
  /** The time unit. */
  unit: ServiceLevelObjectiveRollingTimeWindowUnit;
};

/** The time window configuration of the SLO. */
export type ServiceLevelObjectiveTimeWindow = {
  __typename?: 'ServiceLevelObjectiveTimeWindow';
  /** The rolling time window configuration of the SLO. */
  rolling?: Maybe<ServiceLevelObjectiveRollingTimeWindow>;
};

/** The time window configuration of the SLO. */
export type ServiceLevelObjectiveTimeWindowCreateInput = {
  /** The rolling time window configuration of the SLO. */
  rolling: ServiceLevelObjectiveRollingTimeWindowCreateInput;
};

/** The time window configuration of the SLO. */
export type ServiceLevelObjectiveTimeWindowUpdateInput = {
  /** The rolling time window configuration of the SLO. */
  rolling: ServiceLevelObjectiveRollingTimeWindowUpdateInput;
};

/** The input object that represents an objective definition. */
export type ServiceLevelObjectiveUpdateInput = {
  /** The description of the SLO. */
  description?: InputMaybe<Scalars['String']['input']>;
  /** The name of the SLO. */
  name?: InputMaybe<Scalars['String']['input']>;
  /** The target percentage of the SLO. Maximum value is 100. */
  target: Scalars['Float']['input'];
  /** The time window configuration of the SLO. */
  timeWindow: ServiceLevelObjectiveTimeWindowUpdateInput;
};

/** The template of the NRQL queries that define how is calculated the recommended SLI. */
export type ServiceLevelQueryTemplates = {
  __typename?: 'ServiceLevelQueryTemplates';
  /** The events that define the recommended SLI. */
  events?: Maybe<ServiceLevelRecommendedEvents>;
  /** The recommended SLOs for the SLI. */
  recommendedObjectives?: Maybe<Array<ServiceLevelRecommendedObjective>>;
  /** The details of the parameters to be replaced in the query templates. */
  templateParameters?: Maybe<Array<ServiceLevelTemplateParameters>>;
};

/** The recommended service level for a specific entity. */
export type ServiceLevelRecommendation = {
  __typename?: 'ServiceLevelRecommendation';
  /** A list of recommended SLIs with the recommended SLOs for a specific entity. */
  indicators?: Maybe<Array<ServiceLevelRecommendedIndicator>>;
};

/** The events that define the recommended SLI. */
export type ServiceLevelRecommendedEvents = {
  __typename?: 'ServiceLevelRecommendedEvents';
  /** The query template that defines the bad events. */
  badEvents?: Maybe<ServiceLevelRecommendedEventsQuery>;
  /** The query template that defines the good events. */
  goodEvents?: Maybe<ServiceLevelRecommendedEventsQuery>;
  /** The query template that defines the valid events. */
  validEvents: ServiceLevelRecommendedEventsQuery;
};

/** The query template that represents the events to fetch. */
export type ServiceLevelRecommendedEventsQuery = {
  __typename?: 'ServiceLevelRecommendedEventsQuery';
  /** The NRDB event to fetch the data from. */
  from: Scalars['Nrql']['output'];
  /** The NRQL condition to filter the events. */
  where?: Maybe<Scalars['Nrql']['output']>;
};

/** A recommended SLI with the recommended SLOs for a specific entity. */
export type ServiceLevelRecommendedIndicator = {
  __typename?: 'ServiceLevelRecommendedIndicator';
  /** The category of the recommended SLI. */
  category?: Maybe<Scalars['String']['output']>;
  /** The description of the recommended SLI. */
  description?: Maybe<Scalars['String']['output']>;
  /** The name of the recommended SLI. */
  name?: Maybe<Scalars['String']['output']>;
  /** The template of the NRQL queries that define how is calculated the SLI. */
  queryTemplates?: Maybe<ServiceLevelQueryTemplates>;
};

/** The response containing the result of the creation of recommended indicators. */
export type ServiceLevelRecommendedIndicatorsCreationResult = {
  __typename?: 'ServiceLevelRecommendedIndicatorsCreationResult';
  /** The failures during the creation of the SLIs. */
  failures?: Maybe<Array<Maybe<ServiceLevelFailure>>>;
  /** The SLIs created with success. */
  successes?: Maybe<Array<Maybe<ServiceLevelIndicator>>>;
};

/** A recommended SLO for the SLI. */
export type ServiceLevelRecommendedObjective = {
  __typename?: 'ServiceLevelRecommendedObjective';
  /** The limits of the target and the default value to fall back if it cannot be computed successfully */
  computedTargetLimits?: Maybe<ServiceLevelComputedValueLimits>;
  /** The recommended target percentage of the SLO. */
  target?: Maybe<Scalars['Float']['output']>;
  /** The query that defines how to calculate the recommended target of SLO. */
  targetQuery?: Maybe<Scalars['Nrql']['output']>;
};

/** A resulting query. */
export type ServiceLevelResultQuery = {
  __typename?: 'ServiceLevelResultQuery';
  /** A NRQL query. */
  nrql: Scalars['Nrql']['output'];
};

/** The Service Level Indicator source */
export enum ServiceLevelServiceLevelSource {
  /** SLI created from the advanced UI flow. */
  Custom = 'CUSTOM',
  /** SLI created from recommended queries with different query parameters. */
  RecommendedEdited = 'RECOMMENDED_EDITED',
  /** SLI created from recommended queries with the same query parameters. */
  RecommendedRaw = 'RECOMMENDED_RAW'
}

/** The details of the parameters to be replaced in the query templates. */
export type ServiceLevelTemplateParameters = {
  __typename?: 'ServiceLevelTemplateParameters';
  /** The limits of the baseline and the default value to fall back if it cannot be computed successfully */
  computedBaselineLimits?: Maybe<ServiceLevelComputedValueLimits>;
  /** The description of the parameter. */
  description?: Maybe<Scalars['String']['output']>;
  /** The key to be replaced in a query template. */
  key: Scalars['String']['output'];
  /** The name of the parameter. */
  name?: Maybe<Scalars['String']['output']>;
  /** The operator of the parameter. */
  operator?: Maybe<Scalars['String']['output']>;
  /** The query that defines how the value should be calculated. */
  query: Scalars['Nrql']['output'];
  /** The unit of the parameter. */
  unit?: Maybe<Scalars['String']['output']>;
};

/** A way of stitching into the existing account schema type oject on NerdGraph */
export type SignupIntegrationsAccountStitchedFields = {
  __typename?: 'SignupIntegrationsAccountStitchedFields';
  /** List of signup integration accounts */
  integrationAccounts?: Maybe<Array<SignupIntegrationsIntegrationAccount>>;
};

/** Result of creating promotions in bulk */
export type SignupIntegrationsBulkCreatePromoCodesResult = {
  __typename?: 'SignupIntegrationsBulkCreatePromoCodesResult';
  /** Details of the promotions created */
  promotions?: Maybe<Array<SignupIntegrationsPromotion>>;
};

/** Integration results and validity information */
export type SignupIntegrationsIntegrationAccount = {
  __typename?: 'SignupIntegrationsIntegrationAccount';
  /** New Relic account ID associated with the integration */
  accountId?: Maybe<Scalars['Int']['output']>;
  /** ID of the integration */
  integrationId: Scalars['String']['output'];
  /** UUID of the integration process */
  integrationUuid: Scalars['String']['output'];
  /** Describes validation state */
  validationResult?: Maybe<SignupIntegrationsValidationResult>;
};

/** A promotion */
export type SignupIntegrationsPromotion = {
  __typename?: 'SignupIntegrationsPromotion';
  /** asdf */
  appliedTo?: Maybe<Scalars['Int']['output']>;
  /** asdf */
  createdAt?: Maybe<Scalars['DateTime']['output']>;
  /** asdf */
  expiresOn?: Maybe<Scalars['DateTime']['output']>;
  /** asdf */
  id?: Maybe<Scalars['Int']['output']>;
  /** asdf */
  integrationId?: Maybe<Scalars['String']['output']>;
  /** asdf */
  issuedOn?: Maybe<Scalars['DateTime']['output']>;
  /** asdf */
  modalBody?: Maybe<Scalars['String']['output']>;
  /** asdf */
  modalTitle?: Maybe<Scalars['String']['output']>;
  /** asdf */
  nagBody?: Maybe<Scalars['String']['output']>;
  /** asdf */
  promoCode?: Maybe<Scalars['String']['output']>;
  /** asdf */
  promoKey?: Maybe<Scalars['String']['output']>;
  /** asdf */
  reusable?: Maybe<Scalars['Boolean']['output']>;
  /** asdf */
  updatedAt?: Maybe<Scalars['DateTime']['output']>;
  /** asdf */
  urlForInvalid?: Maybe<Scalars['String']['output']>;
  /** asdf */
  urlForValid?: Maybe<Scalars['String']['output']>;
};

/** Specifies if valid */
export enum SignupIntegrationsValidationResult {
  /** Specifies that the promo code is invalid */
  Invalid = 'INVALID',
  /** Specifies that the promo code is valid */
  Valid = 'VALID'
}

/** The `SortBy` enum is for designating sort order. */
export enum SortBy {
  /** Sort in ascending order. */
  Asc = 'ASC',
  /** Sort in descending order. */
  Desc = 'DESC'
}

/** Possible entity sorting criterion with direction */
export type SortCriterionWithDirection = {
  /** Sort entities by attribute. Mutally exclusive with the `tag` argument */
  attribute?: InputMaybe<EntitySearchSortCriteria>;
  /** The direction to sort results */
  direction?: InputMaybe<SortBy>;
  /** Sort entities by tag. Mutally exclusive with the `attribute` argument */
  tag?: InputMaybe<Scalars['String']['input']>;
};

/** A structured representation of an exception for an APM application. */
export type StackTraceApmException = {
  __typename?: 'StackTraceApmException';
  /** The top level message associated with the exception. */
  message?: Maybe<Scalars['String']['output']>;
  /** The stack trace associated with the exception. */
  stackTrace?: Maybe<StackTraceApmStackTrace>;
};

/** A structured representation of a stack trace for an APM application. */
export type StackTraceApmStackTrace = {
  __typename?: 'StackTraceApmStackTrace';
  /** Stack trace frames. */
  frames?: Maybe<Array<Maybe<StackTraceApmStackTraceFrame>>>;
};

/** An object representing a stack trace segment */
export type StackTraceApmStackTraceFrame = {
  __typename?: 'StackTraceApmStackTraceFrame';
  /** Frame filepath */
  filepath?: Maybe<Scalars['String']['output']>;
  /** Formatted frame */
  formatted: Scalars['String']['output'];
  /** Frame line number */
  line?: Maybe<Scalars['Int']['output']>;
  /** Frame name */
  name?: Maybe<Scalars['String']['output']>;
};

/** A structured representation of an exception for a Browser application. */
export type StackTraceBrowserException = {
  __typename?: 'StackTraceBrowserException';
  /** The top level message associated to the stack trace. */
  message?: Maybe<Scalars['String']['output']>;
  /** The stack trace associated with the exception. */
  stackTrace?: Maybe<StackTraceBrowserStackTrace>;
};

/** A structured representation of a stack trace for a Browser application. */
export type StackTraceBrowserStackTrace = {
  __typename?: 'StackTraceBrowserStackTrace';
  /** Stack trace frames. */
  frames?: Maybe<Array<Maybe<StackTraceBrowserStackTraceFrame>>>;
};

/** An object representing a stack trace segment */
export type StackTraceBrowserStackTraceFrame = {
  __typename?: 'StackTraceBrowserStackTraceFrame';
  /** Frame column number */
  column?: Maybe<Scalars['Int']['output']>;
  /** Formatted frame */
  formatted: Scalars['String']['output'];
  /** Frame line number */
  line?: Maybe<Scalars['Int']['output']>;
  /** Frame name */
  name?: Maybe<Scalars['String']['output']>;
};

/** A structured representation of a crash occurring in a mobile application. */
export type StackTraceMobileCrash = {
  __typename?: 'StackTraceMobileCrash';
  /** A structured representation of a stack trace for a crash that occurs on a mobile application. */
  stackTrace?: Maybe<StackTraceMobileCrashStackTrace>;
};

/** A structured representation of a stack trace of a crash in a mobile application. */
export type StackTraceMobileCrashStackTrace = {
  __typename?: 'StackTraceMobileCrashStackTrace';
  /** Stack trace frames. */
  frames?: Maybe<Array<Maybe<StackTraceMobileCrashStackTraceFrame>>>;
};

/** An object representing a stack trace segment */
export type StackTraceMobileCrashStackTraceFrame = {
  __typename?: 'StackTraceMobileCrashStackTraceFrame';
  /** Frame filepath */
  filepath?: Maybe<Scalars['String']['output']>;
  /** Formatted frame */
  formatted: Scalars['String']['output'];
  /** Frame line number */
  line?: Maybe<Scalars['Int']['output']>;
  /** Frame name */
  name?: Maybe<Scalars['String']['output']>;
};

/** A structured representation of a handled exception occurring in a mobile application. */
export type StackTraceMobileException = {
  __typename?: 'StackTraceMobileException';
  /** A structured representation of a handled exception in a mobile application. */
  stackTrace?: Maybe<StackTraceMobileExceptionStackTrace>;
};

/** A structured representation of a handled exception in a mobile application. */
export type StackTraceMobileExceptionStackTrace = {
  __typename?: 'StackTraceMobileExceptionStackTrace';
  /** Stack trace frames. */
  frames?: Maybe<Array<Maybe<StackTraceMobileExceptionStackTraceFrame>>>;
};

/** An object representing a stack trace segment */
export type StackTraceMobileExceptionStackTraceFrame = {
  __typename?: 'StackTraceMobileExceptionStackTraceFrame';
  /** Frame filepath */
  filepath?: Maybe<Scalars['String']['output']>;
  /** Formatted frame */
  formatted: Scalars['String']['output'];
  /** Frame line number */
  line?: Maybe<Scalars['Int']['output']>;
  /** Frame name */
  name?: Maybe<Scalars['String']['output']>;
};

export type StreamingExportAccountStitchedFields = {
  __typename?: 'StreamingExportAccountStitchedFields';
  /** Get the information for a specific streaming rule */
  streamingRule?: Maybe<StreamingExportRule>;
  /** List the streaming rules for the given account */
  streamingRules?: Maybe<Array<Maybe<StreamingExportRule>>>;
};


export type StreamingExportAccountStitchedFieldsStreamingRuleArgs = {
  id: Scalars['ID']['input'];
};

/** AWS details about a streaming rule */
export type StreamingExportAwsDetails = {
  __typename?: 'StreamingExportAwsDetails';
  /** The AWS account to which the target firehose belongs */
  awsAccountId: Scalars['ID']['output'];
  /** The name of the delivery stream to write events to */
  deliveryStreamName: Scalars['String']['output'];
  /** The AWS region the delivery stream is located in */
  region: Scalars['String']['output'];
  /** The role configured for New Relic to assume */
  role: Scalars['String']['output'];
};

/** AWS input parameters for a new streaming rule */
export type StreamingExportAwsInput = {
  /** The AWS account to which the target firehose belongs */
  awsAccountId: Scalars['ID']['input'];
  /** The name of the delivery stream to write events to */
  deliveryStreamName: Scalars['String']['input'];
  /** The AWS region the delivery stream is located in */
  region: Scalars['String']['input'];
  /** The role configured for New Relic to assume */
  role: Scalars['String']['input'];
};

/** Azure details about a streaming rule */
export type StreamingExportAzureDetails = {
  __typename?: 'StreamingExportAzureDetails';
  /** Connection string that has access to the specific Event Hub */
  eventHubConnectionString: Scalars['String']['output'];
  /** The name of Event Hub to write events to */
  eventHubName: Scalars['String']['output'];
};

/** Azure input parameters for a new streaming rule */
export type StreamingExportAzureInput = {
  /** Connection string that has access to the specific Event Hub */
  eventHubConnectionString: Scalars['String']['input'];
  /** The name of Event Hub to write events to */
  eventHubName: Scalars['String']['input'];
};

/** Whether Compression is enabled for the export rule, and what compression format is used */
export enum StreamingExportPayloadCompression {
  /** Do not compress payloads for this export rule */
  Disabled = 'DISABLED',
  /** Compress payloads for this export rule using the GZIP compression format */
  Gzip = 'GZIP'
}

/** Details about a streaming rule */
export type StreamingExportRule = {
  __typename?: 'StreamingExportRule';
  /** The account associated to this streaming rule */
  account?: Maybe<AccountReference>;
  /** The AWS information configured for the streaming rule */
  aws?: Maybe<StreamingExportAwsDetails>;
  /** The Azure information configured for the streaming rule */
  azure?: Maybe<StreamingExportAzureDetails>;
  /** The time at which the process of creating the streaming rule began */
  createdAt: Scalars['EpochMilliseconds']['output'];
  /** Additional information about the streaming rule */
  description?: Maybe<Scalars['String']['output']>;
  /** The rule ID for this streaming rule */
  id: Scalars['ID']['output'];
  /** A message returned by the latest API call */
  message?: Maybe<Scalars['String']['output']>;
  /** The name of this streaming rule */
  name: Scalars['String']['output'];
  /** NRQL used to select data to be exported */
  nrql?: Maybe<Scalars['Nrql']['output']>;
  /** Whether or not to compress payloads before exporting them, and what compression format to use if so */
  payloadCompression?: Maybe<StreamingExportPayloadCompression>;
  /** The state of this streaming rule */
  status: StreamingExportStatus;
  /** The last time the status of the streaming rule was updated */
  updatedAt: Scalars['EpochMilliseconds']['output'];
};

/** The input parameters for a new streaming rule */
export type StreamingExportRuleInput = {
  /** Additional information about the rule */
  description?: InputMaybe<Scalars['String']['input']>;
  /** The name of this export rule */
  name: Scalars['String']['input'];
  /** NRQL to select the telemetry data to export */
  nrql: Scalars['Nrql']['input'];
  /** Whether to compress payloads before sending them out, and what compression format to use if enabled */
  payloadCompression?: InputMaybe<StreamingExportPayloadCompression>;
};

/** Set of streaming rules states */
export enum StreamingExportStatus {
  /** Status set for a streaming rule that could not be created due to an error */
  CreationFailed = 'CREATION_FAILED',
  /** Status set for a streaming rule being set up */
  CreationInProgress = 'CREATION_IN_PROGRESS',
  /** Status set for a streaming rule when it is deleted */
  Deleted = 'DELETED',
  /** Status set for a streaming rule when it is disabled */
  Disabled = 'DISABLED',
  /** Status set for a streaming rule when it is enabled */
  Enabled = 'ENABLED'
}

export type SubscriptionEntitlement = {
  __typename?: 'SubscriptionEntitlement';
  attributes?: Maybe<Array<Maybe<EntitlementAttribute>>>;
  name?: Maybe<Scalars['String']['output']>;
};

/**
 * A query suggestion based on analysis of events within a specific anomalous time
 * range vs. nearby events outside of that time range.
 */
export type SuggestedAnomalyBasedNrqlQuery = SuggestedNrqlQuery & {
  __typename?: 'SuggestedAnomalyBasedNrqlQuery';
  /** Information about the anomaly upon which this suggestion is based */
  anomaly: SuggestedNrqlQueryAnomaly;
  /** Meta information about the suggested query. */
  metadata: SuggestedNrqlQueryMetadata;
  /** The NRQL string to run for the suggested query */
  nrql: Scalars['String']['output'];
  /**
   * Indicates whether the suggested query reflects a relationship between entities.
   *
   * Examples: Database call times or service-to-service call times.
   */
  relatedComponent?: Maybe<SuggestedNrqlQueryRelatedComponentType>;
  /** A human-readable title describing what the query shows */
  title: Scalars['String']['output'];
};

/** A query suggestion based on historical query patterns. */
export type SuggestedHistoryBasedNrqlQuery = SuggestedNrqlQuery & {
  __typename?: 'SuggestedHistoryBasedNrqlQuery';
  /** Meta information about the suggested query. */
  metadata: SuggestedNrqlQueryMetadata;
  /** The NRQL string to run for the suggested query */
  nrql: Scalars['String']['output'];
  /**
   * Indicates whether the suggested query reflects a relationship between entities.
   *
   * Examples: Database call times or service-to-service call times.
   */
  relatedComponent?: Maybe<SuggestedNrqlQueryRelatedComponentType>;
  /** A human-readable title describing what the query shows */
  title: Scalars['String']['output'];
};

/** Interface type representing a query suggestion. */
export type SuggestedNrqlQuery = {
  /**
   * The suggested query decomposed into its constituent parts for introspection.
   * Use the query metadata to determine the query's event types, aggregator functions,
   * time range, and more.
   *
   * If the suggested query contains a FACET clause, the metadata contains the names
   * of the attributes used.
   *
   * If the suggested query contains a TIMESERIES clause, the metadata contains the
   * aggregation window size. If it also uses a sliding window (SLIDE BY), the metadata
   * contains the aggregation window step size.
   */
  metadata: SuggestedNrqlQueryMetadata;
  /** The NRQL string to run for the suggested query */
  nrql: Scalars['String']['output'];
  /**
   * Indicates whether the suggested query reflects a relationship between entities.
   *
   * Examples: Database call times or service-to-service call times.
   */
  relatedComponent?: Maybe<SuggestedNrqlQueryRelatedComponentType>;
  /** A human-readable title describing what the query shows */
  title: Scalars['String']['output'];
};

/** Information about the anomaly upon which this analysis was based. */
export type SuggestedNrqlQueryAnomaly = {
  __typename?: 'SuggestedNrqlQueryAnomaly';
  /** The approximate time window of the anomalous region */
  timeWindow: TimeWindow;
};

/** Categorizes the results of a suggested query as matching one of the golden signals. */
export enum SuggestedNrqlQueryGoldenSignal {
  /**
   * The results of a suggested query represent the failure rate of one or more operations.
   *
   * Example: The number of HTTP requests resulting in a 5xx response code.
   */
  Errors = 'ERRORS',
  /**
   * The results of a suggested query represent the time taken to perform an operation.
   *
   * Examples: The time spent servicing an HTTP request, the time spent executing a query against a database.
   */
  Latency = 'LATENCY',
  /**
   * The results of a suggested query represent the load on a resource with finite capacity.
   *
   * Examples: CPU utilization, the number of HTTP requests waiting to be serviced (request queueing).
   */
  Saturation = 'SATURATION',
  /**
   * The results of a suggested query represent the rate one or more operations were executed.
   *
   * Example: The number of HTTP requests completed by a service.
   */
  Traffic = 'TRAFFIC'
}

/**
 * Meta information about the structure of a suggested NRQL query. This meta information
 * decomposes the NRQL query into a base query, a time range, and one or more enhancements
 * to the base query to highlight when something changed (TIMESERIES), or what changed
 * (FACET).
 *
 * The base query defines the data set of interest using the SELECT, FROM, and WHERE clauses.
 * The time range is taken from the input NRQL query. Finally, the query enhancements highlight
 * what makes the data interesting using the FACET, TIMESERIES, SLIDE BY, and LIMIT clauses.
 *
 * Use NRQL query metadata to remix suggested NRQL queries into a new queries. For example,
 * by changing the time window to zoom in or out, adding or removing facets,
 */
export type SuggestedNrqlQueryMetadata = {
  __typename?: 'SuggestedNrqlQueryMetadata';
  /**
   * Excludes any SINCE, UNTIL, FACET, TIMESERIES, SLIDE BY, or LIMIT clauses that may
   * be present in the suggested query. Use this to remix the suggestion into new queries.
   */
  baseNrql: Scalars['Nrql']['output'];
  /** Meta information about each expression in the SELECT clause of the suggested query. */
  content: Array<SuggestedNrqlQueryProjection>;
  /** The event types in the FROM clause of the suggested query. */
  eventTypes: Array<Scalars['String']['output']>;
  /**
   * If the suggested query has a FACET clause, contains the names of the attributes used.
   * Otherwise, this will be null.
   */
  facets?: Maybe<Array<Scalars['String']['output']>>;
  /**
   * Indicates which category of golden signal the suggested query best matches, if any.
   * The value will be null when a best match could not be determined.
   */
  goldenSignal?: Maybe<SuggestedNrqlQueryGoldenSignal>;
  /**
   * If the suggested query has a LIMIT clause, contains a NRQL expression specifying the
   * maximum number of facets to return.
   *
   * Does not include the LIMIT keyword.
   *
   * Examples: `100`, `MAX`.
   */
  limit?: Maybe<Scalars['Nrql']['output']>;
  /**
   * If the suggested query has a SLIDE BY clause, contains a NRQL expression for
   * the aggregation window step size. Otherwise, the value will be null. Does not
   * include the SLIDE BY keywords.
   *
   * When this field is non-null, the `timeSeries` field will also be non-null.
   *
   * Examples: `1 minute`, `MAX`, or `AUTO`.
   */
  slideBy?: Maybe<Scalars['Nrql']['output']>;
  /**
   * If the suggested query has a TIMESERIES clause, contains a NRQL expression for
   * the aggregation window size. Otherwise, the value will be null. Does not include the
   * TIMESERIES keyword.
   *
   * When this field is null, the `slideBy` field will also be null.
   *
   * A TIMESERIES clause will be suggested to highlight points in time where (change points).
   *
   * Examples: `1 minute`, `MAX`, or `AUTO`.
   */
  timeSeries?: Maybe<Scalars['Nrql']['output']>;
  /** The time range of the suggested query. */
  timeWindow: TimeWindow;
};

/** Meta information about an expression within the SELECT clause of a suggested NRQL query. */
export type SuggestedNrqlQueryProjection = {
  __typename?: 'SuggestedNrqlQueryProjection';
  /** The NRQL aggregator function used. */
  aggregateFunction: Scalars['String']['output'];
  /** A NRQL expression containing an aggregator function. */
  expression: Scalars['Nrql']['output'];
  /** A short description of the results produced by `expression` suitable for use in a chart. */
  label?: Maybe<Scalars['String']['output']>;
};

/** Indicates whether a suggested query reflects a relationship between entities. */
export enum SuggestedNrqlQueryRelatedComponentType {
  /** The suggested query reflects a "calls" relationship between a service entity and a database. */
  Database = 'DATABASE',
  /** The suggested query reflects a "calls" relationship between entities. */
  DownstreamService = 'DOWNSTREAM_SERVICE',
  /** The suggested query reflects a "called-by" relationship between entities. */
  UpstreamService = 'UPSTREAM_SERVICE'
}

/** A result type encapsulating suggested queries */
export type SuggestedNrqlQueryResponse = {
  __typename?: 'SuggestedNrqlQueryResponse';
  /** List of suggested queries. */
  suggestions?: Maybe<Array<SuggestedNrqlQuery>>;
};

export enum SummaryUnit {
  Apdex = 'APDEX',
  LoadAverage = 'LOAD_AVERAGE',
  Percent = 'PERCENT',
  RequestsPerMinute = 'REQUESTS_PER_MINUTE',
  Seconds = 'SECONDS'
}

export type SummaryValue = {
  __typename?: 'SummaryValue';
  unit?: Maybe<SummaryUnit>;
  value?: Maybe<Scalars['Float']['output']>;
};

export type SupportAccountStitchedFields = {
  __typename?: 'SupportAccountStitchedFields';
  /** The support channels available to an account */
  channels?: Maybe<Array<Maybe<SupportChannel>>>;
  /** Single New Relic Diagnostics Run */
  diagnosticsRun?: Maybe<SupportDiagnosticsRun>;
  /** Results from review of logs gathered from a specified run of the Diagnostics CLI */
  diagnosticsRunLogReview?: Maybe<SupportDiagnosticsRunLogReviewResponse>;
  /** New Relic Diagnostics Runs for the Account */
  diagnosticsRuns?: Maybe<Array<Maybe<SupportDiagnosticsItem>>>;
  /** Run a staging query using the Diagnostics Query Service */
  diagnosticsStagingQuery?: Maybe<SupportDiagnosticsStagingQuery>;
  /** New Relic Diagnostics Run Zip Link */
  diagnosticsZip?: Maybe<SupportDiagnosticsItem>;
  /** The phone numbers available to an account */
  phoneNumbers?: Maybe<Array<Maybe<SupportPhoneNumber>>>;
  /**
   * Run a staging query
   * @deprecated This has been renamed to diagnosticsStagingQuery
   */
  stagingQuery?: Maybe<SupportStagingQuery>;
  /** The paginated support tickets associated with a user scoped to an account */
  ticketSearch?: Maybe<SupportTicketsResult>;
  /** The support tier of the account */
  tier?: Maybe<Scalars['String']['output']>;
};


export type SupportAccountStitchedFieldsDiagnosticsRunArgs = {
  fileId: Scalars['String']['input'];
  fileName: Scalars['String']['input'];
};


export type SupportAccountStitchedFieldsDiagnosticsRunLogReviewArgs = {
  runId: Scalars['ID']['input'];
};


export type SupportAccountStitchedFieldsDiagnosticsRunsArgs = {
  fileDate?: InputMaybe<Scalars['String']['input']>;
  fileType?: InputMaybe<SupportFileType>;
};


export type SupportAccountStitchedFieldsDiagnosticsStagingQueryArgs = {
  beginTime?: InputMaybe<Scalars['EpochMilliseconds']['input']>;
  duration?: InputMaybe<Scalars['Seconds']['input']>;
  endTime?: InputMaybe<Scalars['EpochMilliseconds']['input']>;
  filters?: InputMaybe<Array<InputMaybe<SupportDiagnosticsQueryFilter>>>;
  id: Scalars['ID']['input'];
};


export type SupportAccountStitchedFieldsDiagnosticsZipArgs = {
  fileDate?: InputMaybe<Scalars['String']['input']>;
};


export type SupportAccountStitchedFieldsStagingQueryArgs = {
  beginTime?: InputMaybe<Scalars['Float']['input']>;
  duration?: InputMaybe<Scalars['Seconds']['input']>;
  endTime?: InputMaybe<Scalars['Float']['input']>;
  filters?: InputMaybe<Array<InputMaybe<SupportStagingQueryFilter>>>;
  queryId: Scalars['Int']['input'];
};


export type SupportAccountStitchedFieldsTicketSearchArgs = {
  criteria: SupportTicketSearchCriteria;
};

export type SupportActorStitchedFields = {
  __typename?: 'SupportActorStitchedFields';
  /** The paginated support cases associated with a user */
  caseSearch?: Maybe<SupportCasesResult>;
  /** Get Search Terms used for filtering New Relic Diagnostics Run log data */
  diagnosticsLogSearchTerms?: Maybe<SupportDiagnosticsLogSearchTermsResponse>;
  /** Get one or more Nerdgraph queries from the Diagnostics Query Service */
  diagnosticsNerdgraphQueries?: Maybe<SupportDiagnosticsNerdgraphQueryResponse>;
  /** Get one or more NRQL queries from the Diagnostics Query Service */
  diagnosticsNrqlQueries?: Maybe<SupportDiagnosticsQueryResponse>;
  /** A list of available support based feature categories */
  featureContexts?: Maybe<Array<Maybe<SupportFeatureContext>>>;
  /** Guided Diagnostics All Categories */
  guidedDiagnosticsCategories?: Maybe<Array<Maybe<SupportGuidedDiagnosticsCategory>>>;
  /** Guided Diagnostics Category by ID */
  guidedDiagnosticsCategory?: Maybe<SupportGuidedDiagnosticsCategory>;
  /** Guided Diagnostics Edge by root and target */
  guidedDiagnosticsEdge?: Maybe<SupportGuidedDiagnosticsEdge>;
  /** Guided Diagnostics Edges, all returned if no root specified */
  guidedDiagnosticsEdges?: Maybe<Array<Maybe<SupportGuidedDiagnosticsEdge>>>;
  /** Guided Diagnostics Framework by ID and revision */
  guidedDiagnosticsFramework?: Maybe<SupportGuidedDiagnosticsFramework>;
  /** Guided Diagnostics All Frameworks */
  guidedDiagnosticsFrameworks?: Maybe<Array<Maybe<SupportGuidedDiagnosticsFramework>>>;
  /** Guided Diagnostics Nodes, gets the neighbors of the specified ID */
  guidedDiagnosticsNeighbors?: Maybe<Array<Maybe<SupportGuidedDiagnosticsNode>>>;
  /** Guided Diagnostics Node by ID */
  guidedDiagnosticsNode?: Maybe<SupportGuidedDiagnosticsNode>;
  /** A specific support ticket associated with a user */
  ticket?: Maybe<SupportTicketDetail>;
  /** The paginated support tickets associated with a user */
  ticketSearch?: Maybe<SupportTicketsResult>;
};


export type SupportActorStitchedFieldsCaseSearchArgs = {
  criteria: SupportCaseSearchCriteria;
};


export type SupportActorStitchedFieldsDiagnosticsNerdgraphQueriesArgs = {
  id?: InputMaybe<Scalars['ID']['input']>;
};


export type SupportActorStitchedFieldsDiagnosticsNrqlQueriesArgs = {
  filters?: InputMaybe<Array<InputMaybe<SupportDiagnosticsQueryFilter>>>;
  id?: InputMaybe<Scalars['ID']['input']>;
};


export type SupportActorStitchedFieldsGuidedDiagnosticsCategoryArgs = {
  categoryId: Scalars['ID']['input'];
};


export type SupportActorStitchedFieldsGuidedDiagnosticsEdgeArgs = {
  root: Scalars['ID']['input'];
  target: Scalars['ID']['input'];
};


export type SupportActorStitchedFieldsGuidedDiagnosticsEdgesArgs = {
  root?: InputMaybe<Scalars['ID']['input']>;
};


export type SupportActorStitchedFieldsGuidedDiagnosticsFrameworkArgs = {
  frameworkId: Scalars['ID']['input'];
  revision?: InputMaybe<Scalars['Int']['input']>;
};


export type SupportActorStitchedFieldsGuidedDiagnosticsFrameworksArgs = {
  includeRevisions?: InputMaybe<Scalars['Boolean']['input']>;
  state?: InputMaybe<SupportStateType>;
};


export type SupportActorStitchedFieldsGuidedDiagnosticsNeighborsArgs = {
  nodeId: Scalars['ID']['input'];
};


export type SupportActorStitchedFieldsGuidedDiagnosticsNodeArgs = {
  nodeId: Scalars['ID']['input'];
};


export type SupportActorStitchedFieldsTicketArgs = {
  id: Scalars['ID']['input'];
};


export type SupportActorStitchedFieldsTicketSearchArgs = {
  criteria: SupportTicketSearchCriteria;
};

/** A support case */
export type SupportCase = {
  __typename?: 'SupportCase';
  /** The RPM accountId associated at case creation */
  accountId: Scalars['Int']['output'];
  /** The case number displayed to the customer */
  caseNumber: Scalars['String']['output'];
  /** The url where an issue can be observed */
  contextUrl?: Maybe<Scalars['String']['output']>;
  /** Date and time of case creation */
  createdAt: Scalars['DateTime']['output'];
  /** The case id */
  id: Scalars['ID']['output'];
  /** Is the case escalated */
  isEscalated: Scalars['Boolean']['output'];
  /** Is the case eligible for escalation */
  isEscalationEligible: Scalars['Boolean']['output'];
  /** Date and time of last public reply */
  latestReplyAt?: Maybe<Scalars['DateTime']['output']>;
  /** The parent case id */
  parentCaseId?: Maybe<Scalars['String']['output']>;
  /** The FeatureContext for the issue */
  productFeature: Scalars['String']['output'];
  /** The email address of the case requester */
  requesterEmail: Scalars['String']['output'];
  /** The severity the issue in the case has on a customer's business operations */
  severity: SupportCaseSeverity;
  /** The status of the case */
  status: SupportCaseStatus;
  /** The title or subject of the support case */
  title: Scalars['String']['output'];
  /** Date and time of last case update */
  updatedAt: Scalars['DateTime']['output'];
};

/** Information about case files associated with the ticket */
export type SupportCaseFile = {
  __typename?: 'SupportCaseFile';
  /** The Salesforce URL where the attachment can be downloaded */
  link?: Maybe<Scalars['String']['output']>;
  /** The file name of the attachment */
  name?: Maybe<Scalars['String']['output']>;
  /** The size of the attachment */
  size?: Maybe<Scalars['Int']['output']>;
  /** The file type of the attachment */
  type?: Maybe<Scalars['String']['output']>;
};

/** The role a user has in a case */
export enum SupportCaseRole {
  /** User is the collaborator of the case */
  Collaborator = 'COLLABORATOR',
  /** User is the requester of the case */
  Requester = 'REQUESTER'
}

/** The parameters used to query for a list of a user's support cases */
export type SupportCaseSearchCriteria = {
  /** The value to access the next page of CaseResult */
  cursor?: InputMaybe<Scalars['String']['input']>;
  /** The role of the user in the cases to be fetched */
  role: SupportCaseRole;
};

/** The severity levels for the issue in the case indicating its impact on a customer's business operations */
export enum SupportCaseSeverity {
  /** Critical means customer's business operations are severely impacted due to New Relic with no available workaround; or there is a critical security issue. */
  Critical = 'CRITICAL',
  /** Issue has high impact on a customer's business operations */
  High = 'HIGH',
  /** Issue has low impact on a customer's business operations */
  Low = 'LOW',
  /** Issue has normal impact on a customer's business operations */
  Normal = 'NORMAL'
}

/** The status of a support case */
export enum SupportCaseStatus {
  /** After being in a solved state, the case no longer has support engagement and is permanently closed. */
  Closed = 'CLOSED',
  /** Case that is engaged with support and is awaiting support engineer response */
  Inprogress = 'INPROGRESS',
  /** Case that has not been assigned to an support engineer or has had support engineer response */
  New = 'NEW',
  /** Case cannot progress until there is engagement with a 3rd-party */
  Onhold = 'ONHOLD',
  /** Case that is engaged with support and is awaiting customer response */
  Pending = 'PENDING',
  /** The issues in the case are presumed resolved and no longer has support engagement, but can be reopened */
  Solved = 'SOLVED'
}

/** A paginated list of support cases */
export type SupportCasesResult = {
  __typename?: 'SupportCasesResult';
  /** List of support cases */
  cases: Array<SupportCase>;
  /** The value to use to get the next page of support cases */
  nextCursor?: Maybe<Scalars['String']['output']>;
  /** The value to use to get the previous page of support cases */
  prevCursor?: Maybe<Scalars['String']['output']>;
  /** The total count of support cases */
  totalCount: Scalars['Int']['output'];
};

/** These fields are used to create a Category */
export type SupportCategoryCreateInput = {
  /** The title of the category */
  categoryTitle: Scalars['String']['input'];
};

/** These fields are used to create a Category */
export type SupportCategoryUpdateInput = {
  /** The title of the category */
  categoryTitle?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the Category to be updated */
  id: Scalars['ID']['input'];
};

/** A channel, like tickets or chat, to offer customer support service */
export type SupportChannel = {
  __typename?: 'SupportChannel';
  /** Category of the support channel */
  category?: Maybe<SupportChannelCategory>;
  /** Status of the support channel */
  status?: Maybe<SupportChannelStatus>;
  /** Type of the support channel */
  type?: Maybe<SupportChannelType>;
};

/** Categories of channels available to users */
export enum SupportChannelCategory {
  /** Channels shown to everyone */
  Basic = 'BASIC',
  /** Additional direct channels for Critical issues */
  Critical = 'CRITICAL',
  /** Channels that offer direct engagement with Support */
  Direct = 'DIRECT'
}

/** Represents an engagement with a support channel */
export type SupportChannelEngagement = {
  /** The type of support channel engagement */
  channelType?: Maybe<SupportChannelType>;
  /** The time at which a support channel was first engaged */
  createdAt?: Maybe<Scalars['DateTime']['output']>;
};

/** Support channel status */
export enum SupportChannelStatus {
  /** The channel is available to its entitled users, but functionality is disabled */
  Disabled = 'DISABLED',
  /** The channel is available to its entitled users */
  Enabled = 'ENABLED'
}

/** Types of support channels */
export enum SupportChannelType {
  /** Type for phone support */
  PhoneListing = 'PHONE_LISTING',
  /** Type for support tickets */
  Tickets = 'TICKETS',
  /** Type for escalating an existing ticket */
  TicketEscalation = 'TICKET_ESCALATION'
}

/** The customer defined status of a support ticket */
export enum SupportCustomerDefinedTicketStatus {
  /** Ticket that is engaged with support and is awaiting support engineer response */
  Open = 'OPEN',
  /** The issues in the ticket are presumed resolved and no longer has support engagement, but can be reopened */
  Solved = 'SOLVED'
}

/** Item from List of New Relic Diagnostics Runs */
export type SupportDiagnosticsItem = {
  __typename?: 'SupportDiagnosticsItem';
  /** The attachment UUID */
  fileId?: Maybe<Scalars['String']['output']>;
  /** File name */
  fileName?: Maybe<Scalars['String']['output']>;
  /** File type */
  fileType?: Maybe<SupportFileType>;
  /** File URL */
  fileUrl?: Maybe<Scalars['String']['output']>;
  /** Parsed date (FORMAT: YYYY-MM-DD HH:MM:SS) */
  parsedDate?: Maybe<Scalars['String']['output']>;
};

/** Search Term used to filter logs gathered by the Diagnostics CLI */
export type SupportDiagnosticsLogSearchTerm = {
  __typename?: 'SupportDiagnosticsLogSearchTerm';
  /** The search term's category */
  category?: Maybe<Scalars['String']['output']>;
  /** Documentation to help understand how to troubleshoot matches to this search term */
  docLink?: Maybe<Scalars['String']['output']>;
  /** The ID of the search term */
  id?: Maybe<Scalars['ID']['output']>;
  /** The number of lines after the match to display */
  linesAfter?: Maybe<Scalars['Int']['output']>;
  /** The number of lines before the match to display */
  linesBefore?: Maybe<Scalars['Int']['output']>;
  /** The search term */
  term?: Maybe<Scalars['String']['output']>;
};

/** Provides the list of search terms */
export type SupportDiagnosticsLogSearchTermsResponse = {
  __typename?: 'SupportDiagnosticsLogSearchTermsResponse';
  /** The list of search terms */
  searchTerms?: Maybe<Array<Maybe<SupportDiagnosticsLogSearchTerm>>>;
};

/** Nerdgraph Query for use with New Relic Guided Diagnostics */
export type SupportDiagnosticsNerdgraphQuery = {
  __typename?: 'SupportDiagnosticsNerdgraphQuery';
  /** A description of the query */
  description?: Maybe<Scalars['String']['output']>;
  /** The id of the query */
  id?: Maybe<Scalars['ID']['output']>;
  /** The query */
  query?: Maybe<Scalars['String']['output']>;
  /** The attributes to use as variables */
  variables?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
};

/** The fields used for creating a nerdgraph query */
export type SupportDiagnosticsNerdgraphQueryCreateInput = {
  /** A description of the query */
  description?: InputMaybe<Scalars['String']['input']>;
  /** The query */
  query: Scalars['String']['input'];
  /** The attributes to use as variables */
  variables?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
};

/** Describes the response from the Diagnostics Query Service when creating or modifying a query */
export type SupportDiagnosticsNerdgraphQueryMutationResponse = {
  __typename?: 'SupportDiagnosticsNerdgraphQueryMutationResponse';
  /** The query that was modified */
  nerdgraphQuery?: Maybe<SupportDiagnosticsNerdgraphQuery>;
};

/** Describes the response from the Diagnostics Query Service when listing a nerdgraph query */
export type SupportDiagnosticsNerdgraphQueryResponse = {
  __typename?: 'SupportDiagnosticsNerdgraphQueryResponse';
  /** The list of nerdgraph queries */
  nerdgraphQueries?: Maybe<Array<Maybe<SupportDiagnosticsQueryServiceListResponse>>>;
};

/** NRQL or Staging Query for use with New Relic Guided Diagnostics */
export type SupportDiagnosticsQuery = {
  __typename?: 'SupportDiagnosticsQuery';
  /** The attribute that denotes the customer account */
  accountAttribute?: Maybe<Scalars['String']['output']>;
  /** A description of the query */
  description?: Maybe<Scalars['String']['output']>;
  /** The attributes to use as filters for WHERE and FACET clauses */
  filters?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
  /** The FROM clause of the query */
  from?: Maybe<Scalars['String']['output']>;
  /** The id of the query */
  id?: Maybe<Scalars['ID']['output']>;
  /** The ID of the nested query */
  nestedQueryId?: Maybe<Scalars['ID']['output']>;
  /** The SELECT clause of the query */
  select?: Maybe<Scalars['String']['output']>;
  /** The staging id to query */
  stagingId?: Maybe<Scalars['ID']['output']>;
  /** Does the query use TIMESERIES */
  timeseries?: Maybe<Scalars['Boolean']['output']>;
};

/** The fields used for creating a query */
export type SupportDiagnosticsQueryCreateInput = {
  /** The attribute that denotes the customer account */
  accountAttribute?: InputMaybe<Scalars['String']['input']>;
  /** A description of the query */
  description?: InputMaybe<Scalars['String']['input']>;
  /** The attributes to use as filters for WHERE and FACET clauses */
  filters?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  /** The FROM clause of the query */
  from?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the nested query */
  nestedQueryId?: InputMaybe<Scalars['ID']['input']>;
  /** The SELECT clause of the query */
  select: Scalars['String']['input'];
  /** The staging id to query */
  stagingId?: InputMaybe<Scalars['ID']['input']>;
  /** Does the query use TIMESERIES */
  timeseries: Scalars['Boolean']['input'];
};

/** The response from the Diagnostics Query Service when deleting a query */
export type SupportDiagnosticsQueryDeleteResponse = {
  __typename?: 'SupportDiagnosticsQueryDeleteResponse';
  /** The ID of the query that was deleted */
  id?: Maybe<Scalars['ID']['output']>;
};

/** Filters to apply to the query */
export type SupportDiagnosticsQueryFilter = {
  /** The name of the attribute to filter against */
  name?: InputMaybe<Scalars['String']['input']>;
  /** The value of the attribute to filter against */
  value?: InputMaybe<Scalars['String']['input']>;
};

/** Describes the response from the Diagnostics Query Service when creating or modifying a query */
export type SupportDiagnosticsQueryMutationResponse = {
  __typename?: 'SupportDiagnosticsQueryMutationResponse';
  /** The query that was modified */
  query?: Maybe<SupportDiagnosticsQuery>;
};

/** Describes the response from the Diagnostics Query Service when listing a query */
export type SupportDiagnosticsQueryResponse = {
  __typename?: 'SupportDiagnosticsQueryResponse';
  /** The list of queries */
  queries?: Maybe<Array<Maybe<SupportDiagnosticsQueryServiceListResponse>>>;
};

/** The response from the Diagnostics Query Service when listing a query */
export type SupportDiagnosticsQueryServiceListResponse = {
  __typename?: 'SupportDiagnosticsQueryServiceListResponse';
  /** The ID of the query */
  id?: Maybe<Scalars['ID']['output']>;
  /** The query */
  query?: Maybe<Scalars['String']['output']>;
  /** The variables available for the query */
  variables?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
};

/** Details from a New Relic Diagnostic run */
export type SupportDiagnosticsRun = {
  __typename?: 'SupportDiagnosticsRun';
  /** Run contents */
  data?: Maybe<Scalars['String']['output']>;
};

/** Review result from a log */
export type SupportDiagnosticsRunLogReviewItem = {
  __typename?: 'SupportDiagnosticsRunLogReviewItem';
  /** Search term category */
  category?: Maybe<Scalars['String']['output']>;
  /** Documentation link */
  docLink?: Maybe<Scalars['String']['output']>;
  /** Log Filename */
  filename?: Maybe<Scalars['String']['output']>;
  /** Log line that matched the search term */
  lineMatched?: Maybe<Scalars['String']['output']>;
  /** Line number */
  lineNumber?: Maybe<Scalars['Int']['output']>;
  /** Log lines after the match */
  linesAfter?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
  /** Log lines preceeding the match */
  linesBefore?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
  /** Log lines */
  logLines?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
  /** Search term that was matched */
  termMatched?: Maybe<Scalars['String']['output']>;
};

/** Log file metadata */
export type SupportDiagnosticsRunLogReviewMetadata = {
  __typename?: 'SupportDiagnosticsRunLogReviewMetadata';
  /** Log Filename */
  filename?: Maybe<Scalars['String']['output']>;
  /** Review status */
  status?: Maybe<SupportLogReviewStatus>;
};

/** Review results from a Diagnostics CLI run */
export type SupportDiagnosticsRunLogReviewResponse = {
  __typename?: 'SupportDiagnosticsRunLogReviewResponse';
  /** The review results */
  logErrors?: Maybe<Array<Maybe<SupportDiagnosticsRunLogReviewItem>>>;
  /** Log file metadata */
  metadata?: Maybe<Array<Maybe<SupportDiagnosticsRunLogReviewMetadata>>>;
};

/** Staging query data for use with New Relic Guided Diagnostics */
export type SupportDiagnosticsStagingQuery = {
  __typename?: 'SupportDiagnosticsStagingQuery';
  /** Results of running the query */
  data?: Maybe<Scalars['String']['output']>;
  /** The filters for the data that are returned from the query */
  filterData?: Maybe<Array<Maybe<SupportFilterData>>>;
  /** The type of data that is returned from the query */
  type?: Maybe<Scalars['String']['output']>;
};

/** These fields are used to create an Edge */
export type SupportEdgeCreateInput = {
  /** The relationship text */
  relationship: Scalars['String']['input'];
  /** The root node id */
  root: Scalars['ID']['input'];
  /** The target node id */
  target: Scalars['ID']['input'];
};

/** These fields are used to delete an Edge */
export type SupportEdgeDeleteInput = {
  /** The starting node of the edge to be deleted */
  root: Scalars['ID']['input'];
  /** The connecting node of the edge to be deleted */
  target: Scalars['ID']['input'];
};

/** Represents an engagement with the Ticket Escalation channel */
export type SupportEscalationEngagement = SupportChannelEngagement & {
  __typename?: 'SupportEscalationEngagement';
  /** The type of support channel engagement */
  channelType?: Maybe<SupportChannelType>;
  /** The time at which a support channel was first engaged */
  createdAt?: Maybe<Scalars['DateTime']['output']>;
};

/** The support based feature category an issue is scoped to */
export type SupportFeatureContext = {
  __typename?: 'SupportFeatureContext';
  /** The internal identifier for the feature */
  id?: Maybe<Scalars['ID']['output']>;
  /** The customer facing label name of the feature */
  name?: Maybe<Scalars['String']['output']>;
};

/** Valid File Types for Diagnostics */
export enum SupportFileType {
  /** JSON file */
  Json = 'JSON',
  /** ZIP file */
  Zip = 'ZIP'
}

/** The filters for the data that are returned from the query */
export type SupportFilterData = {
  __typename?: 'SupportFilterData';
  /** The name of the filter */
  name?: Maybe<Scalars['String']['output']>;
  /** The values associated with each filter */
  values?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
};

/** These fields are used to create a Framework */
export type SupportFrameworkCreateInput = {
  /** The Category under which the framework lies */
  categoryTitle: Scalars['String']['input'];
  /** The node that the Framework starts on */
  entrypoint: Scalars['ID']['input'];
  /** The ID of the framework. Only use this if creating a revision */
  id?: InputMaybe<Scalars['ID']['input']>;
  /** The inputs used by the framework */
  inputs?: InputMaybe<Array<InputMaybe<SupportFrameworkInputCreateInput>>>;
  /** The react flow object */
  reactFlowObject: Scalars['String']['input'];
  /** Describes what the framework is helping to solve */
  summary: Scalars['String']['input'];
  /** The title of the Framework */
  title: Scalars['String']['input'];
};

/** An input used by a framework */
export type SupportFrameworkInput = {
  __typename?: 'SupportFrameworkInput';
  /** Input description */
  description?: Maybe<Scalars['String']['output']>;
  /** Input fields */
  fields?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
  /** ID of the input */
  id: Scalars['ID']['output'];
  /** Input label */
  label: Scalars['String']['output'];
  /** Node IDs that use this input */
  nodeIds?: Maybe<Array<Maybe<Scalars['ID']['output']>>>;
  /** UUID of the input */
  uuid: Scalars['ID']['output'];
};

/** An input used by a framework */
export type SupportFrameworkInputCreateInput = {
  /** Input description */
  description?: InputMaybe<Scalars['String']['input']>;
  /** Input fields */
  fields?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  /** Input label */
  label: Scalars['String']['input'];
  /** Node IDs that use this input */
  nodeIds: Array<InputMaybe<Scalars['ID']['input']>>;
  /** UUID of the input */
  uuid: Scalars['ID']['input'];
};

/** Category for use with Guided Diagnostics */
export type SupportGuidedDiagnosticsCategory = {
  __typename?: 'SupportGuidedDiagnosticsCategory';
  /** Category ID */
  id: Scalars['ID']['output'];
  /** Category title */
  title: Scalars['String']['output'];
};

/** The response from Guided Diagnostics from deletion */
export type SupportGuidedDiagnosticsDeleteResponse = {
  __typename?: 'SupportGuidedDiagnosticsDeleteResponse';
  /** The ID of the entity being deleted */
  id?: Maybe<Scalars['ID']['output']>;
};

/** Edge for use with Guided Diagnostics */
export type SupportGuidedDiagnosticsEdge = {
  __typename?: 'SupportGuidedDiagnosticsEdge';
  /** Edge relationship label */
  relationship: Scalars['String']['output'];
  /** Edge root node id */
  root: Scalars['ID']['output'];
  /** Edge target node id */
  target: Scalars['ID']['output'];
};

/** The response from Guided Diagnostics from deletion */
export type SupportGuidedDiagnosticsEdgeDeleteResponse = {
  __typename?: 'SupportGuidedDiagnosticsEdgeDeleteResponse';
  /** Root and target response */
  rootAndTarget: Scalars['String']['output'];
};

/** Framework for use with Guided Diagnostics */
export type SupportGuidedDiagnosticsFramework = {
  __typename?: 'SupportGuidedDiagnosticsFramework';
  /** Framework revision that is active */
  activeRevision: Scalars['Int']['output'];
  /** Category title for framework */
  categoryTitle: Scalars['String']['output'];
  /** The date of creation */
  createdAt: Scalars['DateTime']['output'];
  /** The creator of the framework */
  createdBy: Scalars['String']['output'];
  /** Framework Entrypoint */
  entrypoint: Scalars['ID']['output'];
  /** Framework ID */
  id: Scalars['ID']['output'];
  /** The inputs the framework uses */
  inputs?: Maybe<Array<Maybe<SupportFrameworkInput>>>;
  /** The react flow object */
  reactFlowObject: Scalars['String']['output'];
  /** Framework revision */
  revision: Scalars['Int']['output'];
  /** The state of the framework */
  state: SupportStateType;
  /** Framework summary */
  summary: Scalars['String']['output'];
  /** Framework Title */
  title: Scalars['String']['output'];
  /** The date the framework was last modified */
  updatedAt: Scalars['DateTime']['output'];
  /** The last user to update a framework */
  updatedBy: Scalars['String']['output'];
};

/** Node for use with Guided Diagnostics */
export type SupportGuidedDiagnosticsNode = {
  __typename?: 'SupportGuidedDiagnosticsNode';
  /** The date of creation */
  createdAt: Scalars['DateTime']['output'];
  /** The creator of the node */
  createdBy: Scalars['String']['output'];
  /** Edges for node */
  edges?: Maybe<Array<Maybe<SupportGuidedDiagnosticsEdge>>>;
  /** Node framework link */
  frameworkLink?: Maybe<SupportGuidedDiagnosticsFramework>;
  /** Node ID */
  id: Scalars['ID']['output'];
  /** Node nerdgraph queries */
  nerdgraphQueries?: Maybe<SupportGuidedDiagnosticsQueryNode>;
  /** Node nrql queries */
  nrqlQueries?: Maybe<SupportGuidedDiagnosticsQueryNode>;
  /** Node output link */
  outputLink?: Maybe<Scalars['String']['output']>;
  /** Node output summary */
  outputSummary?: Maybe<Scalars['String']['output']>;
  /** Node output title */
  outputTitle?: Maybe<Scalars['String']['output']>;
  /** Node staging queries */
  stagingQueries?: Maybe<SupportGuidedDiagnosticsQueryNode>;
  /** Node summary */
  summary: Scalars['String']['output'];
  /** Node title */
  title: Scalars['String']['output'];
  /** The date the node was last modified */
  updatedAt: Scalars['DateTime']['output'];
  /** The last user to update a node */
  updatedBy: Scalars['String']['output'];
};

/** The response from the Guided Diagnostics when listing a query */
export type SupportGuidedDiagnosticsQueryNode = {
  __typename?: 'SupportGuidedDiagnosticsQueryNode';
  /** The ID of the query */
  id?: Maybe<Scalars['ID']['output']>;
  /** The query */
  query?: Maybe<Scalars['String']['output']>;
  /** The variables available for the query */
  variables?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
};

/** Contextual information of an issue */
export type SupportIssueContext = {
  /** The identifier of the FeatureContext for the issue */
  featureContextId: Scalars['ID']['input'];
  /** The url where an issue can be observed */
  url?: InputMaybe<Scalars['String']['input']>;
};

/** Valid metadata statuses */
export enum SupportLogReviewStatus {
  /** The log review results are complete */
  Complete = 'COMPLETE',
  /** The log was skipped */
  Skipped = 'SKIPPED',
  /** The log review results are truncated */
  Truncated = 'TRUNCATED'
}

/** Message associated with the ticket */
export type SupportMessage = {
  __typename?: 'SupportMessage';
  /** The text body of the message */
  body?: Maybe<Scalars['String']['output']>;
  /** Date and time of ticket creation */
  createdDate?: Maybe<Scalars['DateTime']['output']>;
  /** The id the message */
  id?: Maybe<Scalars['String']['output']>;
  /** A boolean indicates if message if from Customer or New Relic. */
  isNewRelic?: Maybe<Scalars['Boolean']['output']>;
  /** The url where an issue can be observed */
  link?: Maybe<Scalars['String']['output']>;
  /** Email of message creator */
  messageByEmail?: Maybe<Scalars['String']['output']>;
  /** Name of message creator */
  messageByName?: Maybe<Scalars['String']['output']>;
  /** RPM User ID of message creator */
  messageByRpmUserId?: Maybe<Scalars['String']['output']>;
};

/** These fields are used to create a Node */
export type SupportNodeCreateInput = {
  /** Optional framework this node links to */
  frameworkLink?: InputMaybe<Scalars['ID']['input']>;
  /** The output from Nerdgraph */
  nerdgraphQueries?: InputMaybe<Scalars['ID']['input']>;
  /** The output from Nrql */
  nrqlQueries?: InputMaybe<Scalars['ID']['input']>;
  /** The link in the node's output */
  outputLink?: InputMaybe<Scalars['String']['input']>;
  /** Describes what the node's output is solving */
  outputSummary?: InputMaybe<Scalars['String']['input']>;
  /** The title of the node's output */
  outputTitle?: InputMaybe<Scalars['String']['input']>;
  /** the output from staging */
  stagingQueries?: InputMaybe<Scalars['ID']['input']>;
  /** Describes what the node is solving */
  summary: Scalars['String']['input'];
  /** The title of the node */
  title: Scalars['String']['input'];
};

/** Support Phone Number */
export type SupportPhoneNumber = {
  __typename?: 'SupportPhoneNumber';
  /** Display name */
  name?: Maybe<Scalars['String']['output']>;
  /** Phone number */
  number?: Maybe<Scalars['String']['output']>;
};

/** Describes the severity the issue in the ticket has on a customer's business operations */
export type SupportSeverityContext = {
  __typename?: 'SupportSeverityContext';
  /** Detailed explanation the issue has on a customer's business operations */
  description?: Maybe<Scalars['String']['output']>;
  /** The level of severity the issue has on a customer's business operations */
  level?: Maybe<SupportTicketSeverity>;
  /** The categorical reason for the severity level */
  reason?: Maybe<Scalars['String']['output']>;
};

/** Describes the severity the issue in the ticket has on a customer's business operations */
export type SupportSeverityContextInput = {
  /** Detailed explanation the issue has on a customer's business operations */
  description?: InputMaybe<Scalars['String']['input']>;
  /** The level of severity the issue has on a customer's business operations */
  level?: InputMaybe<SupportTicketSeverity>;
  /** The categorical reason for the severity level */
  reason?: InputMaybe<Scalars['String']['input']>;
};

/** Staging Query for use with New Relic Guided Diagnostics */
export type SupportStagingQuery = {
  __typename?: 'SupportStagingQuery';
  /** Results of running the query */
  data?: Maybe<Scalars['String']['output']>;
  /** The filters for the data that are returned from the query */
  filterData?: Maybe<Array<Maybe<SupportFilterData>>>;
  /** The type of data that is returned from the query */
  type?: Maybe<Scalars['String']['output']>;
};

/** Filters to apply to the query */
export type SupportStagingQueryFilter = {
  /** The name of the attribute to filter against */
  name?: InputMaybe<Scalars['String']['input']>;
  /** The value of the attribute to filter against */
  value?: InputMaybe<Scalars['String']['input']>;
};

/** The state of the Framework */
export enum SupportStateType {
  /** A Framework is still not ready to be used */
  Draft = 'DRAFT',
  /** A Framework is able to be used by customers */
  Published = 'PUBLISHED',
  /** A Framework is ready to be used by NR Admins */
  Qa = 'QA'
}

/** A support ticket */
export type SupportTicket = {
  __typename?: 'SupportTicket';
  /** The RPM accountId associated at ticket creation */
  accountId?: Maybe<Scalars['Int']['output']>;
  /** The key used by New Relic Diagnostics to automatically attach results to a support ticket */
  attachmentKey?: Maybe<Scalars['String']['output']>;
  /** The ticket number displayed to the customer */
  caseNumber: Scalars['String']['output'];
  /** The history of additional channel engagements on the ticket */
  channelEngagements?: Maybe<Array<Maybe<SupportChannelEngagement>>>;
  /** A list of email addresses of the collaborators cc'd to the ticket */
  collaboratorEmails?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
  /** The url where an issue can be observed */
  contextUrl: Scalars['String']['output'];
  /** Date and time of ticket creation */
  createdAt?: Maybe<Scalars['DateTime']['output']>;
  /** The first customer message of the ticket */
  description?: Maybe<Scalars['String']['output']>;
  /** The ticket id */
  id?: Maybe<Scalars['ID']['output']>;
  /** Is the ticket awaiting SLA boolean */
  isAwaitingSla?: Maybe<Scalars['Boolean']['output']>;
  /** Is the ticket eligible for escalation */
  isEscalationEligible?: Maybe<Scalars['Boolean']['output']>;
  /** Is the ticket eligible for follow up case creation */
  isFollowUpEligible?: Maybe<Scalars['Boolean']['output']>;
  /** Latest customer facing reply for ticket */
  latestReply?: Maybe<Scalars['DateTime']['output']>;
  /** The url provided when the case was created */
  originalUrl: Scalars['String']['output'];
  /** The parent ticket id */
  parentCaseId?: Maybe<Scalars['String']['output']>;
  /** The FeatureContext for the issue */
  productFeature?: Maybe<Scalars['String']['output']>;
  /** The email address of the ticket requester */
  requesterEmail?: Maybe<Scalars['String']['output']>;
  /** The severity the issue in the ticket has on a customer's business operations */
  severity?: Maybe<SupportTicketSeverity>;
  /** Describes the severity the issue in the ticket has on a customer's business operations */
  severityContext?: Maybe<SupportSeverityContext>;
  /** The status of the ticket */
  status?: Maybe<SupportTicketStatus>;
  /** The title or subject of the support ticket */
  title?: Maybe<Scalars['String']['output']>;
  /** Date and time of last ticket update */
  updatedAt?: Maybe<Scalars['DateTime']['output']>;
};

/** Represents an Attachment for a Support Ticket */
export type SupportTicketAttachment = {
  __typename?: 'SupportTicketAttachment';
  /** The attachment identifier. This is used to associate a TicketAttachment to a newly created ticket or ticket comment */
  id?: Maybe<Scalars['ID']['output']>;
  /** The URL to upload the file */
  uploadUrl?: Maybe<Scalars['String']['output']>;
};

/** Describes the list of ticket collaborators */
export type SupportTicketCollaboratorsResponse = {
  __typename?: 'SupportTicketCollaboratorsResponse';
  /** The list of email addresses */
  collaboratorEmails?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
};

/** Describes an error that occurred when creating a support ticket */
export type SupportTicketCreateError = {
  __typename?: 'SupportTicketCreateError';
  /** Error message, with further detail on the issue */
  message: Scalars['String']['output'];
  /** Error type that occurred when creating a ticket */
  type: SupportTicketCreateErrorType;
};

/** Enumerates the expected error types when creating a ticket */
export enum SupportTicketCreateErrorType {
  /** Account does not have access to the Tickets support channel */
  NoAccessToTicketSupportChannel = 'NO_ACCESS_TO_TICKET_SUPPORT_CHANNEL',
  /** Ticket was created but there was a problem creating the ticket comment with links to the provided attachments */
  TicketCommentWithAttachmentsLinksFailed = 'TICKET_COMMENT_WITH_ATTACHMENTS_LINKS_FAILED'
}

/** The fields used for creating a support ticket */
export type SupportTicketCreateInput = {
  /** List of attachment identifiers to be associated with the ticket */
  attachments?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;
  /** A list of email addresses of the collaborators to be cc'd to the ticket */
  collaboratorEmails?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  /** A description of the issue for the ticket. This will be the first comment in the ticket */
  description: Scalars['String']['input'];
  /** Information that provides context for the issue */
  issueContext: SupportIssueContext;
  /** The parent case associated with the support ticket */
  parentCaseId?: InputMaybe<Scalars['String']['input']>;
  /** Deprecated! Use 'severityContext' instead. The severity the issue in the ticket has on a customer's business operations */
  severity?: InputMaybe<SupportTicketSeverity>;
  /** Describes the severity the issue in the ticket has on a customer's business operations */
  severityContext?: InputMaybe<SupportSeverityContextInput>;
  /** The customer's timezone */
  timeZone?: InputMaybe<Scalars['String']['input']>;
  /** The title or subject of the support ticket */
  title: Scalars['String']['input'];
};

/** Describes the created ticket and errors that may have occurred in the process */
export type SupportTicketCreateResponse = {
  __typename?: 'SupportTicketCreateResponse';
  /** Errors that may occur when creating a support ticket */
  errors?: Maybe<Array<Maybe<SupportTicketCreateError>>>;
  /** The support ticket created */
  ticket?: Maybe<SupportTicket>;
};

/** A detailed support ticket */
export type SupportTicketDetail = {
  __typename?: 'SupportTicketDetail';
  /** The RPM accountId associated at ticket creation */
  accountId?: Maybe<Scalars['Int']['output']>;
  /** The key used by New Relic Diagnostics to automatically attach results to a support ticket */
  attachmentKey?: Maybe<Scalars['String']['output']>;
  /** List of files associated with the ticket */
  caseFiles?: Maybe<Array<Maybe<SupportCaseFile>>>;
  /** List of messages on the ticket */
  caseMessages?: Maybe<Array<SupportMessage>>;
  /** The ticket number */
  caseNumber: Scalars['String']['output'];
  /** The history of additional channel engagements on the ticket */
  channelEngagements?: Maybe<Array<Maybe<SupportChannelEngagement>>>;
  /** A list of email addresses of the collaborators cc'd to the ticket */
  collaboratorEmails?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
  /** The url where an issue can be observed */
  contextUrl: Scalars['String']['output'];
  /** Date and time of ticket creation */
  createdAt?: Maybe<Scalars['DateTime']['output']>;
  /** The first customer message of the ticket */
  description?: Maybe<Scalars['String']['output']>;
  /** The ticket id */
  id?: Maybe<Scalars['ID']['output']>;
  /** Is the ticket awaiting SLA boolean */
  isAwaitingSla?: Maybe<Scalars['Boolean']['output']>;
  /** Is the ticket eligible for escalation */
  isEscalationEligible?: Maybe<Scalars['Boolean']['output']>;
  /** Is the ticket eligible for follow up case creation */
  isFollowUpEligible?: Maybe<Scalars['Boolean']['output']>;
  /** Latest customer facing reply for ticket */
  latestReply?: Maybe<Scalars['DateTime']['output']>;
  /** The url provided when the case was created */
  originalUrl: Scalars['String']['output'];
  /** The parent ticket id */
  parentCaseId?: Maybe<Scalars['String']['output']>;
  /** The FeatureContext for the issue */
  productFeature?: Maybe<Scalars['String']['output']>;
  /** The email address of the ticket requester */
  requesterEmail?: Maybe<Scalars['String']['output']>;
  /** The severity the issue in the ticket has on a customer's business operations */
  severity?: Maybe<SupportTicketSeverity>;
  /** Describes the severity the issue in the ticket has on a customer's business operations */
  severityContext?: Maybe<SupportSeverityContext>;
  /** The status of the ticket */
  status?: Maybe<SupportTicketStatus>;
  /** The title or subject of the support ticket */
  title?: Maybe<Scalars['String']['output']>;
  /** Date and time of last ticket update */
  updatedAt?: Maybe<Scalars['DateTime']['output']>;
};

/** Describes an error that occurred when creating a support ticket */
export type SupportTicketEscalationError = {
  __typename?: 'SupportTicketEscalationError';
  /** Error message, with further detail on the issue */
  message?: Maybe<Scalars['String']['output']>;
  /** Error type that occurred when escalating a ticket */
  type?: Maybe<SupportTicketEscalationErrorType>;
};

/** Enumerates the expected error types when escalating a ticket */
export enum SupportTicketEscalationErrorType {
  /** Ticket cannot be escalated due to closed state */
  CantEscalateClosedTicket = 'CANT_ESCALATE_CLOSED_TICKET',
  /** User does not have access to the ticket */
  NoAccessToTicket = 'NO_ACCESS_TO_TICKET',
  /** Account does not have access to the ticket escalation support channel */
  NoAccessToTicketEscalationSupportChannel = 'NO_ACCESS_TO_TICKET_ESCALATION_SUPPORT_CHANNEL',
  /** Ticket already escalated */
  TicketAlreadyEscalated = 'TICKET_ALREADY_ESCALATED',
  /** Ticket Escalation is currently disabled */
  TicketEscalationSupportChannelDisabled = 'TICKET_ESCALATION_SUPPORT_CHANNEL_DISABLED',
  /** Ticket is awaiting service agreement fulfillment */
  TicketIsAwaitingSla = 'TICKET_IS_AWAITING_SLA'
}

/** The fields used to create a ticket escalation */
export type SupportTicketEscalationInput = {
  /** Customer's description of availability for phone call */
  callAvailability: Scalars['String']['input'];
  /** The customer's preferred phone number for escalation contact */
  phoneNumber: Scalars['String']['input'];
  /** The customer's reason for ticket escalation */
  reason: Scalars['String']['input'];
  /** The id of the ticket being escalated */
  ticketId: Scalars['ID']['input'];
  /** The customer's timezone */
  timeZoneName: Scalars['String']['input'];
};

/** Describes the escalated ticket and errors that may have occurred in the process */
export type SupportTicketEscalationResponse = {
  __typename?: 'SupportTicketEscalationResponse';
  /** Errors that may occur when creating a ticket escalation */
  errors?: Maybe<Array<Maybe<SupportTicketEscalationError>>>;
  /** The escalated ticket object */
  ticket?: Maybe<SupportTicket>;
};

/** Describes the created ticket message and errors that may have occurred in the process */
export type SupportTicketMessageCreateResponse = {
  __typename?: 'SupportTicketMessageCreateResponse';
  /** The support ticket we created a message for */
  ticket?: Maybe<SupportTicketDetail>;
};

/** The fields used for when creating a message associated with the ticket */
export type SupportTicketMessageInput = {
  /** List of attachment identifiers to be associated with the message */
  attachments?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;
  /** The text body of the message */
  body: Scalars['String']['input'];
  /** The url where an issue can be observed */
  newUrl?: InputMaybe<Scalars['String']['input']>;
  /** The customers selected status for the ticket */
  setCaseStatus?: InputMaybe<SupportCustomerDefinedTicketStatus>;
};

/** The role a user has in a ticket */
export enum SupportTicketRole {
  /** User is cc'd to a ticket */
  Collaborator = 'COLLABORATOR',
  /** User is the requester of the ticket */
  Requester = 'REQUESTER'
}

/** The parameters used to query for a list of a user's support tickets */
export type SupportTicketSearchCriteria = {
  /** The value to access the next page of TicketResult */
  cursor?: InputMaybe<Scalars['String']['input']>;
  /** The role of the user in the tickets to be fetched */
  role: SupportTicketRole;
};

/** The severity levels for the issue in the ticket indicating its impact on a customer's business operations */
export enum SupportTicketSeverity {
  /** Critical means customers business operations are severely impacted due to New Relic with no available workaround; or there is a critical security issue. */
  Critical = 'CRITICAL',
  /** Issue has high impact on a customer's business operations */
  High = 'HIGH',
  /** Issue has low impact on a customer's business operations */
  Low = 'LOW',
  /** Issue has normal impact on a customer's business operations */
  Normal = 'NORMAL'
}

/** The status of a support ticket */
export enum SupportTicketStatus {
  /** After being in a solved state, the ticket no longer has support engagement and is permanently closed. */
  Closed = 'CLOSED',
  /** Ticket cannot progress until there is engagement with a 3rd-party */
  Hold = 'HOLD',
  /** Ticket that has not been assigned to an support engineer or has had support engineer response */
  New = 'NEW',
  /** Ticket that is engaged with support and is awaiting support engineer response */
  Open = 'OPEN',
  /** Ticket that is engaged with support and is awaiting customer response */
  Pending = 'PENDING',
  /** The issues in the ticket are presumed resolved and no longer has support engagement, but can be reopened */
  Solved = 'SOLVED'
}

/** A paginated list of support tickets */
export type SupportTicketsResult = {
  __typename?: 'SupportTicketsResult';
  /** The value to use to get the next page of support tickets */
  nextCursor?: Maybe<Scalars['String']['output']>;
  /** The value to use to get the previous page of support tickets */
  prevCursor?: Maybe<Scalars['String']['output']>;
  /** List of support tickets */
  tickets?: Maybe<Array<Maybe<SupportTicket>>>;
  /** The total count of support tickets */
  totalCount?: Maybe<Scalars['Int']['output']>;
};

/** The result of a synthetic monitor check */
export type SyntheticMonitorCheckResult = {
  __typename?: 'SyntheticMonitorCheckResult';
  /** The synthetic monitor check result id */
  id?: Maybe<Scalars['String']['output']>;
  /** The synthetic monitor check result status */
  status?: Maybe<SyntheticMonitorCheckStatus>;
};

/** The status of a synthetic monitor check. */
export enum SyntheticMonitorCheckStatus {
  /** Failed check */
  Failed = 'FAILED',
  /** Successful check */
  Success = 'SUCCESS'
}

/** A Synthetic Monitor entity. */
export type SyntheticMonitorEntity = AlertableEntity & Entity & {
  __typename?: 'SyntheticMonitorEntity';
  account?: Maybe<AccountOutline>;
  /** The New Relic account ID associated with this entity. */
  accountId?: Maybe<Scalars['Int']['output']>;
  /** The current alerting severity of the entity. */
  alertSeverity?: Maybe<EntityAlertSeverity>;
  /**
   * The alert status of the entity.
   * @deprecated Please use `alertSeverity` and `reporting`
   */
  alertStatus?: Maybe<EntityAlertStatus>;
  /** Violations on the entity that were open during the specified time window. This will return up to 500 violations - if there are more in the time window selected, you must narrow the time window or look at fewer entities. */
  alertViolations?: Maybe<Array<Maybe<EntityAlertViolation>>>;
  /** Assets produced during the execution of the check, such as screenshots */
  assets?: Maybe<Array<Maybe<SyntheticsSyntheticMonitorAsset>>>;
  /** Retrieve the deployment event(s). Ordered by timestamp DESC. */
  deploymentSearch?: Maybe<ChangeTrackingDeploymentSearchResult>;
  /** The entity's domain */
  domain?: Maybe<Scalars['String']['output']>;
  /** A value representing the combination of the entity's domain and type. */
  entityType?: Maybe<EntityType>;
  /** The date of last time the entity has updated any of its fields. */
  firstIndexedAt?: Maybe<Scalars['EpochMilliseconds']['output']>;
  /** The list of golden metrics for a specific entity */
  goldenMetrics?: Maybe<EntityGoldenContextScopedGoldenMetrics>;
  /**
   * For the golden signal on this entity, show correlated signals from related entities.
   * Well inspect the golden signals for all related entities and return a sorted list.
   * You can also filter the results.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  goldenSignalCorrelations?: Maybe<GoldenSignalCorrelationResult>;
  /**
   * The deviation from normal of golden signal(s) for the given entity.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  goldenSignalDeviations?: Maybe<Array<Maybe<GoldenSignalSignalDeviation>>>;
  /**
   * The stored golden signal(s) for the given entity.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  goldenSignalValues?: Maybe<GoldenSignalValues>;
  /**
   * The stored golden signal(s) for the given entity. To be removed, use goldenSignalValues instead.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  goldenSignalValuesV2?: Maybe<GoldenSignalValues>;
  /** The list of golden tags for a specific entityType. */
  goldenTags?: Maybe<EntityGoldenContextScopedGoldenTags>;
  /** A unique entity identifier. */
  guid?: Maybe<Scalars['EntityGuid']['output']>;
  /** The time the entity was indexed. */
  indexedAt?: Maybe<Scalars['EpochMilliseconds']['output']>;
  /** The last time the entity's reporting status changed. */
  lastReportingChangeAt?: Maybe<Scalars['EpochMilliseconds']['output']>;
  /** The Synthetic Monitor ID */
  monitorId?: Maybe<Scalars['ID']['output']>;
  /** Summary statistics for the Synthetic Monitor. */
  monitorSummary?: Maybe<SyntheticMonitorSummaryData>;
  /** The Synthetic Monitor type */
  monitorType?: Maybe<SyntheticMonitorType>;
  /** The URL being monitored by a `SIMPLE` or `BROWSER` monitor type. */
  monitoredUrl?: Maybe<Scalars['String']['output']>;
  /** The name of this entity. */
  name?: Maybe<Scalars['String']['output']>;
  nerdStorage?: Maybe<NerdStorageEntityScope>;
  nerdStoreCollection?: Maybe<Array<Maybe<NerdStoreCollectionMember>>>;
  nerdStoreDocument?: Maybe<Scalars['NerdStoreDocument']['output']>;
  /**
   * Make an `Entity` scoped query to NRDB with a NRQL string.
   *
   * A relevant `WHERE` clause will be added to your query to scope data to the entity in question.
   *
   * See the [NRQL Docs](https://docs.newrelic.com/docs/insights/nrql-new-relic-query-language/nrql-resources/nrql-syntax-components-functions) for more information about generating a query string.
   */
  nrdbQuery?: Maybe<NrdbResultContainer>;
  /**
   * Poll for the results of a previously-executed asychronous NRDB query.
   *
   * The `queryId` is available in the `queryProgress` data returned by the original asynchronous query.
   *
   * See [this page](https://docs.newrelic.com/docs/apis/nerdgraph/examples/async-queries-nrql-tutorial) for additional asynchronous query documentation.
   * @deprecated This field is experimental! It may change at any time.
   *
   */
  nrdbQueryProgress?: Maybe<NrdbResultContainer>;
  /** The duration in minutes between Synthetic Monitor runs. */
  period?: Maybe<Scalars['Minutes']['output']>;
  /** The url to the entity. */
  permalink?: Maybe<Scalars['String']['output']>;
  /** Recent violations on the entity. */
  recentAlertViolations?: Maybe<Array<Maybe<EntityAlertViolation>>>;
  /** The recommended service levels for the entity. */
  recommendedServiceLevel?: Maybe<ServiceLevelRecommendation>;
  /** Related dashboards results */
  relatedDashboards: RelatedDashboardsRelatedDashboardResult;
  /** Related entities result with optional filtering. */
  relatedEntities?: Maybe<EntityRelationshipRelatedEntitiesResult>;
  /** Relationship traversal results with optional filtering. WARNING: this query is still experimental, and subject to breaking changes. */
  relationshipTraversal?: Maybe<EntityRelationshipTraversalResult>;
  /**
   * A list of the entities' relationships.
   *
   * For more information, visit [our docs](https://docs.newrelic.com/docs/apis/graphql-api/tutorials/graphql-relationships-api-tutorial).
   * @deprecated This field is deprecated! Please use `relatedEntities`.
   */
  relationships?: Maybe<Array<Maybe<EntityRelationship>>>;
  /** The reporting status of the entity. If New Relic is successfully collecting data from your application, this will be true. */
  reporting?: Maybe<Scalars['Boolean']['output']>;
  /** The service level defined for the entity. */
  serviceLevel?: Maybe<ServiceLevelDefinition>;
  /** The list of summary metrics. */
  summaryMetrics?: Maybe<Array<Maybe<EntitySummaryMetric>>>;
  /**
   * The tags applied to the entity.
   *
   * For details on tags, as well as query and mutation examples, visit [our docs](https://docs.newrelic.com/docs/apis/graphql-api/tutorials/graphql-tagging-api-tutorial).
   */
  tags?: Maybe<Array<Maybe<EntityTag>>>;
  /** The tags applied to the entity with their metadata. */
  tagsWithMetadata?: Maybe<Array<Maybe<EntityTagWithMetadata>>>;
  /** Look up Distributed Tracing summary data for the selected `EntityGuid` */
  tracingSummary?: Maybe<DistributedTracingEntityTracingSummary>;
  /** The entity's type */
  type?: Maybe<Scalars['String']['output']>;
  /** List of templates availables for this entity. */
  uiTemplates?: Maybe<Array<EntityDashboardTemplatesUi>>;
};


/** A Synthetic Monitor entity. */
export type SyntheticMonitorEntityAlertViolationsArgs = {
  endTime: Scalars['EpochMilliseconds']['input'];
  startTime: Scalars['EpochMilliseconds']['input'];
};


/** A Synthetic Monitor entity. */
export type SyntheticMonitorEntityAssetsArgs = {
  checkId: Scalars['String']['input'];
};


/** A Synthetic Monitor entity. */
export type SyntheticMonitorEntityDeploymentSearchArgs = {
  filter?: InputMaybe<ChangeTrackingSearchFilter>;
};


/** A Synthetic Monitor entity. */
export type SyntheticMonitorEntityGoldenMetricsArgs = {
  context?: InputMaybe<EntityGoldenContextInput>;
  timeWindow?: InputMaybe<EntityGoldenNrqlTimeWindowInput>;
};


/** A Synthetic Monitor entity. */
export type SyntheticMonitorEntityGoldenSignalCorrelationsArgs = {
  filter?: InputMaybe<GoldenSignalCorrelationsEntityFilter>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  timeWindow?: InputMaybe<TimeWindowInput>;
};


/** A Synthetic Monitor entity. */
export type SyntheticMonitorEntityGoldenSignalDeviationsArgs = {
  comparisonTimeWindow?: InputMaybe<TimeWindowInput>;
  evaluationTimeWindow?: InputMaybe<TimeWindowInput>;
};


/** A Synthetic Monitor entity. */
export type SyntheticMonitorEntityGoldenSignalValuesArgs = {
  timeWindow?: InputMaybe<TimeWindowInput>;
};


/** A Synthetic Monitor entity. */
export type SyntheticMonitorEntityGoldenSignalValuesV2Args = {
  timeWindow?: InputMaybe<TimeWindowInput>;
};


/** A Synthetic Monitor entity. */
export type SyntheticMonitorEntityGoldenTagsArgs = {
  context?: InputMaybe<EntityGoldenContextInput>;
};


/** A Synthetic Monitor entity. */
export type SyntheticMonitorEntityNerdStoreCollectionArgs = {
  collection: Scalars['String']['input'];
  scopeByActor?: InputMaybe<Scalars['Boolean']['input']>;
};


/** A Synthetic Monitor entity. */
export type SyntheticMonitorEntityNerdStoreDocumentArgs = {
  collection: Scalars['String']['input'];
  documentId: Scalars['String']['input'];
  scopeByActor?: InputMaybe<Scalars['Boolean']['input']>;
};


/** A Synthetic Monitor entity. */
export type SyntheticMonitorEntityNrdbQueryArgs = {
  async?: InputMaybe<Scalars['Boolean']['input']>;
  nrql: Scalars['Nrql']['input'];
  options?: InputMaybe<NrqlQueryOptions>;
  timeout?: InputMaybe<Scalars['Seconds']['input']>;
};


/** A Synthetic Monitor entity. */
export type SyntheticMonitorEntityNrdbQueryProgressArgs = {
  queryId: Scalars['ID']['input'];
};


/** A Synthetic Monitor entity. */
export type SyntheticMonitorEntityRecentAlertViolationsArgs = {
  count?: InputMaybe<Scalars['Int']['input']>;
};


/** A Synthetic Monitor entity. */
export type SyntheticMonitorEntityRelatedEntitiesArgs = {
  cursor?: InputMaybe<Scalars['String']['input']>;
  filter?: InputMaybe<EntityRelationshipEdgeFilter>;
  limit?: InputMaybe<Scalars['Int']['input']>;
};


/** A Synthetic Monitor entity. */
export type SyntheticMonitorEntityRelationshipTraversalArgs = {
  cursor?: InputMaybe<Scalars['String']['input']>;
  hopFilters?: InputMaybe<EntityRelationshipTraversalHopFilters>;
  hops?: InputMaybe<Scalars['Int']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
};


/** A Synthetic Monitor entity. */
export type SyntheticMonitorEntityRelationshipsArgs = {
  endTime?: InputMaybe<Scalars['EpochMilliseconds']['input']>;
  filter?: InputMaybe<EntityRelationshipFilter>;
};


/** A Synthetic Monitor entity. */
export type SyntheticMonitorEntitySummaryMetricsArgs = {
  timeWindow?: InputMaybe<TimeWindowInput>;
};


/** A Synthetic Monitor entity. */
export type SyntheticMonitorEntityTracingSummaryArgs = {
  timeWindow?: InputMaybe<TimeWindowInput>;
};

/** A Synthetic Monitor entity outline. */
export type SyntheticMonitorEntityOutline = AlertableEntityOutline & EntityOutline & {
  __typename?: 'SyntheticMonitorEntityOutline';
  account?: Maybe<AccountOutline>;
  /** The New Relic account ID associated with this entity. */
  accountId?: Maybe<Scalars['Int']['output']>;
  /** The current alerting severity of the entity. */
  alertSeverity?: Maybe<EntityAlertSeverity>;
  /**
   * The alert status of the entity.
   * @deprecated Please use `alertSeverity` and `reporting`
   */
  alertStatus?: Maybe<EntityAlertStatus>;
  /** The entity's domain */
  domain?: Maybe<Scalars['String']['output']>;
  /** A value representing the combination of the entity's domain and type. */
  entityType?: Maybe<EntityType>;
  /** The date of last time the entity has updated any of its fields. */
  firstIndexedAt?: Maybe<Scalars['EpochMilliseconds']['output']>;
  /** The list of golden metrics for a specific entity */
  goldenMetrics?: Maybe<EntityGoldenContextScopedGoldenMetrics>;
  /**
   * For the golden signal on this entity, show correlated signals from related entities.
   * Well inspect the golden signals for all related entities and return a sorted list.
   * You can also filter the results.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  goldenSignalCorrelations?: Maybe<GoldenSignalCorrelationResult>;
  /**
   * The deviation from normal of golden signal(s) for the given entity.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  goldenSignalDeviations?: Maybe<Array<Maybe<GoldenSignalSignalDeviation>>>;
  /**
   * The stored golden signal(s) for the given entity.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  goldenSignalValues?: Maybe<GoldenSignalValues>;
  /**
   * The stored golden signal(s) for the given entity. To be removed, use goldenSignalValues instead.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  goldenSignalValuesV2?: Maybe<GoldenSignalValues>;
  /** The list of golden tags for a specific entityType. */
  goldenTags?: Maybe<EntityGoldenContextScopedGoldenTags>;
  /** A unique entity identifier. */
  guid?: Maybe<Scalars['EntityGuid']['output']>;
  /** The time the entity was indexed. */
  indexedAt?: Maybe<Scalars['EpochMilliseconds']['output']>;
  /** The last time the entity's reporting status changed. */
  lastReportingChangeAt?: Maybe<Scalars['EpochMilliseconds']['output']>;
  /** The Synthetic Monitor ID */
  monitorId?: Maybe<Scalars['ID']['output']>;
  /** Summary statistics for the Synthetic Monitor. */
  monitorSummary?: Maybe<SyntheticMonitorSummaryData>;
  /** The Synthetic Monitor type */
  monitorType?: Maybe<SyntheticMonitorType>;
  /** The URL being monitored by a `SIMPLE` or `BROWSER` monitor type. */
  monitoredUrl?: Maybe<Scalars['String']['output']>;
  /** The name of this entity. */
  name?: Maybe<Scalars['String']['output']>;
  /** The duration in minutes between Synthetic Monitor runs. */
  period?: Maybe<Scalars['Minutes']['output']>;
  /** The url to the entity. */
  permalink?: Maybe<Scalars['String']['output']>;
  /** The recommended service levels for the entity. */
  recommendedServiceLevel?: Maybe<ServiceLevelRecommendation>;
  /** Related dashboards results */
  relatedDashboards: RelatedDashboardsRelatedDashboardResult;
  /** The reporting status of the entity. If New Relic is successfully collecting data from your application, this will be true. */
  reporting?: Maybe<Scalars['Boolean']['output']>;
  /** The service level defined for the entity. */
  serviceLevel?: Maybe<ServiceLevelDefinition>;
  /** The list of summary metrics. */
  summaryMetrics?: Maybe<Array<Maybe<EntitySummaryMetric>>>;
  /**
   * The tags applied to the entity.
   *
   * For details on tags, as well as query and mutation examples, visit [our docs](https://docs.newrelic.com/docs/apis/graphql-api/tutorials/graphql-tagging-api-tutorial).
   */
  tags?: Maybe<Array<Maybe<EntityTag>>>;
  /** The entity's type */
  type?: Maybe<Scalars['String']['output']>;
  /** List of templates availables for this entity. */
  uiTemplates?: Maybe<Array<EntityDashboardTemplatesUi>>;
};


/** A Synthetic Monitor entity outline. */
export type SyntheticMonitorEntityOutlineGoldenMetricsArgs = {
  context?: InputMaybe<EntityGoldenContextInput>;
  timeWindow?: InputMaybe<EntityGoldenNrqlTimeWindowInput>;
};


/** A Synthetic Monitor entity outline. */
export type SyntheticMonitorEntityOutlineGoldenSignalCorrelationsArgs = {
  filter?: InputMaybe<GoldenSignalCorrelationsEntityFilter>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  timeWindow?: InputMaybe<TimeWindowInput>;
};


/** A Synthetic Monitor entity outline. */
export type SyntheticMonitorEntityOutlineGoldenSignalDeviationsArgs = {
  comparisonTimeWindow?: InputMaybe<TimeWindowInput>;
  evaluationTimeWindow?: InputMaybe<TimeWindowInput>;
};


/** A Synthetic Monitor entity outline. */
export type SyntheticMonitorEntityOutlineGoldenSignalValuesArgs = {
  timeWindow?: InputMaybe<TimeWindowInput>;
};


/** A Synthetic Monitor entity outline. */
export type SyntheticMonitorEntityOutlineGoldenSignalValuesV2Args = {
  timeWindow?: InputMaybe<TimeWindowInput>;
};


/** A Synthetic Monitor entity outline. */
export type SyntheticMonitorEntityOutlineGoldenTagsArgs = {
  context?: InputMaybe<EntityGoldenContextInput>;
};


/** A Synthetic Monitor entity outline. */
export type SyntheticMonitorEntityOutlineSummaryMetricsArgs = {
  timeWindow?: InputMaybe<TimeWindowInput>;
};

export enum SyntheticMonitorStatus {
  Deleted = 'DELETED',
  Disabled = 'DISABLED',
  Enabled = 'ENABLED',
  Faulty = 'FAULTY',
  Muted = 'MUTED',
  Paused = 'PAUSED'
}

/** Summary statistics for the Synthetic Monitor. */
export type SyntheticMonitorSummaryData = {
  __typename?: 'SyntheticMonitorSummaryData';
  /** The latest 5 synthetic monitor check results. */
  latestResults?: Maybe<Array<Maybe<SyntheticMonitorCheckResult>>>;
  /** The mean load size in bytes for synthetic monitor checks in the last 24 hours. */
  loadSizeAverage?: Maybe<Scalars['Float']['output']>;
  /** The 50th percentile load time in milliseconds for synthetic monitor checks in the last 24 hours. */
  loadTimeP50?: Maybe<Scalars['Milliseconds']['output']>;
  /** The 95th percentile load time in milliseconds for synthetic monitor checks in the last 24 hours. */
  loadTimeP95?: Maybe<Scalars['Milliseconds']['output']>;
  /** The number of locations that are currently failing. */
  locationsFailing?: Maybe<Scalars['Int']['output']>;
  /** The number of locations that are currently running. */
  locationsRunning?: Maybe<Scalars['Int']['output']>;
  status?: Maybe<SyntheticMonitorStatus>;
  /** The percentage of successful synthetic monitor checks in the last 24 hours. */
  successRate?: Maybe<Scalars['Float']['output']>;
};

/** The types of Synthetic Monitors. */
export enum SyntheticMonitorType {
  BrokenLinks = 'BROKEN_LINKS',
  Browser = 'BROWSER',
  CertCheck = 'CERT_CHECK',
  ScriptApi = 'SCRIPT_API',
  ScriptBrowser = 'SCRIPT_BROWSER',
  Simple = 'SIMPLE',
  StepMonitor = 'STEP_MONITOR'
}

/** Information about synthetics checks across the selected account + related */
export type SyntheticsAccountChecks = {
  __typename?: 'SyntheticsAccountChecks';
  /** The number of monitor checks per month allocated to this account */
  monthlyAllocatedChecks?: Maybe<Scalars['Int']['output']>;
  /** The total monthly scheduled monitor checks for the selected account + related accounts */
  monthlyChecks?: Maybe<Scalars['Int']['output']>;
  /** The limit of monitor checks per month for this account. A -1 indicates limits are not enforced for this account */
  monthlyChecksLimit?: Maybe<Scalars['Float']['output']>;
};

/** Nerdgraph account field */
export type SyntheticsAccountStitchedFields = {
  __typename?: 'SyntheticsAccountStitchedFields';
  /** Query that fetches results for an automated test */
  automatedTestResult?: Maybe<SyntheticsAutomatedTestResult>;
  /** Query for getting data from script validation jobs */
  checkValidationJob?: Maybe<SyntheticsScriptValidationQueryResponse>;
  /** Query that fetches Synthetics monitor checks related data */
  checks?: Maybe<SyntheticsAccountChecks>;
  /** Query that fetches job assets */
  getJobAssets?: Maybe<SyntheticsJobAssetsQueryResponse>;
  /** Query that fetches the total monthly scheduled monitor checks for the selected account + related accounts */
  monthlyChecks?: Maybe<Scalars['Int']['output']>;
  /** Query that fetches the private locations available in the specified account plus parent account if applicable */
  privateLocations?: Maybe<Array<Maybe<SyntheticsPrivateLocation>>>;
  /** Query that fetches the script of a specific scripted monitor */
  script?: Maybe<SyntheticsMonitorScriptQueryResponse>;
  /** visiblity(flag:Synthetics/setGraphqlCustomerVisible) Query that fetches the steps used by the specified Step Monitor */
  steps?: Maybe<Array<SyntheticsStep>>;
};


/** Nerdgraph account field */
export type SyntheticsAccountStitchedFieldsAutomatedTestResultArgs = {
  batchId: Scalars['String']['input'];
};


/** Nerdgraph account field */
export type SyntheticsAccountStitchedFieldsCheckValidationJobArgs = {
  validationId: Scalars['String']['input'];
};


/** Nerdgraph account field */
export type SyntheticsAccountStitchedFieldsGetJobAssetsArgs = {
  assetType: SyntheticsAssetType;
  jobId: Scalars['String']['input'];
  monitorGuid: Scalars['EntityGuid']['input'];
};


/** Nerdgraph account field */
export type SyntheticsAccountStitchedFieldsScriptArgs = {
  monitorGuid: Scalars['EntityGuid']['input'];
};


/** Nerdgraph account field */
export type SyntheticsAccountStitchedFieldsStepsArgs = {
  monitorGuid: Scalars['EntityGuid']['input'];
};

export type SyntheticsActorStitchedFields = {
  __typename?: 'SyntheticsActorStitchedFields';
  /** Query that fetches the details of a specific public location */
  publicLocation?: Maybe<SyntheticsPublicLocation>;
  /** Query that fetches all available public locations, plus their geographic data and current status */
  publicLocations?: Maybe<Array<Maybe<SyntheticsPublicLocationOutline>>>;
};


export type SyntheticsActorStitchedFieldsPublicLocationArgs = {
  locationName: Scalars['String']['input'];
};

/** Advanced options for the monitor */
export type SyntheticsAdvancedOptions = {
  __typename?: 'SyntheticsAdvancedOptions';
  /** Custom headers to use in monitor */
  customHeaders?: Maybe<Array<Maybe<SyntheticsCustomHeader>>>;
  /** (SIMPLE monitors only) Categorize redirects during a monitor job as a failure */
  redirectIsFailure?: Maybe<Scalars['Boolean']['output']>;
  /** (SIMPLE and BROWSER monitors only) Validation text for monitor to search for at given URI */
  responseValidation?: Maybe<Scalars['String']['output']>;
  /** (SIMPLE monitors only) Monitor should skip default HEAD request and instead use GET verb in check */
  shouldBypassHeadRequest?: Maybe<Scalars['Boolean']['output']>;
  /** (BROWSER and SCRIPT_BROWSER monitors only) Capture a screenshot during job execution */
  shouldTakeScreenshot?: Maybe<Scalars['Boolean']['output']>;
  /** (SIMPLE and BROWSER monitors only) Monitor should validate SSL certificate chain */
  tlsValidation?: Maybe<Scalars['Boolean']['output']>;
};

/** Advanced options entries for the monitor input */
export type SyntheticsAdvancedOptionsInput = {
  /** Custom headers to use in monitor */
  customHeaders?: InputMaybe<Array<InputMaybe<SyntheticsCustomHeaderInput>>>;
  /** (BROWSER and SCRIPT_BROWSER monitors only) Settings for device emulation */
  deviceEmulation?: InputMaybe<SyntheticsDeviceEmulationInput>;
  /** (SIMPLE monitors only) Categorize redirects during a monitor job as a failure */
  redirectIsFailure?: InputMaybe<Scalars['Boolean']['input']>;
  /** (SIMPLE and BROWSER monitors only) Validation text for monitor to search for at given URI */
  responseValidation?: InputMaybe<Scalars['String']['input']>;
  /** (SIMPLE monitors only) Monitor should skip default HEAD request and instead use GET verb in check */
  shouldBypassHeadRequest?: InputMaybe<Scalars['Boolean']['input']>;
  /** (BROWSER and SCRIPT_BROWSER monitors only) Capture a screenshot during job execution */
  shouldTakeScreenshot?: InputMaybe<Scalars['Boolean']['input']>;
  /** (SIMPLE and BROWSER monitors only) Monitor should validate SSL certificate chain */
  tlsValidation?: InputMaybe<Scalars['Boolean']['input']>;
};

/** Enum of job asset types */
export enum SyntheticsAssetType {
  /** Automated test job assets */
  AutomatedTest = 'AUTOMATED_TEST',
  /** Monitor job assets */
  Monitor = 'MONITOR',
  /** Validation job assets */
  Validation = 'VALIDATION'
}

/** Global automated test config */
export type SyntheticsAutomatedTestConfig = {
  __typename?: 'SyntheticsAutomatedTestConfig';
  /** An identifier for the automated test run */
  batchName?: Maybe<Scalars['String']['output']>;
  /** Branch metadata to indicate what triggered the automated test */
  branch?: Maybe<Scalars['String']['output']>;
  /** Commit metadata to indicate what commit triggered the automated test */
  commit?: Maybe<Scalars['String']['output']>;
  /** Metadata for the automated test */
  deepLink?: Maybe<Scalars['String']['output']>;
  /** Metadata about the platform target the automated test will run against */
  platform?: Maybe<Scalars['String']['output']>;
  /** The unique client identifier for the Synthetics Monitor in New Relic */
  repository?: Maybe<Scalars['String']['output']>;
};

/** Global automated test config */
export type SyntheticsAutomatedTestConfigInput = {
  /** An identifier for the automated test run */
  batchName?: InputMaybe<Scalars['String']['input']>;
  /** Branch metadata to indicate what triggered the automated test */
  branch?: InputMaybe<Scalars['String']['input']>;
  /** Commit metadata to indicate what commit triggered the automated test */
  commit?: InputMaybe<Scalars['String']['input']>;
  /** Metadata for the automated test */
  deepLink?: InputMaybe<Scalars['String']['input']>;
  /** Metadata about the platform target the automated test will run against */
  platform?: InputMaybe<Scalars['String']['input']>;
  /** The unique client identifier for the Synthetics Monitor in New Relic */
  repository?: InputMaybe<Scalars['String']['input']>;
};

/** Information on a job that was apart of a batch of automated test jobs */
export type SyntheticsAutomatedTestJobResult = {
  __typename?: 'SyntheticsAutomatedTestJobResult';
  /** Test overrides */
  automatedTestMonitorConfig?: Maybe<SyntheticsAutomatedTestMonitorConfig>;
  /** Job batch Id */
  batchId?: Maybe<Scalars['String']['output']>;
  /** Job duration */
  duration?: Maybe<Scalars['Milliseconds']['output']>;
  /** Job error if any */
  error?: Maybe<Scalars['String']['output']>;
  /** Job Id */
  id?: Maybe<Scalars['String']['output']>;
  /** Job location */
  location?: Maybe<Scalars['String']['output']>;
  /** Job location label */
  locationLabel?: Maybe<Scalars['String']['output']>;
  /** Monitor nr1 entity guid */
  monitorGuid?: Maybe<Scalars['EntityGuid']['output']>;
  /** Job monitor Id */
  monitorId?: Maybe<Scalars['String']['output']>;
  /** Job monitor name */
  monitorName?: Maybe<Scalars['String']['output']>;
  /** Job result */
  result?: Maybe<SyntheticsJobStatus>;
  /** Link to job results */
  resultsUrl?: Maybe<Scalars['String']['output']>;
  /** Job type */
  type?: Maybe<SyntheticsMonitorType>;
  /** Job type label */
  typeLabel?: Maybe<Scalars['String']['output']>;
};

/** Monitor specific test config */
export type SyntheticsAutomatedTestMonitorConfig = {
  __typename?: 'SyntheticsAutomatedTestMonitorConfig';
  /** Specifies whether a failure of this monitor should fail the entire automated test */
  isBlocking?: Maybe<Scalars['Boolean']['output']>;
  /** Specific overrides for the given monitor */
  overrides?: Maybe<SyntheticsAutomatedTestOverrides>;
};

/** Monitor specific test configuration */
export type SyntheticsAutomatedTestMonitorConfigInput = {
  /** Specifies whether a failure of this monitor should fail the entire automated test */
  isBlocking?: InputMaybe<Scalars['Boolean']['input']>;
  /** Specific overrides for the given monitor */
  overrides?: InputMaybe<SyntheticsAutomatedTestOverridesInput>;
};

/** Monitor test definition to be included in the automated test */
export type SyntheticsAutomatedTestMonitorInput = {
  /** The monitor config for an automated test */
  config?: InputMaybe<SyntheticsAutomatedTestMonitorConfigInput>;
  /** The unique client identifier for the Synthetics Monitor in New Relic */
  monitorGuid: Scalars['EntityGuid']['input'];
};

/** Automated test monitor overrides */
export type SyntheticsAutomatedTestOverrides = {
  __typename?: 'SyntheticsAutomatedTestOverrides';
  /** Override a domain throughout a scripted monitor */
  domain?: Maybe<Array<Maybe<SyntheticsScriptDomainOverride>>>;
  /** Override monitor to use a specific location */
  location?: Maybe<Scalars['String']['output']>;
  /** Override a script secure credential with another credential value */
  secureCredential?: Maybe<Array<Maybe<SyntheticsSecureCredentialOverride>>>;
  /** Override a browser monitor starting url */
  startingUrl?: Maybe<Scalars['String']['output']>;
};

/** Automated test monitor overrides */
export type SyntheticsAutomatedTestOverridesInput = {
  /** Override a domain throughout a scripted monitor */
  domain?: InputMaybe<Array<InputMaybe<SyntheticsScriptDomainOverrideInput>>>;
  /** Override monitor to use a specific location */
  location?: InputMaybe<Scalars['String']['input']>;
  /** Override a script secure credential with another credential value */
  secureCredential?: InputMaybe<Array<InputMaybe<SyntheticsSecureCredentialOverrideInput>>>;
  /** Override a browser monitor starting url */
  startingUrl?: InputMaybe<Scalars['String']['input']>;
};

/** Results from fetching automated test job */
export type SyntheticsAutomatedTestResult = {
  __typename?: 'SyntheticsAutomatedTestResult';
  /** Automated test config */
  config?: Maybe<SyntheticsAutomatedTestConfig>;
  /** Finished time of the automated test batch */
  finishTimestamp?: Maybe<Scalars['EpochMilliseconds']['output']>;
  /** Start time of the automated test batch */
  startTimestamp?: Maybe<Scalars['EpochMilliseconds']['output']>;
  /** Calculated status of automated test as a whole */
  status?: Maybe<SyntheticsAutomatedTestStatus>;
  /** List of completed automated test jobs */
  tests?: Maybe<Array<Maybe<SyntheticsAutomatedTestJobResult>>>;
};

/** Results from starting automated test job */
export type SyntheticsAutomatedTestStartResult = {
  __typename?: 'SyntheticsAutomatedTestStartResult';
  /** Job batch Id */
  batchId?: Maybe<Scalars['String']['output']>;
};

/** Enum of automated test status */
export enum SyntheticsAutomatedTestStatus {
  /** At least one blocking job in the automated test has failed */
  Failed = 'FAILED',
  /** Indicates jobs in the automated test are still running */
  InProgress = 'IN_PROGRESS',
  /** All blocking jobs in the automated test has passed */
  Passed = 'PASSED',
  /** Some jobs in the automated test failed to provide a status within the timeout */
  Timeout = 'TIMEOUT'
}

/** A Broken Links monitor resulting from a Broken Links monitor mutation */
export type SyntheticsBrokenLinksMonitor = {
  __typename?: 'SyntheticsBrokenLinksMonitor';
  /** The creation time of the monitor in millis */
  createdAt?: Maybe<Scalars['EpochMilliseconds']['output']>;
  /** The unique client identifier for the Synthetics Monitor in New Relic */
  guid?: Maybe<Scalars['EntityGuid']['output']>;
  /** The unique identifier of the monitor within the Synthetics domain */
  id?: Maybe<Scalars['ID']['output']>;
  /** The locations the monitor runs from */
  locations?: Maybe<SyntheticsLocations>;
  /** The last modification time of the monitor in millis */
  modifiedAt?: Maybe<Scalars['EpochMilliseconds']['output']>;
  /** The human readable identifier for the monitor */
  name?: Maybe<Scalars['String']['output']>;
  /** The interval at which the monitor runs in minutes */
  period?: Maybe<SyntheticsMonitorPeriod>;
  /** The runtime that the monitor will use to run jobs */
  runtime?: Maybe<SyntheticsExtendedTypeMonitorRuntime>;
  /** The run state of the monitor */
  status?: Maybe<SyntheticsMonitorStatus>;
  /** The uri the monitor runs against */
  uri?: Maybe<Scalars['String']['output']>;
};

/** The result of a Broken Links monitor create mutation */
export type SyntheticsBrokenLinksMonitorCreateMutationResult = {
  __typename?: 'SyntheticsBrokenLinksMonitorCreateMutationResult';
  /** Errors that occurred during Broken Links monitor create mutation */
  errors: Array<Maybe<SyntheticsMonitorCreateError>>;
  /** The resulting Broken Links monitor */
  monitor?: Maybe<SyntheticsBrokenLinksMonitor>;
};

/** The result of a Broken Links monitor update mutation */
export type SyntheticsBrokenLinksMonitorUpdateMutationResult = {
  __typename?: 'SyntheticsBrokenLinksMonitorUpdateMutationResult';
  /** Errors that occurred during Broken Links monitor update mutation */
  errors: Array<Maybe<SyntheticsMonitorUpdateError>>;
  /** The resulting Broken Links monitor */
  monitor?: Maybe<SyntheticsBrokenLinksMonitor>;
};

/** A Cert Check monitor resulting from a Cert Check monitor mutation */
export type SyntheticsCertCheckMonitor = {
  __typename?: 'SyntheticsCertCheckMonitor';
  /** The creation time of the monitor in millis */
  createdAt?: Maybe<Scalars['EpochMilliseconds']['output']>;
  /** The domain of the host that will have its certificate checked */
  domain?: Maybe<Scalars['String']['output']>;
  /** The unique client identifier for the Synthetics Monitor in New Relic */
  guid?: Maybe<Scalars['EntityGuid']['output']>;
  /** The unique identifier of the monitor within the Synthetics domain */
  id?: Maybe<Scalars['ID']['output']>;
  /** The locations the monitor runs from */
  locations?: Maybe<SyntheticsLocations>;
  /** The last modification time of the monitor in millis */
  modifiedAt?: Maybe<Scalars['EpochMilliseconds']['output']>;
  /** The human readable identifier for the monitor */
  name?: Maybe<Scalars['String']['output']>;
  /** The desired number of remaining days until the certificate expires to trigger a monitor failure */
  numberDaysToFailBeforeCertExpires?: Maybe<Scalars['Int']['output']>;
  /** The interval at which the monitor runs in minutes */
  period?: Maybe<SyntheticsMonitorPeriod>;
  /** The runtime that the monitor will use to run jobs */
  runtime?: Maybe<SyntheticsExtendedTypeMonitorRuntime>;
  /** The run state of the monitor */
  status?: Maybe<SyntheticsMonitorStatus>;
};

/** The result of a Cert Check monitor create mutation */
export type SyntheticsCertCheckMonitorCreateMutationResult = {
  __typename?: 'SyntheticsCertCheckMonitorCreateMutationResult';
  /** Errors that occurred during Cert Check monitor create mutation */
  errors: Array<Maybe<SyntheticsMonitorCreateError>>;
  /** The resulting Cert Check monitor */
  monitor?: Maybe<SyntheticsCertCheckMonitor>;
};

/** The result of a Cert Check monitor update mutation */
export type SyntheticsCertCheckMonitorUpdateMutationResult = {
  __typename?: 'SyntheticsCertCheckMonitorUpdateMutationResult';
  /** Errors that occurred during Cert Check monitor update mutation */
  errors: Array<Maybe<SyntheticsMonitorUpdateError>>;
  /** The resulting Cert Check monitor */
  monitor?: Maybe<SyntheticsCertCheckMonitor>;
};

/** Possible Continents associated with the public location */
export enum SyntheticsContinent {
  /** Africa */
  Africa = 'AFRICA',
  /** Asia */
  Asia = 'ASIA',
  /** Australia */
  Australia = 'AUSTRALIA',
  /** Europe */
  Europe = 'EUROPE',
  /** North America */
  NorthAmerica = 'NORTH_AMERICA',
  /** South America */
  SouthAmerica = 'SOUTH_AMERICA',
  /** Unknown: Will be returned when geographic data is missing for a given public location */
  Unknown = 'UNKNOWN'
}

/** The monitor input values needed to create a Broken Links monitor */
export type SyntheticsCreateBrokenLinksMonitorInput = {
  /** The monitor's Apdex target used to populate SLA reports */
  apdexTarget?: InputMaybe<Scalars['Float']['input']>;
  /** The locations the monitor will run from */
  locations: SyntheticsLocationsInput;
  /** The human readable identifier for the monitor */
  name: Scalars['String']['input'];
  /** The interval at which the monitor runs in minutes */
  period: SyntheticsMonitorPeriod;
  /** The runtime that the monitor will use to run jobs. The only accepted values are runtimeType: NODE_API & runtimeTypeVersion: 16.10 */
  runtime?: InputMaybe<SyntheticsExtendedTypeMonitorRuntimeInput>;
  /** The run state of the monitor */
  status: SyntheticsMonitorStatus;
  /** The tags that will be associated with the monitor */
  tags?: InputMaybe<Array<InputMaybe<SyntheticsTag>>>;
  /** The uri the monitor runs against */
  uri: Scalars['String']['input'];
};

/** The monitor input values needed to create a Cert Check monitor */
export type SyntheticsCreateCertCheckMonitorInput = {
  /** The monitor's Apdex target used to populate SLA reports */
  apdexTarget?: InputMaybe<Scalars['Float']['input']>;
  /** The domain of the host that will have its certificate checked */
  domain: Scalars['String']['input'];
  /** The locations the monitor will run from */
  locations: SyntheticsLocationsInput;
  /** The human readable identifier for the monitor */
  name: Scalars['String']['input'];
  /** The desired number of remaining days until the certificate expires to trigger a monitor failure */
  numberDaysToFailBeforeCertExpires: Scalars['Int']['input'];
  /** The interval at which the monitor runs in minutes */
  period: SyntheticsMonitorPeriod;
  /** The runtime that the monitor will use to run jobs. The only accepted values are runtimeType: NODE_API & runtimeTypeVersion: 16.10 */
  runtime?: InputMaybe<SyntheticsExtendedTypeMonitorRuntimeInput>;
  /** The run state of the monitor */
  status: SyntheticsMonitorStatus;
  /** The tags that will be associated with the monitor */
  tags?: InputMaybe<Array<InputMaybe<SyntheticsTag>>>;
};

/** The monitor input values needed to create a Script Api monitor */
export type SyntheticsCreateScriptApiMonitorInput = {
  /** The monitor's Apdex target used to populate SLA reports */
  apdexTarget?: InputMaybe<Scalars['Float']['input']>;
  /** The locations the monitor will run from */
  locations: SyntheticsScriptedMonitorLocationsInput;
  /** The human readable identifier for the monitor */
  name: Scalars['String']['input'];
  /** The interval at which the monitor runs in minutes */
  period: SyntheticsMonitorPeriod;
  /** The runtime that the monitor will use to run jobs */
  runtime?: InputMaybe<SyntheticsRuntimeInput>;
  /** The script that the monitor runs */
  script: Scalars['String']['input'];
  /** The run state of the monitor */
  status: SyntheticsMonitorStatus;
  /** The tags that will be associated with the monitor */
  tags?: InputMaybe<Array<InputMaybe<SyntheticsTag>>>;
};

/** The monitor input values needed to create a Script Browser monitor */
export type SyntheticsCreateScriptBrowserMonitorInput = {
  /** The monitor advanced options */
  advancedOptions?: InputMaybe<SyntheticsScriptBrowserMonitorAdvancedOptionsInput>;
  /** The monitor's Apdex target used to populate SLA reports */
  apdexTarget?: InputMaybe<Scalars['Float']['input']>;
  /** The locations the monitor will run from */
  locations: SyntheticsScriptedMonitorLocationsInput;
  /** The human readable identifier for the monitor */
  name: Scalars['String']['input'];
  /** The interval at which the monitor runs in minutes */
  period: SyntheticsMonitorPeriod;
  /** The runtime that the monitor will use to run jobs */
  runtime?: InputMaybe<SyntheticsRuntimeInput>;
  /** The script that the monitor runs */
  script: Scalars['String']['input'];
  /** The run state of the monitor */
  status: SyntheticsMonitorStatus;
  /** The tags that will be associated with the monitor */
  tags?: InputMaybe<Array<InputMaybe<SyntheticsTag>>>;
};

/** The monitor input values needed to create a Simple Browser monitor */
export type SyntheticsCreateSimpleBrowserMonitorInput = {
  /** The monitor advanced options */
  advancedOptions?: InputMaybe<SyntheticsSimpleBrowserMonitorAdvancedOptionsInput>;
  /** The monitor's Apdex target used to populate SLA reports */
  apdexTarget?: InputMaybe<Scalars['Float']['input']>;
  /** The locations the monitor will run from */
  locations: SyntheticsLocationsInput;
  /** The human readable identifier for the monitor */
  name: Scalars['String']['input'];
  /** The interval at which the monitor runs in minutes */
  period: SyntheticsMonitorPeriod;
  /** The runtime that the monitor will use to run jobs */
  runtime?: InputMaybe<SyntheticsRuntimeInput>;
  /** The run state of the monitor */
  status: SyntheticsMonitorStatus;
  /** The tags that will be associated with the monitor */
  tags?: InputMaybe<Array<InputMaybe<SyntheticsTag>>>;
  /** The uri the monitor runs against */
  uri: Scalars['String']['input'];
};

/** The monitor input values needed to create a Simple (ping) monitor */
export type SyntheticsCreateSimpleMonitorInput = {
  /** The monitor advanced options */
  advancedOptions?: InputMaybe<SyntheticsSimpleMonitorAdvancedOptionsInput>;
  /** The monitor's Apdex target used to populate SLA reports */
  apdexTarget?: InputMaybe<Scalars['Float']['input']>;
  /** The locations the monitor will run from */
  locations: SyntheticsLocationsInput;
  /** The human readable identifier for the monitor */
  name: Scalars['String']['input'];
  /** The interval at which the monitor runs in minutes */
  period: SyntheticsMonitorPeriod;
  /** The run state of the monitor */
  status: SyntheticsMonitorStatus;
  /** The tags that will be associated with the monitor */
  tags?: InputMaybe<Array<InputMaybe<SyntheticsTag>>>;
  /** The uri the monitor runs against */
  uri: Scalars['String']['input'];
};

/** The monitor input values needed to create a Step monitor */
export type SyntheticsCreateStepMonitorInput = {
  /** The monitor advanced options */
  advancedOptions?: InputMaybe<SyntheticsStepMonitorAdvancedOptionsInput>;
  /** The monitor's Apdex target used to populate SLA reports */
  apdexTarget?: InputMaybe<Scalars['Float']['input']>;
  /** The locations the monitor will run from */
  locations: SyntheticsScriptedMonitorLocationsInput;
  /** The human readable identifier for the monitor */
  name: Scalars['String']['input'];
  /** The interval at which the monitor runs in minutes */
  period: SyntheticsMonitorPeriod;
  /** The runtime that the monitor will use to run jobs. The only accepted values are runtimeType: CHROME_BROWSER & runtimeTypeVersion: 100 */
  runtime?: InputMaybe<SyntheticsExtendedTypeMonitorRuntimeInput>;
  /** The run state of the monitor */
  status: SyntheticsMonitorStatus;
  /** The steps that make up the script the monitor will run */
  steps: Array<SyntheticsStepInput>;
  /** The tags that will be associated with the monitor */
  tags?: InputMaybe<Array<InputMaybe<SyntheticsTag>>>;
};

/** Custom header for monitor jobs */
export type SyntheticsCustomHeader = {
  __typename?: 'SyntheticsCustomHeader';
  /** Header name */
  name: Scalars['String']['output'];
  /** Header value */
  value: Scalars['String']['output'];
};

/** Custom header input for monitor jobs */
export type SyntheticsCustomHeaderInput = {
  /** Header name */
  name: Scalars['String']['input'];
  /** Header value */
  value: Scalars['String']['input'];
};

/** Monitor downtime object returned to the customer for a downtime run daily */
export type SyntheticsDailyMonitorDowntimeMutationResult = {
  __typename?: 'SyntheticsDailyMonitorDowntimeMutationResult';
  /** The account ID associated with the monitor downtime */
  accountId?: Maybe<Scalars['Int']['output']>;
  /** Configuration options if the customer wants the monitor to end at a specific date */
  endRepeat?: Maybe<SyntheticsDateWindowEndOutput>;
  /** The date and time in which the monitor downtime will end */
  endTime?: Maybe<Scalars['NaiveDateTime']['output']>;
  /** The entity GUID associated with the monitor downtime */
  guid?: Maybe<Scalars['EntityGuid']['output']>;
  /** The monitor GUIDs associated with the monitor downtime */
  monitorGuids?: Maybe<Array<Maybe<Scalars['EntityGuid']['output']>>>;
  /** The name of the monitor downtime */
  name?: Maybe<Scalars['String']['output']>;
  /** The date and time in which the monitor downtime will begin */
  startTime?: Maybe<Scalars['NaiveDateTime']['output']>;
  /** The timezone the time values will be in */
  timezone?: Maybe<Scalars['String']['output']>;
};

/** Configuration options for when a monitor downtime should end */
export type SyntheticsDateWindowEndConfig = {
  /** End the monitor downtime on a particular date */
  onDate?: InputMaybe<Scalars['Date']['input']>;
  /** End the monitor downtime after a set number of occurrences */
  onRepeat?: InputMaybe<Scalars['Int']['input']>;
};

/** Configuration options for when a monitor downtime should end */
export type SyntheticsDateWindowEndOutput = {
  __typename?: 'SyntheticsDateWindowEndOutput';
  /** End the monitor downtime on a particular date */
  onDate?: Maybe<Scalars['Date']['output']>;
  /** End the monitor downtime after a set number of occurrences */
  onRepeat?: Maybe<Scalars['Int']['output']>;
};

/** Configuration options for a monthly monitor downtime that runs on days of the week */
export type SyntheticsDaysOfWeek = {
  /** Which occurrence of the day selected within the month */
  ordinalDayOfMonth: SyntheticsMonitorDowntimeDayOfMonthOrdinal;
  /** Which day of the week the monitor downtime runs */
  weekDay: SyntheticsMonitorDowntimeWeekDays;
};

/** Configuration options for a monthly monitor downtime that runs on days of the week */
export type SyntheticsDaysOfWeekOutput = {
  __typename?: 'SyntheticsDaysOfWeekOutput';
  /** Which occurrence of the day selected within the month */
  ordinalDayOfMonth?: Maybe<SyntheticsMonitorDowntimeDayOfMonthOrdinal>;
  /** Which day of the week the monitor downtime runs */
  weekDay?: Maybe<SyntheticsMonitorDowntimeWeekDays>;
};

/** Information related to device emulation */
export type SyntheticsDeviceEmulation = {
  __typename?: 'SyntheticsDeviceEmulation';
  /** The device orientation the user would like to represent */
  deviceOrientation: SyntheticsDeviceOrientation;
  /** The device type that a user can select */
  deviceType: SyntheticsDeviceType;
};

/** Information related to device browser emulation */
export type SyntheticsDeviceEmulationInput = {
  /** The device orientation the user would like to represent */
  deviceOrientation: SyntheticsDeviceOrientation;
  /** The device type that a user can select */
  deviceType: SyntheticsDeviceType;
};

/** enum of Orientations that the user can select for their emulated device */
export enum SyntheticsDeviceOrientation {
  /** This allows the screenshot to be taken in the landscape orientation */
  Landscape = 'LANDSCAPE',
  /** This will disable device emulation */
  None = 'NONE',
  /** This allows the screenshot to be taken in the portrait orientation */
  Portrait = 'PORTRAIT'
}

/** enum of DeviceTypes that the user can use for device emulation */
export enum SyntheticsDeviceType {
  /** This will be dimensions for a typical mobile device */
  Mobile = 'MOBILE',
  /** This will disable device emulation */
  None = 'NONE',
  /** This will be dimensions for a typical tablet device */
  Tablet = 'TABLET'
}

/** Error object for Synthetics mutations */
export type SyntheticsError = {
  __typename?: 'SyntheticsError';
  /** Description explaining the cause of the error */
  description?: Maybe<Scalars['String']['output']>;
};

/** Additional input parameters for extended type monitors */
export type SyntheticsExtendedTypeInput = {
  /** (CERT_CHECK) The desired number of remaining days until the certificate expires to trigger a monitor failure */
  daysUntilExpiration?: InputMaybe<Scalars['Int']['input']>;
  /** (CERT_CHECK) The domain of the host to check the certificate on */
  domain?: InputMaybe<Scalars['String']['input']>;
};

/** Additional metadata/parameters for newer extended type monitors */
export type SyntheticsExtendedTypeMetadata = {
  __typename?: 'SyntheticsExtendedTypeMetadata';
  /** The desired number of remaining days until the certificate expires to trigger a monitor failure */
  daysUntilExpiration?: Maybe<Scalars['Int']['output']>;
  /** The domain of the host to check the certificate on */
  domain?: Maybe<Scalars['String']['output']>;
};

/** The runtime that a step monitor runs */
export type SyntheticsExtendedTypeMonitorRuntime = {
  __typename?: 'SyntheticsExtendedTypeMonitorRuntime';
  /** The runtime type that the monitor will run */
  runtimeType?: Maybe<Scalars['String']['output']>;
  /** The specific version of the runtime type selected */
  runtimeTypeVersion?: Maybe<Scalars['SemVer']['output']>;
};

/** Input to determine which runtime the step monitor will run */
export type SyntheticsExtendedTypeMonitorRuntimeInput = {
  /** The runtime type that the monitor will run. */
  runtimeType: Scalars['String']['input'];
  /** The specific version of the runtime type selected. */
  runtimeTypeVersion: Scalars['SemVer']['input'];
};

/** Input to generate a monitor script from monitor steps */
export type SyntheticsGenerateMonitorScriptInput = {
  /** Steps that will make up the monitor script */
  steps: Array<SyntheticsStepInput>;
};

/** Result of a script generation mutation */
export type SyntheticsGenerateMonitorScriptResult = {
  __typename?: 'SyntheticsGenerateMonitorScriptResult';
  /** Errors during script generation mutation */
  errors?: Maybe<Array<Maybe<SyntheticsGenerateScriptError>>>;
  /** Resulting script */
  script?: Maybe<Scalars['String']['output']>;
};

/** Error object for Synthetics script generator requests */
export type SyntheticsGenerateScriptError = {
  __typename?: 'SyntheticsGenerateScriptError';
  /** Description of error response */
  description: Scalars['String']['output'];
  /** Enum type of error response */
  type: SyntheticsTriggerScriptValidationErrorType;
};

/** Assets produced for job */
export type SyntheticsJobAssetsQueryResponse = {
  __typename?: 'SyntheticsJobAssetsQueryResponse';
  /** Public url for the raw Synthetics job */
  jobUrl?: Maybe<Scalars['String']['output']>;
  /** Public url for job screenshot */
  screenshotUrl?: Maybe<Scalars['String']['output']>;
};

/** Enum of job status */
export enum SyntheticsJobStatus {
  /** Indicates the job has failed */
  Failed = 'FAILED',
  /** Indicates an in-progress job */
  Pending = 'PENDING',
  /** Indicates the job has succeeded */
  Success = 'SUCCESS',
  /** Indicates the job status was lost or unknown */
  Unknown = 'UNKNOWN'
}

/** The location(s) from which the monitor runs */
export type SyntheticsLocations = {
  __typename?: 'SyntheticsLocations';
  /** Existing private location(s) in which the monitor will run */
  private?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
  /** Publicly available location(s) in which the monitor will run. For formatting tips, see [this link](https://docs.newrelic.com/docs/apis/nerdgraph/examples/nerdgraph-synthetics-tutorial/#location-field) */
  public?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
};

/** The location(s) from which a non-scripted monitor runs */
export type SyntheticsLocationsInput = {
  /** Existing private location(s) in which the monitor will run */
  private?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  /** Publicly available location(s) in which the monitor will run. For formatting tips, see [this link](https://docs.newrelic.com/docs/apis/nerdgraph/examples/nerdgraph-synthetics-tutorial/#location-field) */
  public?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
};

/** Error object for Synthetics monitor creation request */
export type SyntheticsMonitorCreateError = {
  __typename?: 'SyntheticsMonitorCreateError';
  /** String description of error */
  description: Scalars['String']['output'];
  /** Enum of error that was returned during monitor creation */
  type: SyntheticsMonitorCreateErrorType;
};

/** Types of errors that can be returned from a create monitor request */
export enum SyntheticsMonitorCreateErrorType {
  /** Received a request missing required fields or containing invalid data */
  BadRequest = 'BAD_REQUEST',
  /** An unknown error occurred while processing request to mutate monitor */
  InternalServerError = 'INTERNAL_SERVER_ERROR',
  /** Monitor not found for given guid (monitor does not exist on account or has already been deleted) */
  NotFound = 'NOT_FOUND',
  /** Monitor creation exceeds account subscription limits */
  PaymentRequired = 'PAYMENT_REQUIRED',
  /** Monitor tags were not updated. */
  TaggingError = 'TAGGING_ERROR',
  /** User does not have authorization to perform monitor mutation. */
  Unauthorized = 'UNAUTHORIZED',
  /** An unknown error occurred while processing request to create monitor */
  UnknownError = 'UNKNOWN_ERROR'
}

/** The result of a monitor delete mutation */
export type SyntheticsMonitorDeleteMutationResult = {
  __typename?: 'SyntheticsMonitorDeleteMutationResult';
  /** The unique identifier of the deleted monitor */
  deletedGuid?: Maybe<Scalars['EntityGuid']['output']>;
};

/** Configuration options for a monitor downtime that runs daily */
export type SyntheticsMonitorDowntimeDailyConfig = {
  /** Configuration options if the customer wants the monitor to end at a specific date */
  endRepeat?: InputMaybe<SyntheticsDateWindowEndConfig>;
  /** The date and time in which the monitor downtime will end */
  endTime?: InputMaybe<Scalars['NaiveDateTime']['input']>;
  /** The date and time in which the monitor downtime will begin */
  startTime?: InputMaybe<Scalars['NaiveDateTime']['input']>;
  /** The timezone the time values will be in */
  timezone?: InputMaybe<Scalars['String']['input']>;
};

/** enum of which day in the month a customer can have a monitor downtime run */
export enum SyntheticsMonitorDowntimeDayOfMonthOrdinal {
  /** First selected day of the month */
  First = 'FIRST',
  /** Fourth selected day of the month */
  Fourth = 'FOURTH',
  /** Last selected day of the month */
  Last = 'LAST',
  /** Second selected day of the month */
  Second = 'SECOND',
  /** Third selected day of the month */
  Third = 'THIRD'
}

/** Monitor downtime object returned to the customer once a monitor downtime is deleted */
export type SyntheticsMonitorDowntimeDeleteResult = {
  __typename?: 'SyntheticsMonitorDowntimeDeleteResult';
  /** The entity guid of the deleted MonitorDowntime */
  guid?: Maybe<Scalars['EntityGuid']['output']>;
};

/** Configuration options for a monitor downtime that runs monthly */
export type SyntheticsMonitorDowntimeMonthlyConfig = {
  /** Configuration options if the customer wants the monitor to end at a specific date */
  endRepeat?: InputMaybe<SyntheticsDateWindowEndConfig>;
  /** The date and time in which the monitor downtime will end */
  endTime?: InputMaybe<Scalars['NaiveDateTime']['input']>;
  /** Configuration options for which days of the month a monitor downtime will occur */
  frequency?: InputMaybe<SyntheticsMonitorDowntimeMonthlyFrequency>;
  /** The date and time in which the monitor downtime will begin */
  startTime?: InputMaybe<Scalars['NaiveDateTime']['input']>;
  /** The timezone the time values will be in */
  timezone?: InputMaybe<Scalars['String']['input']>;
};

/** Configuration options for when a monthly monitor downtime should run */
export type SyntheticsMonitorDowntimeMonthlyFrequency = {
  /** Which dates a monitor downtime is run (only 1 of these can be selected) */
  daysOfMonth?: InputMaybe<Array<InputMaybe<Scalars['Int']['input']>>>;
  /** Which weekdays in the month the monitor downtime will run (only 1 of these can be selected) */
  daysOfWeek?: InputMaybe<SyntheticsDaysOfWeek>;
};

/** Configuration options for when a monthly monitor downtime should run */
export type SyntheticsMonitorDowntimeMonthlyFrequencyOutput = {
  __typename?: 'SyntheticsMonitorDowntimeMonthlyFrequencyOutput';
  /**
   * Which dates a monitor downtime is run
   *  (only 1 of these can be selected)
   */
  daysOfMonth?: Maybe<Array<Maybe<Scalars['Int']['output']>>>;
  /**
   * Which weekdays in the month the monitor downtime will run
   *  (only 1 of these can be selected)
   */
  daysOfWeek?: Maybe<SyntheticsDaysOfWeekOutput>;
};

/** Monitor downtime object returned to the customer for an edit mutation */
export type SyntheticsMonitorDowntimeMutationResult = {
  __typename?: 'SyntheticsMonitorDowntimeMutationResult';
  /** The account ID associated with the monitor downtime */
  accountId?: Maybe<Scalars['Int']['output']>;
  /** Configuration options if the customer wants the monitor to end at a specific date */
  endRepeat?: Maybe<SyntheticsDateWindowEndOutput>;
  /** The date and time in which the monitor downtime will end */
  endTime?: Maybe<Scalars['NaiveDateTime']['output']>;
  /** Configuration options for which days of the month a monitor downtime will occur */
  frequency?: Maybe<SyntheticsMonitorDowntimeMonthlyFrequencyOutput>;
  /** The entity GUID associated with the monitor downtime */
  guid?: Maybe<Scalars['EntityGuid']['output']>;
  /** Days of the week the monitor downtime will run */
  maintenanceDays?: Maybe<Array<Maybe<SyntheticsMonitorDowntimeWeekDays>>>;
  /** The monitor GUIDs associated with the monitor downtime */
  monitorGuids?: Maybe<Array<Maybe<Scalars['EntityGuid']['output']>>>;
  /** The name of the monitor downtime */
  name?: Maybe<Scalars['String']['output']>;
  /** The date and time in which the monitor downtime will begin */
  startTime?: Maybe<Scalars['NaiveDateTime']['output']>;
  /** The timezone the time values will be in */
  timezone?: Maybe<Scalars['String']['output']>;
};

/** Configuration options for a monitor downtime that runs once */
export type SyntheticsMonitorDowntimeOnceConfig = {
  /** The date and time in which the monitor downtime will end */
  endTime?: InputMaybe<Scalars['NaiveDateTime']['input']>;
  /** The date and time in which the monitor downtime will begin */
  startTime?: InputMaybe<Scalars['NaiveDateTime']['input']>;
  /** The timezone the time values will be in */
  timezone?: InputMaybe<Scalars['String']['input']>;
};

/** enum of weekdays customers can select monitor downtimes to run */
export enum SyntheticsMonitorDowntimeWeekDays {
  /** Select monitor downtime to run on Friday */
  Friday = 'FRIDAY',
  /** Select monitor downtime to run on Monday */
  Monday = 'MONDAY',
  /** Select monitor downtime to run on Saturday */
  Saturday = 'SATURDAY',
  /** Select monitor downtime to run on Sunday */
  Sunday = 'SUNDAY',
  /** Select monitor downtime to run on Thursday */
  Thursday = 'THURSDAY',
  /** Select monitor downtime to run on Tuesday */
  Tuesday = 'TUESDAY',
  /** Select monitor downtime to run on Wednesday */
  Wednesday = 'WEDNESDAY'
}

/** Configuration options for a monitor downtime that runs weekly */
export type SyntheticsMonitorDowntimeWeeklyConfig = {
  /** Configuration options if the customer wants the monitor to end at a specific date */
  endRepeat?: InputMaybe<SyntheticsDateWindowEndConfig>;
  /** The date and time in which the monitor downtime will end */
  endTime?: InputMaybe<Scalars['NaiveDateTime']['input']>;
  /** Configuration options if the customer wants the monitor to end at a specific date */
  maintenanceDays?: InputMaybe<Array<InputMaybe<SyntheticsMonitorDowntimeWeekDays>>>;
  /** The date and time in which the monitor downtime will begin */
  startTime?: InputMaybe<Scalars['NaiveDateTime']['input']>;
  /** The timezone the time values will be in */
  timezone?: InputMaybe<Scalars['String']['input']>;
};

/** The result of a monitor mutation */
export type SyntheticsMonitorMutationResult = {
  __typename?: 'SyntheticsMonitorMutationResult';
  /** The monitor advanced options */
  advancedOptions?: Maybe<SyntheticsAdvancedOptions>;
  /** The runtime environment for the monitor */
  apiVersion?: Maybe<Scalars['String']['output']>;
  /** The creation time of the monitor in millis */
  createdAt?: Maybe<Scalars['EpochMilliseconds']['output']>;
  /** Errors during monitor mutation */
  errors?: Maybe<Array<Maybe<SyntheticsError>>>;
  /** Additional monitor metadata for newer monitor types */
  extendedTypeMetadata?: Maybe<SyntheticsExtendedTypeMetadata>;
  /** The unique identifier of the monitor, if available */
  guid?: Maybe<Scalars['EntityGuid']['output']>;
  /** The unique identifier of the monitor within the Synthetics domain */
  id?: Maybe<Scalars['ID']['output']>;
  /** The locations the monitor will run from */
  locations?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
  /** The last modification time of the monitor in millis */
  modifiedAt?: Maybe<Scalars['EpochMilliseconds']['output']>;
  /** A monitor identifier for humans */
  name?: Maybe<Scalars['String']['output']>;
  /** The interval at which the monitor runs in minutes */
  period?: Maybe<SyntheticsMonitorPeriod>;
  /** The sla threshold for the monitor */
  slaThreshold?: Maybe<Scalars['Float']['output']>;
  /** The run state of the monitor */
  status?: Maybe<SyntheticsMonitorStatus>;
  /** The steps that will make up the monitor script */
  steps?: Maybe<Array<Maybe<SyntheticsStep>>>;
  /** The type of monitor */
  type?: Maybe<SyntheticsMonitorType>;
  /** The uri the monitor will run against */
  uri?: Maybe<Scalars['String']['output']>;
};

/** Enum of monitor period types */
export enum SyntheticsMonitorPeriod {
  /** 5 minute monitor period */
  Every_5Minutes = 'EVERY_5_MINUTES',
  /** 6 hour monitor period (360 minutes) */
  Every_6Hours = 'EVERY_6_HOURS',
  /** 10 minute monitor period */
  Every_10Minutes = 'EVERY_10_MINUTES',
  /** 12 hour monitor period (720 minutes) */
  Every_12Hours = 'EVERY_12_HOURS',
  /** 15 minute monitor period */
  Every_15Minutes = 'EVERY_15_MINUTES',
  /** 30 minute monitor period */
  Every_30Minutes = 'EVERY_30_MINUTES',
  /** 1 day monitor period (1440 minutes) */
  EveryDay = 'EVERY_DAY',
  /** 1 hour monitor period (60 minutes) */
  EveryHour = 'EVERY_HOUR',
  /** 1 minute monitor period */
  EveryMinute = 'EVERY_MINUTE'
}

/** The result of a monitor script mutation */
export type SyntheticsMonitorScriptMutationResult = {
  __typename?: 'SyntheticsMonitorScriptMutationResult';
  /** An array containing errors, if any */
  errors?: Maybe<Array<Maybe<SyntheticsError>>>;
};

/** The script that a monitor runs */
export type SyntheticsMonitorScriptQueryResponse = {
  __typename?: 'SyntheticsMonitorScriptQueryResponse';
  /** The script associated with the specified monitor */
  text?: Maybe<Scalars['String']['output']>;
};

/** Run state of the monitor */
export enum SyntheticsMonitorStatus {
  /** Monitor disabled runs status of a monitor */
  Disabled = 'DISABLED',
  /**
   * Enabled status of a monitor
   * @deprecated The muted monitor status will be removed on February 29. Please use enabled status and monitor downtimes or muting rules instead.
   */
  Enabled = 'ENABLED',
  Muted = 'MUTED'
}

/** Enum of monitor types */
export enum SyntheticsMonitorType {
  /** Broken links monitor */
  BrokenLinks = 'BROKEN_LINKS',
  /** Simple browser monitor */
  Browser = 'BROWSER',
  /** Certificate Check */
  CertCheck = 'CERT_CHECK',
  /** Script API monitor */
  ScriptApi = 'SCRIPT_API',
  /** Script browser monitor */
  ScriptBrowser = 'SCRIPT_BROWSER',
  /** Simple (ping) monitor */
  Simple = 'SIMPLE',
  /** Step Monitor */
  StepMonitor = 'STEP_MONITOR'
}

/** Error object for Synthetics monitor update request */
export type SyntheticsMonitorUpdateError = {
  __typename?: 'SyntheticsMonitorUpdateError';
  /** String description of error */
  description: Scalars['String']['output'];
  /** Enum of error that was returned during monitor update */
  type: SyntheticsMonitorUpdateErrorType;
};

/** Types of errors that can be returned from a Monitor mutation request */
export enum SyntheticsMonitorUpdateErrorType {
  /** Received a request missing required fields or containing invalid data */
  BadRequest = 'BAD_REQUEST',
  /** An unknown error occurred while processing request to mutate monitor */
  InternalServerError = 'INTERNAL_SERVER_ERROR',
  /** Monitor not found for given guid (monitor does not exist on account or has already been deleted) */
  NotFound = 'NOT_FOUND',
  /** Monitor update exceeds account subscription limits */
  PaymentRequired = 'PAYMENT_REQUIRED',
  /** An error occurred while updating monitor script */
  ScriptError = 'SCRIPT_ERROR',
  /** Monitor tags were not updated. */
  TaggingError = 'TAGGING_ERROR',
  /** User does not have authorization to perform monitor mutation. */
  Unauthorized = 'UNAUTHORIZED',
  /** An unknown error occurred while processing request to update monitor */
  UnknownError = 'UNKNOWN_ERROR'
}

/** Monitor downtime object returned to the customer for a downtime run monthly */
export type SyntheticsMonthlyMonitorDowntimeMutationResult = {
  __typename?: 'SyntheticsMonthlyMonitorDowntimeMutationResult';
  /** The account ID associated with the monitor downtime */
  accountId?: Maybe<Scalars['Int']['output']>;
  /** Configuration options if the customer wants the monitor to end at a specific date */
  endRepeat?: Maybe<SyntheticsDateWindowEndOutput>;
  /** The date and time in which the monitor downtime will end */
  endTime?: Maybe<Scalars['NaiveDateTime']['output']>;
  /** Configuration options for which days of the month a monitor downtime will occur */
  frequency?: Maybe<SyntheticsMonitorDowntimeMonthlyFrequencyOutput>;
  /** The entity GUID associated with the monitor downtime */
  guid?: Maybe<Scalars['EntityGuid']['output']>;
  /** The monitor GUIDs associated with the monitor downtime */
  monitorGuids?: Maybe<Array<Maybe<Scalars['EntityGuid']['output']>>>;
  /** The name of the monitor downtime */
  name?: Maybe<Scalars['String']['output']>;
  /** The date and time in which the monitor downtime will begin */
  startTime?: Maybe<Scalars['NaiveDateTime']['output']>;
  /** The timezone the time values will be in */
  timezone?: Maybe<Scalars['String']['output']>;
};

/** Monitor downtime object returned to the customer for a downtime run once */
export type SyntheticsOnceMonitorDowntimeMutationResult = {
  __typename?: 'SyntheticsOnceMonitorDowntimeMutationResult';
  /** The account ID associated with the monitor downtime */
  accountId?: Maybe<Scalars['Int']['output']>;
  /** The date and time in which the monitor downtime will end */
  endTime?: Maybe<Scalars['NaiveDateTime']['output']>;
  /** The entity GUID associated with the monitor downtime */
  guid?: Maybe<Scalars['EntityGuid']['output']>;
  /** The monitor GUIDs associated with the monitor downtime */
  monitorGuids?: Maybe<Array<Maybe<Scalars['EntityGuid']['output']>>>;
  /** The name of the monitor downtime */
  name?: Maybe<Scalars['String']['output']>;
  /** The date and time in which the monitor downtime will begin */
  startTime?: Maybe<Scalars['NaiveDateTime']['output']>;
  /** The timezone the time values will be in */
  timezone?: Maybe<Scalars['String']['output']>;
};

/** Private Location data for private location query */
export type SyntheticsPrivateLocation = {
  __typename?: 'SyntheticsPrivateLocation';
  /** The account associated to the private location */
  accountId?: Maybe<Scalars['Int']['output']>;
  /** The unique client identifier for the Synthetics private location in New Relic */
  guid?: Maybe<Scalars['EntityGuid']['output']>;
  /** The private locations key */
  key?: Maybe<Scalars['String']['output']>;
  /** An alternate identifier based on name */
  locationId?: Maybe<Scalars['String']['output']>;
  /** The name of the private location */
  name?: Maybe<Scalars['String']['output']>;
  /** Specifies whether the private location requires a password for scripted monitors */
  verifiedScriptExecution?: Maybe<Scalars['Boolean']['output']>;
};

/** An array containing errors from the deletion of a private location, if any */
export type SyntheticsPrivateLocationDeleteResult = {
  __typename?: 'SyntheticsPrivateLocationDeleteResult';
  /** An array container errors resulting from the mutation, if any */
  errors?: Maybe<Array<Maybe<SyntheticsPrivateLocationMutationError>>>;
};

/** HMAC for private location */
export type SyntheticsPrivateLocationHmacInput = {
  /** HMAC */
  hmac: Scalars['String']['input'];
  /** Id of private location */
  locationId: Scalars['String']['input'];
};

/** Information realating to a private location */
export type SyntheticsPrivateLocationInput = {
  /** The unique identifier for the Synthetics private location in New Relic */
  guid: Scalars['ID']['input'];
  /** The location's Verified Script Execution password (Only necessary if Verified Script Execution is enabled for the location) */
  vsePassword?: InputMaybe<Scalars['SecureValue']['input']>;
};

/** Error object for Synthetic Private Location mutation request */
export type SyntheticsPrivateLocationMutationError = {
  __typename?: 'SyntheticsPrivateLocationMutationError';
  /** String description of error */
  description: Scalars['String']['output'];
  /** Enum type of error response */
  type: SyntheticsPrivateLocationMutationErrorType;
};

/** Types of errors that can be returned from a Private Location mutation request */
export enum SyntheticsPrivateLocationMutationErrorType {
  /** Received a request missing required fields or containing invalid data */
  BadRequest = 'BAD_REQUEST',
  /** An unknown error occurred while processing request to purge specified private location job queue */
  InternalServerError = 'INTERNAL_SERVER_ERROR',
  /** Private location not found for key (private location does not exist on account or has already been deleted) */
  NotFound = 'NOT_FOUND',
  /** User does not have authorization to purge job queue for specified private location */
  Unauthorized = 'UNAUTHORIZED'
}

/** Result of a private location mutation */
export type SyntheticsPrivateLocationMutationResult = {
  __typename?: 'SyntheticsPrivateLocationMutationResult';
  /** The account associated to the private location */
  accountId?: Maybe<Scalars['Int']['output']>;
  /** A description of the private location */
  description?: Maybe<Scalars['String']['output']>;
  /** The private location globally unique identifier */
  domainId?: Maybe<Scalars['String']['output']>;
  /** An array container errors resulting from the mutation, if any */
  errors?: Maybe<Array<Maybe<SyntheticsPrivateLocationMutationError>>>;
  /** The unique client identifier for the Synthetics private location in New Relic */
  guid?: Maybe<Scalars['EntityGuid']['output']>;
  /** The private locations key */
  key?: Maybe<Scalars['String']['output']>;
  /** An alternate identifier based on name */
  locationId?: Maybe<Scalars['String']['output']>;
  /** The name of the private location */
  name?: Maybe<Scalars['String']['output']>;
  /** Specifies whether the private location requires a password for scripted monitors */
  verifiedScriptExecution?: Maybe<Scalars['Boolean']['output']>;
};

/** Result of a Synthetics purge private location queue mutation */
export type SyntheticsPrivateLocationPurgeQueueResult = {
  __typename?: 'SyntheticsPrivateLocationPurgeQueueResult';
  /** An array containing errors resulting from the mutation, if any */
  errors?: Maybe<Array<Maybe<SyntheticsPrivateLocationMutationError>>>;
};

/** Public Location data for public location queries */
export type SyntheticsPublicLocation = {
  __typename?: 'SyntheticsPublicLocation';
  /** The city associated with the public location */
  city?: Maybe<Scalars['String']['output']>;
  /** The continent associated with the public location */
  continent?: Maybe<SyntheticsContinent>;
  /** The current status of the public location */
  currentStatus?: Maybe<SyntheticsPublicLocationStatus>;
  /** The public location statuses by hour for the past twelve hours */
  hourlyStatuses?: Maybe<Array<Maybe<SyntheticsPublicLocationHourlyStatus>>>;
  /** The name of the public location */
  name?: Maybe<Scalars['String']['output']>;
};

/** Time window specific status of a public location */
export type SyntheticsPublicLocationHourlyStatus = {
  __typename?: 'SyntheticsPublicLocationHourlyStatus';
  /** Beginning of time window */
  beginTimeSeconds?: Maybe<Scalars['EpochSeconds']['output']>;
  /** End of time window */
  endTimeSeconds?: Maybe<Scalars['EpochSeconds']['output']>;
  /** Status during the given time window */
  status?: Maybe<SyntheticsPublicLocationStatus>;
};

/** Public Location data for public location queries */
export type SyntheticsPublicLocationOutline = {
  __typename?: 'SyntheticsPublicLocationOutline';
  /** The city associated with the public location */
  city?: Maybe<Scalars['String']['output']>;
  /** The continent associated with the public location */
  continent?: Maybe<SyntheticsContinent>;
  /** The name of the public location */
  name?: Maybe<Scalars['String']['output']>;
  /** The current status of the public location */
  status?: Maybe<SyntheticsPublicLocationStatus>;
};

/** Possible public location statuses */
export enum SyntheticsPublicLocationStatus {
  /** Location is not operating within acceptable parameters */
  Degraded = 'DEGRADED',
  /** Location is operating within acceptable parameters */
  Operational = 'OPERATIONAL'
}

/** The result of a runMonitor mutation */
export type SyntheticsRunMonitorMutationResult = {
  __typename?: 'SyntheticsRunMonitorMutationResult';
  /** The unique identifier of the resulting check, if available */
  checkId?: Maybe<Scalars['String']['output']>;
  /** An array containing errors, if any */
  errors?: Maybe<Array<Maybe<SyntheticsError>>>;
};

/** The runtime that a monitor runs */
export type SyntheticsRuntime = {
  __typename?: 'SyntheticsRuntime';
  /** The runtime type that the monitor will run */
  runtimeType?: Maybe<Scalars['String']['output']>;
  /** The specific version of the runtime type selected */
  runtimeTypeVersion: Scalars['SemVer']['output'];
  /** The programing language that should execute the script */
  scriptLanguage?: Maybe<Scalars['String']['output']>;
};

/** Input to determine which runtime the monitor will run */
export type SyntheticsRuntimeInput = {
  /** The runtime type that the monitor will run */
  runtimeType: Scalars['String']['input'];
  /** The specific version of the runtime type selected */
  runtimeTypeVersion: Scalars['SemVer']['input'];
  /** The programing language that should execute the script */
  scriptLanguage?: InputMaybe<Scalars['String']['input']>;
};

/** A Script Api monitor resulting from a Script Api mutation */
export type SyntheticsScriptApiMonitor = {
  __typename?: 'SyntheticsScriptApiMonitor';
  /** The creation time of the monitor in millis */
  createdAt?: Maybe<Scalars['EpochMilliseconds']['output']>;
  /** The unique client identifier for the Synthetics Monitor in New Relic */
  guid?: Maybe<Scalars['EntityGuid']['output']>;
  /** The unique identifier of the monitor within the Synthetics domain */
  id?: Maybe<Scalars['ID']['output']>;
  /** The locations the monitor runs from */
  locations?: Maybe<SyntheticsLocations>;
  /** The last modification time of the monitor in millis */
  modifiedAt?: Maybe<Scalars['EpochMilliseconds']['output']>;
  /** The human readable identifier for the monitor */
  name?: Maybe<Scalars['String']['output']>;
  /** The interval at which the monitor runs in minutes */
  period?: Maybe<SyntheticsMonitorPeriod>;
  /** The runtime that the monitor will use to run jobs */
  runtime?: Maybe<SyntheticsRuntime>;
  /** The run state of the monitor */
  status?: Maybe<SyntheticsMonitorStatus>;
};

/** The result of a Script Api monitor create mutation */
export type SyntheticsScriptApiMonitorCreateMutationResult = {
  __typename?: 'SyntheticsScriptApiMonitorCreateMutationResult';
  /** Errors that occurred during Script Api monitor create mutation */
  errors: Array<Maybe<SyntheticsMonitorCreateError>>;
  /** The resulting Script Api monitor */
  monitor?: Maybe<SyntheticsScriptApiMonitor>;
};

/** The result of a Script Api monitor update mutation */
export type SyntheticsScriptApiMonitorUpdateMutationResult = {
  __typename?: 'SyntheticsScriptApiMonitorUpdateMutationResult';
  /** Errors that occurred during Script Api monitor update mutation */
  errors: Array<Maybe<SyntheticsMonitorUpdateError>>;
  /** The resulting Script Api monitor */
  monitor?: Maybe<SyntheticsScriptApiMonitor>;
};

/** A Script Browser monitor resulting from a Script Browser mutation */
export type SyntheticsScriptBrowserMonitor = {
  __typename?: 'SyntheticsScriptBrowserMonitor';
  /** The monitor advanced options */
  advancedOptions?: Maybe<SyntheticsScriptBrowserMonitorAdvancedOptions>;
  /** The creation time of the monitor in millis */
  createdAt?: Maybe<Scalars['EpochMilliseconds']['output']>;
  /** The unique client identifier for the Synthetics Monitor in New Relic */
  guid?: Maybe<Scalars['EntityGuid']['output']>;
  /** The unique identifier of the monitor within the Synthetics domain */
  id?: Maybe<Scalars['ID']['output']>;
  /** The locations the monitor runs from */
  locations?: Maybe<SyntheticsLocations>;
  /** The last modification time of the monitor in millis */
  modifiedAt?: Maybe<Scalars['EpochMilliseconds']['output']>;
  /** The human readable identifier for the monitor */
  name?: Maybe<Scalars['String']['output']>;
  /** The interval at which the monitor runs in minutes */
  period?: Maybe<SyntheticsMonitorPeriod>;
  /** The runtime that the monitor will use to run jobs */
  runtime?: Maybe<SyntheticsRuntime>;
  /** The run state of the monitor */
  status?: Maybe<SyntheticsMonitorStatus>;
};

/** The advanced options available for a Script Browser monitor */
export type SyntheticsScriptBrowserMonitorAdvancedOptions = {
  __typename?: 'SyntheticsScriptBrowserMonitorAdvancedOptions';
  /** Emulate a device */
  deviceEmulation?: Maybe<SyntheticsDeviceEmulation>;
  /** Capture a screenshot during job execution */
  enableScreenshotOnFailureAndScript?: Maybe<Scalars['Boolean']['output']>;
};

/** The advanced options inputs available for a Script Browser monitor */
export type SyntheticsScriptBrowserMonitorAdvancedOptionsInput = {
  /** Emulate a device */
  deviceEmulation?: InputMaybe<SyntheticsDeviceEmulationInput>;
  /** Capture a screenshot during job execution */
  enableScreenshotOnFailureAndScript?: InputMaybe<Scalars['Boolean']['input']>;
};

/** The result of a Script Browser monitor create mutation */
export type SyntheticsScriptBrowserMonitorCreateMutationResult = {
  __typename?: 'SyntheticsScriptBrowserMonitorCreateMutationResult';
  /** Errors that occurred during Script Browser monitor create mutation */
  errors: Array<Maybe<SyntheticsMonitorCreateError>>;
  /** The resulting script browser monitor */
  monitor?: Maybe<SyntheticsScriptBrowserMonitor>;
};

/** The result of a Script Browser monitor update mutation */
export type SyntheticsScriptBrowserMonitorUpdateMutationResult = {
  __typename?: 'SyntheticsScriptBrowserMonitorUpdateMutationResult';
  /** Errors that occurred during Script Browser monitor update mutation */
  errors: Array<Maybe<SyntheticsMonitorUpdateError>>;
  /** The resulting script browser monitor */
  monitor?: Maybe<SyntheticsScriptBrowserMonitor>;
};

/** Override a script url domain */
export type SyntheticsScriptDomainOverride = {
  __typename?: 'SyntheticsScriptDomainOverride';
  /** The target domain to override */
  domain?: Maybe<Scalars['String']['output']>;
  /** The override value for the domain */
  override?: Maybe<Scalars['String']['output']>;
};

/** Override a script url domain */
export type SyntheticsScriptDomainOverrideInput = {
  /** The target domain to override */
  domain?: InputMaybe<Scalars['String']['input']>;
  /** The override value for the domain */
  override?: InputMaybe<Scalars['String']['input']>;
};

/** Error object for Synthetics script validation trigger requests */
export type SyntheticsScriptValidationQueryError = {
  __typename?: 'SyntheticsScriptValidationQueryError';
  /** String description of error */
  description: Scalars['String']['output'];
  /** Enum type of error */
  type: SyntheticsScriptValidationQueryErrorType;
};

/** Types of errors that can be returned from a TriggerScriptValidation mutation */
export enum SyntheticsScriptValidationQueryErrorType {
  /** Received a request missing required fields or containing invalid data */
  BadRequest = 'BAD_REQUEST',
  /** Job not found for validation ID (data past retention rate, or job not yet complete) */
  NotFound = 'NOT_FOUND',
  /** User does not have authorization to perform a script validation on the specified account */
  Unauthorized = 'UNAUTHORIZED'
}

/** Results from a script validation job */
export type SyntheticsScriptValidationQueryResponse = {
  __typename?: 'SyntheticsScriptValidationQueryResponse';
  /** Error message for validation job */
  error?: Maybe<Scalars['String']['output']>;
  /** An array containing errors resulting from the query */
  errors?: Maybe<Array<Maybe<SyntheticsScriptValidationQueryError>>>;
  /** Formatted job results for validation job */
  jobResults?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
  /** URL to screenshot taken during validation */
  screenshot?: Maybe<Scalars['String']['output']>;
  /** Script log for validation job */
  scriptLog?: Maybe<Scalars['String']['output']>;
  /** Status of validation job */
  status?: Maybe<SyntheticsJobStatus>;
};

/** The location(s) from which the scripted monitor runs. */
export type SyntheticsScriptedMonitorLocationsInput = {
  /** The private location(s) that the monitor will run jobs from */
  private?: InputMaybe<Array<SyntheticsPrivateLocationInput>>;
  /** The public location(s) that the monitor will run jobs from */
  public?: InputMaybe<Array<Scalars['String']['input']>>;
};

/** The result of a secure credential mutation */
export type SyntheticsSecureCredentialMutationResult = {
  __typename?: 'SyntheticsSecureCredentialMutationResult';
  /** The moment when the secure credential was created, represented in milliseconds since the Unix epoch. */
  createdAt?: Maybe<Scalars['EpochMilliseconds']['output']>;
  /** Description of the secure credential, if available */
  description?: Maybe<Scalars['String']['output']>;
  /** An array containing errors, if any */
  errors?: Maybe<Array<Maybe<SyntheticsError>>>;
  /** The unique identifier of the secure credential, if available */
  key?: Maybe<Scalars['String']['output']>;
  /** The moment when the secure credential was last updated, represented in milliseconds since the Unix epoch. */
  lastUpdate?: Maybe<Scalars['EpochMilliseconds']['output']>;
};

/** Override a monitor scripts secure credential key with a different key */
export type SyntheticsSecureCredentialOverride = {
  __typename?: 'SyntheticsSecureCredentialOverride';
  /** The target secure credential key to override */
  key?: Maybe<Scalars['String']['output']>;
  /** The secure credential key override */
  overrideKey?: Maybe<Scalars['String']['output']>;
};

/** Override a monitor scripts secure credential key with a different key */
export type SyntheticsSecureCredentialOverrideInput = {
  /** The target secure credential key to override */
  key?: InputMaybe<Scalars['String']['input']>;
  /** The secure credential key override */
  overrideKey?: InputMaybe<Scalars['String']['input']>;
};

/** A Simple Browser monitor resulting from a Simple Browser monitor mutation */
export type SyntheticsSimpleBrowserMonitor = {
  __typename?: 'SyntheticsSimpleBrowserMonitor';
  /** The monitor advanced options */
  advancedOptions?: Maybe<SyntheticsSimpleBrowserMonitorAdvancedOptions>;
  /** The creation time of the monitor in millis */
  createdAt?: Maybe<Scalars['EpochMilliseconds']['output']>;
  /** The unique client identifier for the Synthetics Monitor in New Relic */
  guid?: Maybe<Scalars['EntityGuid']['output']>;
  /** The unique identifier of the monitor within the Synthetics domain */
  id?: Maybe<Scalars['ID']['output']>;
  /** The locations the monitor runs from */
  locations?: Maybe<SyntheticsLocations>;
  /** The last modification time of the monitor in millis */
  modifiedAt?: Maybe<Scalars['EpochMilliseconds']['output']>;
  /** The human readable identifier for the monitor */
  name?: Maybe<Scalars['String']['output']>;
  /** The interval at which the monitor runs in minutes */
  period?: Maybe<SyntheticsMonitorPeriod>;
  /** The runtime that the monitor will use to run jobs */
  runtime?: Maybe<SyntheticsRuntime>;
  /** The run state of the monitor */
  status?: Maybe<SyntheticsMonitorStatus>;
  /** The uri the monitor runs against */
  uri?: Maybe<Scalars['String']['output']>;
};

/** The advanced options available for a Simple Browser monitor */
export type SyntheticsSimpleBrowserMonitorAdvancedOptions = {
  __typename?: 'SyntheticsSimpleBrowserMonitorAdvancedOptions';
  /** Custom headers to use in monitor job */
  customHeaders?: Maybe<Array<Maybe<SyntheticsCustomHeader>>>;
  /** Emulate a device */
  deviceEmulation?: Maybe<SyntheticsDeviceEmulation>;
  /** Capture a screenshot during job execution */
  enableScreenshotOnFailureAndScript?: Maybe<Scalars['Boolean']['output']>;
  /** Validation text for monitor to search for at given URI */
  responseValidationText?: Maybe<Scalars['String']['output']>;
  /** Monitor should validate SSL certificate chain */
  useTlsValidation?: Maybe<Scalars['Boolean']['output']>;
};

/** The advanced options inputs available for a Simple Browser monitor */
export type SyntheticsSimpleBrowserMonitorAdvancedOptionsInput = {
  /** Custom headers to use in monitor job */
  customHeaders?: InputMaybe<Array<InputMaybe<SyntheticsCustomHeaderInput>>>;
  /** Emulate a device */
  deviceEmulation?: InputMaybe<SyntheticsDeviceEmulationInput>;
  /** Capture a screenshot during job execution */
  enableScreenshotOnFailureAndScript?: InputMaybe<Scalars['Boolean']['input']>;
  /** Validation text for monitor to search for at given URI */
  responseValidationText?: InputMaybe<Scalars['String']['input']>;
  /** Monitor should validate SSL certificate chain */
  useTlsValidation?: InputMaybe<Scalars['Boolean']['input']>;
};

/** The result of a Simple Browser monitor create mutation */
export type SyntheticsSimpleBrowserMonitorCreateMutationResult = {
  __typename?: 'SyntheticsSimpleBrowserMonitorCreateMutationResult';
  /** Errors that occurred during Simple Browser monitor create mutation */
  errors: Array<Maybe<SyntheticsMonitorCreateError>>;
  /** The resulting Simple Browser monitor */
  monitor?: Maybe<SyntheticsSimpleBrowserMonitor>;
};

/** The result of a Simple Browser monitor update mutation */
export type SyntheticsSimpleBrowserMonitorUpdateMutationResult = {
  __typename?: 'SyntheticsSimpleBrowserMonitorUpdateMutationResult';
  /** Errors that occurred during Simple Browser monitor update mutation */
  errors: Array<Maybe<SyntheticsMonitorUpdateError>>;
  /** The resulting Simple Browser monitor */
  monitor?: Maybe<SyntheticsSimpleBrowserMonitor>;
};

/** A Simple (ping) monitor resulting from a Simple monitor mutation */
export type SyntheticsSimpleMonitor = {
  __typename?: 'SyntheticsSimpleMonitor';
  /** The monitor advanced options */
  advancedOptions?: Maybe<SyntheticsSimpleMonitorAdvancedOptions>;
  /** The creation time of the monitor in millis */
  createdAt?: Maybe<Scalars['EpochMilliseconds']['output']>;
  /** The unique client identifier for the Synthetics Monitor in New Relic */
  guid?: Maybe<Scalars['EntityGuid']['output']>;
  /** The unique identifier of the monitor within the Synthetics domain */
  id?: Maybe<Scalars['ID']['output']>;
  /** The locations the monitor runs from */
  locations?: Maybe<SyntheticsLocations>;
  /** The last modification time of the monitor in millis */
  modifiedAt?: Maybe<Scalars['EpochMilliseconds']['output']>;
  /** The human readable identifier for the monitor */
  name?: Maybe<Scalars['String']['output']>;
  /** The interval at which the monitor runs in minutes */
  period?: Maybe<SyntheticsMonitorPeriod>;
  /** The run state of the monitor */
  status?: Maybe<SyntheticsMonitorStatus>;
  /** The uri the monitor runs against */
  uri?: Maybe<Scalars['String']['output']>;
};

/** The advanced options available for a Simple (ping) monitor */
export type SyntheticsSimpleMonitorAdvancedOptions = {
  __typename?: 'SyntheticsSimpleMonitorAdvancedOptions';
  /** Custom headers to use in monitor job */
  customHeaders?: Maybe<Array<Maybe<SyntheticsCustomHeader>>>;
  /** Categorize redirects during a monitor job as a failure */
  redirectIsFailure?: Maybe<Scalars['Boolean']['output']>;
  /** Validation text for monitor to search for at given URI */
  responseValidationText?: Maybe<Scalars['String']['output']>;
  /** Monitor should skip default HEAD request and instead use GET verb in check */
  shouldBypassHeadRequest?: Maybe<Scalars['Boolean']['output']>;
  /** Monitor should validate SSL certificate chain */
  useTlsValidation?: Maybe<Scalars['Boolean']['output']>;
};

/** The advanced options inputs available for a Simple (ping) monitor */
export type SyntheticsSimpleMonitorAdvancedOptionsInput = {
  /** Custom headers to use in monitor job */
  customHeaders?: InputMaybe<Array<InputMaybe<SyntheticsCustomHeaderInput>>>;
  /** Categorize redirects during a monitor job as a failure */
  redirectIsFailure?: InputMaybe<Scalars['Boolean']['input']>;
  /** Validation text for monitor to search for at given URI */
  responseValidationText?: InputMaybe<Scalars['String']['input']>;
  /** Monitor should skip default HEAD request and instead use GET verb in check */
  shouldBypassHeadRequest?: InputMaybe<Scalars['Boolean']['input']>;
  /** Monitor should validate SSL certificate chain */
  useTlsValidation?: InputMaybe<Scalars['Boolean']['input']>;
};

/** The result of a Simple (ping) monitor update mutation */
export type SyntheticsSimpleMonitorUpdateMutationResult = {
  __typename?: 'SyntheticsSimpleMonitorUpdateMutationResult';
  /** Errors that occurred during Simple (ping) monitor update mutation */
  errors: Array<Maybe<SyntheticsMonitorUpdateError>>;
  /** The resulting Simple (ping) monitor */
  monitor?: Maybe<SyntheticsSimpleMonitor>;
};

/** A step that will be added to the monitor script */
export type SyntheticsStep = {
  __typename?: 'SyntheticsStep';
  /** The position of the step within the script ranging from 1-100. */
  ordinal: Scalars['Int']['output'];
  /** The type of step to be added to the script */
  type: SyntheticsStepType;
  /** The metadata values related to the step */
  values?: Maybe<Array<Scalars['String']['output']>>;
};

/** A step that will be added to the monitor script */
export type SyntheticsStepInput = {
  /** The position of the step within the script ranging from 1-100. */
  ordinal: Scalars['Int']['input'];
  /** The type of step to be added to the script */
  type: SyntheticsStepType;
  /** The metadata values related to the step */
  values?: InputMaybe<Array<Scalars['String']['input']>>;
};

/** A Step monitor resulting from a Step monitor mutation */
export type SyntheticsStepMonitor = {
  __typename?: 'SyntheticsStepMonitor';
  /** The monitor advanced options */
  advancedOptions?: Maybe<SyntheticsStepMonitorAdvancedOptions>;
  /** The creation time of the monitor in millis */
  createdAt?: Maybe<Scalars['EpochMilliseconds']['output']>;
  /** The unique client identifier for the Synthetics Monitor in New Relic */
  guid?: Maybe<Scalars['EntityGuid']['output']>;
  /** The unique identifier of the monitor within the Synthetics domain */
  id?: Maybe<Scalars['ID']['output']>;
  /** The locations the monitor runs from */
  locations?: Maybe<SyntheticsLocations>;
  /** The last modification time of the monitor in millis */
  modifiedAt?: Maybe<Scalars['EpochMilliseconds']['output']>;
  /** The human readable identifier for the monitor */
  name?: Maybe<Scalars['String']['output']>;
  /** The interval at which the monitor runs in minutes */
  period?: Maybe<SyntheticsMonitorPeriod>;
  /** The runtime that the monitor will use to run jobs */
  runtime?: Maybe<SyntheticsExtendedTypeMonitorRuntime>;
  /** The run state of the monitor */
  status?: Maybe<SyntheticsMonitorStatus>;
  /** The steps that make up the script the monitor will run */
  steps?: Maybe<Array<Maybe<SyntheticsStep>>>;
};

/** The advanced options available for a Step monitor */
export type SyntheticsStepMonitorAdvancedOptions = {
  __typename?: 'SyntheticsStepMonitorAdvancedOptions';
  /** Capture a screenshot during job execution */
  enableScreenshotOnFailureAndScript?: Maybe<Scalars['Boolean']['output']>;
};

/** The advanced options inputs available for a Step monitor */
export type SyntheticsStepMonitorAdvancedOptionsInput = {
  /** Capture a screenshot during job execution */
  enableScreenshotOnFailureAndScript?: InputMaybe<Scalars['Boolean']['input']>;
};

/** The result of a Step monitor create mutation */
export type SyntheticsStepMonitorCreateMutationResult = {
  __typename?: 'SyntheticsStepMonitorCreateMutationResult';
  /** Errors that occurred during Step monitor create mutation */
  errors: Array<Maybe<SyntheticsMonitorCreateError>>;
  /** The resulting Step monitor */
  monitor?: Maybe<SyntheticsStepMonitor>;
};

/** The result of a Step monitor update mutation */
export type SyntheticsStepMonitorUpdateMutationResult = {
  __typename?: 'SyntheticsStepMonitorUpdateMutationResult';
  /** Errors that occurred during Step monitor update mutation */
  errors: Array<Maybe<SyntheticsMonitorUpdateError>>;
  /** The resulting Step monitor */
  monitor?: Maybe<SyntheticsStepMonitor>;
};

/** enum of of script step types */
export enum SyntheticsStepType {
  /** Assert on element accessed by ID, CSS, or x-path */
  AssertElement = 'ASSERT_ELEMENT',
  /** Assert on modal exists */
  AssertModal = 'ASSERT_MODAL',
  /** Assert on text accessed by ID, CSS, or x-path */
  AssertText = 'ASSERT_TEXT',
  /** Assert on title of page */
  AssertTitle = 'ASSERT_TITLE',
  /** Click on an element by ID, CSS, or x-path */
  ClickElement = 'CLICK_ELEMENT',
  /** Preform actions on a modal to dismiss */
  DismissModal = 'DISMISS_MODAL',
  /** Double click on an element by ID, CSS, or x-path */
  DoubleClickElement = 'DOUBLE_CLICK_ELEMENT',
  /** Hover over an element by x-path */
  HoverElement = 'HOVER_ELEMENT',
  /** Navigate to the specified url */
  Navigate = 'NAVIGATE',
  /** Input secure credential into element accessed by ID, CSS, or x-path */
  SecureTextEntry = 'SECURE_TEXT_ENTRY',
  /** Select a dropdown element by value, text, ID, CSS, or x-path */
  SelectElement = 'SELECT_ELEMENT',
  /** Input text into element accessed by ID, CSS, or x-path */
  TextEntry = 'TEXT_ENTRY'
}

/** Asset produced during the execution of the check */
export type SyntheticsSyntheticMonitorAsset = {
  __typename?: 'SyntheticsSyntheticMonitorAsset';
  /** MIME type of asset */
  type?: Maybe<Scalars['String']['output']>;
  /** Temporary url at which the asset is available for download */
  url?: Maybe<Scalars['String']['output']>;
};

/** Tag entries for the monitor */
export type SyntheticsTag = {
  /** Name of the tag key */
  key: Scalars['String']['input'];
  /** Values associated with the tag key */
  values: Array<InputMaybe<Scalars['String']['input']>>;
};

/** Error object for Synthetics script validation trigger requests */
export type SyntheticsTriggerScriptValidationError = {
  __typename?: 'SyntheticsTriggerScriptValidationError';
  /** Description of error response */
  description: Scalars['String']['output'];
  /** Enum type of error response */
  type: SyntheticsTriggerScriptValidationErrorType;
};

/** Types of errors that can be returned from a TriggerScriptValidation mutation */
export enum SyntheticsTriggerScriptValidationErrorType {
  /** Received a request missing required fields or containing invalid data */
  BadRequest = 'BAD_REQUEST',
  /** User does not have authorization to perform a script validation on the specified account */
  Unauthorized = 'UNAUTHORIZED'
}

/** Metadata returned from triggering a script validation */
export type SyntheticsTriggerScriptValidationResponse = {
  __typename?: 'SyntheticsTriggerScriptValidationResponse';
  /** An array containing errors in the request, if any */
  errors?: Maybe<Array<Maybe<SyntheticsTriggerScriptValidationError>>>;
  /** The location in which the validation job runs */
  location?: Maybe<Scalars['String']['output']>;
  /** The unique identifier of the resulting check, if available */
  validationId?: Maybe<Scalars['String']['output']>;
};

/** The monitor values that can be updated on a Broken Links monitor */
export type SyntheticsUpdateBrokenLinksMonitorInput = {
  /** The monitor's Apdex target used to populate SLA reports */
  apdexTarget?: InputMaybe<Scalars['Float']['input']>;
  /** The locations the monitor will run from */
  locations?: InputMaybe<SyntheticsLocationsInput>;
  /** The human readable identifier for the monitor */
  name?: InputMaybe<Scalars['String']['input']>;
  /** The interval at which the monitor runs in minutes */
  period?: InputMaybe<SyntheticsMonitorPeriod>;
  /** The runtime that the monitor will use to run jobs. The only accepted values are runtimeType: NODE_API & runtimeTypeVersion: 16.10 */
  runtime?: InputMaybe<SyntheticsExtendedTypeMonitorRuntimeInput>;
  /** The run state of the monitor */
  status?: InputMaybe<SyntheticsMonitorStatus>;
  /** The tags that will be associated with the monitor */
  tags?: InputMaybe<Array<InputMaybe<SyntheticsTag>>>;
  /** The uri the monitor runs against */
  uri?: InputMaybe<Scalars['String']['input']>;
};

/** The monitor values that can be updated on a Cert Check monitor */
export type SyntheticsUpdateCertCheckMonitorInput = {
  /** The monitor's Apdex target used to populate SLA reports */
  apdexTarget?: InputMaybe<Scalars['Float']['input']>;
  /** The domain of the host that will have its certificate checked */
  domain?: InputMaybe<Scalars['String']['input']>;
  /** The locations the monitor will run from */
  locations?: InputMaybe<SyntheticsLocationsInput>;
  /** The human readable identifier for the monitor */
  name?: InputMaybe<Scalars['String']['input']>;
  /** The desired number of remaining days until the certificate expires to trigger a monitor failure */
  numberDaysToFailBeforeCertExpires?: InputMaybe<Scalars['Int']['input']>;
  /** The interval at which the monitor runs in minutes */
  period?: InputMaybe<SyntheticsMonitorPeriod>;
  /** The runtime that the monitor will use to run jobs. The only accepted values are runtimeType: NODE_API & runtimeTypeVersion: 16.10 */
  runtime?: InputMaybe<SyntheticsExtendedTypeMonitorRuntimeInput>;
  /** The run state of the monitor */
  status?: InputMaybe<SyntheticsMonitorStatus>;
  /** The tags that will be associated with the monitor */
  tags?: InputMaybe<Array<InputMaybe<SyntheticsTag>>>;
};

/** The monitor values that can be updated on a Script Api monitor */
export type SyntheticsUpdateScriptApiMonitorInput = {
  /** The monitor's Apdex target used to populate SLA reports */
  apdexTarget?: InputMaybe<Scalars['Float']['input']>;
  /** The locations the monitor will run from */
  locations?: InputMaybe<SyntheticsScriptedMonitorLocationsInput>;
  /** The human readable identifier for the monitor */
  name?: InputMaybe<Scalars['String']['input']>;
  /** The interval at which the monitor runs in minutes */
  period?: InputMaybe<SyntheticsMonitorPeriod>;
  /** The runtime that the monitor will use to run jobs */
  runtime?: InputMaybe<SyntheticsRuntimeInput>;
  /** The script that the monitor runs */
  script?: InputMaybe<Scalars['String']['input']>;
  /** The run state of the monitor */
  status?: InputMaybe<SyntheticsMonitorStatus>;
  /** The tags that will be associated with the monitor */
  tags?: InputMaybe<Array<InputMaybe<SyntheticsTag>>>;
};

/** The monitor values that can be updated on a Script Browser monitor */
export type SyntheticsUpdateScriptBrowserMonitorInput = {
  /** The monitor advanced options */
  advancedOptions?: InputMaybe<SyntheticsScriptBrowserMonitorAdvancedOptionsInput>;
  /** The monitor's Apdex target used to populate SLA reports */
  apdexTarget?: InputMaybe<Scalars['Float']['input']>;
  /** The locations the monitor will run from */
  locations?: InputMaybe<SyntheticsScriptedMonitorLocationsInput>;
  /** The human readable identifier for the monitor */
  name?: InputMaybe<Scalars['String']['input']>;
  /** The interval at which the monitor runs in minutes */
  period?: InputMaybe<SyntheticsMonitorPeriod>;
  /** The runtime that the monitor will use to run jobs */
  runtime?: InputMaybe<SyntheticsRuntimeInput>;
  /** The script that the monitor runs */
  script?: InputMaybe<Scalars['String']['input']>;
  /** The run state of the monitor */
  status?: InputMaybe<SyntheticsMonitorStatus>;
  /** The tags that will be associated with the monitor */
  tags?: InputMaybe<Array<InputMaybe<SyntheticsTag>>>;
};

/** The monitor values that can be updated on a Simple Browser monitor */
export type SyntheticsUpdateSimpleBrowserMonitorInput = {
  /** The monitor advanced options */
  advancedOptions?: InputMaybe<SyntheticsSimpleBrowserMonitorAdvancedOptionsInput>;
  /** The monitor's Apdex target used to populate SLA reports */
  apdexTarget?: InputMaybe<Scalars['Float']['input']>;
  /** The locations the monitor will run from */
  locations?: InputMaybe<SyntheticsLocationsInput>;
  /** The human readable identifier for the monitor */
  name?: InputMaybe<Scalars['String']['input']>;
  /** The interval at which the monitor runs in minutes */
  period?: InputMaybe<SyntheticsMonitorPeriod>;
  /** The runtime that the monitor will use to run jobs */
  runtime?: InputMaybe<SyntheticsRuntimeInput>;
  /** The run state of the monitor */
  status?: InputMaybe<SyntheticsMonitorStatus>;
  /** The tags that will be associated with the monitor */
  tags?: InputMaybe<Array<InputMaybe<SyntheticsTag>>>;
  /** The uri the monitor runs against */
  uri?: InputMaybe<Scalars['String']['input']>;
};

/** The monitor values that can be updated on a simple (ping) monitor */
export type SyntheticsUpdateSimpleMonitorInput = {
  /** The monitor advanced options */
  advancedOptions?: InputMaybe<SyntheticsSimpleMonitorAdvancedOptionsInput>;
  /** The monitor's Apdex target used to populate SLA reports */
  apdexTarget?: InputMaybe<Scalars['Float']['input']>;
  /** The locations the monitor will run from */
  locations?: InputMaybe<SyntheticsLocationsInput>;
  /** The human readable identifier for the monitor */
  name?: InputMaybe<Scalars['String']['input']>;
  /** The interval at which the monitor runs in minutes */
  period?: InputMaybe<SyntheticsMonitorPeriod>;
  /** The run state of the monitor */
  status?: InputMaybe<SyntheticsMonitorStatus>;
  /** The tags that will be associated with the monitor */
  tags?: InputMaybe<Array<InputMaybe<SyntheticsTag>>>;
  /** The uri the monitor runs against */
  uri?: InputMaybe<Scalars['String']['input']>;
};

/** The monitor values that can be updated on a Step monitor */
export type SyntheticsUpdateStepMonitorInput = {
  /** The monitor advanced options */
  advancedOptions?: InputMaybe<SyntheticsStepMonitorAdvancedOptionsInput>;
  /** The monitor's Apdex target used to populate SLA reports */
  apdexTarget?: InputMaybe<Scalars['Float']['input']>;
  /** The locations the monitor will run from */
  locations?: InputMaybe<SyntheticsScriptedMonitorLocationsInput>;
  /** The human readable identifier for the monitor */
  name?: InputMaybe<Scalars['String']['input']>;
  /** The interval at which the monitor runs in minutes */
  period?: InputMaybe<SyntheticsMonitorPeriod>;
  /** The runtime that the monitor will use to run jobs. The only accepted values are runtimeType: CHROME_BROWSER & runtimeTypeVersion: 100 */
  runtime?: InputMaybe<SyntheticsExtendedTypeMonitorRuntimeInput>;
  /** The run state of the monitor */
  status?: InputMaybe<SyntheticsMonitorStatus>;
  /** The steps that make up the script the monitor will run */
  steps?: InputMaybe<Array<InputMaybe<SyntheticsStepInput>>>;
  /** The tags that will be associated with the monitor */
  tags?: InputMaybe<Array<InputMaybe<SyntheticsTag>>>;
};

/** Returned after upgrading a set of monitors */
export type SyntheticsUpgradeMonitorRuntimeResult = {
  __typename?: 'SyntheticsUpgradeMonitorRuntimeResult';
  /** status */
  status?: Maybe<Scalars['String']['output']>;
};

/** Statuses for monitor validations */
export enum SyntheticsValidationStatus {
  /** validation failed */
  Failed = 'FAILED',
  /** validation failed due to an unexpected error */
  InternalError = 'INTERNAL_ERROR',
  /** validation was invalidated */
  Invalidated = 'INVALIDATED',
  /** validation in progress */
  InProgress = 'IN_PROGRESS',
  /** validation passed */
  Passed = 'PASSED'
}

/** Monitor downtime object returned to the customer for a downtime run weekly */
export type SyntheticsWeeklyMonitorDowntimeMutationResult = {
  __typename?: 'SyntheticsWeeklyMonitorDowntimeMutationResult';
  /** The account ID associated with the monitor downtime */
  accountId?: Maybe<Scalars['Int']['output']>;
  /** Configuration options if the customer wants the monitor to end at a specific date */
  endRepeat?: Maybe<SyntheticsDateWindowEndOutput>;
  /** The date and time in which the monitor downtime will end */
  endTime?: Maybe<Scalars['NaiveDateTime']['output']>;
  /** The entity GUID associated with the monitor downtime */
  guid?: Maybe<Scalars['EntityGuid']['output']>;
  /** Days of the week the monitor downtime will run */
  maintenanceDays?: Maybe<Array<Maybe<SyntheticsMonitorDowntimeWeekDays>>>;
  /** The monitor GUIDs associated with the monitor downtime */
  monitorGuids?: Maybe<Array<Maybe<Scalars['EntityGuid']['output']>>>;
  /** The name of the monitor downtime */
  name?: Maybe<Scalars['String']['output']>;
  /** The date and time in which the monitor downtime will begin */
  startTime?: Maybe<Scalars['NaiveDateTime']['output']>;
  /** The timezone the time values will be in */
  timezone?: Maybe<Scalars['String']['output']>;
};

/** Retrieves up to 200 tag key values. For keys with more than one value individual TagKeyValues results are returned. Each optional field in this query adds restrictions to the search, this means that only tags that match all the criteria are returned. */
export type TaggingActorStitchedFields = {
  __typename?: 'TaggingActorStitchedFields';
  /** Retrieves up to 200 tag keys ordered by the entitiesCount (number of entities that contain the key). Each optional field in this query adds restrictions to the search, this means that only the key of tags that match all the criteria are returned. */
  tagKeysSearch?: Maybe<TaggingTagKeys>;
  /** Retrieves up to 200 tag key values. For keys with more than one value individual TagKeyValues results are returned. Each optional field in this query adds restrictions to the search, this means that only tags that match all the criteria are returned. */
  tagsSearch?: Maybe<TaggingTagKeyValues>;
};


/** Retrieves up to 200 tag key values. For keys with more than one value individual TagKeyValues results are returned. Each optional field in this query adds restrictions to the search, this means that only tags that match all the criteria are returned. */
export type TaggingActorStitchedFieldsTagKeysSearchArgs = {
  accountIds?: InputMaybe<Array<Scalars['Int']['input']>>;
  domainTypes?: InputMaybe<Array<TaggingDomainType>>;
  entityQuery?: InputMaybe<Scalars['String']['input']>;
  pattern?: InputMaybe<Scalars['String']['input']>;
  tagQuery?: InputMaybe<Scalars['String']['input']>;
  tagsCasing?: InputMaybe<TaggingTagsCasing>;
};


/** Retrieves up to 200 tag key values. For keys with more than one value individual TagKeyValues results are returned. Each optional field in this query adds restrictions to the search, this means that only tags that match all the criteria are returned. */
export type TaggingActorStitchedFieldsTagsSearchArgs = {
  accountIds?: InputMaybe<Array<Scalars['Int']['input']>>;
  domainTypes?: InputMaybe<Array<TaggingDomainType>>;
  entityQuery?: InputMaybe<Scalars['String']['input']>;
  pattern?: InputMaybe<Scalars['String']['input']>;
  query?: InputMaybe<Scalars['String']['input']>;
  tagKey?: InputMaybe<Scalars['String']['input']>;
  tagQuery?: InputMaybe<Scalars['String']['input']>;
  tagsCasing?: InputMaybe<TaggingTagsCasing>;
};

/** An object that describes the domain and type of entities. */
export type TaggingDomainType = {
  /** Domain of an entity. */
  domain?: InputMaybe<Scalars['String']['input']>;
  /** Type of an entity within the given domain. */
  type?: InputMaybe<Scalars['String']['input']>;
};

/** An error object for tag mutations. */
export type TaggingMutationError = {
  __typename?: 'TaggingMutationError';
  /** A message explaining what the errors is about. */
  message?: Maybe<Scalars['String']['output']>;
  /** The type of error. */
  type?: Maybe<TaggingMutationErrorType>;
};

/** The different types of errors the API can return. */
export enum TaggingMutationErrorType {
  /** Too many concurrent tasks for the same GUID are being sent and we cannot process. Please serialize your requests for the given GUID. */
  ConcurrentTaskException = 'CONCURRENT_TASK_EXCEPTION',
  /** Domain Type invalid. The decoded domain type from the provided GUID is not valid. Please provide a correct GUID. */
  InvalidDomainType = 'INVALID_DOMAIN_TYPE',
  /** We could not decode the provided GUID. Entity guid needs to be base64 encoded. */
  InvalidEntityGuid = 'INVALID_ENTITY_GUID',
  /** The tag key is not valid. Char length has been reached, contains a disallowed character(eg :) or is empty */
  InvalidKey = 'INVALID_KEY',
  /** The tag value is not valid. Char length has been reached, contains a disallowed character(eg :) or is empty */
  InvalidValue = 'INVALID_VALUE',
  /** The given GUID or tag you're looking for does not exist. */
  NotFound = 'NOT_FOUND',
  /** You've attempted to do something your Domain/EntityType is not permitted to do. Its also possible that an api key is required. */
  NotPermitted = 'NOT_PERMITTED',
  /** One of the query filters exceeds the character limit. */
  TooManyCharsQueryFilter = 'TOO_MANY_CHARS_QUERY_FILTER',
  /** The given entity has reached its tag key count limit. You will need to delete existing tags for the given GUID before continuing. */
  TooManyTagKeys = 'TOO_MANY_TAG_KEYS',
  /** The given entity has reached its tag value count limit. You will need to delete existing values for the given GUID before continuing. */
  TooManyTagValues = 'TOO_MANY_TAG_VALUES',
  /** The changes will be reflected in the entity with some delay */
  UpdateWillBeDelayed = 'UPDATE_WILL_BE_DELAYED'
}

/** The result of a tag mutation */
export type TaggingMutationResult = {
  __typename?: 'TaggingMutationResult';
  /** An array containing errors, if any. These are expected errors listed in TagMutationErrorType which a request should be capable of handling appropriately. */
  errors?: Maybe<Array<Maybe<TaggingMutationError>>>;
};

/** An object that represents a tag key-values pair. */
export type TaggingTagInput = {
  /** The tag key. */
  key: Scalars['String']['input'];
  /** The tag values. */
  values?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
};

/** An object that represents a tag key and some statistics about it. */
export type TaggingTagKey = {
  __typename?: 'TaggingTagKey';
  /** The number of entities that contain the key. */
  entitiesCount?: Maybe<Scalars['Int']['output']>;
  /** The tag key. */
  key?: Maybe<Scalars['String']['output']>;
  /** The count of distinct values for the key. */
  uniqueValueCount?: Maybe<Scalars['Int']['output']>;
};

/** An object that represents a tag key value. */
export type TaggingTagKeyValue = {
  __typename?: 'TaggingTagKeyValue';
  /** Number of entities that contain the key:value */
  entitiesCount?: Maybe<Scalars['Int']['output']>;
  /** The tag key. */
  key?: Maybe<Scalars['String']['output']>;
  /** The tag key:value pair. */
  keyValue?: Maybe<Scalars['String']['output']>;
  /** The tag value. */
  value?: Maybe<Scalars['String']['output']>;
};

/** An object that encapsulates the result of the tag key value search. */
export type TaggingTagKeyValues = {
  __typename?: 'TaggingTagKeyValues';
  /** Representation of the results. */
  results?: Maybe<TaggingTagsSearchResult>;
};

/** An object that encapsulates the result of the tag key search. */
export type TaggingTagKeys = {
  __typename?: 'TaggingTagKeys';
  /** Representation of the results. */
  results?: Maybe<TaggingTagKeysSearchResult>;
};

/** An object that represents the result of the tag key search. */
export type TaggingTagKeysSearchResult = {
  __typename?: 'TaggingTagKeysSearchResult';
  /** List of tag keys. */
  tagKeys?: Maybe<Array<Maybe<TaggingTagKey>>>;
};

/** An object that represents a tag key-value pair */
export type TaggingTagValueInput = {
  /** The tag key. */
  key: Scalars['String']['input'];
  /** The tag value. */
  value: Scalars['String']['input'];
};

/** The optional casing option for tag searches */
export enum TaggingTagsCasing {
  /** Case insentitive */
  CaseInsensitive = 'CASE_INSENSITIVE',
  /** Case sentitive */
  CaseSensitive = 'CASE_SENSITIVE'
}

/** An object that represents the result of the tag key value search. */
export type TaggingTagsSearchResult = {
  __typename?: 'TaggingTagsSearchResult';
  /** List of TagKeyValues. */
  tags?: Maybe<Array<Maybe<TaggingTagKeyValue>>>;
};

/** Metadata about an user action */
export type TeamActionMetadata = {
  __typename?: 'TeamActionMetadata';
  /** When the used performed the action, represented in milliseconds since the Unix epoch. */
  timestamp?: Maybe<Scalars['EpochMilliseconds']['output']>;
  /** The user who performed the action. */
  user?: Maybe<UserReference>;
};

/** Type defined so its fields will be merged directly into NerdGraph's actor type */
export type TeamActorStitchedFields = {
  __typename?: 'TeamActorStitchedFields';
  /** List of teams to which the user belongs */
  teamMembership?: Maybe<Array<Maybe<TeamDefinition>>>;
};

/** The input object that represents the Team that will be created */
export type TeamCreateInput = {
  /** List of aliases associated to the team */
  aliases?: InputMaybe<Array<Scalars['String']['input']>>;
  /** The description of the Team */
  description?: InputMaybe<Scalars['String']['input']>;
  /** List of members belonging to the team */
  members?: InputMaybe<Array<TeamMemberInput>>;
  /** The name of the Team */
  name: Scalars['String']['input'];
  /** Initial list of resources */
  resources?: InputMaybe<Array<TeamResourceInput>>;
  /** A list of entities owned by the Team */
  staticEntityGuids?: InputMaybe<Array<Scalars['EntityGuid']['input']>>;
};

/** TeamDefinition represents a team after a mutation has been applied */
export type TeamDefinition = {
  __typename?: 'TeamDefinition';
  /** List of aliases associated to the team */
  aliases?: Maybe<Array<Scalars['String']['output']>>;
  /** Metadata about team creation action */
  createdMetadata?: Maybe<TeamActionMetadata>;
  /** Team visible description for final user interface */
  description?: Maybe<Scalars['String']['output']>;
  /** List of the entities owned by the team */
  entities?: Maybe<TeamEntities>;
  /** Team Entity identifier in New Relic */
  guid: Scalars['EntityGuid']['output'];
  /** List of members belonging to the team */
  members?: Maybe<Array<TeamMember>>;
  /** Team visible name for user interface */
  name: Scalars['String']['output'];
  /** List of resources attached to the team */
  resources?: Maybe<Array<TeamResource>>;
  /** Metadata about team last update operation */
  updatedMetadata?: Maybe<TeamActionMetadata>;
};

/** Discovery related settings */
export type TeamDiscoverySettings = {
  __typename?: 'TeamDiscoverySettings';
  /** Is discovery is enabled for that organization or not */
  enabled: Scalars['Boolean']['output'];
  /** Tag keys used for discovery for the organization */
  tags: Array<Scalars['String']['output']>;
};

/** Input to edit discovery settings */
export type TeamDiscoverySettingsInput = {
  /** Is discovery enabled */
  enabled?: InputMaybe<Scalars['Boolean']['input']>;
  /** Tag keys used for discovery for the organization */
  tags?: InputMaybe<Array<Scalars['String']['input']>>;
};

/** A list of entities owned by a Team */
export type TeamEntities = {
  __typename?: 'TeamEntities';
  /** The entity search query that returns the full collection of entities owned by the team. */
  entitySearchQuery: Scalars['String']['output'];
  /** List of the static entities owned by the team */
  static?: Maybe<Array<EntityOutline>>;
};

/** A Team entity. */
export type TeamEntity = AlertableEntity & CollectionEntity & Entity & {
  __typename?: 'TeamEntity';
  account?: Maybe<AccountOutline>;
  /** The New Relic account ID associated with this entity. */
  accountId?: Maybe<Scalars['Int']['output']>;
  /** The current alerting severity of the entity. */
  alertSeverity?: Maybe<EntityAlertSeverity>;
  /**
   * The alert status of the entity.
   * @deprecated Please use `alertSeverity` and `reporting`
   */
  alertStatus?: Maybe<EntityAlertStatus>;
  /** Violations on the entity that were open during the specified time window. This will return up to 500 violations - if there are more in the time window selected, you must narrow the time window or look at fewer entities. */
  alertViolations?: Maybe<Array<Maybe<EntityAlertViolation>>>;
  /** List of aliases associated to the team */
  aliases?: Maybe<Array<Scalars['String']['output']>>;
  collection?: Maybe<EntityCollection>;
  /** Metadata about team creation action */
  createdMetadata?: Maybe<TeamActionMetadata>;
  /** Retrieve the deployment event(s). Ordered by timestamp DESC. */
  deploymentSearch?: Maybe<ChangeTrackingDeploymentSearchResult>;
  /** Further information about team */
  description?: Maybe<Scalars['String']['output']>;
  /** The entity's domain */
  domain?: Maybe<Scalars['String']['output']>;
  /** List of the entities owned by the team */
  entities?: Maybe<TeamEntities>;
  /** A value representing the combination of the entity's domain and type. */
  entityType?: Maybe<EntityType>;
  /** The date of last time the entity has updated any of its fields. */
  firstIndexedAt?: Maybe<Scalars['EpochMilliseconds']['output']>;
  /** The list of golden metrics for a specific entity */
  goldenMetrics?: Maybe<EntityGoldenContextScopedGoldenMetrics>;
  /**
   * For the golden signal on this entity, show correlated signals from related entities.
   * Well inspect the golden signals for all related entities and return a sorted list.
   * You can also filter the results.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  goldenSignalCorrelations?: Maybe<GoldenSignalCorrelationResult>;
  /**
   * The deviation from normal of golden signal(s) for the given entity.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  goldenSignalDeviations?: Maybe<Array<Maybe<GoldenSignalSignalDeviation>>>;
  /**
   * The stored golden signal(s) for the given entity.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  goldenSignalValues?: Maybe<GoldenSignalValues>;
  /**
   * The stored golden signal(s) for the given entity. To be removed, use goldenSignalValues instead.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  goldenSignalValuesV2?: Maybe<GoldenSignalValues>;
  /** The list of golden tags for a specific entityType. */
  goldenTags?: Maybe<EntityGoldenContextScopedGoldenTags>;
  /** A unique entity identifier. */
  guid?: Maybe<Scalars['EntityGuid']['output']>;
  /** The time the entity was indexed. */
  indexedAt?: Maybe<Scalars['EpochMilliseconds']['output']>;
  /** The last time the entity's reporting status changed. */
  lastReportingChangeAt?: Maybe<Scalars['EpochMilliseconds']['output']>;
  /** List of members belonging to the team */
  members?: Maybe<Array<TeamMember>>;
  /** The name of this entity. */
  name?: Maybe<Scalars['String']['output']>;
  nerdStorage?: Maybe<NerdStorageEntityScope>;
  nerdStoreCollection?: Maybe<Array<Maybe<NerdStoreCollectionMember>>>;
  nerdStoreDocument?: Maybe<Scalars['NerdStoreDocument']['output']>;
  /**
   * Make an `Entity` scoped query to NRDB with a NRQL string.
   *
   * A relevant `WHERE` clause will be added to your query to scope data to the entity in question.
   *
   * See the [NRQL Docs](https://docs.newrelic.com/docs/insights/nrql-new-relic-query-language/nrql-resources/nrql-syntax-components-functions) for more information about generating a query string.
   */
  nrdbQuery?: Maybe<NrdbResultContainer>;
  /**
   * Poll for the results of a previously-executed asychronous NRDB query.
   *
   * The `queryId` is available in the `queryProgress` data returned by the original asynchronous query.
   *
   * See [this page](https://docs.newrelic.com/docs/apis/nerdgraph/examples/async-queries-nrql-tutorial) for additional asynchronous query documentation.
   * @deprecated This field is experimental! It may change at any time.
   *
   */
  nrdbQueryProgress?: Maybe<NrdbResultContainer>;
  /** The url to the entity. */
  permalink?: Maybe<Scalars['String']['output']>;
  /** Recent violations on the entity. */
  recentAlertViolations?: Maybe<Array<Maybe<EntityAlertViolation>>>;
  /** The recommended service levels for the entity. */
  recommendedServiceLevel?: Maybe<ServiceLevelRecommendation>;
  /** Related dashboards results */
  relatedDashboards: RelatedDashboardsRelatedDashboardResult;
  /** Related entities result with optional filtering. */
  relatedEntities?: Maybe<EntityRelationshipRelatedEntitiesResult>;
  /** Relationship traversal results with optional filtering. WARNING: this query is still experimental, and subject to breaking changes. */
  relationshipTraversal?: Maybe<EntityRelationshipTraversalResult>;
  /**
   * A list of the entities' relationships.
   *
   * For more information, visit [our docs](https://docs.newrelic.com/docs/apis/graphql-api/tutorials/graphql-relationships-api-tutorial).
   * @deprecated This field is deprecated! Please use `relatedEntities`.
   */
  relationships?: Maybe<Array<Maybe<EntityRelationship>>>;
  /** The reporting status of the entity. If New Relic is successfully collecting data from your application, this will be true. */
  reporting?: Maybe<Scalars['Boolean']['output']>;
  /** List of resources attached to the team */
  resources?: Maybe<Array<TeamResource>>;
  /** The service level defined for the entity. */
  serviceLevel?: Maybe<ServiceLevelDefinition>;
  /** The list of summary metrics. */
  summaryMetrics?: Maybe<Array<Maybe<EntitySummaryMetric>>>;
  /**
   * The tags applied to the entity.
   *
   * For details on tags, as well as query and mutation examples, visit [our docs](https://docs.newrelic.com/docs/apis/graphql-api/tutorials/graphql-tagging-api-tutorial).
   */
  tags?: Maybe<Array<Maybe<EntityTag>>>;
  /** The tags applied to the entity with their metadata. */
  tagsWithMetadata?: Maybe<Array<Maybe<EntityTagWithMetadata>>>;
  /** Look up Distributed Tracing summary data for the selected `EntityGuid` */
  tracingSummary?: Maybe<DistributedTracingEntityTracingSummary>;
  /** The entity's type */
  type?: Maybe<Scalars['String']['output']>;
  /** List of templates availables for this entity. */
  uiTemplates?: Maybe<Array<EntityDashboardTemplatesUi>>;
  /** Metadata about team last update operation */
  updatedMetadata?: Maybe<TeamActionMetadata>;
};


/** A Team entity. */
export type TeamEntityAlertViolationsArgs = {
  endTime: Scalars['EpochMilliseconds']['input'];
  startTime: Scalars['EpochMilliseconds']['input'];
};


/** A Team entity. */
export type TeamEntityCollectionArgs = {
  name: Scalars['String']['input'];
};


/** A Team entity. */
export type TeamEntityDeploymentSearchArgs = {
  filter?: InputMaybe<ChangeTrackingSearchFilter>;
};


/** A Team entity. */
export type TeamEntityGoldenMetricsArgs = {
  context?: InputMaybe<EntityGoldenContextInput>;
  timeWindow?: InputMaybe<EntityGoldenNrqlTimeWindowInput>;
};


/** A Team entity. */
export type TeamEntityGoldenSignalCorrelationsArgs = {
  filter?: InputMaybe<GoldenSignalCorrelationsEntityFilter>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  timeWindow?: InputMaybe<TimeWindowInput>;
};


/** A Team entity. */
export type TeamEntityGoldenSignalDeviationsArgs = {
  comparisonTimeWindow?: InputMaybe<TimeWindowInput>;
  evaluationTimeWindow?: InputMaybe<TimeWindowInput>;
};


/** A Team entity. */
export type TeamEntityGoldenSignalValuesArgs = {
  timeWindow?: InputMaybe<TimeWindowInput>;
};


/** A Team entity. */
export type TeamEntityGoldenSignalValuesV2Args = {
  timeWindow?: InputMaybe<TimeWindowInput>;
};


/** A Team entity. */
export type TeamEntityGoldenTagsArgs = {
  context?: InputMaybe<EntityGoldenContextInput>;
};


/** A Team entity. */
export type TeamEntityNerdStoreCollectionArgs = {
  collection: Scalars['String']['input'];
  scopeByActor?: InputMaybe<Scalars['Boolean']['input']>;
};


/** A Team entity. */
export type TeamEntityNerdStoreDocumentArgs = {
  collection: Scalars['String']['input'];
  documentId: Scalars['String']['input'];
  scopeByActor?: InputMaybe<Scalars['Boolean']['input']>;
};


/** A Team entity. */
export type TeamEntityNrdbQueryArgs = {
  async?: InputMaybe<Scalars['Boolean']['input']>;
  nrql: Scalars['Nrql']['input'];
  options?: InputMaybe<NrqlQueryOptions>;
  timeout?: InputMaybe<Scalars['Seconds']['input']>;
};


/** A Team entity. */
export type TeamEntityNrdbQueryProgressArgs = {
  queryId: Scalars['ID']['input'];
};


/** A Team entity. */
export type TeamEntityRecentAlertViolationsArgs = {
  count?: InputMaybe<Scalars['Int']['input']>;
};


/** A Team entity. */
export type TeamEntityRelatedEntitiesArgs = {
  cursor?: InputMaybe<Scalars['String']['input']>;
  filter?: InputMaybe<EntityRelationshipEdgeFilter>;
  limit?: InputMaybe<Scalars['Int']['input']>;
};


/** A Team entity. */
export type TeamEntityRelationshipTraversalArgs = {
  cursor?: InputMaybe<Scalars['String']['input']>;
  hopFilters?: InputMaybe<EntityRelationshipTraversalHopFilters>;
  hops?: InputMaybe<Scalars['Int']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
};


/** A Team entity. */
export type TeamEntityRelationshipsArgs = {
  endTime?: InputMaybe<Scalars['EpochMilliseconds']['input']>;
  filter?: InputMaybe<EntityRelationshipFilter>;
};


/** A Team entity. */
export type TeamEntitySummaryMetricsArgs = {
  timeWindow?: InputMaybe<TimeWindowInput>;
};


/** A Team entity. */
export type TeamEntityTracingSummaryArgs = {
  timeWindow?: InputMaybe<TimeWindowInput>;
};

/** A Team entity outline. */
export type TeamEntityOutline = AlertableEntityOutline & EntityOutline & {
  __typename?: 'TeamEntityOutline';
  account?: Maybe<AccountOutline>;
  /** The New Relic account ID associated with this entity. */
  accountId?: Maybe<Scalars['Int']['output']>;
  /** The current alerting severity of the entity. */
  alertSeverity?: Maybe<EntityAlertSeverity>;
  /**
   * The alert status of the entity.
   * @deprecated Please use `alertSeverity` and `reporting`
   */
  alertStatus?: Maybe<EntityAlertStatus>;
  /** The entity's domain */
  domain?: Maybe<Scalars['String']['output']>;
  /** A value representing the combination of the entity's domain and type. */
  entityType?: Maybe<EntityType>;
  /** The date of last time the entity has updated any of its fields. */
  firstIndexedAt?: Maybe<Scalars['EpochMilliseconds']['output']>;
  /** The list of golden metrics for a specific entity */
  goldenMetrics?: Maybe<EntityGoldenContextScopedGoldenMetrics>;
  /**
   * For the golden signal on this entity, show correlated signals from related entities.
   * Well inspect the golden signals for all related entities and return a sorted list.
   * You can also filter the results.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  goldenSignalCorrelations?: Maybe<GoldenSignalCorrelationResult>;
  /**
   * The deviation from normal of golden signal(s) for the given entity.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  goldenSignalDeviations?: Maybe<Array<Maybe<GoldenSignalSignalDeviation>>>;
  /**
   * The stored golden signal(s) for the given entity.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  goldenSignalValues?: Maybe<GoldenSignalValues>;
  /**
   * The stored golden signal(s) for the given entity. To be removed, use goldenSignalValues instead.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  goldenSignalValuesV2?: Maybe<GoldenSignalValues>;
  /** The list of golden tags for a specific entityType. */
  goldenTags?: Maybe<EntityGoldenContextScopedGoldenTags>;
  /** A unique entity identifier. */
  guid?: Maybe<Scalars['EntityGuid']['output']>;
  /** The time the entity was indexed. */
  indexedAt?: Maybe<Scalars['EpochMilliseconds']['output']>;
  /** The last time the entity's reporting status changed. */
  lastReportingChangeAt?: Maybe<Scalars['EpochMilliseconds']['output']>;
  /** The name of this entity. */
  name?: Maybe<Scalars['String']['output']>;
  /** The url to the entity. */
  permalink?: Maybe<Scalars['String']['output']>;
  /** The recommended service levels for the entity. */
  recommendedServiceLevel?: Maybe<ServiceLevelRecommendation>;
  /** Related dashboards results */
  relatedDashboards: RelatedDashboardsRelatedDashboardResult;
  /** The reporting status of the entity. If New Relic is successfully collecting data from your application, this will be true. */
  reporting?: Maybe<Scalars['Boolean']['output']>;
  /** The service level defined for the entity. */
  serviceLevel?: Maybe<ServiceLevelDefinition>;
  /** The list of summary metrics. */
  summaryMetrics?: Maybe<Array<Maybe<EntitySummaryMetric>>>;
  /**
   * The tags applied to the entity.
   *
   * For details on tags, as well as query and mutation examples, visit [our docs](https://docs.newrelic.com/docs/apis/graphql-api/tutorials/graphql-tagging-api-tutorial).
   */
  tags?: Maybe<Array<Maybe<EntityTag>>>;
  /** The entity's type */
  type?: Maybe<Scalars['String']['output']>;
  /** List of templates availables for this entity. */
  uiTemplates?: Maybe<Array<EntityDashboardTemplatesUi>>;
};


/** A Team entity outline. */
export type TeamEntityOutlineGoldenMetricsArgs = {
  context?: InputMaybe<EntityGoldenContextInput>;
  timeWindow?: InputMaybe<EntityGoldenNrqlTimeWindowInput>;
};


/** A Team entity outline. */
export type TeamEntityOutlineGoldenSignalCorrelationsArgs = {
  filter?: InputMaybe<GoldenSignalCorrelationsEntityFilter>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  timeWindow?: InputMaybe<TimeWindowInput>;
};


/** A Team entity outline. */
export type TeamEntityOutlineGoldenSignalDeviationsArgs = {
  comparisonTimeWindow?: InputMaybe<TimeWindowInput>;
  evaluationTimeWindow?: InputMaybe<TimeWindowInput>;
};


/** A Team entity outline. */
export type TeamEntityOutlineGoldenSignalValuesArgs = {
  timeWindow?: InputMaybe<TimeWindowInput>;
};


/** A Team entity outline. */
export type TeamEntityOutlineGoldenSignalValuesV2Args = {
  timeWindow?: InputMaybe<TimeWindowInput>;
};


/** A Team entity outline. */
export type TeamEntityOutlineGoldenTagsArgs = {
  context?: InputMaybe<EntityGoldenContextInput>;
};


/** A Team entity outline. */
export type TeamEntityOutlineSummaryMetricsArgs = {
  timeWindow?: InputMaybe<TimeWindowInput>;
};

/** Settings for the organization */
export type TeamGlobalSettings = {
  __typename?: 'TeamGlobalSettings';
  /** Discovery settings */
  discovery?: Maybe<TeamDiscoverySettings>;
};

/** Any user belonging to a Team */
export type TeamMember = {
  __typename?: 'TeamMember';
  /** List of roles of the user */
  roles?: Maybe<Array<Scalars['String']['output']>>;
  /** The user who performed the action. */
  user?: Maybe<UserReference>;
};

/** Input to create a new Member */
export type TeamMemberInput = {
  /** List of roles of the user */
  roles?: InputMaybe<Array<Scalars['String']['input']>>;
  /** The user id of the team member */
  userId: Scalars['ID']['input'];
};

/** Type defined so its fields will be merged directly into NerdGraph's organization type */
export type TeamOrganizationStitchedFields = {
  __typename?: 'TeamOrganizationStitchedFields';
  /** Settings that affect teams in the whole organization */
  globalSettings?: Maybe<TeamGlobalSettings>;
};

/** Any extra information attached to a Team */
export type TeamResource = {
  __typename?: 'TeamResource';
  /** Holds the content of the resource */
  content: Scalars['String']['output'];
  /** Main text for the resource, use the content if null */
  title?: Maybe<Scalars['String']['output']>;
  /** Type of resource, the UI might be enriched based on the value */
  type: Scalars['String']['output'];
};

/** Input to create a new Resource */
export type TeamResourceInput = {
  /** Holds resource value */
  content: Scalars['String']['input'];
  /** Main text to identify the resource in the UI and the API, if null, is replaced by the content */
  title?: InputMaybe<Scalars['String']['input']>;
  /** Valid resource type, if invalid the api will return a descriptive error */
  type: Scalars['String']['input'];
};

/** Input to edit global settings */
export type TeamUpdateGlobalSettingsInput = {
  /** Input to edit discovery settings */
  discoverySettingsInput?: InputMaybe<TeamDiscoverySettingsInput>;
};

/** The input object that represents the Team that will be updated */
export type TeamUpdateInput = {
  /** List of aliases associated to the team */
  aliases?: InputMaybe<Array<Scalars['String']['input']>>;
  /** The description of the Team */
  description?: InputMaybe<Scalars['String']['input']>;
  /** List of members to replace existing ones */
  members?: InputMaybe<Array<TeamMemberInput>>;
  /** The name of the Team */
  name?: InputMaybe<Scalars['String']['input']>;
  /** List of resources to replace existing ones */
  resources?: InputMaybe<Array<TeamResourceInput>>;
  /** A list of entities owned by the Team */
  staticEntityGuids?: InputMaybe<Array<Scalars['EntityGuid']['input']>>;
};

/** Object to wrap update response */
export type TeamUpdatedEntityOwners = {
  __typename?: 'TeamUpdatedEntityOwners';
  /** Updated entity */
  entity?: Maybe<EntityOutline>;
  /** Updated teams */
  teams?: Maybe<Array<Maybe<TeamDefinition>>>;
};

/** A third party service entity. */
export type ThirdPartyServiceEntity = AlertableEntity & Entity & {
  __typename?: 'ThirdPartyServiceEntity';
  account?: Maybe<AccountOutline>;
  /** The New Relic account ID associated with this entity. */
  accountId?: Maybe<Scalars['Int']['output']>;
  /** The current alerting severity of the entity. */
  alertSeverity?: Maybe<EntityAlertSeverity>;
  /**
   * The alert status of the entity.
   * @deprecated Please use `alertSeverity` and `reporting`
   */
  alertStatus?: Maybe<EntityAlertStatus>;
  /** Violations on the entity that were open during the specified time window. This will return up to 500 violations - if there are more in the time window selected, you must narrow the time window or look at fewer entities. */
  alertViolations?: Maybe<Array<Maybe<EntityAlertViolation>>>;
  /**
   * Query upstream and downstream dependencies for an entity
   * @deprecated This field is experimental and subject to breaking changes.
   */
  connections?: Maybe<RelatedExternalsEntityResult>;
  /** Retrieve the deployment event(s). Ordered by timestamp DESC. */
  deploymentSearch?: Maybe<ChangeTrackingDeploymentSearchResult>;
  /** The entity's domain */
  domain?: Maybe<Scalars['String']['output']>;
  /** A value representing the combination of the entity's domain and type. */
  entityType?: Maybe<EntityType>;
  /** The date of last time the entity has updated any of its fields. */
  firstIndexedAt?: Maybe<Scalars['EpochMilliseconds']['output']>;
  /** The list of golden metrics for a specific entity */
  goldenMetrics?: Maybe<EntityGoldenContextScopedGoldenMetrics>;
  /**
   * For the golden signal on this entity, show correlated signals from related entities.
   * Well inspect the golden signals for all related entities and return a sorted list.
   * You can also filter the results.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  goldenSignalCorrelations?: Maybe<GoldenSignalCorrelationResult>;
  /**
   * The deviation from normal of golden signal(s) for the given entity.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  goldenSignalDeviations?: Maybe<Array<Maybe<GoldenSignalSignalDeviation>>>;
  /**
   * The stored golden signal(s) for the given entity.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  goldenSignalValues?: Maybe<GoldenSignalValues>;
  /**
   * The stored golden signal(s) for the given entity. To be removed, use goldenSignalValues instead.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  goldenSignalValuesV2?: Maybe<GoldenSignalValues>;
  /** The list of golden tags for a specific entityType. */
  goldenTags?: Maybe<EntityGoldenContextScopedGoldenTags>;
  /** A unique entity identifier. */
  guid?: Maybe<Scalars['EntityGuid']['output']>;
  /** The time the entity was indexed. */
  indexedAt?: Maybe<Scalars['EpochMilliseconds']['output']>;
  /** The last time the entity's reporting status changed. */
  lastReportingChangeAt?: Maybe<Scalars['EpochMilliseconds']['output']>;
  /** The name of this entity. */
  name?: Maybe<Scalars['String']['output']>;
  nerdStorage?: Maybe<NerdStorageEntityScope>;
  nerdStoreCollection?: Maybe<Array<Maybe<NerdStoreCollectionMember>>>;
  nerdStoreDocument?: Maybe<Scalars['NerdStoreDocument']['output']>;
  /**
   * Make an `Entity` scoped query to NRDB with a NRQL string.
   *
   * A relevant `WHERE` clause will be added to your query to scope data to the entity in question.
   *
   * See the [NRQL Docs](https://docs.newrelic.com/docs/insights/nrql-new-relic-query-language/nrql-resources/nrql-syntax-components-functions) for more information about generating a query string.
   */
  nrdbQuery?: Maybe<NrdbResultContainer>;
  /**
   * Poll for the results of a previously-executed asychronous NRDB query.
   *
   * The `queryId` is available in the `queryProgress` data returned by the original asynchronous query.
   *
   * See [this page](https://docs.newrelic.com/docs/apis/nerdgraph/examples/async-queries-nrql-tutorial) for additional asynchronous query documentation.
   * @deprecated This field is experimental! It may change at any time.
   *
   */
  nrdbQueryProgress?: Maybe<NrdbResultContainer>;
  /** The url to the entity. */
  permalink?: Maybe<Scalars['String']['output']>;
  /** Recent violations on the entity. */
  recentAlertViolations?: Maybe<Array<Maybe<EntityAlertViolation>>>;
  /** The recommended service levels for the entity. */
  recommendedServiceLevel?: Maybe<ServiceLevelRecommendation>;
  /** Related dashboards results */
  relatedDashboards: RelatedDashboardsRelatedDashboardResult;
  /** Related entities result with optional filtering. */
  relatedEntities?: Maybe<EntityRelationshipRelatedEntitiesResult>;
  /**
   * Query upstream and downstream transaction dependencies for an entity
   * @deprecated This field is experimental and subject to breaking changes.
   */
  relatedTransactions?: Maybe<RelatedExternalsTransactionResult>;
  /** Relationship traversal results with optional filtering. WARNING: this query is still experimental, and subject to breaking changes. */
  relationshipTraversal?: Maybe<EntityRelationshipTraversalResult>;
  /**
   * A list of the entities' relationships.
   *
   * For more information, visit [our docs](https://docs.newrelic.com/docs/apis/graphql-api/tutorials/graphql-relationships-api-tutorial).
   * @deprecated This field is deprecated! Please use `relatedEntities`.
   */
  relationships?: Maybe<Array<Maybe<EntityRelationship>>>;
  /** The reporting status of the entity. If New Relic is successfully collecting data from your application, this will be true. */
  reporting?: Maybe<Scalars['Boolean']['output']>;
  /** The service level defined for the entity. */
  serviceLevel?: Maybe<ServiceLevelDefinition>;
  /** The list of summary metrics. */
  summaryMetrics?: Maybe<Array<Maybe<EntitySummaryMetric>>>;
  /**
   * The tags applied to the entity.
   *
   * For details on tags, as well as query and mutation examples, visit [our docs](https://docs.newrelic.com/docs/apis/graphql-api/tutorials/graphql-tagging-api-tutorial).
   */
  tags?: Maybe<Array<Maybe<EntityTag>>>;
  /** The tags applied to the entity with their metadata. */
  tagsWithMetadata?: Maybe<Array<Maybe<EntityTagWithMetadata>>>;
  /** Look up Distributed Tracing summary data for the selected `EntityGuid` */
  tracingSummary?: Maybe<DistributedTracingEntityTracingSummary>;
  /** Retrieves a transaction trace given its ID. */
  transactionTrace?: Maybe<AgentTracesTransactionTrace>;
  /** Retrieve a list of transaction traces that match the given search query. */
  transactionTraces?: Maybe<Array<Maybe<AgentTracesTransactionTrace>>>;
  /** The entity's type */
  type?: Maybe<Scalars['String']['output']>;
  /** List of templates availables for this entity. */
  uiTemplates?: Maybe<Array<EntityDashboardTemplatesUi>>;
};


/** A third party service entity. */
export type ThirdPartyServiceEntityAlertViolationsArgs = {
  endTime: Scalars['EpochMilliseconds']['input'];
  startTime: Scalars['EpochMilliseconds']['input'];
};


/** A third party service entity. */
export type ThirdPartyServiceEntityConnectionsArgs = {
  timeWindow?: InputMaybe<TimeWindowInput>;
};


/** A third party service entity. */
export type ThirdPartyServiceEntityDeploymentSearchArgs = {
  filter?: InputMaybe<ChangeTrackingSearchFilter>;
};


/** A third party service entity. */
export type ThirdPartyServiceEntityGoldenMetricsArgs = {
  context?: InputMaybe<EntityGoldenContextInput>;
  timeWindow?: InputMaybe<EntityGoldenNrqlTimeWindowInput>;
};


/** A third party service entity. */
export type ThirdPartyServiceEntityGoldenSignalCorrelationsArgs = {
  filter?: InputMaybe<GoldenSignalCorrelationsEntityFilter>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  timeWindow?: InputMaybe<TimeWindowInput>;
};


/** A third party service entity. */
export type ThirdPartyServiceEntityGoldenSignalDeviationsArgs = {
  comparisonTimeWindow?: InputMaybe<TimeWindowInput>;
  evaluationTimeWindow?: InputMaybe<TimeWindowInput>;
};


/** A third party service entity. */
export type ThirdPartyServiceEntityGoldenSignalValuesArgs = {
  timeWindow?: InputMaybe<TimeWindowInput>;
};


/** A third party service entity. */
export type ThirdPartyServiceEntityGoldenSignalValuesV2Args = {
  timeWindow?: InputMaybe<TimeWindowInput>;
};


/** A third party service entity. */
export type ThirdPartyServiceEntityGoldenTagsArgs = {
  context?: InputMaybe<EntityGoldenContextInput>;
};


/** A third party service entity. */
export type ThirdPartyServiceEntityNerdStoreCollectionArgs = {
  collection: Scalars['String']['input'];
  scopeByActor?: InputMaybe<Scalars['Boolean']['input']>;
};


/** A third party service entity. */
export type ThirdPartyServiceEntityNerdStoreDocumentArgs = {
  collection: Scalars['String']['input'];
  documentId: Scalars['String']['input'];
  scopeByActor?: InputMaybe<Scalars['Boolean']['input']>;
};


/** A third party service entity. */
export type ThirdPartyServiceEntityNrdbQueryArgs = {
  async?: InputMaybe<Scalars['Boolean']['input']>;
  nrql: Scalars['Nrql']['input'];
  options?: InputMaybe<NrqlQueryOptions>;
  timeout?: InputMaybe<Scalars['Seconds']['input']>;
};


/** A third party service entity. */
export type ThirdPartyServiceEntityNrdbQueryProgressArgs = {
  queryId: Scalars['ID']['input'];
};


/** A third party service entity. */
export type ThirdPartyServiceEntityRecentAlertViolationsArgs = {
  count?: InputMaybe<Scalars['Int']['input']>;
};


/** A third party service entity. */
export type ThirdPartyServiceEntityRelatedEntitiesArgs = {
  cursor?: InputMaybe<Scalars['String']['input']>;
  filter?: InputMaybe<EntityRelationshipEdgeFilter>;
  limit?: InputMaybe<Scalars['Int']['input']>;
};


/** A third party service entity. */
export type ThirdPartyServiceEntityRelatedTransactionsArgs = {
  search: RelatedExternalsSearch;
  timeWindow?: InputMaybe<TimeWindowInput>;
};


/** A third party service entity. */
export type ThirdPartyServiceEntityRelationshipTraversalArgs = {
  cursor?: InputMaybe<Scalars['String']['input']>;
  hopFilters?: InputMaybe<EntityRelationshipTraversalHopFilters>;
  hops?: InputMaybe<Scalars['Int']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
};


/** A third party service entity. */
export type ThirdPartyServiceEntityRelationshipsArgs = {
  endTime?: InputMaybe<Scalars['EpochMilliseconds']['input']>;
  filter?: InputMaybe<EntityRelationshipFilter>;
};


/** A third party service entity. */
export type ThirdPartyServiceEntitySummaryMetricsArgs = {
  timeWindow?: InputMaybe<TimeWindowInput>;
};


/** A third party service entity. */
export type ThirdPartyServiceEntityTracingSummaryArgs = {
  timeWindow?: InputMaybe<TimeWindowInput>;
};


/** A third party service entity. */
export type ThirdPartyServiceEntityTransactionTraceArgs = {
  filter?: InputMaybe<AgentTracesTransactionTraceFilter>;
  traceId: Scalars['String']['input'];
};


/** A third party service entity. */
export type ThirdPartyServiceEntityTransactionTracesArgs = {
  query: AgentTracesTransactionTraceQuery;
};

/** A third party service entity outline. */
export type ThirdPartyServiceEntityOutline = AlertableEntityOutline & EntityOutline & {
  __typename?: 'ThirdPartyServiceEntityOutline';
  account?: Maybe<AccountOutline>;
  /** The New Relic account ID associated with this entity. */
  accountId?: Maybe<Scalars['Int']['output']>;
  /** The current alerting severity of the entity. */
  alertSeverity?: Maybe<EntityAlertSeverity>;
  /**
   * The alert status of the entity.
   * @deprecated Please use `alertSeverity` and `reporting`
   */
  alertStatus?: Maybe<EntityAlertStatus>;
  /** The entity's domain */
  domain?: Maybe<Scalars['String']['output']>;
  /** A value representing the combination of the entity's domain and type. */
  entityType?: Maybe<EntityType>;
  /** The date of last time the entity has updated any of its fields. */
  firstIndexedAt?: Maybe<Scalars['EpochMilliseconds']['output']>;
  /** The list of golden metrics for a specific entity */
  goldenMetrics?: Maybe<EntityGoldenContextScopedGoldenMetrics>;
  /**
   * For the golden signal on this entity, show correlated signals from related entities.
   * Well inspect the golden signals for all related entities and return a sorted list.
   * You can also filter the results.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  goldenSignalCorrelations?: Maybe<GoldenSignalCorrelationResult>;
  /**
   * The deviation from normal of golden signal(s) for the given entity.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  goldenSignalDeviations?: Maybe<Array<Maybe<GoldenSignalSignalDeviation>>>;
  /**
   * The stored golden signal(s) for the given entity.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  goldenSignalValues?: Maybe<GoldenSignalValues>;
  /**
   * The stored golden signal(s) for the given entity. To be removed, use goldenSignalValues instead.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  goldenSignalValuesV2?: Maybe<GoldenSignalValues>;
  /** The list of golden tags for a specific entityType. */
  goldenTags?: Maybe<EntityGoldenContextScopedGoldenTags>;
  /** A unique entity identifier. */
  guid?: Maybe<Scalars['EntityGuid']['output']>;
  /** The time the entity was indexed. */
  indexedAt?: Maybe<Scalars['EpochMilliseconds']['output']>;
  /** The last time the entity's reporting status changed. */
  lastReportingChangeAt?: Maybe<Scalars['EpochMilliseconds']['output']>;
  /** The name of this entity. */
  name?: Maybe<Scalars['String']['output']>;
  /** The url to the entity. */
  permalink?: Maybe<Scalars['String']['output']>;
  /** The recommended service levels for the entity. */
  recommendedServiceLevel?: Maybe<ServiceLevelRecommendation>;
  /** Related dashboards results */
  relatedDashboards: RelatedDashboardsRelatedDashboardResult;
  /** The reporting status of the entity. If New Relic is successfully collecting data from your application, this will be true. */
  reporting?: Maybe<Scalars['Boolean']['output']>;
  /** The service level defined for the entity. */
  serviceLevel?: Maybe<ServiceLevelDefinition>;
  /** The list of summary metrics. */
  summaryMetrics?: Maybe<Array<Maybe<EntitySummaryMetric>>>;
  /**
   * The tags applied to the entity.
   *
   * For details on tags, as well as query and mutation examples, visit [our docs](https://docs.newrelic.com/docs/apis/graphql-api/tutorials/graphql-tagging-api-tutorial).
   */
  tags?: Maybe<Array<Maybe<EntityTag>>>;
  /** The entity's type */
  type?: Maybe<Scalars['String']['output']>;
  /** List of templates availables for this entity. */
  uiTemplates?: Maybe<Array<EntityDashboardTemplatesUi>>;
};


/** A third party service entity outline. */
export type ThirdPartyServiceEntityOutlineGoldenMetricsArgs = {
  context?: InputMaybe<EntityGoldenContextInput>;
  timeWindow?: InputMaybe<EntityGoldenNrqlTimeWindowInput>;
};


/** A third party service entity outline. */
export type ThirdPartyServiceEntityOutlineGoldenSignalCorrelationsArgs = {
  filter?: InputMaybe<GoldenSignalCorrelationsEntityFilter>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  timeWindow?: InputMaybe<TimeWindowInput>;
};


/** A third party service entity outline. */
export type ThirdPartyServiceEntityOutlineGoldenSignalDeviationsArgs = {
  comparisonTimeWindow?: InputMaybe<TimeWindowInput>;
  evaluationTimeWindow?: InputMaybe<TimeWindowInput>;
};


/** A third party service entity outline. */
export type ThirdPartyServiceEntityOutlineGoldenSignalValuesArgs = {
  timeWindow?: InputMaybe<TimeWindowInput>;
};


/** A third party service entity outline. */
export type ThirdPartyServiceEntityOutlineGoldenSignalValuesV2Args = {
  timeWindow?: InputMaybe<TimeWindowInput>;
};


/** A third party service entity outline. */
export type ThirdPartyServiceEntityOutlineGoldenTagsArgs = {
  context?: InputMaybe<EntityGoldenContextInput>;
};


/** A third party service entity outline. */
export type ThirdPartyServiceEntityOutlineSummaryMetricsArgs = {
  timeWindow?: InputMaybe<TimeWindowInput>;
};

/** Thread Profile */
export type ThreadProfilerMetadata = {
  __typename?: 'ThreadProfilerMetadata';
  /**
   * The user who started the thread profile
   * @deprecated This field is experimental and subject to breaking changes.
   */
  creator?: Maybe<UserReference>;
  /**
   * The end time of this thread profile
   * @deprecated This field is experimental and subject to breaking changes.
   */
  endTime?: Maybe<Scalars['String']['output']>;
  /**
   * The host of this thread profile
   * @deprecated This field is experimental and subject to breaking changes.
   */
  host?: Maybe<Scalars['String']['output']>;
  /**
   * The name of this thread profile
   * @deprecated This field is experimental and subject to breaking changes.
   */
  hostName?: Maybe<Scalars['String']['output']>;
  /**
   * The primary key of this thread profile
   * @deprecated This field is experimental and subject to breaking changes.
   */
  id: Scalars['Int']['output'];
  /**
   * The number of times this thread profile was sampled.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  sampleCount?: Maybe<Scalars['Int']['output']>;
  /**
   * The start time of this thread profile
   * @deprecated This field is experimental and subject to breaking changes.
   */
  startTime?: Maybe<Scalars['String']['output']>;
};

/** A collection of MetadataCollection objects which can be paginated through via a cursor. */
export type ThreadProfilerMetadataCollection = {
  __typename?: 'ThreadProfilerMetadataCollection';
  /**
   * The count of items in the collection.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  count?: Maybe<Scalars['Int']['output']>;
  /**
   * An identifier that can be passed in to paginate through data. Use nextCursor if you are walking through the data in forward order.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  nextCursor?: Maybe<Scalars['String']['output']>;
  /**
   * The collection to paginate through.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  nodes?: Maybe<Array<ThreadProfilerMetadata>>;
  /**
   * An identifier that can be passed in to paginate through data. Use prevCursor if you are walking through the data in reverse order.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  prevCursor?: Maybe<Scalars['String']['output']>;
};

/** Represents a time window. */
export type TimeWindow = {
  __typename?: 'TimeWindow';
  /** The end time of the time window the number of milliseconds since the Unix epoch. */
  endTime?: Maybe<Scalars['EpochMilliseconds']['output']>;
  /** The start time of the time window the number of milliseconds since the Unix epoch. */
  startTime?: Maybe<Scalars['EpochMilliseconds']['output']>;
};

/** Represents a time window input. */
export type TimeWindowInput = {
  /** The end time of the time window the number of milliseconds since the Unix epoch. */
  endTime: Scalars['EpochMilliseconds']['input'];
  /** The start time of the time window the number of milliseconds since the Unix epoch. */
  startTime: Scalars['EpochMilliseconds']['input'];
};

/** Information about a Time Zone */
export type TimeZoneInfo = {
  __typename?: 'TimeZoneInfo';
  /** The name of the Time Zone */
  name?: Maybe<Scalars['String']['output']>;
  /** The offset in seconds from UTC */
  offset?: Maybe<Scalars['Seconds']['output']>;
};

export type TimeZonePeriod = {
  __typename?: 'TimeZonePeriod';
  /** May be nil if the time zone period has no beginning */
  from?: Maybe<Scalars['EpochSeconds']['output']>;
  offset?: Maybe<Scalars['Seconds']['output']>;
  /** May be nil if the time zone period has no end */
  until?: Maybe<Scalars['EpochSeconds']['output']>;
  zoneAbbr?: Maybe<Scalars['String']['output']>;
};

export type TransactionTrace = {
  __typename?: 'TransactionTrace';
  accountId?: Maybe<Scalars['Int']['output']>;
  agentAttributesMap?: Maybe<Scalars['AttributeMap']['output']>;
  duration?: Maybe<Scalars['Seconds']['output']>;
  edges?: Maybe<Array<Maybe<TransactionTraceEdge>>>;
  id?: Maybe<Scalars['String']['output']>;
  intrinsicAttributesMap?: Maybe<Scalars['AttributeMap']['output']>;
  nodes?: Maybe<Array<Maybe<TransactionTraceNode>>>;
  path?: Maybe<Scalars['String']['output']>;
  startTime?: Maybe<Scalars['EpochMilliseconds']['output']>;
  uri?: Maybe<Scalars['String']['output']>;
  userAttributesMap?: Maybe<Scalars['AttributeMap']['output']>;
};

export type TransactionTraceEdge = {
  __typename?: 'TransactionTraceEdge';
  childGuid?: Maybe<Scalars['String']['output']>;
  parentGuid?: Maybe<Scalars['String']['output']>;
};

export type TransactionTraceNode = {
  __typename?: 'TransactionTraceNode';
  attributesMap?: Maybe<Scalars['AttributeMap']['output']>;
  duration?: Maybe<Scalars['Seconds']['output']>;
  exclusiveDurationMs?: Maybe<Scalars['Milliseconds']['output']>;
  guid?: Maybe<Scalars['String']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  timestamp?: Maybe<Scalars['EpochMilliseconds']['output']>;
};

/** An entity that is unavailable. */
export type UnavailableEntity = AlertableEntity & Entity & {
  __typename?: 'UnavailableEntity';
  account?: Maybe<AccountOutline>;
  /** The New Relic account ID associated with this entity. */
  accountId?: Maybe<Scalars['Int']['output']>;
  /** The current alerting severity of the entity. */
  alertSeverity?: Maybe<EntityAlertSeverity>;
  /**
   * The alert status of the entity.
   * @deprecated Please use `alertSeverity` and `reporting`
   */
  alertStatus?: Maybe<EntityAlertStatus>;
  /** Violations on the entity that were open during the specified time window. This will return up to 500 violations - if there are more in the time window selected, you must narrow the time window or look at fewer entities. */
  alertViolations?: Maybe<Array<Maybe<EntityAlertViolation>>>;
  /** Retrieve the deployment event(s). Ordered by timestamp DESC. */
  deploymentSearch?: Maybe<ChangeTrackingDeploymentSearchResult>;
  /** The entity's domain */
  domain?: Maybe<Scalars['String']['output']>;
  /** A value representing the combination of the entity's domain and type. */
  entityType?: Maybe<EntityType>;
  /** The date of last time the entity has updated any of its fields. */
  firstIndexedAt?: Maybe<Scalars['EpochMilliseconds']['output']>;
  /** The list of golden metrics for a specific entity */
  goldenMetrics?: Maybe<EntityGoldenContextScopedGoldenMetrics>;
  /**
   * For the golden signal on this entity, show correlated signals from related entities.
   * Well inspect the golden signals for all related entities and return a sorted list.
   * You can also filter the results.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  goldenSignalCorrelations?: Maybe<GoldenSignalCorrelationResult>;
  /**
   * The deviation from normal of golden signal(s) for the given entity.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  goldenSignalDeviations?: Maybe<Array<Maybe<GoldenSignalSignalDeviation>>>;
  /**
   * The stored golden signal(s) for the given entity.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  goldenSignalValues?: Maybe<GoldenSignalValues>;
  /**
   * The stored golden signal(s) for the given entity. To be removed, use goldenSignalValues instead.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  goldenSignalValuesV2?: Maybe<GoldenSignalValues>;
  /** The list of golden tags for a specific entityType. */
  goldenTags?: Maybe<EntityGoldenContextScopedGoldenTags>;
  /** A unique entity identifier. */
  guid?: Maybe<Scalars['EntityGuid']['output']>;
  /** The time the entity was indexed. */
  indexedAt?: Maybe<Scalars['EpochMilliseconds']['output']>;
  /** The last time the entity's reporting status changed. */
  lastReportingChangeAt?: Maybe<Scalars['EpochMilliseconds']['output']>;
  /** The name of this entity. */
  name?: Maybe<Scalars['String']['output']>;
  nerdStorage?: Maybe<NerdStorageEntityScope>;
  nerdStoreCollection?: Maybe<Array<Maybe<NerdStoreCollectionMember>>>;
  nerdStoreDocument?: Maybe<Scalars['NerdStoreDocument']['output']>;
  /**
   * Make an `Entity` scoped query to NRDB with a NRQL string.
   *
   * A relevant `WHERE` clause will be added to your query to scope data to the entity in question.
   *
   * See the [NRQL Docs](https://docs.newrelic.com/docs/insights/nrql-new-relic-query-language/nrql-resources/nrql-syntax-components-functions) for more information about generating a query string.
   */
  nrdbQuery?: Maybe<NrdbResultContainer>;
  /**
   * Poll for the results of a previously-executed asychronous NRDB query.
   *
   * The `queryId` is available in the `queryProgress` data returned by the original asynchronous query.
   *
   * See [this page](https://docs.newrelic.com/docs/apis/nerdgraph/examples/async-queries-nrql-tutorial) for additional asynchronous query documentation.
   * @deprecated This field is experimental! It may change at any time.
   *
   */
  nrdbQueryProgress?: Maybe<NrdbResultContainer>;
  /** The url to the entity. */
  permalink?: Maybe<Scalars['String']['output']>;
  /** Recent violations on the entity. */
  recentAlertViolations?: Maybe<Array<Maybe<EntityAlertViolation>>>;
  /** The recommended service levels for the entity. */
  recommendedServiceLevel?: Maybe<ServiceLevelRecommendation>;
  /** Related dashboards results */
  relatedDashboards: RelatedDashboardsRelatedDashboardResult;
  /** Related entities result with optional filtering. */
  relatedEntities?: Maybe<EntityRelationshipRelatedEntitiesResult>;
  /** Relationship traversal results with optional filtering. WARNING: this query is still experimental, and subject to breaking changes. */
  relationshipTraversal?: Maybe<EntityRelationshipTraversalResult>;
  /**
   * A list of the entities' relationships.
   *
   * For more information, visit [our docs](https://docs.newrelic.com/docs/apis/graphql-api/tutorials/graphql-relationships-api-tutorial).
   * @deprecated This field is deprecated! Please use `relatedEntities`.
   */
  relationships?: Maybe<Array<Maybe<EntityRelationship>>>;
  /** The reporting status of the entity. If New Relic is successfully collecting data from your application, this will be true. */
  reporting?: Maybe<Scalars['Boolean']['output']>;
  /** The service level defined for the entity. */
  serviceLevel?: Maybe<ServiceLevelDefinition>;
  /** The list of summary metrics. */
  summaryMetrics?: Maybe<Array<Maybe<EntitySummaryMetric>>>;
  /**
   * The tags applied to the entity.
   *
   * For details on tags, as well as query and mutation examples, visit [our docs](https://docs.newrelic.com/docs/apis/graphql-api/tutorials/graphql-tagging-api-tutorial).
   */
  tags?: Maybe<Array<Maybe<EntityTag>>>;
  /** The tags applied to the entity with their metadata. */
  tagsWithMetadata?: Maybe<Array<Maybe<EntityTagWithMetadata>>>;
  /** Look up Distributed Tracing summary data for the selected `EntityGuid` */
  tracingSummary?: Maybe<DistributedTracingEntityTracingSummary>;
  /** The entity's type */
  type?: Maybe<Scalars['String']['output']>;
  /** List of templates availables for this entity. */
  uiTemplates?: Maybe<Array<EntityDashboardTemplatesUi>>;
};


/** An entity that is unavailable. */
export type UnavailableEntityAlertViolationsArgs = {
  endTime: Scalars['EpochMilliseconds']['input'];
  startTime: Scalars['EpochMilliseconds']['input'];
};


/** An entity that is unavailable. */
export type UnavailableEntityDeploymentSearchArgs = {
  filter?: InputMaybe<ChangeTrackingSearchFilter>;
};


/** An entity that is unavailable. */
export type UnavailableEntityGoldenMetricsArgs = {
  context?: InputMaybe<EntityGoldenContextInput>;
  timeWindow?: InputMaybe<EntityGoldenNrqlTimeWindowInput>;
};


/** An entity that is unavailable. */
export type UnavailableEntityGoldenSignalCorrelationsArgs = {
  filter?: InputMaybe<GoldenSignalCorrelationsEntityFilter>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  timeWindow?: InputMaybe<TimeWindowInput>;
};


/** An entity that is unavailable. */
export type UnavailableEntityGoldenSignalDeviationsArgs = {
  comparisonTimeWindow?: InputMaybe<TimeWindowInput>;
  evaluationTimeWindow?: InputMaybe<TimeWindowInput>;
};


/** An entity that is unavailable. */
export type UnavailableEntityGoldenSignalValuesArgs = {
  timeWindow?: InputMaybe<TimeWindowInput>;
};


/** An entity that is unavailable. */
export type UnavailableEntityGoldenSignalValuesV2Args = {
  timeWindow?: InputMaybe<TimeWindowInput>;
};


/** An entity that is unavailable. */
export type UnavailableEntityGoldenTagsArgs = {
  context?: InputMaybe<EntityGoldenContextInput>;
};


/** An entity that is unavailable. */
export type UnavailableEntityNerdStoreCollectionArgs = {
  collection: Scalars['String']['input'];
  scopeByActor?: InputMaybe<Scalars['Boolean']['input']>;
};


/** An entity that is unavailable. */
export type UnavailableEntityNerdStoreDocumentArgs = {
  collection: Scalars['String']['input'];
  documentId: Scalars['String']['input'];
  scopeByActor?: InputMaybe<Scalars['Boolean']['input']>;
};


/** An entity that is unavailable. */
export type UnavailableEntityNrdbQueryArgs = {
  async?: InputMaybe<Scalars['Boolean']['input']>;
  nrql: Scalars['Nrql']['input'];
  options?: InputMaybe<NrqlQueryOptions>;
  timeout?: InputMaybe<Scalars['Seconds']['input']>;
};


/** An entity that is unavailable. */
export type UnavailableEntityNrdbQueryProgressArgs = {
  queryId: Scalars['ID']['input'];
};


/** An entity that is unavailable. */
export type UnavailableEntityRecentAlertViolationsArgs = {
  count?: InputMaybe<Scalars['Int']['input']>;
};


/** An entity that is unavailable. */
export type UnavailableEntityRelatedEntitiesArgs = {
  cursor?: InputMaybe<Scalars['String']['input']>;
  filter?: InputMaybe<EntityRelationshipEdgeFilter>;
  limit?: InputMaybe<Scalars['Int']['input']>;
};


/** An entity that is unavailable. */
export type UnavailableEntityRelationshipTraversalArgs = {
  cursor?: InputMaybe<Scalars['String']['input']>;
  hopFilters?: InputMaybe<EntityRelationshipTraversalHopFilters>;
  hops?: InputMaybe<Scalars['Int']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
};


/** An entity that is unavailable. */
export type UnavailableEntityRelationshipsArgs = {
  endTime?: InputMaybe<Scalars['EpochMilliseconds']['input']>;
  filter?: InputMaybe<EntityRelationshipFilter>;
};


/** An entity that is unavailable. */
export type UnavailableEntitySummaryMetricsArgs = {
  timeWindow?: InputMaybe<TimeWindowInput>;
};


/** An entity that is unavailable. */
export type UnavailableEntityTracingSummaryArgs = {
  timeWindow?: InputMaybe<TimeWindowInput>;
};

/** An entity outline that is unavailable. */
export type UnavailableEntityOutline = AlertableEntityOutline & EntityOutline & {
  __typename?: 'UnavailableEntityOutline';
  account?: Maybe<AccountOutline>;
  /** The New Relic account ID associated with this entity. */
  accountId?: Maybe<Scalars['Int']['output']>;
  /** The current alerting severity of the entity. */
  alertSeverity?: Maybe<EntityAlertSeverity>;
  /**
   * The alert status of the entity.
   * @deprecated Please use `alertSeverity` and `reporting`
   */
  alertStatus?: Maybe<EntityAlertStatus>;
  /** The entity's domain */
  domain?: Maybe<Scalars['String']['output']>;
  /** A value representing the combination of the entity's domain and type. */
  entityType?: Maybe<EntityType>;
  /** The date of last time the entity has updated any of its fields. */
  firstIndexedAt?: Maybe<Scalars['EpochMilliseconds']['output']>;
  /** The list of golden metrics for a specific entity */
  goldenMetrics?: Maybe<EntityGoldenContextScopedGoldenMetrics>;
  /**
   * For the golden signal on this entity, show correlated signals from related entities.
   * Well inspect the golden signals for all related entities and return a sorted list.
   * You can also filter the results.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  goldenSignalCorrelations?: Maybe<GoldenSignalCorrelationResult>;
  /**
   * The deviation from normal of golden signal(s) for the given entity.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  goldenSignalDeviations?: Maybe<Array<Maybe<GoldenSignalSignalDeviation>>>;
  /**
   * The stored golden signal(s) for the given entity.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  goldenSignalValues?: Maybe<GoldenSignalValues>;
  /**
   * The stored golden signal(s) for the given entity. To be removed, use goldenSignalValues instead.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  goldenSignalValuesV2?: Maybe<GoldenSignalValues>;
  /** The list of golden tags for a specific entityType. */
  goldenTags?: Maybe<EntityGoldenContextScopedGoldenTags>;
  /** A unique entity identifier. */
  guid?: Maybe<Scalars['EntityGuid']['output']>;
  /** The time the entity was indexed. */
  indexedAt?: Maybe<Scalars['EpochMilliseconds']['output']>;
  /** The last time the entity's reporting status changed. */
  lastReportingChangeAt?: Maybe<Scalars['EpochMilliseconds']['output']>;
  /** The name of this entity. */
  name?: Maybe<Scalars['String']['output']>;
  /** The url to the entity. */
  permalink?: Maybe<Scalars['String']['output']>;
  /** The recommended service levels for the entity. */
  recommendedServiceLevel?: Maybe<ServiceLevelRecommendation>;
  /** Related dashboards results */
  relatedDashboards: RelatedDashboardsRelatedDashboardResult;
  /** The reporting status of the entity. If New Relic is successfully collecting data from your application, this will be true. */
  reporting?: Maybe<Scalars['Boolean']['output']>;
  /** The service level defined for the entity. */
  serviceLevel?: Maybe<ServiceLevelDefinition>;
  /** The list of summary metrics. */
  summaryMetrics?: Maybe<Array<Maybe<EntitySummaryMetric>>>;
  /**
   * The tags applied to the entity.
   *
   * For details on tags, as well as query and mutation examples, visit [our docs](https://docs.newrelic.com/docs/apis/graphql-api/tutorials/graphql-tagging-api-tutorial).
   */
  tags?: Maybe<Array<Maybe<EntityTag>>>;
  /** The entity's type */
  type?: Maybe<Scalars['String']['output']>;
  /** List of templates availables for this entity. */
  uiTemplates?: Maybe<Array<EntityDashboardTemplatesUi>>;
};


/** An entity outline that is unavailable. */
export type UnavailableEntityOutlineGoldenMetricsArgs = {
  context?: InputMaybe<EntityGoldenContextInput>;
  timeWindow?: InputMaybe<EntityGoldenNrqlTimeWindowInput>;
};


/** An entity outline that is unavailable. */
export type UnavailableEntityOutlineGoldenSignalCorrelationsArgs = {
  filter?: InputMaybe<GoldenSignalCorrelationsEntityFilter>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  timeWindow?: InputMaybe<TimeWindowInput>;
};


/** An entity outline that is unavailable. */
export type UnavailableEntityOutlineGoldenSignalDeviationsArgs = {
  comparisonTimeWindow?: InputMaybe<TimeWindowInput>;
  evaluationTimeWindow?: InputMaybe<TimeWindowInput>;
};


/** An entity outline that is unavailable. */
export type UnavailableEntityOutlineGoldenSignalValuesArgs = {
  timeWindow?: InputMaybe<TimeWindowInput>;
};


/** An entity outline that is unavailable. */
export type UnavailableEntityOutlineGoldenSignalValuesV2Args = {
  timeWindow?: InputMaybe<TimeWindowInput>;
};


/** An entity outline that is unavailable. */
export type UnavailableEntityOutlineGoldenTagsArgs = {
  context?: InputMaybe<EntityGoldenContextInput>;
};


/** An entity outline that is unavailable. */
export type UnavailableEntityOutlineSummaryMetricsArgs = {
  timeWindow?: InputMaybe<TimeWindowInput>;
};

/** The `User` object provides general data about the user. */
export type User = {
  __typename?: 'User';
  email?: Maybe<Scalars['String']['output']>;
  id?: Maybe<Scalars['Int']['output']>;
  name?: Maybe<Scalars['String']['output']>;
};

export type UserConsumptionAccountStitchedFields = {
  __typename?: 'UserConsumptionAccountStitchedFields';
  /** The list of on demand sessions started for the given account. */
  onDemandSessions?: Maybe<Array<UserConsumptionOnDemandSessionUser>>;
  /** The list of monetized users for the given account. */
  ratedUsers?: Maybe<Array<Maybe<UserConsumptionRatedUser>>>;
  /** A summary of user types for the given account. */
  userTierSummaries?: Maybe<Array<Maybe<UserConsumptionUserTierSummary>>>;
};


export type UserConsumptionAccountStitchedFieldsOnDemandSessionsArgs = {
  queryWindow: DateTimeWindowInput;
};


export type UserConsumptionAccountStitchedFieldsRatedUsersArgs = {
  ids: Array<InputMaybe<Scalars['ID']['input']>>;
};


export type UserConsumptionAccountStitchedFieldsUserTierSummariesArgs = {
  queryWindow: DateTimeWindowInput;
};

export type UserConsumptionConsumptionStitchedFields = {
  __typename?: 'UserConsumptionConsumptionStitchedFields';
  /** The list of monetized users for the given account. */
  ratedUsers?: Maybe<Array<Maybe<UserConsumptionRatedUser>>>;
  /** A summary of user types for the given account. */
  userTierSummaries?: Maybe<Array<Maybe<UserConsumptionUserTierSummary>>>;
};


export type UserConsumptionConsumptionStitchedFieldsRatedUsersArgs = {
  ids: Array<InputMaybe<Scalars['ID']['input']>>;
};


export type UserConsumptionConsumptionStitchedFieldsUserTierSummariesArgs = {
  queryWindow: DateTimeWindowInput;
};

/** An on-demand session. */
export type UserConsumptionOnDemandSession = {
  __typename?: 'UserConsumptionOnDemandSession';
  /** Flag indicating the session impact on billing */
  billableStatus?: Maybe<UserConsumptionSessionBillingStatus>;
  /** The unique id of the session */
  sessionId?: Maybe<Scalars['ID']['output']>;
  /** Start time of the session */
  timestamp?: Maybe<Scalars['DateTime']['output']>;
};

/** A monetized user. */
export type UserConsumptionOnDemandSessionUser = {
  __typename?: 'UserConsumptionOnDemandSessionUser';
  /** Number of billable sessions in the period. */
  billable?: Maybe<Scalars['Int']['output']>;
  /** The email of the user. */
  email?: Maybe<Scalars['String']['output']>;
  /** Number of free on-demand sessions in the period. */
  free?: Maybe<Scalars['Int']['output']>;
  /** Sessions included in the period */
  sessions?: Maybe<Array<UserConsumptionOnDemandSession>>;
  /** Total number of on-demand sessions in the period. */
  total?: Maybe<Scalars['Int']['output']>;
  /** The id of the user. */
  userId?: Maybe<Scalars['ID']['output']>;
};

export type UserConsumptionOrganizationStitchedFields = {
  __typename?: 'UserConsumptionOrganizationStitchedFields';
  /** The list of monetized users for the given organization. */
  ratedUsers?: Maybe<Array<Maybe<UserConsumptionRatedUser>>>;
};


export type UserConsumptionOrganizationStitchedFieldsRatedUsersArgs = {
  ids?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;
};

/** A monetized user. */
export type UserConsumptionRatedUser = {
  __typename?: 'UserConsumptionRatedUser';
  /** The tier this user is billed as. */
  billableType?: Maybe<UserConsumptionUserTier>;
  /** The email of the user. */
  email?: Maybe<Scalars['String']['output']>;
  /** The id of the user. */
  id?: Maybe<Scalars['ID']['output']>;
  /** The tier this user is provisioned as. */
  provisionedType?: Maybe<UserConsumptionUserTier>;
};

/** A monetized user without primary lookup information (i.e. an ID). */
export type UserConsumptionReducedRatedUser = {
  __typename?: 'UserConsumptionReducedRatedUser';
  /** The tier this user is billed as. */
  billableType?: Maybe<UserConsumptionUserTier>;
  /** The email of the user. */
  email?: Maybe<Scalars['String']['output']>;
  /** The tier this user is provisioned as. */
  provisionedType?: Maybe<UserConsumptionUserTier>;
};

/** Flag indicating whether the session was billed. */
export enum UserConsumptionSessionBillingStatus {
  /** The session incurred billing */
  Billable = 'BILLABLE',
  /** The session did not impact billing */
  Free = 'FREE'
}

/** User tiers to represent billable and provisioned user types. */
export enum UserConsumptionUserTier {
  /** The basic user tier. */
  Basic = 'BASIC',
  /** The core user tier. */
  Core = 'CORE',
  /** This user has been deleted. */
  Deleted = 'DELETED',
  /** The full platform user tier. */
  FullPlatform = 'FULL_PLATFORM'
}

/** The UserTier summary for a given account. */
export type UserConsumptionUserTierSummary = {
  __typename?: 'UserConsumptionUserTierSummary';
  /** The number of users billed at this tier. */
  billable?: Maybe<Scalars['Int']['output']>;
  /** The billed users in this tier. */
  billedUsers?: Maybe<Array<UserConsumptionReducedRatedUser>>;
  /** The id of summary. */
  id?: Maybe<Scalars['ID']['output']>;
  /** The name of user tier the summary represents. */
  name?: Maybe<UserConsumptionUserTier>;
  /** The number of users provisioned at this tier. */
  provisioned?: Maybe<Scalars['Int']['output']>;
  /** The datetime of the summary data. */
  summaryTime?: Maybe<Scalars['DateTime']['output']>;
};

export type UserEmailNotificationPreferencesActorStitchedFields = {
  __typename?: 'UserEmailNotificationPreferencesActorStitchedFields';
  /**
   * Get notification preferences for a user
   * @deprecated This field is experimental and subject to breaking changes.
   */
  notificationPreferences?: Maybe<Array<Maybe<UserEmailNotificationPreferencesNotificationPreference>>>;
  /**
   * Get suppression groups for a user
   * @deprecated This field is experimental and subject to breaking changes.
   */
  userSuppressionGroups?: Maybe<Array<Maybe<UserEmailNotificationPreferencesSuppressionGroup>>>;
};

/** User notification preference */
export type UserEmailNotificationPreferencesNotificationPreference = {
  __typename?: 'UserEmailNotificationPreferencesNotificationPreference';
  /**
   * Indicates whether the user is opted in for this subscription
   * @deprecated This field is experimental and subject to breaking changes.
   */
  isOptedIn: Scalars['Boolean']['output'];
  /**
   * Unique identifier for the subscription topic
   * @deprecated This field is experimental and subject to breaking changes.
   */
  topicId: Scalars['String']['output'];
  /**
   * Name of the subscription topic
   * @deprecated This field is experimental and subject to breaking changes.
   */
  topicName: Scalars['String']['output'];
};

/** Represents the subscription status of a user */
export enum UserEmailNotificationPreferencesSubscriptionStatus {
  /**
   * The user has opted in to receive notifications
   * @deprecated This field is experimental and subject to breaking changes.
   */
  OptedIn = 'OPTED_IN',
  /**
   * The user has opted out and will not receive notifications
   * @deprecated This field is experimental and subject to breaking changes.
   */
  OptedOut = 'OPTED_OUT'
}

/** User suppression group preference */
export type UserEmailNotificationPreferencesSuppressionGroup = {
  __typename?: 'UserEmailNotificationPreferencesSuppressionGroup';
  /**
   * Unique identifier for the suppression group id
   * @deprecated This field is experimental and subject to breaking changes.
   */
  id: Scalars['Int']['output'];
  /**
   * Name of the suppression group
   * @deprecated This field is experimental and subject to breaking changes.
   */
  name: Scalars['String']['output'];
  /**
   * Indicates whether the user is suppressed for the suppression group
   * @deprecated This field is experimental and subject to breaking changes.
   */
  suppressed: Scalars['Boolean']['output'];
};

/** Input for a subscription topic */
export type UserEmailNotificationPreferencesTopic = {
  /** New subscription status */
  status: UserEmailNotificationPreferencesSubscriptionStatus;
  /** Unique identifier for the subscription topic */
  topicId: Scalars['String']['input'];
};

/** Input for updated notification preference */
export type UserEmailNotificationPreferencesUpdatedNotificationPreference = {
  /** Details of the subscription topic to update */
  topic: UserEmailNotificationPreferencesTopic;
};

/** Response to an updated subscription request */
export type UserEmailNotificationPreferencesUpdatedNotificationPreferenceResponse = {
  __typename?: 'UserEmailNotificationPreferencesUpdatedNotificationPreferenceResponse';
  /**
   * Message describing the updated subscription status
   * @deprecated This field is experimental and subject to breaking changes.
   */
  message: Scalars['String']['output'];
  /**
   * Unique identifier for the subscription topic
   * @deprecated This field is experimental and subject to breaking changes.
   */
  topicId: Scalars['String']['output'];
};

/** Input for updated suppression group */
export type UserEmailNotificationPreferencesUpdatedSuppressionGroup = {
  /** Unique identifier for the suppression group id */
  id: Scalars['Int']['input'];
  /** Indicates whether the user is suppressed for the suppression group */
  suppressed: Scalars['Boolean']['input'];
};

/** Response to an updated suppression group request */
export type UserEmailNotificationPreferencesUpdatedSuppressionGroupResponse = {
  __typename?: 'UserEmailNotificationPreferencesUpdatedSuppressionGroupResponse';
  /**
   * Unique identifier for the suppression group id
   * @deprecated This field is experimental and subject to breaking changes.
   */
  id: Scalars['Int']['output'];
  /**
   * Updated suppression group message
   * @deprecated This field is experimental and subject to breaking changes.
   */
  message: Scalars['String']['output'];
};

export type UserInfo = {
  __typename?: 'UserInfo';
  email?: Maybe<Scalars['String']['output']>;
  gravatar?: Maybe<Scalars['String']['output']>;
  id?: Maybe<Scalars['Int']['output']>;
  label?: Maybe<Scalars['String']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  type?: Maybe<UserType>;
};

/** Autogenerated return type of AddUsersToGroups. */
export type UserManagementAddUsersToGroupsPayload = {
  __typename?: 'UserManagementAddUsersToGroupsPayload';
  /** The group(s) updated. */
  groups?: Maybe<Array<UserManagementGroup>>;
};

/** An "authentication domain" is a grouping of New Relic users governed by the same user management settings, like how they're provisioned (added and updated), how they're authenticated (logged in), session settings, and how user upgrades are managed. */
export type UserManagementAuthenticationDomain = {
  __typename?: 'UserManagementAuthenticationDomain';
  /** container for groups enabling cursor based pagination */
  groups?: Maybe<UserManagementGroups>;
  /** a value that uniquely identifies this object */
  id: Scalars['ID']['output'];
  /** the name of the object */
  name: Scalars['String']['output'];
  /** the method used to provision users in this authentication domain */
  provisioningType: Scalars['String']['output'];
  /** container for users enabling cursor based pagination */
  users?: Maybe<UserManagementUsers>;
};


/** An "authentication domain" is a grouping of New Relic users governed by the same user management settings, like how they're provisioned (added and updated), how they're authenticated (logged in), session settings, and how user upgrades are managed. */
export type UserManagementAuthenticationDomainGroupsArgs = {
  cursor?: InputMaybe<Scalars['String']['input']>;
  filter?: InputMaybe<UserManagementGroupFilterInput>;
  id?: InputMaybe<Array<Scalars['ID']['input']>>;
  sort?: InputMaybe<Array<UserManagementGroupSortInput>>;
};


/** An "authentication domain" is a grouping of New Relic users governed by the same user management settings, like how they're provisioned (added and updated), how they're authenticated (logged in), session settings, and how user upgrades are managed. */
export type UserManagementAuthenticationDomainUsersArgs = {
  cursor?: InputMaybe<Scalars['String']['input']>;
  filter?: InputMaybe<UserManagementUserFilterInput>;
  id?: InputMaybe<Array<Scalars['ID']['input']>>;
};

/** container for authentication domains enabling cursor based pagination */
export type UserManagementAuthenticationDomains = {
  __typename?: 'UserManagementAuthenticationDomains';
  /** container for authentication_domains enabling cursor based pagination */
  authenticationDomains: Array<UserManagementAuthenticationDomain>;
  /** an opaque cursor to supply with subsequent     requests to get the next page of results, null if there are no more pages */
  nextCursor?: Maybe<Scalars['String']['output']>;
  /** the total number of results */
  totalCount: Scalars['Int']['output'];
};

/** The input object representing the group being created */
export type UserManagementCreateGroup = {
  /** The id of the authentication domain the group will belong to */
  authenticationDomainId: Scalars['ID']['input'];
  /** The name of the group */
  displayName: Scalars['String']['input'];
};

/** Autogenerated return type of CreateGroup. */
export type UserManagementCreateGroupPayload = {
  __typename?: 'UserManagementCreateGroupPayload';
  /** The group that was created */
  group?: Maybe<UserManagementGroup>;
};

/** The input object representing the user being created */
export type UserManagementCreateUser = {
  /** The authentication domain id for the user to be created under. */
  authenticationDomainId: Scalars['ID']['input'];
  /** The email address of the user to be created. */
  email: Scalars['String']['input'];
  /** The name of the user to be created. */
  name: Scalars['String']['input'];
  /** The user type for the user to be created. */
  userType?: InputMaybe<UserManagementRequestedTierName>;
};

/** Autogenerated return type of CreateUser. */
export type UserManagementCreateUserPayload = {
  __typename?: 'UserManagementCreateUserPayload';
  /** The user that was created */
  createdUser?: Maybe<UserManagementCreatedUser>;
};

/** A newly created user of New Relic scoped to an authentication domain. */
export type UserManagementCreatedUser = {
  __typename?: 'UserManagementCreatedUser';
  /** Authentication domain of the created user. */
  authenticationDomainId?: Maybe<Scalars['ID']['output']>;
  /** Email address of the created user. */
  email: Scalars['String']['output'];
  /** The ID of the created user. */
  id: Scalars['ID']['output'];
  /** The full name of the created user. */
  name: Scalars['String']['output'];
  /** A "user type" is what determines the set of New Relic capabilities a user can theoretically access. */
  type: UserManagementUserType;
};

/** The input object representing the group to remove */
export type UserManagementDeleteGroup = {
  /** The ID of the group being removed. */
  id: Scalars['String']['input'];
};

/** Autogenerated return type of DeleteGroup. */
export type UserManagementDeleteGroupPayload = {
  __typename?: 'UserManagementDeleteGroupPayload';
  /** The group that was deleted */
  group?: Maybe<UserManagementGroup>;
};

/** The input object representing the user being deleted */
export type UserManagementDeleteUser = {
  /** The ID of the user to be deleted */
  id: Scalars['ID']['input'];
};

/** Autogenerated return type of DeleteUser. */
export type UserManagementDeleteUserPayload = {
  __typename?: 'UserManagementDeleteUserPayload';
  /** The user that was deleted */
  deletedUser?: Maybe<UserManagementDeletedUser>;
};

/** A user of New Relic to be deleted. */
export type UserManagementDeletedUser = {
  __typename?: 'UserManagementDeletedUser';
  /** The id of the deleted user */
  id: Scalars['ID']['output'];
};

/** Available filtering types for group display names */
export type UserManagementDisplayNameInput = {
  /** Part of a display name */
  contains?: InputMaybe<Scalars['String']['input']>;
  /** A display name */
  eq?: InputMaybe<Scalars['String']['input']>;
};

/** Available filtering types for email addresses */
export type UserManagementEmailInput = {
  /** Part of a user email */
  contains?: InputMaybe<Scalars['String']['input']>;
  /** A user email */
  eq?: InputMaybe<Scalars['String']['input']>;
};

/** Available filtering types for email verification states */
export type UserManagementEmailVerificationStateInput = {
  /** An email verification state */
  pending: Scalars['Boolean']['input'];
};

/** For users on our New Relic One user model, a "group" represents a group of users. Putting users in a group allows the managing of permissions for multiple users at the same time. */
export type UserManagementGroup = {
  __typename?: 'UserManagementGroup';
  /** the name of the object */
  displayName: Scalars['String']['output'];
  /** a value that uniquely identifies this object */
  id: Scalars['ID']['output'];
  /** container for users enabling cursor based pagination */
  users?: Maybe<UserManagementGroupUsers>;
};


/** For users on our New Relic One user model, a "group" represents a group of users. Putting users in a group allows the managing of permissions for multiple users at the same time. */
export type UserManagementGroupUsersArgs = {
  cursor?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Array<Scalars['ID']['input']>>;
};

/** The input object representing the filter parameters for groups */
export type UserManagementGroupFilterInput = {
  /** Filter groups by display name */
  displayName?: InputMaybe<UserManagementDisplayNameInput>;
  /** Filter groups by group ID */
  id?: InputMaybe<UserManagementGroupIdInput>;
};

/** Available filtering types for group IDs */
export type UserManagementGroupIdInput = {
  /** A group ID */
  eq?: InputMaybe<Scalars['ID']['input']>;
  /** An array of group IDs */
  in?: InputMaybe<Array<Scalars['ID']['input']>>;
};

/** The input object representing the sort parameters for groups */
export type UserManagementGroupSortInput = {
  /** Sort groups in this direction */
  direction?: InputMaybe<UserManagementSortDirection>;
  /** Sort groups by this key */
  key?: InputMaybe<UserManagementGroupSortKey>;
};

/** Available keys for sorting groups */
export enum UserManagementGroupSortKey {
  /** Sort by display name */
  DisplayName = 'DISPLAY_NAME',
  /** Sort by ID */
  Id = 'ID'
}

/** User information returned within Groups */
export type UserManagementGroupUser = {
  __typename?: 'UserManagementGroupUser';
  /** The email of the user. */
  email: Scalars['String']['output'];
  /** a value that uniquely identifies this object */
  id: Scalars['ID']['output'];
  /** The full name of the user. */
  name: Scalars['String']['output'];
  /** The configured time zone of the user. */
  timeZone: Scalars['String']['output'];
};

/** container for users enabling cursor based pagination */
export type UserManagementGroupUsers = {
  __typename?: 'UserManagementGroupUsers';
  /** an opaque cursor to supply with subsequent     requests to get the next page of results, null if there are no more pages */
  nextCursor?: Maybe<Scalars['String']['output']>;
  /** the total number of results */
  totalCount: Scalars['Int']['output'];
  /** container for users enabling cursor based pagination */
  users: Array<UserManagementGroupUser>;
};

/** container for groups enabling cursor based pagination */
export type UserManagementGroups = {
  __typename?: 'UserManagementGroups';
  /** container for groups enabling cursor based pagination */
  groups: Array<UserManagementGroup>;
  /** an opaque cursor to supply with subsequent     requests to get the next page of results, null if there are no more pages */
  nextCursor?: Maybe<Scalars['String']['output']>;
  /** the total number of results */
  totalCount: Scalars['Int']['output'];
};

/** Available filtering types for names */
export type UserManagementNameInput = {
  /** Part of a user name */
  contains?: InputMaybe<Scalars['String']['input']>;
  /** A user name */
  eq?: InputMaybe<Scalars['String']['input']>;
};

export type UserManagementOrganizationStitchedFields = {
  __typename?: 'UserManagementOrganizationStitchedFields';
  /** An "authentication domain" is a grouping of New Relic users governed by the same user management settings, like how they're provisioned (added and updated), how they're authenticated (logged in), session settings, and how user upgrades are managed. */
  authenticationDomains?: Maybe<UserManagementAuthenticationDomains>;
  /** User Types available for this organization */
  types?: Maybe<Array<UserManagementOrganizationUserType>>;
};


export type UserManagementOrganizationStitchedFieldsAuthenticationDomainsArgs = {
  cursor?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Array<Scalars['ID']['input']>>;
};

/** A "user type" is what determines the set of New Relic capabilities a user can theoretically access. */
export type UserManagementOrganizationUserType = {
  __typename?: 'UserManagementOrganizationUserType';
  /** the name of the object */
  displayName: Scalars['String']['output'];
  /** a value that uniquely identifies this object */
  id: Scalars['ID']['output'];
};

/** Exists only if a user has a pending upgrade request. */
export type UserManagementPendingUpgradeRequest = {
  __typename?: 'UserManagementPendingUpgradeRequest';
  /** a value that uniquely identifies this object */
  id: Scalars['ID']['output'];
  /** Requester message, why the user believes they require the upgrade. */
  message?: Maybe<Scalars['String']['output']>;
  /** Requested user type for the user. */
  requestedUserType?: Maybe<UserManagementUserType>;
};

/** Available filtering types for pending upgrade requests */
export type UserManagementPendingUpgradeRequestInput = {
  /** Whether a request exists or not */
  exists: Scalars['Boolean']['input'];
};

/** Autogenerated return type of RemoveUsersFromGroups. */
export type UserManagementRemoveUsersFromGroupsPayload = {
  __typename?: 'UserManagementRemoveUsersFromGroupsPayload';
  /** The group(s) updated. */
  groups?: Maybe<Array<UserManagementGroup>>;
};

/** Valid request types for user change requests */
export enum UserManagementRequestedTierName {
  /** basic tier */
  BasicUserTier = 'BASIC_USER_TIER',
  /** core tier */
  CoreUserTier = 'CORE_USER_TIER',
  /** full tier */
  FullUserTier = 'FULL_USER_TIER'
}

/** Available directions for sorting */
export enum UserManagementSortDirection {
  /** Sort in ascending order */
  Ascending = 'ASCENDING',
  /** Sort in descending order */
  Descending = 'DESCENDING'
}

/** Available values for Type */
export enum UserManagementTypeEnum {
  /** Basic type */
  Basic = 'BASIC',
  /** Core type */
  Core = 'CORE',
  /** Full type */
  FullPlatform = 'FULL_PLATFORM'
}

/** Available filtering types for user type */
export type UserManagementTypeInput = {
  /** A user type */
  eq: UserManagementTypeEnum;
};

/** The input object representing the group being updated */
export type UserManagementUpdateGroup = {
  /** The name of the group */
  displayName: Scalars['String']['input'];
  /** The id of the group to update */
  id: Scalars['ID']['input'];
};

/** Autogenerated return type of UpdateGroup. */
export type UserManagementUpdateGroupPayload = {
  __typename?: 'UserManagementUpdateGroupPayload';
  /** The group that was updated */
  group?: Maybe<UserManagementGroup>;
};

/** The input object representing the user being updated */
export type UserManagementUpdateUser = {
  /** The new email address to be updated on the user */
  email?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the user to be updated */
  id: Scalars['ID']['input'];
  /** The full name of the user to be updated */
  name?: InputMaybe<Scalars['String']['input']>;
  /** The user time zone to be updated, in IANA zoneinfo format, e.g. 'America/Chicago' */
  timeZone?: InputMaybe<Scalars['String']['input']>;
  /** The new user type to be updated on the user */
  userType?: InputMaybe<UserManagementRequestedTierName>;
};

/** Autogenerated return type of UpdateUser. */
export type UserManagementUpdateUserPayload = {
  __typename?: 'UserManagementUpdateUserPayload';
  /** The user that was updated */
  user?: Maybe<UserManagementUser>;
};

/** A user of New Relic scoped to an authentication domain. */
export type UserManagementUser = {
  __typename?: 'UserManagementUser';
  /** Email address of the user. */
  email?: Maybe<Scalars['String']['output']>;
  /**
   * One of: "Not Verifiable", "Verified", and "Pending".
   *
   * Not Verifiable: the user's email does not require verification.
   *
   * Verified: the user's email requires verification and has been.
   *
   * Pending: the user's email requires verification and has not been.
   */
  emailVerificationState: Scalars['String']['output'];
  /** container for groups enabling cursor based pagination */
  groups?: Maybe<UserManagementUserGroups>;
  /** a value that uniquely identifies this object */
  id: Scalars['ID']['output'];
  /** The last active date of the user. */
  lastActive?: Maybe<Scalars['DateTime']['output']>;
  /** The full name of the user. */
  name?: Maybe<Scalars['String']['output']>;
  /** The pending upgrade request for the user (if any). */
  pendingUpgradeRequest?: Maybe<UserManagementPendingUpgradeRequest>;
  /** Time zone of the user in IANA Time Zone database format, also known as the "Olson" time zone database format (for exmaple, "America/Los_Angeles"). */
  timeZone?: Maybe<Scalars['String']['output']>;
  /** A "user type" is what determines the set of New Relic capabilities a user can theoretically access. */
  type: UserManagementUserType;
};


/** A user of New Relic scoped to an authentication domain. */
export type UserManagementUserGroupsArgs = {
  cursor?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Array<Scalars['ID']['input']>>;
};

/** The input object representing the filter parameters for users */
export type UserManagementUserFilterInput = {
  /** Filter users by email address */
  email?: InputMaybe<UserManagementEmailInput>;
  /** Filter users by email verification state */
  emailVerificationState?: InputMaybe<UserManagementEmailVerificationStateInput>;
  /** Filter users by user ID */
  id?: InputMaybe<UserManagementUserIdInput>;
  /** Filter users by name */
  name?: InputMaybe<UserManagementNameInput>;
  /** Filter users by pending upgrade request */
  pendingUpgradeRequest?: InputMaybe<UserManagementPendingUpgradeRequestInput>;
  /** Filter users by type */
  type?: InputMaybe<UserManagementTypeInput>;
};

/** For users on our New Relic One user model, a "group" represents a group of users. Putting users in a group allows the managing of permissions for multiple users at the same time. */
export type UserManagementUserGroup = {
  __typename?: 'UserManagementUserGroup';
  /** the name of the object */
  displayName: Scalars['String']['output'];
  /** a value that uniquely identifies this object */
  id: Scalars['ID']['output'];
};

/** container for groups enabling cursor based pagination */
export type UserManagementUserGroups = {
  __typename?: 'UserManagementUserGroups';
  /** container for groups enabling cursor based pagination */
  groups: Array<UserManagementUserGroup>;
  /** an opaque cursor to supply with subsequent     requests to get the next page of results, null if there are no more pages */
  nextCursor?: Maybe<Scalars['String']['output']>;
  /** the total number of results */
  totalCount: Scalars['Int']['output'];
};

/** Available filtering types for user IDs */
export type UserManagementUserIdInput = {
  /** A user ID */
  eq?: InputMaybe<Scalars['ID']['input']>;
  /** An array of user IDs */
  in?: InputMaybe<Array<Scalars['ID']['input']>>;
};

/** A "user type" is what determines the set of New Relic capabilities a user can theoretically access. */
export type UserManagementUserType = {
  __typename?: 'UserManagementUserType';
  /** the name of the object */
  displayName: Scalars['String']['output'];
  /** a value that uniquely identifies this object */
  id: Scalars['ID']['output'];
};

/** container for users enabling cursor based pagination */
export type UserManagementUsers = {
  __typename?: 'UserManagementUsers';
  /** an opaque cursor to supply with subsequent     requests to get the next page of results, null if there are no more pages */
  nextCursor?: Maybe<Scalars['String']['output']>;
  /** the total number of results */
  totalCount: Scalars['Int']['output'];
  /** container for users enabling cursor based pagination */
  users: Array<UserManagementUser>;
};

/** The input object representing the group(s) and user(s) to update. */
export type UserManagementUsersGroupsInput = {
  /** The id of the group(s) to add the user(s) to. Max: 10 */
  groupIds: Array<Scalars['ID']['input']>;
  /** The id of the user(s) to be added to the group(s). Max: 50 */
  userIds: Array<Scalars['ID']['input']>;
};

export type UserObject = {
  __typename?: 'UserObject';
  /**
   * The `account` field is the entry point into data that is scoped to a single account.
   *
   * **Note:** This field has atypical authorization behavior:
   *
   * Using access token auth:
   * - For requests sent to NerdGraph's `/accounts/:id/grapqhl` endpoint, it will only allow users to access the account provided as `:id` in the URL, assuming it is in their list of authorized accounts.
   * - For requests sent with the `x-account-id` header, it will only allow users to access the account provided in the `x-account-id` header, assuming it is in their list of authorized accounts.
   * - Otherwise, it will allow the user to request any account ID in their list of authorized accounts.
   *
   * Using API key auth: **It will only allow users to access the account associated with the API key.**
   *
   * For more typical authorization behavior, wherein a user's whole list of authorized accounts is accessible without the exceptions above, use `actor.account` instead.
   */
  account?: Maybe<AccountObject>;
  /**
   * This is the full list of Accounts that the User is associated with, including all child sub-accounts.
   *
   * This is appropriate for things like an Account dropdown menu, but it does *NOT* imply access.
   * The User may be required to re-authenticate when attempting to view an account in this list.
   *
   * Caveats:
   * * This does not include Partnership accounts - for the list of accounts that are part of a Partnership, use `account.ownedPartnerships.accounts`
   * * For the list of accounts that the User can *currently* access, use `currentUser.authorizedAccounts`
   */
  accounts?: Maybe<Array<Maybe<AccountInfo>>>;
  /** The regions that the User has `authorizedAccounts` in. */
  authorizedAccountRegions?: Maybe<Array<Maybe<Region>>>;
  /**
   * This is the list of Accounts that the User can currently access given their current authorization mechanism.
   *
   * This is appropriate for allowing access to Account data.
   *
   * Caveats:
   * * This does not include Partnership accounts - for the list of accounts that are part of a Partnership, use `account.ownedPartnerships.accounts`
   * * For the complete list of accounts that the User is directly associated with, use `currentUser.accounts`
   */
  authorizedAccounts?: Maybe<Array<Maybe<AccountAccessInfo>>>;
  /** Checks if the listed accounts are authorized by the given context. */
  authorizedAccountsCheck?: Maybe<Array<Maybe<AccountAuthorization>>>;
  capabilities?: Maybe<Array<Maybe<Capability>>>;
  /** Provides data that spans _all_ of the `currentUser`'s `authorizedAccounts`. */
  crossAccount?: Maybe<CrossAccount>;
  currentAccount?: Maybe<AccountObject>;
  email?: Maybe<Scalars['String']['output']>;
  /**
   * Please use `actor.entities` instead.
   *
   * Fetch a list of entities.
   *
   * You can fetch a max of 25 entities in one query.
   *
   * For more details on entities, visit our [entity docs](https://docs.newrelic.com/docs/apis/graphql-api/tutorials/use-new-relic-graphql-api-query-entities).
   */
  entities?: Maybe<Array<Maybe<Entity>>>;
  /**
   * Please use `actor.entity` instead.
   *
   * Fetch a single entity.
   *
   * For more details on entities, visit our [entity docs](https://docs.newrelic.com/docs/apis/graphql-api/tutorials/use-new-relic-graphql-api-query-entities).
   */
  entity?: Maybe<Entity>;
  entityBulkLoad?: Maybe<Array<Maybe<EntityOutline>>>;
  /**
   * Search for entities by a custom query.
   *
   * For more details on Entities, visit our [Entity Docs](https://docs.newrelic.com/docs/apis/graphql-api/tutorials/use-new-relic-graphql-api-query-entities).
   * Note: you must supply either a `query` OR a `queryBuilder` argument, not both.
   */
  entitySearch?: Maybe<EntitySearch>;
  fallbackAccount?: Maybe<AccountInfo>;
  /** These Feature Flags will be evaluated exclusively against the User ID. */
  featureFlags?: Maybe<Array<Maybe<FeatureFlag>>>;
  gravatar?: Maybe<Scalars['String']['output']>;
  id?: Maybe<Scalars['Int']['output']>;
  isImpersonated?: Maybe<Scalars['Boolean']['output']>;
  label?: Maybe<Scalars['String']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  /**
   * NerdStorage is a document database that is accessible within the New Relic One interface.
   * This allows for persistence of Nerdpack data including users' configuration settings and preferences
   * (like favorites), or any other small data sets.
   *
   * Conceptually, you can imagine NerdStorage as a nested key-value map.
   *
   * For information on New Relic NerdStorage, visit [our docs](https://developer.newrelic.com/build-tools/new-relic-one-applications/nerdstorage).
   *
   * To use the NerdStorage schema you must specify a Nerdpack ID using the NewRelic-Package-Id header in your request.
   */
  nerdStorage?: Maybe<NerdStorageActorScope>;
  nerdStoreCollection?: Maybe<Array<Maybe<NerdStoreCollectionMember>>>;
  nerdStoreDocument?: Maybe<Scalars['NerdStoreDocument']['output']>;
  /**
   * A historical log of NRQL queries executed by you.
   * @deprecated This field is deprecated and returns no data. Please use `queryHistory`.
   *
   */
  nrqlQueryHistory?: Maybe<Array<Maybe<NrqlHistoricalQuery>>>;
  timeZoneName?: Maybe<Scalars['String']['output']>;
  /** Time Zone offset in seconds, including Daylight Savings Time */
  timeZoneOffset?: Maybe<Scalars['Seconds']['output']>;
  timeZonePeriod?: Maybe<Array<Maybe<TimeZonePeriod>>>;
  type?: Maybe<UserType>;
};


export type UserObjectAccountArgs = {
  id: Scalars['Int']['input'];
};


export type UserObjectAuthorizedAccountsArgs = {
  filter?: InputMaybe<AuthorizedAccountsFilter>;
  scope?: InputMaybe<RegionScope>;
};


export type UserObjectAuthorizedAccountsCheckArgs = {
  accountIds: Array<InputMaybe<Scalars['Int']['input']>>;
};


export type UserObjectCapabilitiesArgs = {
  accountId: Scalars['Int']['input'];
  filter?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
};


export type UserObjectEntitiesArgs = {
  guids: Array<InputMaybe<Scalars['EntityGuid']['input']>>;
};


export type UserObjectEntityArgs = {
  guid: Scalars['EntityGuid']['input'];
};


export type UserObjectEntityBulkLoadArgs = {
  guids: Array<InputMaybe<Scalars['EntityGuid']['input']>>;
};


export type UserObjectEntitySearchArgs = {
  options?: InputMaybe<EntitySearchOptions>;
  query?: InputMaybe<Scalars['String']['input']>;
  queryBuilder?: InputMaybe<EntitySearchQueryBuilder>;
  sortBy?: InputMaybe<Array<InputMaybe<EntitySearchSortCriteria>>>;
  sortByWithDirection?: InputMaybe<Array<InputMaybe<SortCriterionWithDirection>>>;
};


export type UserObjectFeatureFlagsArgs = {
  criteria?: InputMaybe<Scalars['String']['input']>;
  names: Array<InputMaybe<Scalars['String']['input']>>;
};


export type UserObjectNerdStoreCollectionArgs = {
  collection: Scalars['String']['input'];
};


export type UserObjectNerdStoreDocumentArgs = {
  collection: Scalars['String']['input'];
  documentId: Scalars['String']['input'];
};


export type UserObjectTimeZonePeriodArgs = {
  at: Scalars['EpochSeconds']['input'];
};

/** An object that stores the preferences updated by the user */
export type UserPreferences = {
  __typename?: 'UserPreferences';
  /** The user id */
  id?: Maybe<Scalars['ID']['output']>;
  /** The user name */
  name?: Maybe<Scalars['String']['output']>;
  /** The user time zone, displayed in a user friendly format */
  timeZoneName?: Maybe<Scalars['String']['output']>;
  /** Where the time zone information comes from */
  timeZoneSource?: Maybe<UserTimeZoneSource>;
};

/** The `UserReference` object provides basic identifying information about the user. */
export type UserReference = {
  __typename?: 'UserReference';
  email?: Maybe<Scalars['String']['output']>;
  gravatar?: Maybe<Scalars['String']['output']>;
  id?: Maybe<Scalars['Int']['output']>;
  name?: Maybe<Scalars['String']['output']>;
};

/** Valid request types for user change requests */
export enum UserRequestedTierName {
  /** basic tier */
  BasicUserTier = 'BASIC_USER_TIER',
  /** core tier */
  CoreUserTier = 'CORE_USER_TIER',
  /** full tier */
  FullUserTier = 'FULL_USER_TIER'
}

/** The source of the user's time zone */
export enum UserTimeZoneSource {
  /** when a user's time zone comes from the field on the user */
  TimeZone = 'TIME_ZONE',
  /** when a user has set a time_zone_override */
  TimeZoneOverride = 'TIME_ZONE_OVERRIDE'
}

export enum UserType {
  /** Customer */
  Customer = 'CUSTOMER',
  /** New Relic Administrator */
  NrAdmin = 'NR_ADMIN'
}

/** The input object representing the user preferences to be updated */
export type UserUpdatePreferences = {
  /** The full name of the user */
  name?: InputMaybe<Scalars['String']['input']>;
  /** The user time zone */
  timeZone?: InputMaybe<Scalars['String']['input']>;
};

/** A user-readable error */
export type UserUpdatePreferencesError = {
  __typename?: 'UserUpdatePreferencesError';
  /** A description of the error */
  message: Scalars['String']['output'];
};

/** Autogenerated return type of UpdatePreferences. */
export type UserUpdatePreferencesPayload = {
  __typename?: 'UserUpdatePreferencesPayload';
  /**
   * List of errors which occurred while performing the request.
   * @deprecated Errors are now returned outside of the data payload
   */
  errors: Array<UserUpdatePreferencesError>;
  /** Indicator for if the request was successful */
  status: UserUpdatePreferencesStatus;
  /** An object storing the preferences updated by the user */
  userPreferences?: Maybe<UserPreferences>;
};

/** The possible return values for the UpdatePreferences mutation. */
export enum UserUpdatePreferencesStatus {
  /** Status indicating the attempt to update the user preferences failed */
  UpdatePreferencesFailure = 'UPDATE_PREFERENCES_FAILURE',
  /** Status indicating the user successfully updated their preferences */
  UpdatePreferencesSuccess = 'UPDATE_PREFERENCES_SUCCESS'
}

/** A user-readable error */
export type UserUpgradeError = {
  __typename?: 'UserUpgradeError';
  /** A description of the error */
  message: Scalars['String']['output'];
};

/** The input object representing the user upgrade options */
export type UserUpgradeSelf = {
  /** An optional message for admins to see when upgrade request is sent */
  requestMessage?: InputMaybe<Scalars['String']['input']>;
  /** The tier that the user would like to change to */
  requestedTier?: InputMaybe<UserRequestedTierName>;
};

/** Autogenerated return type of UpgradeSelf. */
export type UserUpgradeSelfPayload = {
  __typename?: 'UserUpgradeSelfPayload';
  /**
   * List of errors which occurred while performing the request.
   * @deprecated Errors are now returned outside of the data payload
   */
  errors: Array<UserUpgradeError>;
  /** Indicator for if the request was successful */
  status: UserUpgradeSelfStatus;
};

/** The possible return values for the UpgradeSelf mutation. */
export enum UserUpgradeSelfStatus {
  /** Status indicating the user's tier change was already requested, and was unchanged by this operation */
  AlreadyRequestedTier = 'ALREADY_REQUESTED_TIER',
  /** Status indicating the user was already upgraded, and was unchanged by this operation */
  AlreadyUpgraded = 'ALREADY_UPGRADED',
  /** Status indicating the attempt to change the user's tier failed */
  TierChangeFailure = 'TIER_CHANGE_FAILURE',
  /** Status indicating the user has successfully initiated a tier change request with their admin(s) */
  TierChangeRequested = 'TIER_CHANGE_REQUESTED',
  /** Status indicating the user's tier was successfully changed */
  TierChangeSuccess = 'TIER_CHANGE_SUCCESS',
  /** Status indicating the attempt to upgrade a user failed */
  UpgradeFailure = 'UPGRADE_FAILURE',
  /** Status indicating the user has successfully initiated an upgrade request with their admin(s) */
  UpgradeRequested = 'UPGRADE_REQUESTED',
  /** Status indicating the user was successfully upgraded */
  UpgradeSuccess = 'UPGRADE_SUCCESS'
}

export type UsersActorStitchedFields = {
  __typename?: 'UsersActorStitchedFields';
  /**
   * Search for users using a custom query.
   *  If no query is provided, returns all visible users.
   *  NOTE: this API only supports users in the New Relic One user model.
   */
  userSearch?: Maybe<UsersUserSearchResult>;
};


export type UsersActorStitchedFieldsUserSearchArgs = {
  cursor?: InputMaybe<Scalars['String']['input']>;
  query?: InputMaybe<UsersUserSearchQuery>;
};

export type UsersCountOrganizationStitchedFields = {
  __typename?: 'UsersCountOrganizationStitchedFields';
  /** A summary of user counts for the given organization. */
  summary?: Maybe<UsersCountSummary>;
};

/** The UserCount summary for a given organization. */
export type UsersCountSummary = {
  __typename?: 'UsersCountSummary';
  /** The basic users count of given organization */
  basicUsersCount?: Maybe<Scalars['Int']['output']>;
  /** The core users count of given organization */
  coreUsersCount?: Maybe<Scalars['Int']['output']>;
  /** The full-platform users count of given organization */
  fullUsersCount?: Maybe<Scalars['Int']['output']>;
  /** The total count of all the users in given organization */
  totalUsersCount?: Maybe<Scalars['Int']['output']>;
};

/** User information returned for UserSearch */
export type UsersUserSearch = {
  __typename?: 'UsersUserSearch';
  /** The email of the user. */
  email?: Maybe<Scalars['String']['output']>;
  /** The full name of the user. */
  name?: Maybe<Scalars['String']['output']>;
  /** The unique identifier of the user. */
  userId?: Maybe<Scalars['ID']['output']>;
};

/** Query object for UserSearch. */
export type UsersUserSearchQuery = {
  /** The scope to filter the search response by. */
  scope?: InputMaybe<UsersUserSearchScope>;
};

/** The result object for UserSearch. */
export type UsersUserSearchResult = {
  __typename?: 'UsersUserSearchResult';
  /** The cursor for the next page. */
  nextCursor?: Maybe<Scalars['String']['output']>;
  /**
   * The total number of users found.
   *  Note: Not necessarily the same as number of users returned, due to pagination.
   */
  totalCount: Scalars['Int']['output'];
  /** Set of all users returned from the query. */
  users: Array<UsersUserSearch>;
};

/** Different scopes that can be used to filter the returned users. */
export type UsersUserSearchScope = {
  /** Filter by string that will partially match a User's `email`.  Same as `name` it will partially match and case is ignored. */
  email?: InputMaybe<Scalars['String']['input']>;
  /** Filter by string that will partially match a User's `name`. So argument `name='Ste'` will match `name='Steve'` and case is ignored so `name='Koester'` would also match. */
  name?: InputMaybe<Scalars['String']['input']>;
  /** Will match both a User's `email` and `name`.  So argument `search='ple'`  will match `name='Johnny Appleseed'` and `email='mary@example.com'`. */
  search?: InputMaybe<Scalars['String']['input']>;
  /** List of 1 or more userIds to filter by. Will only return data for users with ids that match the full ID, no partial matching. (so 2 ids provided will yield at most 2 users) */
  userIds?: InputMaybe<Array<Scalars['ID']['input']>>;
};

/** Account Details of the website performance monitoring query */
export type WebsitePerformanceMonitoringAccountDetailsResponse = {
  __typename?: 'WebsitePerformanceMonitoringAccountDetailsResponse';
  /**
   * The status of the account
   * @deprecated This field is experimental and subject to breaking changes.
   */
  status: WebsitePerformanceMonitoringAccountStatus;
};

/** The possible status of the account */
export enum WebsitePerformanceMonitoringAccountStatus {
  /**
   * The requested account already exists with website performance monitoring
   * @deprecated This field is experimental and subject to breaking changes.
   */
  Exists = 'EXISTS',
  /**
   * The requested account not exists with website performance monitoring
   * @deprecated This field is experimental and subject to breaking changes.
   */
  New = 'NEW'
}

export type WebsitePerformanceMonitoringAccountStitchedFields = {
  __typename?: 'WebsitePerformanceMonitoringAccountStitchedFields';
  /**
   * Details of account
   * @deprecated This field is experimental and subject to breaking changes.
   */
  accountDetails?: Maybe<WebsitePerformanceMonitoringAccountDetailsResponse>;
  /**
   * Check and returns if website url is valid
   * @deprecated This field is experimental and subject to breaking changes.
   */
  websiteUrl?: Maybe<WebsitePerformanceMonitoringWebsiteUrlResponse>;
};


export type WebsitePerformanceMonitoringAccountStitchedFieldsWebsiteUrlArgs = {
  websiteDetails: WebsitePerformanceMonitoringWebsiteInput;
};

/** The result of website performance monitors' creation mutation */
export type WebsitePerformanceMonitoringCreateMonitorsResponse = {
  __typename?: 'WebsitePerformanceMonitoringCreateMonitorsResponse';
  /**
   * The status message of the mutation call
   * @deprecated This field is experimental and subject to breaking changes.
   */
  message: Scalars['String']['output'];
  /**
   * List of monitor details of the mutation call
   * @deprecated This field is experimental and subject to breaking changes.
   */
  monitorDetails?: Maybe<Array<Maybe<WebsitePerformanceMonitoringMonitorDetails>>>;
  /**
   * Url of the website
   * @deprecated This field is experimental and subject to breaking changes.
   */
  url: Scalars['String']['output'];
};

/** Monitor Details of the website performance monitoring mutation */
export type WebsitePerformanceMonitoringMonitorDetails = {
  __typename?: 'WebsitePerformanceMonitoringMonitorDetails';
  /**
   * Guid of the syntheticsMonitor
   * @deprecated This field is experimental and subject to breaking changes.
   */
  guid: Scalars['EntityGuid']['output'];
  /**
   * Id of the syntheticsMonitor
   * @deprecated This field is experimental and subject to breaking changes.
   */
  monitorId: Scalars['String']['output'];
  /**
   * Type of the syntheticsMonitor
   * @deprecated This field is experimental and subject to breaking changes.
   */
  monitorType: Scalars['String']['output'];
};

/** The request source of website performance monitoring */
export enum WebsitePerformanceMonitoringRequestSource {
  /**
   * Request from other sources
   * @deprecated This field is experimental and subject to breaking changes.
   */
  Other = 'OTHER',
  /**
   * Request from website performance monitoring nerdlet
   * @deprecated This field is experimental and subject to breaking changes.
   */
  WebsiteMonitoring = 'WEBSITE_MONITORING'
}

/** The request status of website performance monitoring */
export enum WebsitePerformanceMonitoringRequestStatus {
  /**
   * The website performance monitoring is deleted
   * @deprecated This field is experimental and subject to breaking changes.
   */
  Deleted = 'DELETED',
  /**
   * Monitors are not active and the request is disabled
   * @deprecated This field is experimental and subject to breaking changes.
   */
  Disabled = 'DISABLED',
  /**
   * Monitors are active and the request is Enabled
   * @deprecated This field is experimental and subject to breaking changes.
   */
  Enabled = 'ENABLED'
}

/** The request type of website performance monitoring */
export enum WebsitePerformanceMonitoringRequestType {
  /**
   * Competitor website request
   * @deprecated This field is experimental and subject to breaking changes.
   */
  Competitor = 'COMPETITOR',
  /**
   * Other website request
   * @deprecated This field is experimental and subject to breaking changes.
   */
  Other = 'OTHER',
  /**
   * User website request
   * @deprecated This field is experimental and subject to breaking changes.
   */
  User = 'USER'
}

/** Website Performance Monitoring update request fields */
export type WebsitePerformanceMonitoringUpdateRequestFields = {
  /** The status to be updated */
  status?: InputMaybe<WebsitePerformanceMonitoringRequestStatus>;
};

/** Result of website performance monitoring update mutation */
export type WebsitePerformanceMonitoringUpdateRequestResponse = {
  __typename?: 'WebsitePerformanceMonitoringUpdateRequestResponse';
  /**
   * The status message of the mutation call
   * @deprecated This field is experimental and subject to breaking changes.
   */
  message: Scalars['String']['output'];
  /**
   * Url of the website
   * @deprecated This field is experimental and subject to breaking changes.
   */
  url: Scalars['String']['output'];
};

/** Details of the website */
export type WebsitePerformanceMonitoringWebsiteInput = {
  /** Url of the website */
  url: Scalars['String']['input'];
};

/** The result validate website url query */
export type WebsitePerformanceMonitoringWebsiteUrlResponse = {
  __typename?: 'WebsitePerformanceMonitoringWebsiteUrlResponse';
  /**
   * The response code for the query call
   * @deprecated This field is experimental and subject to breaking changes.
   */
  code?: Maybe<Scalars['Int']['output']>;
  /**
   * The response message for the query call
   * @deprecated This field is experimental and subject to breaking changes.
   */
  message?: Maybe<Scalars['String']['output']>;
  /**
   * final url value after validation
   * @deprecated This field is experimental and subject to breaking changes.
   */
  url: Scalars['String']['output'];
};

/** Represents the details about an announcement. */
export type WhatsNewAnnouncementContent = WhatsNewContent & {
  __typename?: 'WhatsNewAnnouncementContent';
  /** The body of the news. */
  body?: Maybe<Scalars['String']['output']>;
  /** The type of the news. */
  contentType: WhatsNewContentType;
  /** Contains information about the context of the announcement. */
  context?: Maybe<Array<Scalars['String']['output']>>;
  /** A link to the documentation. */
  docUrl?: Maybe<Scalars['String']['output']>;
  /** A link to a page to get started. */
  gettingStartedUrl?: Maybe<Scalars['String']['output']>;
  /** The ID of the announcement. */
  id: Scalars['ID']['output'];
  /** A boolean representing whether this content is Featured. */
  isFeatured?: Maybe<Scalars['Boolean']['output']>;
  /** A link to a page to learn more about the announcement. */
  learnMoreUrl?: Maybe<Scalars['String']['output']>;
  /** The date the announcement was published. */
  publishDate?: Maybe<Scalars['EpochMilliseconds']['output']>;
  /** Information about the requirements. */
  requirements?: Maybe<Scalars['String']['output']>;
  /** The summary of the announcement. */
  summary?: Maybe<Scalars['String']['output']>;
  /** The title of the announcement. */
  title?: Maybe<Scalars['String']['output']>;
};

/** Represents the details in common between all types of news. */
export type WhatsNewContent = {
  /** The type of the news. */
  contentType: WhatsNewContentType;
  /** Contains information about the context of the news. */
  context?: Maybe<Array<Scalars['String']['output']>>;
  /** The ID of the news. */
  id: Scalars['ID']['output'];
  /** The date the news was published. */
  publishDate?: Maybe<Scalars['EpochMilliseconds']['output']>;
  /** The summary of the news. */
  summary?: Maybe<Scalars['String']['output']>;
  /** The title of the news. */
  title?: Maybe<Scalars['String']['output']>;
};

/** A query that represents a criteria for searching news. */
export type WhatsNewContentSearchQuery = {
  /** Criteria to narrow the scope of the search to a specific type of news. */
  contentType?: InputMaybe<WhatsNewContentType>;
  /** Criteria to narrow the scope of the search to only those news that are unread by the current user. */
  unreadOnly?: InputMaybe<Scalars['Boolean']['input']>;
};

/** Represents the different types of content available when searching by news. */
export enum WhatsNewContentType {
  /** News the content of which is type of announcement. */
  Announcement = 'ANNOUNCEMENT'
}

export type WhatsNewDocsStitchedFields = {
  __typename?: 'WhatsNewDocsStitchedFields';
  /** Fetches an announcement by ID. */
  announcement?: Maybe<WhatsNewAnnouncementContent>;
  /** Provides a paginated search to fetch news. */
  newsSearch?: Maybe<WhatsNewSearchResult>;
};


export type WhatsNewDocsStitchedFieldsAnnouncementArgs = {
  id: Scalars['ID']['input'];
};


export type WhatsNewDocsStitchedFieldsNewsSearchArgs = {
  cursor?: InputMaybe<Scalars['String']['input']>;
  query?: InputMaybe<WhatsNewContentSearchQuery>;
};

/** Represents the resulting details from a search of news. */
export type WhatsNewSearchResult = {
  __typename?: 'WhatsNewSearchResult';
  /** The next cursor, used for pagination. If a cursor is present, it means more content can be fetched. */
  nextCursor?: Maybe<Scalars['String']['output']>;
  /** A list of news. */
  results?: Maybe<Array<WhatsNewContent>>;
  /** The total amount of news available that satisfies the search criteria. */
  totalCount: Scalars['Int']['output'];
};

export type WorkloadAccountStitchedFields = {
  __typename?: 'WorkloadAccountStitchedFields';
  /**
   * [DEPRECATED] Retrieves a workload.
   * @deprecated Use the entity-specific alternatives like entity(guid).
   */
  collection?: Maybe<WorkloadCollection>;
  /**
   * [DEPRECATED] Retrieves a list of workloads.
   * @deprecated Use the entity-specific alternatives like entitySearch(query).
   */
  collections?: Maybe<Array<WorkloadCollectionWithoutStatus>>;
  /**
   * [DEPRECATED] Status and breakdown preview.
   * @deprecated This field is subject to breaking changes.
   */
  statusBreakdownPreview?: Maybe<WorkloadWorkloadStatus>;
  /**
   * [DEPRECATED] Retrieves all the accounts from the same organization that user has access to.
   * @deprecated This field is subject to breaking changes.
   */
  validAccounts?: Maybe<WorkloadValidAccounts>;
};


export type WorkloadAccountStitchedFieldsCollectionArgs = {
  guid: Scalars['EntityGuid']['input'];
};


export type WorkloadAccountStitchedFieldsStatusBreakdownPreviewArgs = {
  entitySearchQuery: Scalars['String']['input'];
  scopeAccounts: WorkloadScopeAccountsInput;
  statusConfig: WorkloadStatusConfigInput;
};

/** The automatic status configuration. */
export type WorkloadAutomaticStatus = {
  __typename?: 'WorkloadAutomaticStatus';
  /** Whether the automatic status configuration is enabled or not. */
  enabled: Scalars['Boolean']['output'];
  /** An additional meta-rule that can consider all entities that haven't been evaluated by any other rule. */
  remainingEntitiesRule?: Maybe<WorkloadRemainingEntitiesRule>;
  /** A list of rules. */
  rules: Array<WorkloadRegularRule>;
};

/** An input object used to represent an automatic status configuration. If not provided, a status configuration will be created by default. */
export type WorkloadAutomaticStatusInput = {
  /** Whether the automatic status configuration is enabled or not. */
  enabled: Scalars['Boolean']['input'];
  /** An additional meta-rule that can consider all entities that haven't been evaluated by any other rule. */
  remainingEntitiesRule?: InputMaybe<WorkloadRemainingEntitiesRuleInput>;
  /** A list of rules. */
  rules?: InputMaybe<Array<WorkloadRegularRuleInput>>;
};

/** A user defined group of entities. */
export type WorkloadCollection = {
  __typename?: 'WorkloadCollection';
  /** The account the workload belongs to. */
  account?: Maybe<AccountReference>;
  /** Whether the workload has been automatically deactivated */
  autoDeactivated: Scalars['Boolean']['output'];
  /** The moment when the object was created, represented in milliseconds since the Unix epoch. */
  createdAt: Scalars['EpochMilliseconds']['output'];
  /** The user who created the workload. */
  createdBy?: Maybe<UserReference>;
  /** Relevant information about the workload. */
  description?: Maybe<Scalars['String']['output']>;
  /** A list of entity GUIDs. These entities will belong to the collection as long as their accounts are included in the scope accounts of the collection. */
  entities?: Maybe<Array<WorkloadEntityRef>>;
  /** A list of entity search queries. The resulting entities will be limited to the scope accounts of the collection. */
  entitySearchQueries?: Maybe<Array<WorkloadEntitySearchQuery>>;
  /** The entity search query that returns the full collection of entities. */
  entitySearchQuery?: Maybe<Scalars['String']['output']>;
  /** The unique entity identifier of the workload in New Relic. */
  guid: Scalars['EntityGuid']['output'];
  /** The unique identifier of the workload. */
  id: Scalars['Int']['output'];
  /** The entity search query that returns the dashboards linked to a workload. */
  linkedDashboardsSearchQuery?: Maybe<Scalars['String']['output']>;
  /** A list of dynamic dashboards linked to the workload. */
  linkedDynamicDashboards?: Maybe<WorkloadDynamicDashboards>;
  /** A list of individual dashboards linked to the workload. */
  linkedIndividualDashboards?: Maybe<Array<WorkloadIndividualDashboard>>;
  /** The workload's name. */
  name: Scalars['String']['output'];
  /** The URL of the workload. */
  permalink: Scalars['String']['output'];
  /** A list of resources associated to the workload. */
  resources?: Maybe<Array<WorkloadResource>>;
  /** Accounts that will be used to get entities from. */
  scopeAccounts: WorkloadScopeAccounts;
  /** Status of the workload. */
  status: WorkloadWorkloadStatus;
  /** The configuration that defines how the status of the workload is calculated. */
  statusConfig?: Maybe<WorkloadStatusConfig>;
  /** The moment when the object was last updated, represented in milliseconds since the Unix epoch. */
  updatedAt?: Maybe<Scalars['EpochMilliseconds']['output']>;
  /** The user who last updated the workload. */
  updatedBy?: Maybe<UserReference>;
};

/** A user defined group of entities without Status */
export type WorkloadCollectionWithoutStatus = {
  __typename?: 'WorkloadCollectionWithoutStatus';
  /** The account the workload belongs to. */
  account?: Maybe<AccountReference>;
  /** Whether the workload has been automatically deactivated */
  autoDeactivated: Scalars['Boolean']['output'];
  /** The moment when the object was created, represented in milliseconds since the Unix epoch. */
  createdAt: Scalars['EpochMilliseconds']['output'];
  /** The user who created the workload. */
  createdBy?: Maybe<UserReference>;
  /** Relevant information about the workload. */
  description?: Maybe<Scalars['String']['output']>;
  /** A list of entity GUIDs. These entities will belong to the collection as long as their accounts are included in the scope accounts of the collection. */
  entities?: Maybe<Array<WorkloadEntityRef>>;
  /** A list of entity search queries. The resulting entities will be limited to the scope accounts of the collection. */
  entitySearchQueries?: Maybe<Array<WorkloadEntitySearchQuery>>;
  /** The entity search query that returns the full collection of entities. */
  entitySearchQuery?: Maybe<Scalars['String']['output']>;
  /** The unique entity identifier of the workload in New Relic. */
  guid: Scalars['EntityGuid']['output'];
  /** The unique identifier of the workload. */
  id: Scalars['Int']['output'];
  /** The entity search query that returns the dashboards linked to a workload. */
  linkedDashboardsSearchQuery?: Maybe<Scalars['String']['output']>;
  /** A list of dynamic dashboards linked to the workload. */
  linkedDynamicDashboards?: Maybe<WorkloadDynamicDashboards>;
  /** A list of individual dashboards linked to the workload. */
  linkedIndividualDashboards?: Maybe<Array<WorkloadIndividualDashboard>>;
  /** The workload's name. */
  name: Scalars['String']['output'];
  /** The URL of the workload. */
  permalink: Scalars['String']['output'];
  /** A list of resources associated to the workload. */
  resources?: Maybe<Array<WorkloadResource>>;
  /** Accounts that will be used to get entities from. */
  scopeAccounts: WorkloadScopeAccounts;
  /** The configuration that defines how the status of the workload is calculated. */
  statusConfig?: Maybe<WorkloadStatusConfig>;
  /** The moment when the object was last updated, represented in milliseconds since the Unix epoch. */
  updatedAt?: Maybe<Scalars['EpochMilliseconds']['output']>;
  /** The user who last updated the workload. */
  updatedBy?: Maybe<UserReference>;
};

/** The input object used to represent the workload to be created. */
export type WorkloadCreateInput = {
  /** Relevant information about the workload. */
  description?: InputMaybe<Scalars['String']['input']>;
  /** A list of entity GUIDs composing the workload. */
  entityGuids?: InputMaybe<Array<Scalars['EntityGuid']['input']>>;
  /** A list of entity search queries used to retrieve the entities that compose the workload. */
  entitySearchQueries?: InputMaybe<Array<WorkloadEntitySearchQueryInput>>;
  /** A list of dynamic dashboards linked to the workload. */
  linkedDynamicDashboards?: InputMaybe<WorkloadDynamicDashboardsInput>;
  /** A list of individual dashboards linked to the workload. */
  linkedIndividualDashboards?: InputMaybe<Array<WorkloadIndividualDashboardInput>>;
  /** The name of the workload. */
  name: Scalars['String']['input'];
  /** A list of resources associated to the workload. */
  resources?: InputMaybe<Array<WorkloadResourceInput>>;
  /** Accounts that will be used to get entities from. */
  scopeAccounts?: InputMaybe<WorkloadScopeAccountsInput>;
  /** The configuration that defines how the status of the workload is calculated. */
  statusConfig?: InputMaybe<WorkloadStatusConfigInput>;
};

/** The input object used to represent the workload duplicate. */
export type WorkloadDuplicateInput = {
  /** The name of the workload duplicate. If the name isn't specified, the name + ' copy' of the source workload is used to compose the new name. */
  name?: InputMaybe<Scalars['String']['input']>;
};

/** Represents a collection of dashboards linked to the workload. */
export type WorkloadDynamicDashboards = {
  __typename?: 'WorkloadDynamicDashboards';
  /** A list of search queries used to retrieve dynamically the dashboards linked to the workload. */
  searchQueries?: Maybe<Array<WorkloadEntitySearchQuery>>;
};

/** The input object used to represent a collection of dashboards linked to the workload. */
export type WorkloadDynamicDashboardsInput = {
  /** A list of search queries used to retrieve dynamically the dashboards linked to the workload. */
  searchQueries?: InputMaybe<Array<WorkloadEntitySearchQueryInput>>;
};

/** A workload entity. */
export type WorkloadEntity = AlertableEntity & CollectionEntity & Entity & {
  __typename?: 'WorkloadEntity';
  account?: Maybe<AccountOutline>;
  /** The New Relic account ID associated with this entity. */
  accountId?: Maybe<Scalars['Int']['output']>;
  /** The current alerting severity of the entity. */
  alertSeverity?: Maybe<EntityAlertSeverity>;
  /**
   * The alert status of the entity.
   * @deprecated Please use `alertSeverity` and `reporting`
   */
  alertStatus?: Maybe<EntityAlertStatus>;
  /** Violations on the entity that were open during the specified time window. This will return up to 500 violations - if there are more in the time window selected, you must narrow the time window or look at fewer entities. */
  alertViolations?: Maybe<Array<Maybe<EntityAlertViolation>>>;
  collection?: Maybe<EntityCollection>;
  /** When the workload was created. */
  createdAt?: Maybe<Scalars['EpochMilliseconds']['output']>;
  /** The user that created the workload. */
  createdByUser?: Maybe<UserReference>;
  /** Retrieve the deployment event(s). Ordered by timestamp DESC. */
  deploymentSearch?: Maybe<ChangeTrackingDeploymentSearchResult>;
  /** The entity's domain */
  domain?: Maybe<Scalars['String']['output']>;
  /** A value representing the combination of the entity's domain and type. */
  entityType?: Maybe<EntityType>;
  /**
   * Retrieve metadata on a specific error group.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  errorGroup?: Maybe<ErrorTrackingErrorGroup>;
  /**
   * Fetch the number of error groups counted within a given time range (default 3 hours).
   * @deprecated This field is experimental and subject to breaking changes.
   */
  errorGroupCount?: Maybe<ErrorTrackingErrorGroupCount>;
  /**
   * Fetch a list of error groups.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  errorGroupListing?: Maybe<Array<ErrorTrackingErrorGroup>>;
  /**
   * The associated error group notification policy.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  errorGroupNotificationPolicy?: Maybe<ErrorTrackingNotificationPolicy>;
  /** The date of last time the entity has updated any of its fields. */
  firstIndexedAt?: Maybe<Scalars['EpochMilliseconds']['output']>;
  /** The list of golden metrics for a specific entity */
  goldenMetrics?: Maybe<EntityGoldenContextScopedGoldenMetrics>;
  /**
   * For the golden signal on this entity, show correlated signals from related entities.
   * Well inspect the golden signals for all related entities and return a sorted list.
   * You can also filter the results.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  goldenSignalCorrelations?: Maybe<GoldenSignalCorrelationResult>;
  /**
   * The deviation from normal of golden signal(s) for the given entity.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  goldenSignalDeviations?: Maybe<Array<Maybe<GoldenSignalSignalDeviation>>>;
  /**
   * The stored golden signal(s) for the given entity.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  goldenSignalValues?: Maybe<GoldenSignalValues>;
  /**
   * The stored golden signal(s) for the given entity. To be removed, use goldenSignalValues instead.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  goldenSignalValuesV2?: Maybe<GoldenSignalValues>;
  /** The list of golden tags for a specific entityType. */
  goldenTags?: Maybe<EntityGoldenContextScopedGoldenTags>;
  /** A unique entity identifier. */
  guid?: Maybe<Scalars['EntityGuid']['output']>;
  /** The time the entity was indexed. */
  indexedAt?: Maybe<Scalars['EpochMilliseconds']['output']>;
  /** The last time the entity's reporting status changed. */
  lastReportingChangeAt?: Maybe<Scalars['EpochMilliseconds']['output']>;
  /** The name of this entity. */
  name?: Maybe<Scalars['String']['output']>;
  nerdStorage?: Maybe<NerdStorageEntityScope>;
  nerdStoreCollection?: Maybe<Array<Maybe<NerdStoreCollectionMember>>>;
  nerdStoreDocument?: Maybe<Scalars['NerdStoreDocument']['output']>;
  /**
   * Make an `Entity` scoped query to NRDB with a NRQL string.
   *
   * A relevant `WHERE` clause will be added to your query to scope data to the entity in question.
   *
   * See the [NRQL Docs](https://docs.newrelic.com/docs/insights/nrql-new-relic-query-language/nrql-resources/nrql-syntax-components-functions) for more information about generating a query string.
   */
  nrdbQuery?: Maybe<NrdbResultContainer>;
  /**
   * Poll for the results of a previously-executed asychronous NRDB query.
   *
   * The `queryId` is available in the `queryProgress` data returned by the original asynchronous query.
   *
   * See [this page](https://docs.newrelic.com/docs/apis/nerdgraph/examples/async-queries-nrql-tutorial) for additional asynchronous query documentation.
   * @deprecated This field is experimental! It may change at any time.
   *
   */
  nrdbQueryProgress?: Maybe<NrdbResultContainer>;
  /** The url to the entity. */
  permalink?: Maybe<Scalars['String']['output']>;
  /** Recent violations on the entity. */
  recentAlertViolations?: Maybe<Array<Maybe<EntityAlertViolation>>>;
  /** The recommended service levels for the entity. */
  recommendedServiceLevel?: Maybe<ServiceLevelRecommendation>;
  /** Related dashboards results */
  relatedDashboards: RelatedDashboardsRelatedDashboardResult;
  /** Related entities result with optional filtering. */
  relatedEntities?: Maybe<EntityRelationshipRelatedEntitiesResult>;
  /** Relationship traversal results with optional filtering. WARNING: this query is still experimental, and subject to breaking changes. */
  relationshipTraversal?: Maybe<EntityRelationshipTraversalResult>;
  /**
   * A list of the entities' relationships.
   *
   * For more information, visit [our docs](https://docs.newrelic.com/docs/apis/graphql-api/tutorials/graphql-relationships-api-tutorial).
   * @deprecated This field is deprecated! Please use `relatedEntities`.
   */
  relationships?: Maybe<Array<Maybe<EntityRelationship>>>;
  /** The reporting status of the entity. If New Relic is successfully collecting data from your application, this will be true. */
  reporting?: Maybe<Scalars['Boolean']['output']>;
  /** The service level defined for the entity. */
  serviceLevel?: Maybe<ServiceLevelDefinition>;
  /** The list of summary metrics. */
  summaryMetrics?: Maybe<Array<Maybe<EntitySummaryMetric>>>;
  /**
   * The tags applied to the entity.
   *
   * For details on tags, as well as query and mutation examples, visit [our docs](https://docs.newrelic.com/docs/apis/graphql-api/tutorials/graphql-tagging-api-tutorial).
   */
  tags?: Maybe<Array<Maybe<EntityTag>>>;
  /** The tags applied to the entity with their metadata. */
  tagsWithMetadata?: Maybe<Array<Maybe<EntityTagWithMetadata>>>;
  /** Look up Distributed Tracing summary data for the selected `EntityGuid` */
  tracingSummary?: Maybe<DistributedTracingEntityTracingSummary>;
  /** The entity's type */
  type?: Maybe<Scalars['String']['output']>;
  /** List of templates availables for this entity. */
  uiTemplates?: Maybe<Array<EntityDashboardTemplatesUi>>;
  /** When the workload was last updated. */
  updatedAt?: Maybe<Scalars['EpochMilliseconds']['output']>;
  /** Status of the workload. */
  workloadStatus?: Maybe<WorkloadStatus>;
};


/** A workload entity. */
export type WorkloadEntityAlertViolationsArgs = {
  endTime: Scalars['EpochMilliseconds']['input'];
  startTime: Scalars['EpochMilliseconds']['input'];
};


/** A workload entity. */
export type WorkloadEntityCollectionArgs = {
  name: Scalars['String']['input'];
};


/** A workload entity. */
export type WorkloadEntityDeploymentSearchArgs = {
  filter?: InputMaybe<ChangeTrackingSearchFilter>;
};


/** A workload entity. */
export type WorkloadEntityErrorGroupArgs = {
  id: Scalars['ID']['input'];
};


/** A workload entity. */
export type WorkloadEntityErrorGroupCountArgs = {
  timeWindow?: InputMaybe<TimeWindowInput>;
};


/** A workload entity. */
export type WorkloadEntityErrorGroupListingArgs = {
  ids: Array<Scalars['ID']['input']>;
};


/** A workload entity. */
export type WorkloadEntityGoldenMetricsArgs = {
  context?: InputMaybe<EntityGoldenContextInput>;
  timeWindow?: InputMaybe<EntityGoldenNrqlTimeWindowInput>;
};


/** A workload entity. */
export type WorkloadEntityGoldenSignalCorrelationsArgs = {
  filter?: InputMaybe<GoldenSignalCorrelationsEntityFilter>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  timeWindow?: InputMaybe<TimeWindowInput>;
};


/** A workload entity. */
export type WorkloadEntityGoldenSignalDeviationsArgs = {
  comparisonTimeWindow?: InputMaybe<TimeWindowInput>;
  evaluationTimeWindow?: InputMaybe<TimeWindowInput>;
};


/** A workload entity. */
export type WorkloadEntityGoldenSignalValuesArgs = {
  timeWindow?: InputMaybe<TimeWindowInput>;
};


/** A workload entity. */
export type WorkloadEntityGoldenSignalValuesV2Args = {
  timeWindow?: InputMaybe<TimeWindowInput>;
};


/** A workload entity. */
export type WorkloadEntityGoldenTagsArgs = {
  context?: InputMaybe<EntityGoldenContextInput>;
};


/** A workload entity. */
export type WorkloadEntityNerdStoreCollectionArgs = {
  collection: Scalars['String']['input'];
  scopeByActor?: InputMaybe<Scalars['Boolean']['input']>;
};


/** A workload entity. */
export type WorkloadEntityNerdStoreDocumentArgs = {
  collection: Scalars['String']['input'];
  documentId: Scalars['String']['input'];
  scopeByActor?: InputMaybe<Scalars['Boolean']['input']>;
};


/** A workload entity. */
export type WorkloadEntityNrdbQueryArgs = {
  async?: InputMaybe<Scalars['Boolean']['input']>;
  nrql: Scalars['Nrql']['input'];
  options?: InputMaybe<NrqlQueryOptions>;
  timeout?: InputMaybe<Scalars['Seconds']['input']>;
};


/** A workload entity. */
export type WorkloadEntityNrdbQueryProgressArgs = {
  queryId: Scalars['ID']['input'];
};


/** A workload entity. */
export type WorkloadEntityRecentAlertViolationsArgs = {
  count?: InputMaybe<Scalars['Int']['input']>;
};


/** A workload entity. */
export type WorkloadEntityRelatedEntitiesArgs = {
  cursor?: InputMaybe<Scalars['String']['input']>;
  filter?: InputMaybe<EntityRelationshipEdgeFilter>;
  limit?: InputMaybe<Scalars['Int']['input']>;
};


/** A workload entity. */
export type WorkloadEntityRelationshipTraversalArgs = {
  cursor?: InputMaybe<Scalars['String']['input']>;
  hopFilters?: InputMaybe<EntityRelationshipTraversalHopFilters>;
  hops?: InputMaybe<Scalars['Int']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
};


/** A workload entity. */
export type WorkloadEntityRelationshipsArgs = {
  endTime?: InputMaybe<Scalars['EpochMilliseconds']['input']>;
  filter?: InputMaybe<EntityRelationshipFilter>;
};


/** A workload entity. */
export type WorkloadEntitySummaryMetricsArgs = {
  timeWindow?: InputMaybe<TimeWindowInput>;
};


/** A workload entity. */
export type WorkloadEntityTracingSummaryArgs = {
  timeWindow?: InputMaybe<TimeWindowInput>;
};

/** A workload entity outline. */
export type WorkloadEntityOutline = AlertableEntityOutline & EntityOutline & {
  __typename?: 'WorkloadEntityOutline';
  account?: Maybe<AccountOutline>;
  /** The New Relic account ID associated with this entity. */
  accountId?: Maybe<Scalars['Int']['output']>;
  /** The current alerting severity of the entity. */
  alertSeverity?: Maybe<EntityAlertSeverity>;
  /**
   * The alert status of the entity.
   * @deprecated Please use `alertSeverity` and `reporting`
   */
  alertStatus?: Maybe<EntityAlertStatus>;
  /** When the workload was created. */
  createdAt?: Maybe<Scalars['EpochMilliseconds']['output']>;
  /** The user that created the workload. */
  createdByUser?: Maybe<UserReference>;
  /** The entity's domain */
  domain?: Maybe<Scalars['String']['output']>;
  /** A value representing the combination of the entity's domain and type. */
  entityType?: Maybe<EntityType>;
  /** The date of last time the entity has updated any of its fields. */
  firstIndexedAt?: Maybe<Scalars['EpochMilliseconds']['output']>;
  /** The list of golden metrics for a specific entity */
  goldenMetrics?: Maybe<EntityGoldenContextScopedGoldenMetrics>;
  /**
   * For the golden signal on this entity, show correlated signals from related entities.
   * Well inspect the golden signals for all related entities and return a sorted list.
   * You can also filter the results.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  goldenSignalCorrelations?: Maybe<GoldenSignalCorrelationResult>;
  /**
   * The deviation from normal of golden signal(s) for the given entity.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  goldenSignalDeviations?: Maybe<Array<Maybe<GoldenSignalSignalDeviation>>>;
  /**
   * The stored golden signal(s) for the given entity.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  goldenSignalValues?: Maybe<GoldenSignalValues>;
  /**
   * The stored golden signal(s) for the given entity. To be removed, use goldenSignalValues instead.
   * @deprecated This field is experimental and subject to breaking changes.
   */
  goldenSignalValuesV2?: Maybe<GoldenSignalValues>;
  /** The list of golden tags for a specific entityType. */
  goldenTags?: Maybe<EntityGoldenContextScopedGoldenTags>;
  /** A unique entity identifier. */
  guid?: Maybe<Scalars['EntityGuid']['output']>;
  /** The time the entity was indexed. */
  indexedAt?: Maybe<Scalars['EpochMilliseconds']['output']>;
  /** The last time the entity's reporting status changed. */
  lastReportingChangeAt?: Maybe<Scalars['EpochMilliseconds']['output']>;
  /** The name of this entity. */
  name?: Maybe<Scalars['String']['output']>;
  /** The url to the entity. */
  permalink?: Maybe<Scalars['String']['output']>;
  /** The recommended service levels for the entity. */
  recommendedServiceLevel?: Maybe<ServiceLevelRecommendation>;
  /** Related dashboards results */
  relatedDashboards: RelatedDashboardsRelatedDashboardResult;
  /** The reporting status of the entity. If New Relic is successfully collecting data from your application, this will be true. */
  reporting?: Maybe<Scalars['Boolean']['output']>;
  /** The service level defined for the entity. */
  serviceLevel?: Maybe<ServiceLevelDefinition>;
  /** The list of summary metrics. */
  summaryMetrics?: Maybe<Array<Maybe<EntitySummaryMetric>>>;
  /**
   * The tags applied to the entity.
   *
   * For details on tags, as well as query and mutation examples, visit [our docs](https://docs.newrelic.com/docs/apis/graphql-api/tutorials/graphql-tagging-api-tutorial).
   */
  tags?: Maybe<Array<Maybe<EntityTag>>>;
  /** The entity's type */
  type?: Maybe<Scalars['String']['output']>;
  /** List of templates availables for this entity. */
  uiTemplates?: Maybe<Array<EntityDashboardTemplatesUi>>;
  /** When the workload was last updated. */
  updatedAt?: Maybe<Scalars['EpochMilliseconds']['output']>;
  /** Status of the workload. */
  workloadStatus?: Maybe<WorkloadStatus>;
};


/** A workload entity outline. */
export type WorkloadEntityOutlineGoldenMetricsArgs = {
  context?: InputMaybe<EntityGoldenContextInput>;
  timeWindow?: InputMaybe<EntityGoldenNrqlTimeWindowInput>;
};


/** A workload entity outline. */
export type WorkloadEntityOutlineGoldenSignalCorrelationsArgs = {
  filter?: InputMaybe<GoldenSignalCorrelationsEntityFilter>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  timeWindow?: InputMaybe<TimeWindowInput>;
};


/** A workload entity outline. */
export type WorkloadEntityOutlineGoldenSignalDeviationsArgs = {
  comparisonTimeWindow?: InputMaybe<TimeWindowInput>;
  evaluationTimeWindow?: InputMaybe<TimeWindowInput>;
};


/** A workload entity outline. */
export type WorkloadEntityOutlineGoldenSignalValuesArgs = {
  timeWindow?: InputMaybe<TimeWindowInput>;
};


/** A workload entity outline. */
export type WorkloadEntityOutlineGoldenSignalValuesV2Args = {
  timeWindow?: InputMaybe<TimeWindowInput>;
};


/** A workload entity outline. */
export type WorkloadEntityOutlineGoldenTagsArgs = {
  context?: InputMaybe<EntityGoldenContextInput>;
};


/** A workload entity outline. */
export type WorkloadEntityOutlineSummaryMetricsArgs = {
  timeWindow?: InputMaybe<TimeWindowInput>;
};

/** A reference to a New Relic entity. */
export type WorkloadEntityRef = {
  __typename?: 'WorkloadEntityRef';
  /** The unique entity identifier in New Relic. */
  guid?: Maybe<Scalars['EntityGuid']['output']>;
};

/** An entity search query used to dynamically retrieve a group of entities. */
export type WorkloadEntitySearchQuery = {
  __typename?: 'WorkloadEntitySearchQuery';
  /** The moment when the object was created, represented in milliseconds since the Unix epoch. */
  createdAt: Scalars['EpochMilliseconds']['output'];
  /** The user who created the entity search query. */
  createdBy?: Maybe<UserReference>;
  /** The unique identifier of the entity search query. */
  id: Scalars['Int']['output'];
  /** The entity search query that is used to perform the search of a group of entities. */
  query: Scalars['String']['output'];
  /** The moment when the object was last updated, represented in milliseconds since the Unix epoch. */
  updatedAt?: Maybe<Scalars['EpochMilliseconds']['output']>;
};

/** The input object used to represent the entity search query to be created. */
export type WorkloadEntitySearchQueryInput = {
  /** The entity search query that is used to perform the search of a group of entities. */
  query: Scalars['String']['input'];
};

/** Indicates by which field the remaining entities rule should be grouped. */
export enum WorkloadGroupRemainingEntitiesRuleBy {
  /** Group the remaining entities rule by entity type. */
  EntityType = 'ENTITY_TYPE',
  /** Do not apply any grouping to the remaining entities rule. */
  None = 'NONE'
}

/** Represents an individual dashboard linked to the workload and optionally a NRQL filter that is applied to it. */
export type WorkloadIndividualDashboard = {
  __typename?: 'WorkloadIndividualDashboard';
  /** A NRQL filter that is applied to the dashboard. */
  filter?: Maybe<Scalars['Nrql']['output']>;
  /** The unique identifier for an entity of type dashboard. */
  guid: Scalars['EntityGuid']['output'];
};

/** The input object used to represent an individual dashboard linked to the workload and optionally a NRQL filter that is applied to it. */
export type WorkloadIndividualDashboardInput = {
  /** A NRQL filter that is applied to the dashboard. */
  filter?: InputMaybe<Scalars['Nrql']['input']>;
  /** The unique identifier for an entity of type dashboard. */
  guid: Scalars['EntityGuid']['input'];
};

/** The definition of a rule, which consists of a group of entities and a rollup strategy. */
export type WorkloadRegularRule = {
  __typename?: 'WorkloadRegularRule';
  /** A list of entity GUIDs. These entities will belong to the collection as long as their accounts are included in the scope accounts of the collection. */
  entities?: Maybe<Array<WorkloadEntityRef>>;
  /** A list of entity search queries. These queries are constrained to the workload contents. */
  entitySearchQueries?: Maybe<Array<WorkloadEntitySearchQuery>>;
  /** The unique identifier of the rule. */
  id?: Maybe<Scalars['Int']['output']>;
  /** The rollup strategy. */
  rollup: WorkloadRollup;
};

/** The input object used to represent a rule. */
export type WorkloadRegularRuleInput = {
  /** A list of entity GUIDs composing the rule. */
  entityGuids?: InputMaybe<Array<Scalars['EntityGuid']['input']>>;
  /** A list of entity search queries used to retrieve the entities that compose the rule. */
  entitySearchQueries?: InputMaybe<Array<WorkloadEntitySearchQueryInput>>;
  /** The input object used to represent a rollup strategy. */
  rollup: WorkloadRollupInput;
};

/** The definition of a remaining entities rule. */
export type WorkloadRemainingEntitiesRule = {
  __typename?: 'WorkloadRemainingEntitiesRule';
  /** The rollup strategy. */
  rollup: WorkloadRemainingEntitiesRuleRollup;
};

/** The input object used to represent a remaining entities rule. */
export type WorkloadRemainingEntitiesRuleInput = {
  /** The input object used to represent a rollup strategy. */
  rollup: WorkloadRemainingEntitiesRuleRollupInput;
};

/** The rollup strategy. */
export type WorkloadRemainingEntitiesRuleRollup = {
  __typename?: 'WorkloadRemainingEntitiesRuleRollup';
  /** The grouping to be applied to the remaining entities. */
  groupBy: WorkloadGroupRemainingEntitiesRuleBy;
  /** The rollup strategy that is applied to a group of entities. */
  strategy: WorkloadRollupStrategy;
  /** Type of threshold defined for the rule. This is an optional field that only applies when strategy is WORST_STATUS_WINS. Use a threshold to roll up the worst status only after a certain amount of entities are not operational. */
  thresholdType?: Maybe<WorkloadRuleThresholdType>;
  /** Threshold value defined for the rule. This optional field is used in combination with thresholdType. If the threshold type is null, the threshold value will be ignored. */
  thresholdValue?: Maybe<Scalars['Int']['output']>;
};

/** The input object used to represent a rollup strategy. */
export type WorkloadRemainingEntitiesRuleRollupInput = {
  /** The grouping to be applied to the remaining entities. */
  groupBy: WorkloadGroupRemainingEntitiesRuleBy;
  /** The rollup strategy that is applied to a group of entities. */
  strategy: WorkloadRollupStrategy;
  /** Type of threshold defined for the rule. This is an optional field that only applies when strategy is WORST_STATUS_WINS. Use a threshold to roll up the worst status only after a certain amount of entities are not operational. */
  thresholdType?: InputMaybe<WorkloadRuleThresholdType>;
  /** Threshold value defined for the rule. This optional field is used in combination with thresholdType. If the threshold type is null, the threshold value will be ignored. */
  thresholdValue?: InputMaybe<Scalars['Int']['input']>;
};

/** Represents a resource that contains a link and some other metadata. */
export type WorkloadResource = {
  __typename?: 'WorkloadResource';
  /** The unique identifier of the resource. */
  id: Scalars['Int']['output'];
  /** The link that the resource points to. */
  link: Scalars['String']['output'];
  /** The text contains information about the resource. */
  text?: Maybe<Scalars['String']['output']>;
  /** The type of a resource represents the kind of information it holds. */
  type?: Maybe<Scalars['String']['output']>;
};

/** The input object used to represent a resource that contains a link and some other metadata. */
export type WorkloadResourceInput = {
  /** The link that the resource points to. */
  link: Scalars['String']['input'];
  /** The text contains information about the resource. */
  text?: InputMaybe<Scalars['String']['input']>;
  /** The type of a resource represents the kind of information it holds. */
  type?: InputMaybe<Scalars['String']['input']>;
};

/** Represents the type of the rule that the resulting group of entities belongs to. */
export enum WorkloadResultingGroupType {
  /** The rule considers the entities within a specific group in the workload. */
  RegularGroup = 'REGULAR_GROUP',
  /** The rule considers all the entities within the workload that arent evaluated in any other rule. */
  RemainingEntities = 'REMAINING_ENTITIES'
}

/** The rollup strategy. */
export type WorkloadRollup = {
  __typename?: 'WorkloadRollup';
  /** The rollup strategy that is applied to the group of entities. */
  strategy: WorkloadRollupStrategy;
  /** Type of threshold defined for the rule. This is an optional field that only applies when strategy is WORST_STATUS_WINS. Use a threshold to roll up the worst status only after a certain amount of entities are not operational. */
  thresholdType?: Maybe<WorkloadRuleThresholdType>;
  /** Threshold value defined for the rule. This optional field is used in combination with thresholdType. If the threshold type is null, the threshold value will be ignored. */
  thresholdValue?: Maybe<Scalars['Int']['output']>;
};

/** The input object used to represent a rollup strategy. */
export type WorkloadRollupInput = {
  /** The rollup strategy that is applied to a group of entities. */
  strategy: WorkloadRollupStrategy;
  /** Type of threshold defined for the rule. This is an optional field that only applies when strategy is WORST_STATUS_WINS. Use a threshold to roll up the worst status only after a certain amount of entities are not operational. */
  thresholdType?: InputMaybe<WorkloadRuleThresholdType>;
  /** Threshold value defined for the rule. This optional field is used in combination with thresholdType. If the threshold type is null, the threshold value will be ignored. */
  thresholdValue?: InputMaybe<Scalars['Int']['input']>;
};

/** Represents the details of a rollup rule. */
export type WorkloadRollupRuleDetails = {
  __typename?: 'WorkloadRollupRuleDetails';
  /** A list of entity search queries defined in the rule. */
  entitySearchQueries?: Maybe<Array<Scalars['String']['output']>>;
  /** Indicates if the rule has individual entities. */
  hasIndividualEntities: Scalars['Boolean']['output'];
  /** The amount of not operational entities after evaluating the rule. */
  notOperationalEntities: Scalars['Int']['output'];
  /** The amount of operational entities after evaluating the rule. */
  operationalEntities: Scalars['Int']['output'];
  /** The resulting type of the rollup rule. */
  resultingGroupType: WorkloadResultingGroupType;
  /** Type of threshold defined for the rule. */
  thresholdType?: Maybe<WorkloadRuleThresholdType>;
  /** The amount of entities the status of which is unknown. */
  unknownStatusEntities: Scalars['Int']['output'];
};

/** A rollup rule that was involved in the calculation of the workload status. */
export type WorkloadRollupRuleStatusResult = WorkloadStatusResult & {
  __typename?: 'WorkloadRollupRuleStatusResult';
  /** Represents the details of a rollup rule. */
  rollupRuleDetails?: Maybe<WorkloadRollupRuleDetails>;
  /** Indicates where the status value derives from. */
  source: WorkloadStatusSource;
  /** The status of a rollup rule. */
  value: WorkloadStatusValue;
};

/** Represents the rollup strategy that is applied to a group of entities. */
export enum WorkloadRollupStrategy {
  /** The group status matches the less critical status of all belonging entities. */
  BestStatusWins = 'BEST_STATUS_WINS',
  /** The group status matches the most critical status of all belonging entities. */
  WorstStatusWins = 'WORST_STATUS_WINS'
}

/** Represents the type of the threshold defined for a rule. */
export enum WorkloadRuleThresholdType {
  /** The worst status is rolled up only after a certain number of entities within the workload are not operational. */
  Fixed = 'FIXED',
  /** The worst status is rolled up only after a certain percentage of entities within the workload are not operational. */
  Percentage = 'PERCENTAGE'
}

/** Accounts that will be used to get entities from. */
export type WorkloadScopeAccounts = {
  __typename?: 'WorkloadScopeAccounts';
  /** A list of accounts that will be used to get entities from. */
  accountIds: Array<Scalars['Int']['output']>;
};

/** The input object containing accounts that will be used to get entities from. */
export type WorkloadScopeAccountsInput = {
  /** A list of accounts that will be used to get entities from. */
  accountIds: Array<Scalars['Int']['input']>;
};

/** The static status configuration. */
export type WorkloadStaticStatus = {
  __typename?: 'WorkloadStaticStatus';
  /** A description that provides additional details about the status of the workload. */
  description?: Maybe<Scalars['String']['output']>;
  /** Whether the static status configuration is enabled or not. Note that only one static status can be enabled at a given time. */
  enabled: Scalars['Boolean']['output'];
  /** The unique identifier of the static status. */
  id: Scalars['Int']['output'];
  /** The status of the workload. */
  status: WorkloadStatusValue;
  /** A short description of the status of the workload. */
  summary?: Maybe<Scalars['String']['output']>;
};

/** The input object used to represent the configuration of a static status. */
export type WorkloadStaticStatusInput = {
  /** A description that provides additional details about the status of the workload. */
  description?: InputMaybe<Scalars['String']['input']>;
  /** Whether the static status configuration is enabled or not. */
  enabled: Scalars['Boolean']['input'];
  /** The status of the workload. */
  status: WorkloadStatusValueInput;
  /** A short description of the status of the workload. */
  summary?: InputMaybe<Scalars['String']['input']>;
};

/** A static status that was involved in the calculation of the workload status. */
export type WorkloadStaticStatusResult = WorkloadStatusResult & {
  __typename?: 'WorkloadStaticStatusResult';
  /** A description that provides additional details about the status of the workload. */
  description?: Maybe<Scalars['String']['output']>;
  /** Indicates where the status value derives from. */
  source: WorkloadStatusSource;
  /** A short description of the status of the workload. */
  summary?: Maybe<Scalars['String']['output']>;
  /** The value of a static status. */
  value: WorkloadStatusValue;
};

/** Detailed information about the status of a workload. */
export type WorkloadStatus = {
  __typename?: 'WorkloadStatus';
  /** A description that provides additional details about the status of the workload. */
  description?: Maybe<Scalars['String']['output']>;
  /** Indicates where the status value derives from. */
  statusSource?: Maybe<WorkloadStatusSource>;
  /** The status of the workload. */
  statusValue?: Maybe<WorkloadStatusValue>;
  /** A short description of the status of the workload. */
  summary?: Maybe<Scalars['String']['output']>;
};

/** The configuration that defines how the status of the workload is calculated. */
export type WorkloadStatusConfig = {
  __typename?: 'WorkloadStatusConfig';
  /** An automatic status configuration. */
  automatic?: Maybe<WorkloadAutomaticStatus>;
  /** A list of static status configurations. */
  static?: Maybe<Array<WorkloadStaticStatus>>;
};

/** The input object used to provide the configuration that defines how the status of the workload is calculated. */
export type WorkloadStatusConfigInput = {
  /** An input object used to represent an automatic status configuration. */
  automatic?: InputMaybe<WorkloadAutomaticStatusInput>;
  /** A list of static status configurations. You can only configure one static status for a workload. */
  static?: InputMaybe<Array<WorkloadStaticStatusInput>>;
};

/** The details of a status that was involved in the calculation of the workload status. */
export type WorkloadStatusResult = {
  /** Indicates where the status value derives from. */
  source: WorkloadStatusSource;
  /** The value of a status. */
  value: WorkloadStatusValue;
};

/** Indicates where the status value derives from. */
export enum WorkloadStatusSource {
  /** Refers to the result of an automatic rule defined for a workload. */
  RollupRule = 'ROLLUP_RULE',
  /** Refers to a static status defined for a workload. */
  Static = 'STATIC',
  /** Refers to an undetermined status source. */
  Unknown = 'UNKNOWN',
  /** Refers to the override policy that is applied to a set of partial results within a workload. Any static status always overrides any other status values calculated automatically. Otherwise, the worst status of the partial results is rolled up. */
  Workload = 'WORKLOAD'
}

/** The status of the workload, which is derived from the static and the automatic statuses configured. Any static status always overrides any other status values calculated automatically. */
export enum WorkloadStatusValue {
  /** The status of the workload is degraded. */
  Degraded = 'DEGRADED',
  /** The status of the workload is disrupted. */
  Disrupted = 'DISRUPTED',
  /** The status of the workload is operational. */
  Operational = 'OPERATIONAL',
  /** The status of the workload is unknown. */
  Unknown = 'UNKNOWN'
}

/** The status value. Any static status always overrides any other status values calculated automatically. */
export enum WorkloadStatusValueInput {
  /** The status of the workload is degraded. */
  Degraded = 'DEGRADED',
  /** The status of the workload is disrupted. */
  Disrupted = 'DISRUPTED',
  /** The status of the workload is operational. */
  Operational = 'OPERATIONAL'
}

/** An input object used to represent an automatic status configuration. */
export type WorkloadUpdateAutomaticStatusInput = {
  /** Whether the automatic status configuration is enabled or not. */
  enabled: Scalars['Boolean']['input'];
  /** An additional meta-rule that can consider all entities that haven't been evaluated by any other rule. */
  remainingEntitiesRule?: InputMaybe<WorkloadRemainingEntitiesRuleInput>;
  /** A list of rules. */
  rules?: InputMaybe<Array<WorkloadUpdateRegularRuleInput>>;
};

/** The input object used to represent the entity search query to be updated. */
export type WorkloadUpdateCollectionEntitySearchQueryInput = {
  /** The unique identifier of the entity search query to be updated. If not provided, a new entity search query is created. */
  id?: InputMaybe<Scalars['Int']['input']>;
  /** The entity search query that is used to perform the search of a group of entities. */
  query: Scalars['String']['input'];
};

/** The input object used to represent a collection of dashboards linked to the workload. */
export type WorkloadUpdateDynamicDashboardsInput = {
  /** A list of search queries used to retrieve dynamically the dashboards linked to the workload. */
  searchQueries?: InputMaybe<Array<WorkloadUpdateCollectionEntitySearchQueryInput>>;
};

/** The input object used to identify the workload to be updated and the new values. */
export type WorkloadUpdateInput = {
  /** Whether the workload is automatically deactivated */
  autoDeactivated?: InputMaybe<Scalars['Boolean']['input']>;
  /** Relevant information about the workload. */
  description?: InputMaybe<Scalars['String']['input']>;
  /** A list of entity GUIDs composing the workload. */
  entityGuids?: InputMaybe<Array<Scalars['EntityGuid']['input']>>;
  /** A list of entity search queries used to retrieve the groups of entities that compose the workload. */
  entitySearchQueries?: InputMaybe<Array<WorkloadUpdateCollectionEntitySearchQueryInput>>;
  /** A list of dynamic dashboards linked to the workload. */
  linkedDynamicDashboards?: InputMaybe<WorkloadUpdateDynamicDashboardsInput>;
  /** A list of individual dashboards linked to the workload. */
  linkedIndividualDashboards?: InputMaybe<Array<WorkloadIndividualDashboardInput>>;
  /** The name of the workload. */
  name?: InputMaybe<Scalars['String']['input']>;
  /** A list of resources associated to the workload. */
  resources?: InputMaybe<Array<WorkloadUpdateResourceInput>>;
  /** Accounts that will be used to get entities from. */
  scopeAccounts?: InputMaybe<WorkloadScopeAccountsInput>;
  /** The configuration that defines how the status of the workload is calculated. */
  statusConfig?: InputMaybe<WorkloadUpdateStatusConfigInput>;
};

/** The input object used to represent a rule. */
export type WorkloadUpdateRegularRuleInput = {
  /** A list of entity GUIDs composing the rule. */
  entityGuids?: InputMaybe<Array<Scalars['EntityGuid']['input']>>;
  /** A list of entity search queries used to retrieve the groups of entities that compose the rule. */
  entitySearchQueries?: InputMaybe<Array<WorkloadUpdateCollectionEntitySearchQueryInput>>;
  /** The unique identifier of the rule to be updated. If not provided, a new rule is created. */
  id?: InputMaybe<Scalars['Int']['input']>;
  /** The input object used to represent a roll-up strategy. */
  rollup: WorkloadRollupInput;
};

/** The input object used to represent a resource that contains a link and some other metadata. */
export type WorkloadUpdateResourceInput = {
  /** The unique identifier of the resource to be updated. If not provided, a new resource is created. */
  id?: InputMaybe<Scalars['Int']['input']>;
  /** The link that the resource points to. */
  link: Scalars['String']['input'];
  /** The text contains information about the resource. */
  text?: InputMaybe<Scalars['String']['input']>;
  /** The type of a resource represents the kind of information it holds. */
  type?: InputMaybe<Scalars['String']['input']>;
};

/** The input object used to represent the configuration of a static status. */
export type WorkloadUpdateStaticStatusInput = {
  /** A description that provides additional details about the status of the workload. */
  description?: InputMaybe<Scalars['String']['input']>;
  /** Whether the static status configuration is enabled or not. */
  enabled: Scalars['Boolean']['input'];
  /** The unique identifier of the static status to be updated. If not provided, a new static status is created. */
  id?: InputMaybe<Scalars['Int']['input']>;
  /** The status of the workload. */
  status: WorkloadStatusValueInput;
  /** A short description of the static status. */
  summary?: InputMaybe<Scalars['String']['input']>;
};

/** The input object used to provide the configuration that defines how the status of the workload is calculated. */
export type WorkloadUpdateStatusConfigInput = {
  /** An input object used to represent an automatic status configuration. */
  automatic?: InputMaybe<WorkloadUpdateAutomaticStatusInput>;
  /** A list of static status configurations. You can only configure one static status for a workload. */
  static?: InputMaybe<Array<WorkloadUpdateStaticStatusInput>>;
};

/** All the accounts that user has access to, from the same organization. */
export type WorkloadValidAccounts = {
  __typename?: 'WorkloadValidAccounts';
  /** List of accounts from the same organization. */
  accounts?: Maybe<Array<AccountReference>>;
};

/** Status of the workload. */
export type WorkloadWorkloadStatus = {
  __typename?: 'WorkloadWorkloadStatus';
  /** A description that provides additional details about the status of the workload. */
  description?: Maybe<Scalars['String']['output']>;
  /** Indicates where the status value derives from. */
  source: WorkloadStatusSource;
  /** The details of the statuses that were involved in the calculation of the workload status. */
  statusDetails?: Maybe<Array<WorkloadStatusResult>>;
  /** A short description of the status of the workload. */
  summary?: Maybe<Scalars['String']['output']>;
  /** The status of the workload. */
  value: WorkloadStatusValue;
};

export type EntityRelationshipUserDefinedCreateOrReplaceMutationMutationVariables = Exact<{
  sourceEntityGuid: Scalars['EntityGuid']['input'];
  targetEntityGuid: Scalars['EntityGuid']['input'];
}>;


export type EntityRelationshipUserDefinedCreateOrReplaceMutationMutation = { __typename?: 'RootMutationType', entityRelationshipUserDefinedCreateOrReplace: { __typename?: 'EntityRelationshipUserDefinedCreateOrReplaceResult', errors?: Array<{ __typename?: 'EntityRelationshipUserDefinedCreateOrReplaceResultError', message: string, type: EntityRelationshipUserDefinedCreateOrReplaceErrorType }> | null } };

export type ReferenceEntityCreateOrUpdateRepositoryMutationMutationVariables = Exact<{
  accountId: Scalars['Int']['input'];
  name: Scalars['String']['input'];
  url: Scalars['String']['input'];
}>;


export type ReferenceEntityCreateOrUpdateRepositoryMutationMutation = { __typename?: 'RootMutationType', referenceEntityCreateOrUpdateRepository?: { __typename?: 'ReferenceEntityCreateRepositoryResult', created: Array<any>, updated: Array<any>, failures: Array<{ __typename?: 'ReferenceEntityCreateRepositoryError', guid?: any | null, message: string, type: ReferenceEntityCreateRepositoryErrorType }> } | null };

type EntityFields_ApmApplicationEntity_Fragment = { __typename?: 'ApmApplicationEntity', accountId?: number | null, guid?: any | null, name?: string | null, entityType?: EntityType | null, type?: string | null, account?: { __typename?: 'AccountOutline', name?: string | null, id?: number | null } | null, goldenMetrics?: { __typename?: 'EntityGoldenContextScopedGoldenMetrics', metrics: Array<{ __typename?: 'EntityGoldenMetric', query: string, name: string }> } | null } & { ' $fragmentName'?: 'EntityFields_ApmApplicationEntity_Fragment' };

type EntityFields_ApmDatabaseInstanceEntity_Fragment = { __typename?: 'ApmDatabaseInstanceEntity', accountId?: number | null, guid?: any | null, name?: string | null, entityType?: EntityType | null, type?: string | null, account?: { __typename?: 'AccountOutline', name?: string | null, id?: number | null } | null, goldenMetrics?: { __typename?: 'EntityGoldenContextScopedGoldenMetrics', metrics: Array<{ __typename?: 'EntityGoldenMetric', query: string, name: string }> } | null } & { ' $fragmentName'?: 'EntityFields_ApmDatabaseInstanceEntity_Fragment' };

type EntityFields_ApmExternalServiceEntity_Fragment = { __typename?: 'ApmExternalServiceEntity', accountId?: number | null, guid?: any | null, name?: string | null, entityType?: EntityType | null, type?: string | null, account?: { __typename?: 'AccountOutline', name?: string | null, id?: number | null } | null, goldenMetrics?: { __typename?: 'EntityGoldenContextScopedGoldenMetrics', metrics: Array<{ __typename?: 'EntityGoldenMetric', query: string, name: string }> } | null } & { ' $fragmentName'?: 'EntityFields_ApmExternalServiceEntity_Fragment' };

type EntityFields_BrowserApplicationEntity_Fragment = { __typename?: 'BrowserApplicationEntity', accountId?: number | null, guid?: any | null, name?: string | null, entityType?: EntityType | null, type?: string | null, account?: { __typename?: 'AccountOutline', name?: string | null, id?: number | null } | null, goldenMetrics?: { __typename?: 'EntityGoldenContextScopedGoldenMetrics', metrics: Array<{ __typename?: 'EntityGoldenMetric', query: string, name: string }> } | null } & { ' $fragmentName'?: 'EntityFields_BrowserApplicationEntity_Fragment' };

type EntityFields_DashboardEntity_Fragment = { __typename?: 'DashboardEntity', accountId?: number | null, guid?: any | null, name?: string | null, entityType?: EntityType | null, type?: string | null, account?: { __typename?: 'AccountOutline', name?: string | null, id?: number | null } | null, goldenMetrics?: { __typename?: 'EntityGoldenContextScopedGoldenMetrics', metrics: Array<{ __typename?: 'EntityGoldenMetric', query: string, name: string }> } | null } & { ' $fragmentName'?: 'EntityFields_DashboardEntity_Fragment' };

type EntityFields_ExternalEntity_Fragment = { __typename?: 'ExternalEntity', accountId?: number | null, guid?: any | null, name?: string | null, entityType?: EntityType | null, type?: string | null, account?: { __typename?: 'AccountOutline', name?: string | null, id?: number | null } | null, goldenMetrics?: { __typename?: 'EntityGoldenContextScopedGoldenMetrics', metrics: Array<{ __typename?: 'EntityGoldenMetric', query: string, name: string }> } | null } & { ' $fragmentName'?: 'EntityFields_ExternalEntity_Fragment' };

type EntityFields_GenericEntity_Fragment = { __typename?: 'GenericEntity', accountId?: number | null, guid?: any | null, name?: string | null, entityType?: EntityType | null, type?: string | null, account?: { __typename?: 'AccountOutline', name?: string | null, id?: number | null } | null, goldenMetrics?: { __typename?: 'EntityGoldenContextScopedGoldenMetrics', metrics: Array<{ __typename?: 'EntityGoldenMetric', query: string, name: string }> } | null } & { ' $fragmentName'?: 'EntityFields_GenericEntity_Fragment' };

type EntityFields_GenericInfrastructureEntity_Fragment = { __typename?: 'GenericInfrastructureEntity', accountId?: number | null, guid?: any | null, name?: string | null, entityType?: EntityType | null, type?: string | null, account?: { __typename?: 'AccountOutline', name?: string | null, id?: number | null } | null, goldenMetrics?: { __typename?: 'EntityGoldenContextScopedGoldenMetrics', metrics: Array<{ __typename?: 'EntityGoldenMetric', query: string, name: string }> } | null } & { ' $fragmentName'?: 'EntityFields_GenericInfrastructureEntity_Fragment' };

type EntityFields_InfrastructureAwsLambdaFunctionEntity_Fragment = { __typename?: 'InfrastructureAwsLambdaFunctionEntity', accountId?: number | null, guid?: any | null, name?: string | null, entityType?: EntityType | null, type?: string | null, account?: { __typename?: 'AccountOutline', name?: string | null, id?: number | null } | null, goldenMetrics?: { __typename?: 'EntityGoldenContextScopedGoldenMetrics', metrics: Array<{ __typename?: 'EntityGoldenMetric', query: string, name: string }> } | null } & { ' $fragmentName'?: 'EntityFields_InfrastructureAwsLambdaFunctionEntity_Fragment' };

type EntityFields_InfrastructureHostEntity_Fragment = { __typename?: 'InfrastructureHostEntity', accountId?: number | null, guid?: any | null, name?: string | null, entityType?: EntityType | null, type?: string | null, account?: { __typename?: 'AccountOutline', name?: string | null, id?: number | null } | null, goldenMetrics?: { __typename?: 'EntityGoldenContextScopedGoldenMetrics', metrics: Array<{ __typename?: 'EntityGoldenMetric', query: string, name: string }> } | null } & { ' $fragmentName'?: 'EntityFields_InfrastructureHostEntity_Fragment' };

type EntityFields_KeyTransactionEntity_Fragment = { __typename?: 'KeyTransactionEntity', accountId?: number | null, guid?: any | null, name?: string | null, entityType?: EntityType | null, type?: string | null, account?: { __typename?: 'AccountOutline', name?: string | null, id?: number | null } | null, goldenMetrics?: { __typename?: 'EntityGoldenContextScopedGoldenMetrics', metrics: Array<{ __typename?: 'EntityGoldenMetric', query: string, name: string }> } | null } & { ' $fragmentName'?: 'EntityFields_KeyTransactionEntity_Fragment' };

type EntityFields_MobileApplicationEntity_Fragment = { __typename?: 'MobileApplicationEntity', accountId?: number | null, guid?: any | null, name?: string | null, entityType?: EntityType | null, type?: string | null, account?: { __typename?: 'AccountOutline', name?: string | null, id?: number | null } | null, goldenMetrics?: { __typename?: 'EntityGoldenContextScopedGoldenMetrics', metrics: Array<{ __typename?: 'EntityGoldenMetric', query: string, name: string }> } | null } & { ' $fragmentName'?: 'EntityFields_MobileApplicationEntity_Fragment' };

type EntityFields_SecureCredentialEntity_Fragment = { __typename?: 'SecureCredentialEntity', accountId?: number | null, guid?: any | null, name?: string | null, entityType?: EntityType | null, type?: string | null, account?: { __typename?: 'AccountOutline', name?: string | null, id?: number | null } | null, goldenMetrics?: { __typename?: 'EntityGoldenContextScopedGoldenMetrics', metrics: Array<{ __typename?: 'EntityGoldenMetric', query: string, name: string }> } | null } & { ' $fragmentName'?: 'EntityFields_SecureCredentialEntity_Fragment' };

type EntityFields_SyntheticMonitorEntity_Fragment = { __typename?: 'SyntheticMonitorEntity', accountId?: number | null, guid?: any | null, name?: string | null, entityType?: EntityType | null, type?: string | null, account?: { __typename?: 'AccountOutline', name?: string | null, id?: number | null } | null, goldenMetrics?: { __typename?: 'EntityGoldenContextScopedGoldenMetrics', metrics: Array<{ __typename?: 'EntityGoldenMetric', query: string, name: string }> } | null } & { ' $fragmentName'?: 'EntityFields_SyntheticMonitorEntity_Fragment' };

type EntityFields_TeamEntity_Fragment = { __typename?: 'TeamEntity', accountId?: number | null, guid?: any | null, name?: string | null, entityType?: EntityType | null, type?: string | null, account?: { __typename?: 'AccountOutline', name?: string | null, id?: number | null } | null, goldenMetrics?: { __typename?: 'EntityGoldenContextScopedGoldenMetrics', metrics: Array<{ __typename?: 'EntityGoldenMetric', query: string, name: string }> } | null } & { ' $fragmentName'?: 'EntityFields_TeamEntity_Fragment' };

type EntityFields_ThirdPartyServiceEntity_Fragment = { __typename?: 'ThirdPartyServiceEntity', accountId?: number | null, guid?: any | null, name?: string | null, entityType?: EntityType | null, type?: string | null, account?: { __typename?: 'AccountOutline', name?: string | null, id?: number | null } | null, goldenMetrics?: { __typename?: 'EntityGoldenContextScopedGoldenMetrics', metrics: Array<{ __typename?: 'EntityGoldenMetric', query: string, name: string }> } | null } & { ' $fragmentName'?: 'EntityFields_ThirdPartyServiceEntity_Fragment' };

type EntityFields_UnavailableEntity_Fragment = { __typename?: 'UnavailableEntity', accountId?: number | null, guid?: any | null, name?: string | null, entityType?: EntityType | null, type?: string | null, account?: { __typename?: 'AccountOutline', name?: string | null, id?: number | null } | null, goldenMetrics?: { __typename?: 'EntityGoldenContextScopedGoldenMetrics', metrics: Array<{ __typename?: 'EntityGoldenMetric', query: string, name: string }> } | null } & { ' $fragmentName'?: 'EntityFields_UnavailableEntity_Fragment' };

type EntityFields_WorkloadEntity_Fragment = { __typename?: 'WorkloadEntity', accountId?: number | null, guid?: any | null, name?: string | null, entityType?: EntityType | null, type?: string | null, account?: { __typename?: 'AccountOutline', name?: string | null, id?: number | null } | null, goldenMetrics?: { __typename?: 'EntityGoldenContextScopedGoldenMetrics', metrics: Array<{ __typename?: 'EntityGoldenMetric', query: string, name: string }> } | null } & { ' $fragmentName'?: 'EntityFields_WorkloadEntity_Fragment' };

export type EntityFieldsFragment = EntityFields_ApmApplicationEntity_Fragment | EntityFields_ApmDatabaseInstanceEntity_Fragment | EntityFields_ApmExternalServiceEntity_Fragment | EntityFields_BrowserApplicationEntity_Fragment | EntityFields_DashboardEntity_Fragment | EntityFields_ExternalEntity_Fragment | EntityFields_GenericEntity_Fragment | EntityFields_GenericInfrastructureEntity_Fragment | EntityFields_InfrastructureAwsLambdaFunctionEntity_Fragment | EntityFields_InfrastructureHostEntity_Fragment | EntityFields_KeyTransactionEntity_Fragment | EntityFields_MobileApplicationEntity_Fragment | EntityFields_SecureCredentialEntity_Fragment | EntityFields_SyntheticMonitorEntity_Fragment | EntityFields_TeamEntity_Fragment | EntityFields_ThirdPartyServiceEntity_Fragment | EntityFields_UnavailableEntity_Fragment | EntityFields_WorkloadEntity_Fragment;

export type FetchEntitiesByIdsQueryVariables = Exact<{
  guids: Array<InputMaybe<Scalars['EntityGuid']['input']>> | InputMaybe<Scalars['EntityGuid']['input']>;
}>;


export type FetchEntitiesByIdsQuery = { __typename?: 'RootQueryType', actor?: { __typename?: 'Actor', entities?: Array<(
      { __typename?: 'ApmApplicationEntity' }
      & { ' $fragmentRefs'?: { 'EntityFields_ApmApplicationEntity_Fragment': EntityFields_ApmApplicationEntity_Fragment } }
    ) | (
      { __typename?: 'ApmDatabaseInstanceEntity' }
      & { ' $fragmentRefs'?: { 'EntityFields_ApmDatabaseInstanceEntity_Fragment': EntityFields_ApmDatabaseInstanceEntity_Fragment } }
    ) | (
      { __typename?: 'ApmExternalServiceEntity' }
      & { ' $fragmentRefs'?: { 'EntityFields_ApmExternalServiceEntity_Fragment': EntityFields_ApmExternalServiceEntity_Fragment } }
    ) | (
      { __typename?: 'BrowserApplicationEntity' }
      & { ' $fragmentRefs'?: { 'EntityFields_BrowserApplicationEntity_Fragment': EntityFields_BrowserApplicationEntity_Fragment } }
    ) | (
      { __typename?: 'DashboardEntity' }
      & { ' $fragmentRefs'?: { 'EntityFields_DashboardEntity_Fragment': EntityFields_DashboardEntity_Fragment } }
    ) | (
      { __typename?: 'ExternalEntity' }
      & { ' $fragmentRefs'?: { 'EntityFields_ExternalEntity_Fragment': EntityFields_ExternalEntity_Fragment } }
    ) | (
      { __typename?: 'GenericEntity' }
      & { ' $fragmentRefs'?: { 'EntityFields_GenericEntity_Fragment': EntityFields_GenericEntity_Fragment } }
    ) | (
      { __typename?: 'GenericInfrastructureEntity' }
      & { ' $fragmentRefs'?: { 'EntityFields_GenericInfrastructureEntity_Fragment': EntityFields_GenericInfrastructureEntity_Fragment } }
    ) | (
      { __typename?: 'InfrastructureAwsLambdaFunctionEntity' }
      & { ' $fragmentRefs'?: { 'EntityFields_InfrastructureAwsLambdaFunctionEntity_Fragment': EntityFields_InfrastructureAwsLambdaFunctionEntity_Fragment } }
    ) | (
      { __typename?: 'InfrastructureHostEntity' }
      & { ' $fragmentRefs'?: { 'EntityFields_InfrastructureHostEntity_Fragment': EntityFields_InfrastructureHostEntity_Fragment } }
    ) | (
      { __typename?: 'KeyTransactionEntity' }
      & { ' $fragmentRefs'?: { 'EntityFields_KeyTransactionEntity_Fragment': EntityFields_KeyTransactionEntity_Fragment } }
    ) | (
      { __typename?: 'MobileApplicationEntity' }
      & { ' $fragmentRefs'?: { 'EntityFields_MobileApplicationEntity_Fragment': EntityFields_MobileApplicationEntity_Fragment } }
    ) | (
      { __typename?: 'SecureCredentialEntity' }
      & { ' $fragmentRefs'?: { 'EntityFields_SecureCredentialEntity_Fragment': EntityFields_SecureCredentialEntity_Fragment } }
    ) | (
      { __typename?: 'SyntheticMonitorEntity' }
      & { ' $fragmentRefs'?: { 'EntityFields_SyntheticMonitorEntity_Fragment': EntityFields_SyntheticMonitorEntity_Fragment } }
    ) | (
      { __typename?: 'TeamEntity' }
      & { ' $fragmentRefs'?: { 'EntityFields_TeamEntity_Fragment': EntityFields_TeamEntity_Fragment } }
    ) | (
      { __typename?: 'ThirdPartyServiceEntity' }
      & { ' $fragmentRefs'?: { 'EntityFields_ThirdPartyServiceEntity_Fragment': EntityFields_ThirdPartyServiceEntity_Fragment } }
    ) | (
      { __typename?: 'UnavailableEntity' }
      & { ' $fragmentRefs'?: { 'EntityFields_UnavailableEntity_Fragment': EntityFields_UnavailableEntity_Fragment } }
    ) | (
      { __typename?: 'WorkloadEntity' }
      & { ' $fragmentRefs'?: { 'EntityFields_WorkloadEntity_Fragment': EntityFields_WorkloadEntity_Fragment } }
    ) | null> | null } | null };

export type FetchEntityByIdQueryVariables = Exact<{
  guid: Scalars['EntityGuid']['input'];
}>;


export type FetchEntityByIdQuery = { __typename?: 'RootQueryType', actor?: { __typename?: 'Actor', entity?: (
      { __typename?: 'ApmApplicationEntity' }
      & { ' $fragmentRefs'?: { 'EntityFields_ApmApplicationEntity_Fragment': EntityFields_ApmApplicationEntity_Fragment } }
    ) | (
      { __typename?: 'ApmDatabaseInstanceEntity' }
      & { ' $fragmentRefs'?: { 'EntityFields_ApmDatabaseInstanceEntity_Fragment': EntityFields_ApmDatabaseInstanceEntity_Fragment } }
    ) | (
      { __typename?: 'ApmExternalServiceEntity' }
      & { ' $fragmentRefs'?: { 'EntityFields_ApmExternalServiceEntity_Fragment': EntityFields_ApmExternalServiceEntity_Fragment } }
    ) | (
      { __typename?: 'BrowserApplicationEntity' }
      & { ' $fragmentRefs'?: { 'EntityFields_BrowserApplicationEntity_Fragment': EntityFields_BrowserApplicationEntity_Fragment } }
    ) | (
      { __typename?: 'DashboardEntity' }
      & { ' $fragmentRefs'?: { 'EntityFields_DashboardEntity_Fragment': EntityFields_DashboardEntity_Fragment } }
    ) | (
      { __typename?: 'ExternalEntity' }
      & { ' $fragmentRefs'?: { 'EntityFields_ExternalEntity_Fragment': EntityFields_ExternalEntity_Fragment } }
    ) | (
      { __typename?: 'GenericEntity' }
      & { ' $fragmentRefs'?: { 'EntityFields_GenericEntity_Fragment': EntityFields_GenericEntity_Fragment } }
    ) | (
      { __typename?: 'GenericInfrastructureEntity' }
      & { ' $fragmentRefs'?: { 'EntityFields_GenericInfrastructureEntity_Fragment': EntityFields_GenericInfrastructureEntity_Fragment } }
    ) | (
      { __typename?: 'InfrastructureAwsLambdaFunctionEntity' }
      & { ' $fragmentRefs'?: { 'EntityFields_InfrastructureAwsLambdaFunctionEntity_Fragment': EntityFields_InfrastructureAwsLambdaFunctionEntity_Fragment } }
    ) | (
      { __typename?: 'InfrastructureHostEntity' }
      & { ' $fragmentRefs'?: { 'EntityFields_InfrastructureHostEntity_Fragment': EntityFields_InfrastructureHostEntity_Fragment } }
    ) | (
      { __typename?: 'KeyTransactionEntity' }
      & { ' $fragmentRefs'?: { 'EntityFields_KeyTransactionEntity_Fragment': EntityFields_KeyTransactionEntity_Fragment } }
    ) | (
      { __typename?: 'MobileApplicationEntity' }
      & { ' $fragmentRefs'?: { 'EntityFields_MobileApplicationEntity_Fragment': EntityFields_MobileApplicationEntity_Fragment } }
    ) | (
      { __typename?: 'SecureCredentialEntity' }
      & { ' $fragmentRefs'?: { 'EntityFields_SecureCredentialEntity_Fragment': EntityFields_SecureCredentialEntity_Fragment } }
    ) | (
      { __typename?: 'SyntheticMonitorEntity' }
      & { ' $fragmentRefs'?: { 'EntityFields_SyntheticMonitorEntity_Fragment': EntityFields_SyntheticMonitorEntity_Fragment } }
    ) | (
      { __typename?: 'TeamEntity' }
      & { ' $fragmentRefs'?: { 'EntityFields_TeamEntity_Fragment': EntityFields_TeamEntity_Fragment } }
    ) | (
      { __typename?: 'ThirdPartyServiceEntity' }
      & { ' $fragmentRefs'?: { 'EntityFields_ThirdPartyServiceEntity_Fragment': EntityFields_ThirdPartyServiceEntity_Fragment } }
    ) | (
      { __typename?: 'UnavailableEntity' }
      & { ' $fragmentRefs'?: { 'EntityFields_UnavailableEntity_Fragment': EntityFields_UnavailableEntity_Fragment } }
    ) | (
      { __typename?: 'WorkloadEntity' }
      & { ' $fragmentRefs'?: { 'EntityFields_WorkloadEntity_Fragment': EntityFields_WorkloadEntity_Fragment } }
    ) | null } | null };

export type ErrorsInboxAssignmentsFragment = { __typename?: 'ErrorsInboxErrorGroupOutline', url?: string | null, state?: ErrorsInboxErrorGroupState | null, name?: string | null, message?: string | null, id: string, entityGuid?: any | null } & { ' $fragmentName'?: 'ErrorsInboxAssignmentsFragment' };

export type GetAssignmentsQueryVariables = Exact<{
  userId?: InputMaybe<Scalars['Int']['input']>;
  emailAddress: Scalars['String']['input'];
}>;


export type GetAssignmentsQuery = { __typename?: 'RootQueryType', actor?: { __typename?: 'Actor', errorsInbox?: { __typename?: 'ErrorsInboxActorStitchedFields', errorGroups?: { __typename?: 'ErrorsInboxErrorGroupsResponse', results?: Array<(
          { __typename?: 'ErrorsInboxErrorGroupOutline' }
          & { ' $fragmentRefs'?: { 'ErrorsInboxAssignmentsFragment': ErrorsInboxAssignmentsFragment } }
        )> | null } | null } | null } | null };

export const EntityFieldsFragmentDoc = {"kind":"Document","definitions":[{"kind":"FragmentDefinition","name":{"kind":"Name","value":"EntityFields"},"typeCondition":{"kind":"NamedType","name":{"kind":"Name","value":"Entity"}},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"accountId"}},{"kind":"Field","name":{"kind":"Name","value":"account"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"name"}},{"kind":"Field","name":{"kind":"Name","value":"id"}}]}},{"kind":"Field","name":{"kind":"Name","value":"goldenMetrics"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"metrics"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"query"}},{"kind":"Field","name":{"kind":"Name","value":"name"}}]}}]}},{"kind":"Field","name":{"kind":"Name","value":"guid"}},{"kind":"Field","name":{"kind":"Name","value":"name"}},{"kind":"Field","name":{"kind":"Name","value":"entityType"}},{"kind":"Field","name":{"kind":"Name","value":"type"}}]}}]} as unknown as DocumentNode<EntityFieldsFragment, unknown>;
export const ErrorsInboxAssignmentsFragmentDoc = {"kind":"Document","definitions":[{"kind":"FragmentDefinition","name":{"kind":"Name","value":"ErrorsInboxAssignments"},"typeCondition":{"kind":"NamedType","name":{"kind":"Name","value":"ErrorsInboxErrorGroupOutline"}},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"url"}},{"kind":"Field","name":{"kind":"Name","value":"state"}},{"kind":"Field","name":{"kind":"Name","value":"name"}},{"kind":"Field","name":{"kind":"Name","value":"message"}},{"kind":"Field","name":{"kind":"Name","value":"id"}},{"kind":"Field","name":{"kind":"Name","value":"entityGuid"}}]}}]} as unknown as DocumentNode<ErrorsInboxAssignmentsFragment, unknown>;
export const EntityRelationshipUserDefinedCreateOrReplaceMutationDocument = {"kind":"Document","definitions":[{"kind":"OperationDefinition","operation":"mutation","name":{"kind":"Name","value":"EntityRelationshipUserDefinedCreateOrReplaceMutation"},"variableDefinitions":[{"kind":"VariableDefinition","variable":{"kind":"Variable","name":{"kind":"Name","value":"sourceEntityGuid"}},"type":{"kind":"NonNullType","type":{"kind":"NamedType","name":{"kind":"Name","value":"EntityGuid"}}}},{"kind":"VariableDefinition","variable":{"kind":"Variable","name":{"kind":"Name","value":"targetEntityGuid"}},"type":{"kind":"NonNullType","type":{"kind":"NamedType","name":{"kind":"Name","value":"EntityGuid"}}}}],"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"entityRelationshipUserDefinedCreateOrReplace"},"arguments":[{"kind":"Argument","name":{"kind":"Name","value":"sourceEntityGuid"},"value":{"kind":"Variable","name":{"kind":"Name","value":"sourceEntityGuid"}}},{"kind":"Argument","name":{"kind":"Name","value":"targetEntityGuid"},"value":{"kind":"Variable","name":{"kind":"Name","value":"targetEntityGuid"}}},{"kind":"Argument","name":{"kind":"Name","value":"type"},"value":{"kind":"EnumValue","value":"BUILT_FROM"}}],"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"errors"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"message"}},{"kind":"Field","name":{"kind":"Name","value":"type"}}]}}]}}]}}]} as unknown as DocumentNode<EntityRelationshipUserDefinedCreateOrReplaceMutationMutation, EntityRelationshipUserDefinedCreateOrReplaceMutationMutationVariables>;
export const ReferenceEntityCreateOrUpdateRepositoryMutationDocument = {"kind":"Document","definitions":[{"kind":"OperationDefinition","operation":"mutation","name":{"kind":"Name","value":"ReferenceEntityCreateOrUpdateRepositoryMutation"},"variableDefinitions":[{"kind":"VariableDefinition","variable":{"kind":"Variable","name":{"kind":"Name","value":"accountId"}},"type":{"kind":"NonNullType","type":{"kind":"NamedType","name":{"kind":"Name","value":"Int"}}}},{"kind":"VariableDefinition","variable":{"kind":"Variable","name":{"kind":"Name","value":"name"}},"type":{"kind":"NonNullType","type":{"kind":"NamedType","name":{"kind":"Name","value":"String"}}}},{"kind":"VariableDefinition","variable":{"kind":"Variable","name":{"kind":"Name","value":"url"}},"type":{"kind":"NonNullType","type":{"kind":"NamedType","name":{"kind":"Name","value":"String"}}}}],"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"referenceEntityCreateOrUpdateRepository"},"arguments":[{"kind":"Argument","name":{"kind":"Name","value":"sync"},"value":{"kind":"BooleanValue","value":true}},{"kind":"Argument","name":{"kind":"Name","value":"repositories"},"value":{"kind":"ListValue","values":[{"kind":"ObjectValue","fields":[{"kind":"ObjectField","name":{"kind":"Name","value":"accountId"},"value":{"kind":"Variable","name":{"kind":"Name","value":"accountId"}}},{"kind":"ObjectField","name":{"kind":"Name","value":"name"},"value":{"kind":"Variable","name":{"kind":"Name","value":"name"}}},{"kind":"ObjectField","name":{"kind":"Name","value":"url"},"value":{"kind":"Variable","name":{"kind":"Name","value":"url"}}}]}]}}],"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"created"}},{"kind":"Field","name":{"kind":"Name","value":"updated"}},{"kind":"Field","name":{"kind":"Name","value":"failures"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"guid"}},{"kind":"Field","name":{"kind":"Name","value":"message"}},{"kind":"Field","name":{"kind":"Name","value":"type"}}]}}]}}]}}]} as unknown as DocumentNode<ReferenceEntityCreateOrUpdateRepositoryMutationMutation, ReferenceEntityCreateOrUpdateRepositoryMutationMutationVariables>;
export const FetchEntitiesByIdsDocument = {"kind":"Document","definitions":[{"kind":"OperationDefinition","operation":"query","name":{"kind":"Name","value":"fetchEntitiesByIds"},"variableDefinitions":[{"kind":"VariableDefinition","variable":{"kind":"Variable","name":{"kind":"Name","value":"guids"}},"type":{"kind":"NonNullType","type":{"kind":"ListType","type":{"kind":"NamedType","name":{"kind":"Name","value":"EntityGuid"}}}}}],"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"actor"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"entities"},"arguments":[{"kind":"Argument","name":{"kind":"Name","value":"guids"},"value":{"kind":"Variable","name":{"kind":"Name","value":"guids"}}}],"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"FragmentSpread","name":{"kind":"Name","value":"EntityFields"}}]}}]}}]}},{"kind":"FragmentDefinition","name":{"kind":"Name","value":"EntityFields"},"typeCondition":{"kind":"NamedType","name":{"kind":"Name","value":"Entity"}},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"accountId"}},{"kind":"Field","name":{"kind":"Name","value":"account"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"name"}},{"kind":"Field","name":{"kind":"Name","value":"id"}}]}},{"kind":"Field","name":{"kind":"Name","value":"goldenMetrics"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"metrics"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"query"}},{"kind":"Field","name":{"kind":"Name","value":"name"}}]}}]}},{"kind":"Field","name":{"kind":"Name","value":"guid"}},{"kind":"Field","name":{"kind":"Name","value":"name"}},{"kind":"Field","name":{"kind":"Name","value":"entityType"}},{"kind":"Field","name":{"kind":"Name","value":"type"}}]}}]} as unknown as DocumentNode<FetchEntitiesByIdsQuery, FetchEntitiesByIdsQueryVariables>;
export const FetchEntityByIdDocument = {"kind":"Document","definitions":[{"kind":"OperationDefinition","operation":"query","name":{"kind":"Name","value":"fetchEntityById"},"variableDefinitions":[{"kind":"VariableDefinition","variable":{"kind":"Variable","name":{"kind":"Name","value":"guid"}},"type":{"kind":"NonNullType","type":{"kind":"NamedType","name":{"kind":"Name","value":"EntityGuid"}}}}],"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"actor"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"entity"},"arguments":[{"kind":"Argument","name":{"kind":"Name","value":"guid"},"value":{"kind":"Variable","name":{"kind":"Name","value":"guid"}}}],"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"FragmentSpread","name":{"kind":"Name","value":"EntityFields"}}]}}]}}]}},{"kind":"FragmentDefinition","name":{"kind":"Name","value":"EntityFields"},"typeCondition":{"kind":"NamedType","name":{"kind":"Name","value":"Entity"}},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"accountId"}},{"kind":"Field","name":{"kind":"Name","value":"account"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"name"}},{"kind":"Field","name":{"kind":"Name","value":"id"}}]}},{"kind":"Field","name":{"kind":"Name","value":"goldenMetrics"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"metrics"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"query"}},{"kind":"Field","name":{"kind":"Name","value":"name"}}]}}]}},{"kind":"Field","name":{"kind":"Name","value":"guid"}},{"kind":"Field","name":{"kind":"Name","value":"name"}},{"kind":"Field","name":{"kind":"Name","value":"entityType"}},{"kind":"Field","name":{"kind":"Name","value":"type"}}]}}]} as unknown as DocumentNode<FetchEntityByIdQuery, FetchEntityByIdQueryVariables>;
export const GetAssignmentsDocument = {"kind":"Document","definitions":[{"kind":"OperationDefinition","operation":"query","name":{"kind":"Name","value":"getAssignments"},"variableDefinitions":[{"kind":"VariableDefinition","variable":{"kind":"Variable","name":{"kind":"Name","value":"userId"}},"type":{"kind":"NamedType","name":{"kind":"Name","value":"Int"}}},{"kind":"VariableDefinition","variable":{"kind":"Variable","name":{"kind":"Name","value":"emailAddress"}},"type":{"kind":"NonNullType","type":{"kind":"NamedType","name":{"kind":"Name","value":"String"}}}}],"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"actor"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"errorsInbox"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"errorGroups"},"arguments":[{"kind":"Argument","name":{"kind":"Name","value":"filter"},"value":{"kind":"ObjectValue","fields":[{"kind":"ObjectField","name":{"kind":"Name","value":"isAssigned"},"value":{"kind":"BooleanValue","value":true}},{"kind":"ObjectField","name":{"kind":"Name","value":"assignment"},"value":{"kind":"ObjectValue","fields":[{"kind":"ObjectField","name":{"kind":"Name","value":"userId"},"value":{"kind":"Variable","name":{"kind":"Name","value":"userId"}}},{"kind":"ObjectField","name":{"kind":"Name","value":"userEmail"},"value":{"kind":"Variable","name":{"kind":"Name","value":"emailAddress"}}}]}}]}}],"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"results"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"FragmentSpread","name":{"kind":"Name","value":"ErrorsInboxAssignments"}}]}}]}}]}}]}}]}},{"kind":"FragmentDefinition","name":{"kind":"Name","value":"ErrorsInboxAssignments"},"typeCondition":{"kind":"NamedType","name":{"kind":"Name","value":"ErrorsInboxErrorGroupOutline"}},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"url"}},{"kind":"Field","name":{"kind":"Name","value":"state"}},{"kind":"Field","name":{"kind":"Name","value":"name"}},{"kind":"Field","name":{"kind":"Name","value":"message"}},{"kind":"Field","name":{"kind":"Name","value":"id"}},{"kind":"Field","name":{"kind":"Name","value":"entityGuid"}}]}}]} as unknown as DocumentNode<GetAssignmentsQuery, GetAssignmentsQueryVariables>;